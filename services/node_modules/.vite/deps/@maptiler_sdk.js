import { n as __toESM, t as __commonJS } from "./chunk-CVmoYqME.js";

//#region node_modules/@maptiler/sdk/node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = /* @__PURE__ */ __commonJS({ "node_modules/@maptiler/sdk/node_modules/maplibre-gl/dist/maplibre-gl.js": ((exports, module) => {
	/**
	* MapLibre GL JS
	* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.14.0/LICENSE.txt
	*/
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global$1 = typeof globalThis !== "undefined" ? globalThis : global$1 || self, global$1.maplibregl = factory());
	})(exports, (function() {
		var maplibregl = {};
		var modules = {};
		function define$1(moduleName, _dependencies, moduleFactory) {
			modules[moduleName] = moduleFactory;
			if (moduleName !== "index") return;
			var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
			var sharedModule = {};
			modules.shared(sharedModule);
			modules.index(maplibregl, sharedModule);
			if (typeof window !== "undefined") maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
			return maplibregl;
		}
		define$1("shared", ["exports"], (function(t) {
			function e(t$1, e$1, r$1, n$1) {
				return new (r$1 || (r$1 = Promise))((function(i$1, s$1) {
					function o(t$2) {
						try {
							l$1(n$1.next(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function a$1(t$2) {
						try {
							l$1(n$1.throw(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function l$1(t$2) {
						var e$2;
						t$2.done ? i$1(t$2.value) : (e$2 = t$2.value, e$2 instanceof r$1 ? e$2 : new r$1((function(t$3) {
							t$3(e$2);
						}))).then(o, a$1);
					}
					l$1((n$1 = n$1.apply(t$1, e$1 || [])).next());
				}));
			}
			function r(t$1, e$1) {
				this.x = t$1, this.y = e$1;
			}
			function n(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var i, s;
			r.prototype = {
				clone() {
					return new r(this.x, this.y);
				},
				add(t$1) {
					return this.clone()._add(t$1);
				},
				sub(t$1) {
					return this.clone()._sub(t$1);
				},
				multByPoint(t$1) {
					return this.clone()._multByPoint(t$1);
				},
				divByPoint(t$1) {
					return this.clone()._divByPoint(t$1);
				},
				mult(t$1) {
					return this.clone()._mult(t$1);
				},
				div(t$1) {
					return this.clone()._div(t$1);
				},
				rotate(t$1) {
					return this.clone()._rotate(t$1);
				},
				rotateAround(t$1, e$1) {
					return this.clone()._rotateAround(t$1, e$1);
				},
				matMult(t$1) {
					return this.clone()._matMult(t$1);
				},
				unit() {
					return this.clone()._unit();
				},
				perp() {
					return this.clone()._perp();
				},
				round() {
					return this.clone()._round();
				},
				mag() {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				},
				equals(t$1) {
					return this.x === t$1.x && this.y === t$1.y;
				},
				dist(t$1) {
					return Math.sqrt(this.distSqr(t$1));
				},
				distSqr(t$1) {
					const e$1 = t$1.x - this.x, r$1 = t$1.y - this.y;
					return e$1 * e$1 + r$1 * r$1;
				},
				angle() {
					return Math.atan2(this.y, this.x);
				},
				angleTo(t$1) {
					return Math.atan2(this.y - t$1.y, this.x - t$1.x);
				},
				angleWith(t$1) {
					return this.angleWithSep(t$1.x, t$1.y);
				},
				angleWithSep(t$1, e$1) {
					return Math.atan2(this.x * e$1 - this.y * t$1, this.x * t$1 + this.y * e$1);
				},
				_matMult(t$1) {
					const e$1 = t$1[2] * this.x + t$1[3] * this.y;
					return this.x = t$1[0] * this.x + t$1[1] * this.y, this.y = e$1, this;
				},
				_add(t$1) {
					return this.x += t$1.x, this.y += t$1.y, this;
				},
				_sub(t$1) {
					return this.x -= t$1.x, this.y -= t$1.y, this;
				},
				_mult(t$1) {
					return this.x *= t$1, this.y *= t$1, this;
				},
				_div(t$1) {
					return this.x /= t$1, this.y /= t$1, this;
				},
				_multByPoint(t$1) {
					return this.x *= t$1.x, this.y *= t$1.y, this;
				},
				_divByPoint(t$1) {
					return this.x /= t$1.x, this.y /= t$1.y, this;
				},
				_unit() {
					return this._div(this.mag()), this;
				},
				_perp() {
					const t$1 = this.y;
					return this.y = this.x, this.x = -t$1, this;
				},
				_rotate(t$1) {
					const e$1 = Math.cos(t$1), r$1 = Math.sin(t$1), n$1 = r$1 * this.x + e$1 * this.y;
					return this.x = e$1 * this.x - r$1 * this.y, this.y = n$1, this;
				},
				_rotateAround(t$1, e$1) {
					const r$1 = Math.cos(t$1), n$1 = Math.sin(t$1), i$1 = e$1.y + n$1 * (this.x - e$1.x) + r$1 * (this.y - e$1.y);
					return this.x = e$1.x + r$1 * (this.x - e$1.x) - n$1 * (this.y - e$1.y), this.y = i$1, this;
				},
				_round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
				},
				constructor: r
			}, r.convert = function(t$1) {
				if (t$1 instanceof r) return t$1;
				if (Array.isArray(t$1)) return new r(+t$1[0], +t$1[1]);
				if (void 0 !== t$1.x && void 0 !== t$1.y) return new r(+t$1.x, +t$1.y);
				throw new Error("Expected [x, y] or {x, y} point format");
			};
			var a = n(function() {
				if (s) return i;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return s = 1, i = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var o = 0, a$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? o = r$1 : a$1 = r$1, r$1 = .5 * (a$1 - o) + o;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, i;
			}());
			let l, u;
			function c() {
				return l ??= "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap, l;
			}
			function h() {
				if (null == u && (u = !1, c())) {
					const t$1 = 5, e$1 = new OffscreenCanvas(t$1, t$1).getContext("2d", { willReadFrequently: !0 });
					if (e$1) {
						for (let r$2 = 0; r$2 < t$1 * t$1; r$2++) {
							const n$1 = 4 * r$2;
							e$1.fillStyle = `rgb(${n$1},${n$1 + 1},${n$1 + 2})`, e$1.fillRect(r$2 % t$1, Math.floor(r$2 / t$1), 1, 1);
						}
						const r$1 = e$1.getImageData(0, 0, t$1, t$1).data;
						for (let e$2 = 0; e$2 < t$1 * t$1 * 4; e$2++) if (e$2 % 4 != 3 && r$1[e$2] !== e$2) {
							u = !0;
							break;
						}
					}
				}
				return u || !1;
			}
			var p = 1e-6, f = "undefined" != typeof Float32Array ? Float32Array : Array;
			function d() {
				var t$1 = new f(9);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0), t$1[0] = 1, t$1[4] = 1, t$1[8] = 1, t$1;
			}
			function y(t$1) {
				return t$1[0] = 1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = 1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 1, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}
			function m() {
				var t$1 = new f(3);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1;
			}
			function g$1(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1], n$1 = t$1[2];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1 + n$1 * n$1);
			}
			function x(t$1, e$1, r$1) {
				var n$1 = new f(3);
				return n$1[0] = t$1, n$1[1] = e$1, n$1[2] = r$1, n$1;
			}
			function v(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] + r$1[0], t$1[1] = e$1[1] + r$1[1], t$1[2] = e$1[2] + r$1[2], t$1;
			}
			function b(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1;
			}
			function w$1(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o = r$1[0], a$1 = r$1[1], l$1 = r$1[2];
				return t$1[0] = i$1 * l$1 - s$1 * a$1, t$1[1] = s$1 * o - n$1 * l$1, t$1[2] = n$1 * a$1 - i$1 * o, t$1;
			}
			var _$1, A$1 = g$1;
			function S$1(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o = e$1[3];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12] * o, t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13] * o, t$1[2] = r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14] * o, t$1[3] = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15] * o, t$1;
			}
			function k$1() {
				var t$1 = new f(4);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1[3] = 1, t$1;
			}
			function E(t$1, e$1, r$1, n$1) {
				var i$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "zyx", s$1 = Math.PI / 360;
				e$1 *= s$1, n$1 *= s$1, r$1 *= s$1;
				var o = Math.sin(e$1), a$1 = Math.cos(e$1), l$1 = Math.sin(r$1), u$1 = Math.cos(r$1), c$1 = Math.sin(n$1), h$1 = Math.cos(n$1);
				switch (i$1) {
					case "xyz":
						t$1[0] = o * u$1 * h$1 + a$1 * l$1 * c$1, t$1[1] = a$1 * l$1 * h$1 - o * u$1 * c$1, t$1[2] = a$1 * u$1 * c$1 + o * l$1 * h$1, t$1[3] = a$1 * u$1 * h$1 - o * l$1 * c$1;
						break;
					case "xzy":
						t$1[0] = o * u$1 * h$1 - a$1 * l$1 * c$1, t$1[1] = a$1 * l$1 * h$1 - o * u$1 * c$1, t$1[2] = a$1 * u$1 * c$1 + o * l$1 * h$1, t$1[3] = a$1 * u$1 * h$1 + o * l$1 * c$1;
						break;
					case "yxz":
						t$1[0] = o * u$1 * h$1 + a$1 * l$1 * c$1, t$1[1] = a$1 * l$1 * h$1 - o * u$1 * c$1, t$1[2] = a$1 * u$1 * c$1 - o * l$1 * h$1, t$1[3] = a$1 * u$1 * h$1 + o * l$1 * c$1;
						break;
					case "yzx":
						t$1[0] = o * u$1 * h$1 + a$1 * l$1 * c$1, t$1[1] = a$1 * l$1 * h$1 + o * u$1 * c$1, t$1[2] = a$1 * u$1 * c$1 - o * l$1 * h$1, t$1[3] = a$1 * u$1 * h$1 - o * l$1 * c$1;
						break;
					case "zxy":
						t$1[0] = o * u$1 * h$1 - a$1 * l$1 * c$1, t$1[1] = a$1 * l$1 * h$1 + o * u$1 * c$1, t$1[2] = a$1 * u$1 * c$1 + o * l$1 * h$1, t$1[3] = a$1 * u$1 * h$1 - o * l$1 * c$1;
						break;
					case "zyx":
						t$1[0] = o * u$1 * h$1 - a$1 * l$1 * c$1, t$1[1] = a$1 * l$1 * h$1 + o * u$1 * c$1, t$1[2] = a$1 * u$1 * c$1 - o * l$1 * h$1, t$1[3] = a$1 * u$1 * h$1 + o * l$1 * c$1;
						break;
					default: throw new Error("Unknown angle order " + i$1);
				}
				return t$1;
			}
			function T() {
				var t$1 = new f(2);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0), t$1;
			}
			function I$1(t$1, e$1) {
				var r$1 = new f(2);
				return r$1[0] = t$1, r$1[1] = e$1, r$1;
			}
			m(), _$1 = new f(4), f != Float32Array && (_$1[0] = 0, _$1[1] = 0, _$1[2] = 0, _$1[3] = 0), m(), x(1, 0, 0), x(0, 1, 0), k$1(), k$1(), d(), T();
			const M$1 = 8192;
			function F$1(t$1, e$1, r$1) {
				return e$1 * (M$1 / (t$1.tileSize * Math.pow(2, r$1 - t$1.tileID.overscaledZ)));
			}
			function D$1(t$1, e$1) {
				return (t$1 % e$1 + e$1) % e$1;
			}
			function P$1(t$1, e$1, r$1) {
				return t$1 * (1 - r$1) + e$1 * r$1;
			}
			function z$1(t$1) {
				if (t$1 <= 0) return 0;
				if (t$1 >= 1) return 1;
				const e$1 = t$1 * t$1, r$1 = e$1 * t$1;
				return 4 * (t$1 < .5 ? r$1 : 3 * (t$1 - e$1) + r$1 - .75);
			}
			function B$1(t$1, e$1, r$1, n$1) {
				const i$1 = new a(t$1, e$1, r$1, n$1);
				return (t$2) => i$1.solve(t$2);
			}
			const V$1 = B$1(.25, .1, .25, 1);
			function C(t$1, e$1, r$1) {
				return Math.min(r$1, Math.max(e$1, t$1));
			}
			function L$1(t$1, e$1, r$1) {
				const n$1 = r$1 - e$1, i$1 = ((t$1 - e$1) % n$1 + n$1) % n$1 + e$1;
				return i$1 === e$1 ? r$1 : i$1;
			}
			function O$1(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			let R$2 = 1;
			function N(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) n$1[r$2] = e$1.call(this, t$1[r$2], r$2, t$1);
				return n$1;
			}
			function $$1(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) e$1.call(this, t$1[r$2], r$2, t$1) && (n$1[r$2] = t$1[r$2]);
				return n$1;
			}
			function U$1(t$1) {
				return Array.isArray(t$1) ? t$1.map(U$1) : "object" == typeof t$1 && t$1 ? N(t$1, U$1) : t$1;
			}
			const q$1 = {};
			function j$1(t$1) {
				q$1[t$1] || ("undefined" != typeof console && console.warn(t$1), q$1[t$1] = !0);
			}
			function G$1(t$1, e$1, r$1) {
				return (r$1.y - t$1.y) * (e$1.x - t$1.x) > (e$1.y - t$1.y) * (r$1.x - t$1.x);
			}
			function X(t$1) {
				return "undefined" != typeof WorkerGlobalScope && void 0 !== t$1 && t$1 instanceof WorkerGlobalScope;
			}
			let Y$1 = null;
			function Z$1(t$1) {
				return "undefined" != typeof ImageBitmap && t$1 instanceof ImageBitmap;
			}
			const H$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
			function K$1(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
					const e$1 = new VideoFrame(t$1, { timestamp: 0 });
					try {
						const o = null == e$1 ? void 0 : e$1.format;
						if (!o || !o.startsWith("BGR") && !o.startsWith("RGB")) throw new Error(`Unrecognized format ${o}`);
						const a$1 = o.startsWith("BGR"), l$1 = new Uint8ClampedArray(i$1 * s$1 * 4);
						if (yield e$1.copyTo(l$1, function(t$2, e$2, r$2, n$2, i$2) {
							const s$2 = 4 * Math.max(-e$2, 0), o$1 = (Math.max(0, r$2) - r$2) * n$2 * 4 + s$2, a$2 = 4 * n$2, l$2 = Math.max(0, e$2), u$1 = Math.max(0, r$2);
							return {
								rect: {
									x: l$2,
									y: u$1,
									width: Math.min(t$2.width, e$2 + n$2) - l$2,
									height: Math.min(t$2.height, r$2 + i$2) - u$1
								},
								layout: [{
									offset: o$1,
									stride: a$2
								}]
							};
						}(t$1, r$1, n$1, i$1, s$1)), a$1) for (let t$2 = 0; t$2 < l$1.length; t$2 += 4) {
							const e$2 = l$1[t$2];
							l$1[t$2] = l$1[t$2 + 2], l$1[t$2 + 2] = e$2;
						}
						return l$1;
					} finally {
						e$1.close();
					}
				}));
			}
			let W$1, J$1;
			function Q$1(t$1, e$1, r$1, n$1) {
				return t$1.addEventListener(e$1, r$1, n$1), { unsubscribe: () => {
					t$1.removeEventListener(e$1, r$1, n$1);
				} };
			}
			function tt$1(t$1) {
				return t$1 * Math.PI / 180;
			}
			function et$1(t$1) {
				return t$1 / Math.PI * 180;
			}
			const rt$1 = {
				touchstart: !0,
				touchmove: !0,
				touchmoveWindow: !0,
				touchend: !0,
				touchcancel: !0
			}, nt$1 = {
				dblclick: !0,
				click: !0,
				mouseover: !0,
				mouseout: !0,
				mousedown: !0,
				mousemove: !0,
				mousemoveWindow: !0,
				mouseup: !0,
				mouseupWindow: !0,
				contextmenu: !0,
				wheel: !0
			}, it$1 = "AbortError";
			class st$1 extends Error {
				constructor(t$1 = it$1) {
					super(t$1 instanceof Error ? t$1.message : t$1), this.name = it$1, t$1 instanceof Error && t$1.stack && (this.stack = t$1.stack);
				}
			}
			function ot$1(t$1) {
				return t$1.name === it$1;
			}
			const at$2 = {
				MAX_PARALLEL_IMAGE_REQUESTS: 16,
				MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
				MAX_TILE_CACHE_ZOOM_LEVELS: 5,
				REGISTERED_PROTOCOLS: {},
				WORKER_URL: ""
			};
			function lt$1(t$1) {
				return at$2.REGISTERED_PROTOCOLS[t$1.substring(0, t$1.indexOf("://"))];
			}
			const ut$1 = "global-dispatcher";
			class ct$1 extends Error {
				constructor(t$1, e$1, r$1, n$1) {
					super(`AJAXError: ${e$1} (${t$1}): ${r$1}`), this.status = t$1, this.statusText = e$1, this.url = r$1, this.body = n$1;
				}
			}
			const ht$1 = () => X(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, pt$1 = function(t$1, r$1) {
				if (/:\/\//.test(t$1.url) && !/^https?:|^file:/.test(t$1.url)) {
					const e$1 = lt$1(t$1.url);
					if (e$1) return e$1(t$1, r$1);
					if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						targetMapId: ut$1
					}, r$1);
				}
				if (!(/^file:/.test(n$1 = t$1.url) || /^file:/.test(ht$1()) && !/^\w+:/.test(n$1))) {
					if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t$2, r$2) {
						return e(this, void 0, void 0, (function* () {
							const e$1 = new Request(t$2.url, {
								method: t$2.method || "GET",
								body: t$2.body,
								credentials: t$2.credentials,
								headers: t$2.headers,
								cache: t$2.cache,
								referrer: ht$1(),
								signal: r$2.signal
							});
							let n$2, i$1;
							"json" !== t$2.type || e$1.headers.has("Accept") || e$1.headers.set("Accept", "application/json");
							try {
								n$2 = yield fetch(e$1);
							} catch (e$2) {
								if (ot$1(e$2)) throw e$2;
								throw new ct$1(0, e$2.message, t$2.url, new Blob());
							}
							if (!n$2.ok) {
								const e$2 = yield n$2.blob();
								throw new ct$1(n$2.status, n$2.statusText, t$2.url, e$2);
							}
							i$1 = "arrayBuffer" === t$2.type || "image" === t$2.type ? n$2.arrayBuffer() : "json" === t$2.type ? n$2.json() : n$2.text();
							const s$1 = yield i$1;
							return r$2.signal.throwIfAborted(), {
								data: s$1,
								cacheControl: n$2.headers.get("Cache-Control"),
								expires: n$2.headers.get("Expires")
							};
						}));
					}(t$1, r$1);
					if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						mustQueue: !0,
						targetMapId: ut$1
					}, r$1);
				}
				var n$1;
				return function(t$2, e$1) {
					return new Promise(((r$2, n$2) => {
						var i$1;
						const s$1 = new XMLHttpRequest();
						s$1.open(t$2.method || "GET", t$2.url, !0), "arrayBuffer" !== t$2.type && "image" !== t$2.type || (s$1.responseType = "arraybuffer");
						for (const e$2 in t$2.headers) s$1.setRequestHeader(e$2, t$2.headers[e$2]);
						"json" === t$2.type && (s$1.responseType = "text", !(null === (i$1 = t$2.headers) || void 0 === i$1) && i$1.Accept || s$1.setRequestHeader("Accept", "application/json")), s$1.withCredentials = "include" === t$2.credentials, s$1.onerror = () => {
							n$2(new Error(s$1.statusText));
						}, s$1.onload = () => {
							if (!e$1.signal.aborted) if ((s$1.status >= 200 && s$1.status < 300 || 0 === s$1.status) && null !== s$1.response) {
								let e$2 = s$1.response;
								if ("json" === t$2.type) try {
									e$2 = JSON.parse(s$1.response);
								} catch (t$3) {
									n$2(t$3);
									return;
								}
								r$2({
									data: e$2,
									cacheControl: s$1.getResponseHeader("Cache-Control"),
									expires: s$1.getResponseHeader("Expires")
								});
							} else {
								const e$2 = new Blob([s$1.response], { type: s$1.getResponseHeader("Content-Type") });
								n$2(new ct$1(s$1.status, s$1.statusText, t$2.url, e$2));
							}
						}, e$1.signal.addEventListener("abort", (() => {
							s$1.abort(), n$2(new st$1(e$1.signal.reason));
						})), s$1.send(t$2.body);
					}));
				}(t$1, r$1);
			};
			function ft(t$1) {
				if (!t$1 || t$1.indexOf("://") <= 0 || 0 === t$1.indexOf("data:image/") || 0 === t$1.indexOf("blob:")) return !0;
				const e$1 = new URL(t$1), r$1 = window.location;
				return e$1.protocol === r$1.protocol && e$1.host === r$1.host;
			}
			function dt$1(t$1, e$1, r$1) {
				r$1[t$1] && -1 !== r$1[t$1].indexOf(e$1) || (r$1[t$1] = r$1[t$1] || [], r$1[t$1].push(e$1));
			}
			function yt$1(t$1, e$1, r$1) {
				if (r$1 && r$1[t$1]) {
					const n$1 = r$1[t$1].indexOf(e$1);
					-1 !== n$1 && r$1[t$1].splice(n$1, 1);
				}
			}
			class mt$1 {
				constructor(t$1, e$1 = {}) {
					O$1(this, e$1), this.type = t$1;
				}
			}
			class gt$1 extends mt$1 {
				constructor(t$1, e$1 = {}) {
					super("error", O$1({ error: t$1 }, e$1));
				}
			}
			class xt$1 {
				on(t$1, e$1) {
					return this._listeners = this._listeners || {}, dt$1(t$1, e$1, this._listeners), { unsubscribe: () => {
						this.off(t$1, e$1);
					} };
				}
				off(t$1, e$1) {
					return yt$1(t$1, e$1, this._listeners), yt$1(t$1, e$1, this._oneTimeListeners), this;
				}
				once(t$1, e$1) {
					return e$1 ? (this._oneTimeListeners = this._oneTimeListeners || {}, dt$1(t$1, e$1, this._oneTimeListeners), this) : new Promise(((e$2) => this.once(t$1, e$2)));
				}
				fire(t$1, e$1) {
					"string" == typeof t$1 && (t$1 = new mt$1(t$1, e$1 || {}));
					const r$1 = t$1.type;
					if (this.listens(r$1)) {
						t$1.target = this;
						const e$2 = this._listeners && this._listeners[r$1] ? this._listeners[r$1].slice() : [];
						for (const r$2 of e$2) r$2.call(this, t$1);
						const n$1 = this._oneTimeListeners && this._oneTimeListeners[r$1] ? this._oneTimeListeners[r$1].slice() : [];
						for (const e$3 of n$1) yt$1(r$1, e$3, this._oneTimeListeners), e$3.call(this, t$1);
						const i$1 = this._eventedParent;
						i$1 && (O$1(t$1, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i$1.fire(t$1));
					} else t$1 instanceof gt$1 && console.error(t$1.error);
					return this;
				}
				listens(t$1) {
					return this._listeners && this._listeners[t$1] && this._listeners[t$1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t$1] && this._oneTimeListeners[t$1].length > 0 || this._eventedParent && this._eventedParent.listens(t$1);
				}
				setEventedParent(t$1, e$1) {
					return this._eventedParent = t$1, this._eventedParentData = e$1, this;
				}
			}
			var vt$1 = {
				$version: 8,
				$root: {
					version: {
						required: !0,
						type: "enum",
						values: [8]
					},
					name: { type: "string" },
					metadata: { type: "*" },
					center: {
						type: "array",
						value: "number"
					},
					centerAltitude: { type: "number" },
					zoom: { type: "number" },
					bearing: {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees"
					},
					pitch: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					roll: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					state: {
						type: "state",
						default: {}
					},
					light: { type: "light" },
					sky: { type: "sky" },
					projection: { type: "projection" },
					terrain: { type: "terrain" },
					sources: {
						required: !0,
						type: "sources"
					},
					sprite: { type: "sprite" },
					glyphs: { type: "string" },
					"font-faces": {
						type: "array",
						value: "fontFaces"
					},
					transition: { type: "transition" },
					layers: {
						required: !0,
						type: "array",
						value: "layer"
					}
				},
				sources: { "*": { type: "source" } },
				source: [
					"source_vector",
					"source_raster",
					"source_raster_dem",
					"source_geojson",
					"source_video",
					"source_image"
				],
				source_vector: {
					type: {
						required: !0,
						type: "enum",
						values: { vector: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					attribution: { type: "string" },
					promoteId: { type: "promoteId" },
					volatile: {
						type: "boolean",
						default: !1
					},
					encoding: {
						type: "enum",
						values: {
							mvt: {},
							mlt: {}
						},
						default: "mvt"
					},
					"*": { type: "*" }
				},
				source_raster: {
					type: {
						required: !0,
						type: "enum",
						values: { raster: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					attribution: { type: "string" },
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_raster_dem: {
					type: {
						required: !0,
						type: "enum",
						values: { "raster-dem": {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					attribution: { type: "string" },
					encoding: {
						type: "enum",
						values: {
							terrarium: {},
							mapbox: {},
							custom: {}
						},
						default: "mapbox"
					},
					redFactor: {
						type: "number",
						default: 1
					},
					blueFactor: {
						type: "number",
						default: 1
					},
					greenFactor: {
						type: "number",
						default: 1
					},
					baseShift: {
						type: "number",
						default: 0
					},
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_geojson: {
					type: {
						required: !0,
						type: "enum",
						values: { geojson: {} }
					},
					data: {
						required: !0,
						type: "*"
					},
					maxzoom: {
						type: "number",
						default: 18
					},
					attribution: { type: "string" },
					buffer: {
						type: "number",
						default: 128,
						maximum: 512,
						minimum: 0
					},
					filter: { type: "*" },
					tolerance: {
						type: "number",
						default: .375
					},
					cluster: {
						type: "boolean",
						default: !1
					},
					clusterRadius: {
						type: "number",
						default: 50,
						minimum: 0
					},
					clusterMaxZoom: { type: "number" },
					clusterMinPoints: { type: "number" },
					clusterProperties: { type: "*" },
					lineMetrics: {
						type: "boolean",
						default: !1
					},
					generateId: {
						type: "boolean",
						default: !1
					},
					promoteId: { type: "promoteId" }
				},
				source_video: {
					type: {
						required: !0,
						type: "enum",
						values: { video: {} }
					},
					urls: {
						required: !0,
						type: "array",
						value: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				source_image: {
					type: {
						required: !0,
						type: "enum",
						values: { image: {} }
					},
					url: {
						required: !0,
						type: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				layer: {
					id: {
						type: "string",
						required: !0
					},
					type: {
						type: "enum",
						values: {
							fill: {},
							line: {},
							symbol: {},
							circle: {},
							heatmap: {},
							"fill-extrusion": {},
							raster: {},
							hillshade: {},
							"color-relief": {},
							background: {}
						},
						required: !0
					},
					metadata: { type: "*" },
					source: { type: "string" },
					"source-layer": { type: "string" },
					minzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					maxzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					filter: { type: "filter" },
					layout: { type: "layout" },
					paint: { type: "paint" }
				},
				layout: [
					"layout_fill",
					"layout_line",
					"layout_circle",
					"layout_heatmap",
					"layout_fill-extrusion",
					"layout_symbol",
					"layout_raster",
					"layout_hillshade",
					"layout_color-relief",
					"layout_background"
				],
				layout_background: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_fill: {
					"fill-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_circle: {
					"circle-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_heatmap: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_fill-extrusion": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_line: {
					"line-cap": {
						type: "enum",
						values: {
							butt: {},
							round: {},
							square: {}
						},
						default: "butt",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-join": {
						type: "enum",
						values: {
							bevel: {},
							round: {},
							miter: {}
						},
						default: "miter",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"line-miter-limit": {
						type: "number",
						default: 2,
						requires: [{ "line-join": "miter" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-round-limit": {
						type: "number",
						default: 1.05,
						requires: [{ "line-join": "round" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_symbol: {
					"symbol-placement": {
						type: "enum",
						values: {
							point: {},
							line: {},
							"line-center": {}
						},
						default: "point",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-spacing": {
						type: "number",
						default: 250,
						minimum: 1,
						units: "pixels",
						requires: [{ "symbol-placement": "line" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-avoid-edges": {
						type: "boolean",
						default: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"symbol-z-order": {
						type: "enum",
						values: {
							auto: {},
							"viewport-y": {},
							source: {}
						},
						default: "auto",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", { "!": "icon-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-optional": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-size": {
						type: "number",
						default: 1,
						minimum: 0,
						units: "factor of the original icon size",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-text-fit": {
						type: "enum",
						values: {
							none: {},
							width: {},
							height: {},
							both: {}
						},
						default: "none",
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-text-fit-padding": {
						type: "array",
						value: "number",
						length: 4,
						default: [
							0,
							0,
							0,
							0
						],
						units: "pixels",
						requires: [
							"icon-image",
							"text-field",
							{ "icon-text-fit": [
								"both",
								"width",
								"height"
							] }
						],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-image": {
						type: "resolvedImage",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-padding": {
						type: "padding",
						default: [2],
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-keep-upright": {
						type: "boolean",
						default: !1,
						requires: [
							"icon-image",
							{ "icon-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-offset": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							"viewport-glyph": {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-field": {
						type: "formatted",
						default: "",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-font": {
						type: "array",
						value: "string",
						default: ["Open Sans Regular", "Arial Unicode MS Regular"],
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-size": {
						type: "number",
						default: 16,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-width": {
						type: "number",
						default: 10,
						minimum: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-line-height": {
						type: "number",
						default: 1.2,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-letter-spacing": {
						type: "number",
						default: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-justify": {
						type: "enum",
						values: {
							auto: {},
							left: {},
							center: {},
							right: {}
						},
						default: "center",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-radial-offset": {
						type: "number",
						units: "ems",
						default: 0,
						requires: ["text-field"],
						"property-type": "data-driven",
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						}
					},
					"text-variable-anchor": {
						type: "array",
						value: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-variable-anchor-offset": {
						type: "variableAnchorOffsetCollection",
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["text-field", { "!": "text-variable-anchor" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-angle": {
						type: "number",
						default: 45,
						units: "degrees",
						requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-writing-mode": {
						type: "array",
						value: "enum",
						values: {
							horizontal: {},
							vertical: {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-padding": {
						type: "number",
						default: 2,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-keep-upright": {
						type: "boolean",
						default: !0,
						requires: [
							"text-field",
							{ "text-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-transform": {
						type: "enum",
						values: {
							none: {},
							uppercase: {},
							lowercase: {}
						},
						default: "none",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-offset": {
						type: "array",
						value: "number",
						units: "ems",
						length: 2,
						default: [0, 0],
						requires: ["text-field", { "!": "text-radial-offset" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["text-field", { "!": "text-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-optional": {
						type: "boolean",
						default: !1,
						requires: ["text-field", "icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_raster: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_hillshade: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_color-relief": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				filter: {
					type: "array",
					value: "*"
				},
				filter_operator: {
					type: "enum",
					values: {
						"==": {},
						"!=": {},
						">": {},
						">=": {},
						"<": {},
						"<=": {},
						in: {},
						"!in": {},
						all: {},
						any: {},
						none: {},
						has: {},
						"!has": {}
					}
				},
				geometry_type: {
					type: "enum",
					values: {
						Point: {},
						LineString: {},
						Polygon: {}
					}
				},
				function: {
					expression: { type: "expression" },
					stops: {
						type: "array",
						value: "function_stop"
					},
					base: {
						type: "number",
						default: 1,
						minimum: 0
					},
					property: {
						type: "string",
						default: "$zoom"
					},
					type: {
						type: "enum",
						values: {
							identity: {},
							exponential: {},
							interval: {},
							categorical: {}
						},
						default: "exponential"
					},
					colorSpace: {
						type: "enum",
						values: {
							rgb: {},
							lab: {},
							hcl: {}
						},
						default: "rgb"
					},
					default: {
						type: "*",
						required: !1
					}
				},
				function_stop: {
					type: "array",
					minimum: 0,
					maximum: 24,
					value: ["number", "color"],
					length: 2
				},
				expression: {
					type: "array",
					value: "*",
					minimum: 1
				},
				light: {
					anchor: {
						type: "enum",
						default: "viewport",
						values: {
							map: {},
							viewport: {}
						},
						"property-type": "data-constant",
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						}
					},
					position: {
						type: "array",
						default: [
							1.15,
							210,
							30
						],
						length: 3,
						value: "number",
						"property-type": "data-constant",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						}
					},
					color: {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					intensity: {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				sky: {
					"sky-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#88C6FC",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-ground-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-fog-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"sky-horizon-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"atmosphere-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				terrain: {
					source: {
						type: "string",
						required: !0
					},
					exaggeration: {
						type: "number",
						minimum: 0,
						default: 1
					}
				},
				projection: { type: {
					type: "projectionDefinition",
					default: "mercator",
					"property-type": "data-constant",
					transition: !1,
					expression: {
						interpolated: !0,
						parameters: ["zoom"]
					}
				} },
				paint: [
					"paint_fill",
					"paint_line",
					"paint_circle",
					"paint_heatmap",
					"paint_fill-extrusion",
					"paint_symbol",
					"paint_raster",
					"paint_hillshade",
					"paint_color-relief",
					"paint_background"
				],
				paint_fill: {
					"fill-antialias": {
						type: "boolean",
						default: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-outline-color": {
						type: "color",
						transition: !0,
						requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					}
				},
				"paint_fill-extrusion": {
					"fill-extrusion-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-extrusion-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-extrusion-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"fill-extrusion-height": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-base": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						requires: ["fill-extrusion-height"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-vertical-gradient": {
						type: "boolean",
						default: !0,
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_line: {
					"line-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["line-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-width": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-gap-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-offset": {
						type: "number",
						default: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-dasharray": {
						type: "array",
						value: "number",
						minimum: 0,
						transition: !0,
						units: "line widths",
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-gradient": {
						type: "color",
						transition: !1,
						requires: [
							{ "!": "line-dasharray" },
							{ "!": "line-pattern" },
							{
								source: "geojson",
								has: { lineMetrics: !0 }
							}
						],
						expression: {
							interpolated: !0,
							parameters: ["line-progress"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_circle: {
					"circle-radius": {
						type: "number",
						default: 5,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-blur": {
						type: "number",
						default: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["circle-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-scale": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-stroke-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					}
				},
				paint_heatmap: {
					"heatmap-radius": {
						type: "number",
						default: 30,
						minimum: 1,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-weight": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-intensity": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"heatmap-color": {
						type: "color",
						default: [
							"interpolate",
							["linear"],
							["heatmap-density"],
							0,
							"rgba(0, 0, 255, 0)",
							.1,
							"royalblue",
							.3,
							"cyan",
							.5,
							"lime",
							.7,
							"yellow",
							1,
							"red"
						],
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["heatmap-density"]
						},
						"property-type": "color-ramp"
					},
					"heatmap-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_symbol: {
					"icon-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["icon-image", "icon-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						overridable: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["text-field", "text-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_raster: {
					"raster-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-hue-rotate": {
						type: "number",
						default: 0,
						period: 360,
						transition: !0,
						units: "degrees",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-min": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-max": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-saturation": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-contrast": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-resampling": {
						type: "enum",
						values: {
							linear: {},
							nearest: {}
						},
						default: "linear",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-fade-duration": {
						type: "number",
						default: 300,
						minimum: 0,
						transition: !1,
						units: "milliseconds",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_hillshade: {
					"hillshade-illumination-direction": {
						type: "numberArray",
						default: 335,
						minimum: 0,
						maximum: 359,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-altitude": {
						type: "numberArray",
						default: 45,
						minimum: 0,
						maximum: 90,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-exaggeration": {
						type: "number",
						default: .5,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-shadow-color": {
						type: "colorArray",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-highlight-color": {
						type: "colorArray",
						default: "#FFFFFF",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-accent-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-method": {
						type: "enum",
						values: {
							standard: {},
							basic: {},
							combined: {},
							igor: {},
							multidirectional: {}
						},
						default: "standard",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				"paint_color-relief": {
					"color-relief-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"color-relief-color": {
						type: "color",
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["elevation"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_background: {
					"background-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "background-pattern" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"background-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "cross-faded"
					},
					"background-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				transition: {
					duration: {
						type: "number",
						default: 300,
						minimum: 0,
						units: "milliseconds"
					},
					delay: {
						type: "number",
						default: 0,
						minimum: 0,
						units: "milliseconds"
					}
				},
				"property-type": {
					"data-driven": { type: "property-type" },
					"cross-faded": { type: "property-type" },
					"cross-faded-data-driven": { type: "property-type" },
					"color-ramp": { type: "property-type" },
					"data-constant": { type: "property-type" },
					constant: { type: "property-type" }
				},
				promoteId: { "*": { type: "string" } }
			};
			const bt$1 = [
				"type",
				"source",
				"source-layer",
				"minzoom",
				"maxzoom",
				"filter",
				"layout"
			];
			function wt$1(t$1, e$1) {
				const r$1 = {};
				for (const e$2 in t$1) "ref" !== e$2 && (r$1[e$2] = t$1[e$2]);
				return bt$1.forEach(((t$2) => {
					t$2 in e$1 && (r$1[t$2] = e$1[t$2]);
				})), r$1;
			}
			function _t$1(t$1, e$1) {
				if (Array.isArray(t$1)) {
					if (!Array.isArray(e$1) || t$1.length !== e$1.length) return !1;
					for (let r$1 = 0; r$1 < t$1.length; r$1++) if (!_t$1(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				if ("object" == typeof t$1 && null !== t$1 && null !== e$1) {
					if ("object" != typeof e$1) return !1;
					if (Object.keys(t$1).length !== Object.keys(e$1).length) return !1;
					for (const r$1 in t$1) if (!_t$1(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				return t$1 === e$1;
			}
			function At$1(t$1, e$1) {
				t$1.push(e$1);
			}
			function St$1(t$1, e$1, r$1) {
				At$1(r$1, {
					command: "addSource",
					args: [t$1, e$1[t$1]]
				});
			}
			function kt$1(t$1, e$1, r$1) {
				At$1(e$1, {
					command: "removeSource",
					args: [t$1]
				}), r$1[t$1] = !0;
			}
			function Et$1(t$1, e$1, r$1, n$1) {
				kt$1(t$1, r$1, n$1), St$1(t$1, e$1, r$1);
			}
			function Tt$1(t$1, e$1, r$1) {
				let n$1;
				for (n$1 in t$1[r$1]) if (Object.prototype.hasOwnProperty.call(t$1[r$1], n$1) && "data" !== n$1 && !_t$1(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				for (n$1 in e$1[r$1]) if (Object.prototype.hasOwnProperty.call(e$1[r$1], n$1) && "data" !== n$1 && !_t$1(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				return !0;
			}
			function It$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				t$1 = t$1 || {}, e$1 = e$1 || {};
				for (const o in t$1) Object.prototype.hasOwnProperty.call(t$1, o) && (_t$1(t$1[o], e$1[o]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						o,
						e$1[o],
						i$1
					]
				}));
				for (const o in e$1) Object.prototype.hasOwnProperty.call(e$1, o) && !Object.prototype.hasOwnProperty.call(t$1, o) && (_t$1(t$1[o], e$1[o]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						o,
						e$1[o],
						i$1
					]
				}));
			}
			function Mt$1(t$1) {
				return t$1.id;
			}
			function Ft$1(t$1, e$1) {
				return t$1[e$1.id] = e$1, t$1;
			}
			class Dt$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.message = (t$1 ? `${t$1}: ` : "") + r$1, n$1 && (this.identifier = n$1), null != e$1 && e$1.__line__ && (this.line = e$1.__line__);
				}
			}
			function Pt$1(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			class zt$1 extends Error {
				constructor(t$1, e$1) {
					super(e$1), this.message = e$1, this.key = t$1;
				}
			}
			class Bt$1 {
				constructor(t$1, e$1 = []) {
					this.parent = t$1, this.bindings = {};
					for (const [t$2, r$1] of e$1) this.bindings[t$2] = r$1;
				}
				concat(t$1) {
					return new Bt$1(this, t$1);
				}
				get(t$1) {
					if (this.bindings[t$1]) return this.bindings[t$1];
					if (this.parent) return this.parent.get(t$1);
					throw new Error(`${t$1} not found in scope.`);
				}
				has(t$1) {
					return !!this.bindings[t$1] || !!this.parent && this.parent.has(t$1);
				}
			}
			const Vt$1 = { kind: "null" }, Ct$1 = { kind: "number" }, Lt$1 = { kind: "string" }, Ot$1 = { kind: "boolean" }, Rt$1 = { kind: "color" }, Nt$1 = { kind: "projectionDefinition" }, $t$1 = { kind: "object" }, Ut$1 = { kind: "value" }, qt$1 = { kind: "collator" }, jt$1 = { kind: "formatted" }, Gt$1 = { kind: "padding" }, Xt$1 = { kind: "colorArray" }, Yt$1 = { kind: "numberArray" }, Zt$1 = { kind: "resolvedImage" }, Ht$1 = { kind: "variableAnchorOffsetCollection" };
			function Kt$1(t$1, e$1) {
				return {
					kind: "array",
					itemType: t$1,
					N: e$1
				};
			}
			function Wt$1(t$1) {
				if ("array" === t$1.kind) {
					const e$1 = Wt$1(t$1.itemType);
					return "number" == typeof t$1.N ? `array<${e$1}, ${t$1.N}>` : "value" === t$1.itemType.kind ? "array" : `array<${e$1}>`;
				}
				return t$1.kind;
			}
			const Jt$1 = [
				Vt$1,
				Ct$1,
				Lt$1,
				Ot$1,
				Rt$1,
				Nt$1,
				jt$1,
				$t$1,
				Kt$1(Ut$1),
				Gt$1,
				Yt$1,
				Xt$1,
				Zt$1,
				Ht$1
			];
			function Qt$1(t$1, e$1) {
				if ("error" === e$1.kind) return null;
				if ("array" === t$1.kind) {
					if ("array" === e$1.kind && (0 === e$1.N && "value" === e$1.itemType.kind || !Qt$1(t$1.itemType, e$1.itemType)) && ("number" != typeof t$1.N || t$1.N === e$1.N)) return null;
				} else {
					if (t$1.kind === e$1.kind) return null;
					if ("value" === t$1.kind) {
						for (const t$2 of Jt$1) if (!Qt$1(t$2, e$1)) return null;
					}
				}
				return `Expected ${Wt$1(t$1)} but found ${Wt$1(e$1)} instead.`;
			}
			function te$1(t$1, e$1) {
				return e$1.some(((e$2) => e$2.kind === t$1.kind));
			}
			function ee$1(t$1, e$1) {
				return e$1.some(((e$2) => "null" === e$2 ? null === t$1 : "array" === e$2 ? Array.isArray(t$1) : "object" === e$2 ? t$1 && !Array.isArray(t$1) && "object" == typeof t$1 : e$2 === typeof t$1));
			}
			function re$1(t$1, e$1) {
				return "array" === t$1.kind && "array" === e$1.kind ? t$1.itemType.kind === e$1.itemType.kind && "number" == typeof t$1.N : t$1.kind === e$1.kind;
			}
			const ne$1 = .96422, ie$1 = .82521, se$1 = 4 / 29, oe$1 = 6 / 29, ae$1 = 3 * oe$1 * oe$1, le$1 = oe$1 * oe$1 * oe$1, ue$1 = Math.PI / 180, ce$1 = 180 / Math.PI;
			function he$1(t$1) {
				return (t$1 %= 360) < 0 && (t$1 += 360), t$1;
			}
			function pe$1([t$1, e$1, r$1, n$1]) {
				let i$1, s$1;
				const o = de$1((.2225045 * (t$1 = fe$1(t$1)) + .7168786 * (e$1 = fe$1(e$1)) + .0606169 * (r$1 = fe$1(r$1))) / 1);
				t$1 === e$1 && e$1 === r$1 ? i$1 = s$1 = o : (i$1 = de$1((.4360747 * t$1 + .3850649 * e$1 + .1430804 * r$1) / ne$1), s$1 = de$1((.0139322 * t$1 + .0971045 * e$1 + .7141733 * r$1) / ie$1));
				const a$1 = 116 * o - 16;
				return [
					a$1 < 0 ? 0 : a$1,
					500 * (i$1 - o),
					200 * (o - s$1),
					n$1
				];
			}
			function fe$1(t$1) {
				return t$1 <= .04045 ? t$1 / 12.92 : Math.pow((t$1 + .055) / 1.055, 2.4);
			}
			function de$1(t$1) {
				return t$1 > le$1 ? Math.pow(t$1, 1 / 3) : t$1 / ae$1 + se$1;
			}
			function ye$1([t$1, e$1, r$1, n$1]) {
				let i$1 = (t$1 + 16) / 116, s$1 = isNaN(e$1) ? i$1 : i$1 + e$1 / 500, o = isNaN(r$1) ? i$1 : i$1 - r$1 / 200;
				return i$1 = 1 * ge(i$1), s$1 = ne$1 * ge(s$1), o = ie$1 * ge(o), [
					me$1(3.1338561 * s$1 - 1.6168667 * i$1 - .4906146 * o),
					me$1(-.9787684 * s$1 + 1.9161415 * i$1 + .033454 * o),
					me$1(.0719453 * s$1 - .2289914 * i$1 + 1.4052427 * o),
					n$1
				];
			}
			function me$1(t$1) {
				return (t$1 = t$1 <= .00304 ? 12.92 * t$1 : 1.055 * Math.pow(t$1, 1 / 2.4) - .055) < 0 ? 0 : t$1 > 1 ? 1 : t$1;
			}
			function ge(t$1) {
				return t$1 > oe$1 ? t$1 * t$1 * t$1 : ae$1 * (t$1 - se$1);
			}
			const xe$1 = Object.hasOwn || function(t$1, e$1) {
				return Object.prototype.hasOwnProperty.call(t$1, e$1);
			};
			function ve$1(t$1, e$1) {
				return xe$1(t$1, e$1) ? t$1[e$1] : void 0;
			}
			function be$1(t$1) {
				return parseInt(t$1.padEnd(2, t$1), 16) / 255;
			}
			function we$1(t$1, e$1) {
				return _e$1(e$1 ? t$1 / 100 : t$1, 0, 1);
			}
			function _e$1(t$1, e$1, r$1) {
				return Math.min(Math.max(e$1, t$1), r$1);
			}
			function Ae$1(t$1) {
				return !t$1.some(Number.isNaN);
			}
			const Se$1 = {
				aliceblue: [
					240,
					248,
					255
				],
				antiquewhite: [
					250,
					235,
					215
				],
				aqua: [
					0,
					255,
					255
				],
				aquamarine: [
					127,
					255,
					212
				],
				azure: [
					240,
					255,
					255
				],
				beige: [
					245,
					245,
					220
				],
				bisque: [
					255,
					228,
					196
				],
				black: [
					0,
					0,
					0
				],
				blanchedalmond: [
					255,
					235,
					205
				],
				blue: [
					0,
					0,
					255
				],
				blueviolet: [
					138,
					43,
					226
				],
				brown: [
					165,
					42,
					42
				],
				burlywood: [
					222,
					184,
					135
				],
				cadetblue: [
					95,
					158,
					160
				],
				chartreuse: [
					127,
					255,
					0
				],
				chocolate: [
					210,
					105,
					30
				],
				coral: [
					255,
					127,
					80
				],
				cornflowerblue: [
					100,
					149,
					237
				],
				cornsilk: [
					255,
					248,
					220
				],
				crimson: [
					220,
					20,
					60
				],
				cyan: [
					0,
					255,
					255
				],
				darkblue: [
					0,
					0,
					139
				],
				darkcyan: [
					0,
					139,
					139
				],
				darkgoldenrod: [
					184,
					134,
					11
				],
				darkgray: [
					169,
					169,
					169
				],
				darkgreen: [
					0,
					100,
					0
				],
				darkgrey: [
					169,
					169,
					169
				],
				darkkhaki: [
					189,
					183,
					107
				],
				darkmagenta: [
					139,
					0,
					139
				],
				darkolivegreen: [
					85,
					107,
					47
				],
				darkorange: [
					255,
					140,
					0
				],
				darkorchid: [
					153,
					50,
					204
				],
				darkred: [
					139,
					0,
					0
				],
				darksalmon: [
					233,
					150,
					122
				],
				darkseagreen: [
					143,
					188,
					143
				],
				darkslateblue: [
					72,
					61,
					139
				],
				darkslategray: [
					47,
					79,
					79
				],
				darkslategrey: [
					47,
					79,
					79
				],
				darkturquoise: [
					0,
					206,
					209
				],
				darkviolet: [
					148,
					0,
					211
				],
				deeppink: [
					255,
					20,
					147
				],
				deepskyblue: [
					0,
					191,
					255
				],
				dimgray: [
					105,
					105,
					105
				],
				dimgrey: [
					105,
					105,
					105
				],
				dodgerblue: [
					30,
					144,
					255
				],
				firebrick: [
					178,
					34,
					34
				],
				floralwhite: [
					255,
					250,
					240
				],
				forestgreen: [
					34,
					139,
					34
				],
				fuchsia: [
					255,
					0,
					255
				],
				gainsboro: [
					220,
					220,
					220
				],
				ghostwhite: [
					248,
					248,
					255
				],
				gold: [
					255,
					215,
					0
				],
				goldenrod: [
					218,
					165,
					32
				],
				gray: [
					128,
					128,
					128
				],
				green: [
					0,
					128,
					0
				],
				greenyellow: [
					173,
					255,
					47
				],
				grey: [
					128,
					128,
					128
				],
				honeydew: [
					240,
					255,
					240
				],
				hotpink: [
					255,
					105,
					180
				],
				indianred: [
					205,
					92,
					92
				],
				indigo: [
					75,
					0,
					130
				],
				ivory: [
					255,
					255,
					240
				],
				khaki: [
					240,
					230,
					140
				],
				lavender: [
					230,
					230,
					250
				],
				lavenderblush: [
					255,
					240,
					245
				],
				lawngreen: [
					124,
					252,
					0
				],
				lemonchiffon: [
					255,
					250,
					205
				],
				lightblue: [
					173,
					216,
					230
				],
				lightcoral: [
					240,
					128,
					128
				],
				lightcyan: [
					224,
					255,
					255
				],
				lightgoldenrodyellow: [
					250,
					250,
					210
				],
				lightgray: [
					211,
					211,
					211
				],
				lightgreen: [
					144,
					238,
					144
				],
				lightgrey: [
					211,
					211,
					211
				],
				lightpink: [
					255,
					182,
					193
				],
				lightsalmon: [
					255,
					160,
					122
				],
				lightseagreen: [
					32,
					178,
					170
				],
				lightskyblue: [
					135,
					206,
					250
				],
				lightslategray: [
					119,
					136,
					153
				],
				lightslategrey: [
					119,
					136,
					153
				],
				lightsteelblue: [
					176,
					196,
					222
				],
				lightyellow: [
					255,
					255,
					224
				],
				lime: [
					0,
					255,
					0
				],
				limegreen: [
					50,
					205,
					50
				],
				linen: [
					250,
					240,
					230
				],
				magenta: [
					255,
					0,
					255
				],
				maroon: [
					128,
					0,
					0
				],
				mediumaquamarine: [
					102,
					205,
					170
				],
				mediumblue: [
					0,
					0,
					205
				],
				mediumorchid: [
					186,
					85,
					211
				],
				mediumpurple: [
					147,
					112,
					219
				],
				mediumseagreen: [
					60,
					179,
					113
				],
				mediumslateblue: [
					123,
					104,
					238
				],
				mediumspringgreen: [
					0,
					250,
					154
				],
				mediumturquoise: [
					72,
					209,
					204
				],
				mediumvioletred: [
					199,
					21,
					133
				],
				midnightblue: [
					25,
					25,
					112
				],
				mintcream: [
					245,
					255,
					250
				],
				mistyrose: [
					255,
					228,
					225
				],
				moccasin: [
					255,
					228,
					181
				],
				navajowhite: [
					255,
					222,
					173
				],
				navy: [
					0,
					0,
					128
				],
				oldlace: [
					253,
					245,
					230
				],
				olive: [
					128,
					128,
					0
				],
				olivedrab: [
					107,
					142,
					35
				],
				orange: [
					255,
					165,
					0
				],
				orangered: [
					255,
					69,
					0
				],
				orchid: [
					218,
					112,
					214
				],
				palegoldenrod: [
					238,
					232,
					170
				],
				palegreen: [
					152,
					251,
					152
				],
				paleturquoise: [
					175,
					238,
					238
				],
				palevioletred: [
					219,
					112,
					147
				],
				papayawhip: [
					255,
					239,
					213
				],
				peachpuff: [
					255,
					218,
					185
				],
				peru: [
					205,
					133,
					63
				],
				pink: [
					255,
					192,
					203
				],
				plum: [
					221,
					160,
					221
				],
				powderblue: [
					176,
					224,
					230
				],
				purple: [
					128,
					0,
					128
				],
				rebeccapurple: [
					102,
					51,
					153
				],
				red: [
					255,
					0,
					0
				],
				rosybrown: [
					188,
					143,
					143
				],
				royalblue: [
					65,
					105,
					225
				],
				saddlebrown: [
					139,
					69,
					19
				],
				salmon: [
					250,
					128,
					114
				],
				sandybrown: [
					244,
					164,
					96
				],
				seagreen: [
					46,
					139,
					87
				],
				seashell: [
					255,
					245,
					238
				],
				sienna: [
					160,
					82,
					45
				],
				silver: [
					192,
					192,
					192
				],
				skyblue: [
					135,
					206,
					235
				],
				slateblue: [
					106,
					90,
					205
				],
				slategray: [
					112,
					128,
					144
				],
				slategrey: [
					112,
					128,
					144
				],
				snow: [
					255,
					250,
					250
				],
				springgreen: [
					0,
					255,
					127
				],
				steelblue: [
					70,
					130,
					180
				],
				tan: [
					210,
					180,
					140
				],
				teal: [
					0,
					128,
					128
				],
				thistle: [
					216,
					191,
					216
				],
				tomato: [
					255,
					99,
					71
				],
				turquoise: [
					64,
					224,
					208
				],
				violet: [
					238,
					130,
					238
				],
				wheat: [
					245,
					222,
					179
				],
				white: [
					255,
					255,
					255
				],
				whitesmoke: [
					245,
					245,
					245
				],
				yellow: [
					255,
					255,
					0
				],
				yellowgreen: [
					154,
					205,
					50
				]
			};
			function ke$1(t$1, e$1, r$1) {
				return t$1 + r$1 * (e$1 - t$1);
			}
			function Ee$1(t$1, e$1, r$1) {
				return t$1.map(((t$2, n$1) => ke$1(t$2, e$1[n$1], r$1)));
			}
			class Te$1 {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = !0) {
					this.r = t$1, this.g = e$1, this.b = r$1, this.a = n$1, i$1 || (this.r *= n$1, this.g *= n$1, this.b *= n$1, n$1 || this.overwriteGetter("rgb", [
						t$1,
						e$1,
						r$1,
						n$1
					]));
				}
				static parse(t$1) {
					if (t$1 instanceof Te$1) return t$1;
					if ("string" != typeof t$1) return;
					const e$1 = function(t$2) {
						if ("transparent" === (t$2 = t$2.toLowerCase().trim())) return [
							0,
							0,
							0,
							0
						];
						const e$2 = ve$1(Se$1, t$2);
						if (e$2) {
							const [t$3, r$2, n$1] = e$2;
							return [
								t$3 / 255,
								r$2 / 255,
								n$1 / 255,
								1
							];
						}
						if (t$2.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t$2)) {
							const e$3 = t$2.length < 6 ? 1 : 2;
							let r$2 = 1;
							return [
								be$1(t$2.slice(r$2, r$2 += e$3)),
								be$1(t$2.slice(r$2, r$2 += e$3)),
								be$1(t$2.slice(r$2, r$2 += e$3)),
								be$1(t$2.slice(r$2, r$2 + e$3) || "ff")
							];
						}
						if (t$2.startsWith("rgb")) {
							const e$3 = t$2.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
							if (e$3) {
								const [t$3, r$2, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1] = e$3, f$1 = [
									i$1 || " ",
									a$1 || " ",
									c$1
								].join("");
								if ("  " === f$1 || "  /" === f$1 || ",," === f$1 || ",,," === f$1) {
									const t$4 = [
										n$1,
										o,
										u$1
									].join(""), e$4 = "%%%" === t$4 ? 100 : "" === t$4 ? 255 : 0;
									if (e$4) {
										const t$5 = [
											_e$1(+r$2 / e$4, 0, 1),
											_e$1(+s$1 / e$4, 0, 1),
											_e$1(+l$1 / e$4, 0, 1),
											h$1 ? we$1(+h$1, p$1) : 1
										];
										if (Ae$1(t$5)) return t$5;
									}
								}
								return;
							}
						}
						const r$1 = t$2.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
						if (r$1) {
							const [t$3, e$3, n$1, i$1, s$1, o, a$1, l$1, u$1] = r$1, c$1 = [
								n$1 || " ",
								s$1 || " ",
								a$1
							].join("");
							if ("  " === c$1 || "  /" === c$1 || ",," === c$1 || ",,," === c$1) {
								const t$4 = [
									+e$3,
									_e$1(+i$1, 0, 100),
									_e$1(+o, 0, 100),
									l$1 ? we$1(+l$1, u$1) : 1
								];
								if (Ae$1(t$4)) return function([t$5, e$4, r$2, n$2]) {
									function i$2(n$3) {
										const i$3 = (n$3 + t$5 / 30) % 12, s$2 = e$4 * Math.min(r$2, 1 - r$2);
										return r$2 - s$2 * Math.max(-1, Math.min(i$3 - 3, 9 - i$3, 1));
									}
									return t$5 = he$1(t$5), e$4 /= 100, r$2 /= 100, [
										i$2(0),
										i$2(8),
										i$2(4),
										n$2
									];
								}(t$4);
							}
						}
					}(t$1);
					return e$1 ? new Te$1(...e$1, !1) : void 0;
				}
				get rgb() {
					const { r: t$1, g: e$1, b: r$1, a: n$1 } = this, i$1 = n$1 || Infinity;
					return this.overwriteGetter("rgb", [
						t$1 / i$1,
						e$1 / i$1,
						r$1 / i$1,
						n$1
					]);
				}
				get hcl() {
					return this.overwriteGetter("hcl", function(t$1) {
						const [e$1, r$1, n$1, i$1] = pe$1(t$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
						return [
							Math.round(1e4 * s$1) ? he$1(Math.atan2(n$1, r$1) * ce$1) : NaN,
							s$1,
							e$1,
							i$1
						];
					}(this.rgb));
				}
				get lab() {
					return this.overwriteGetter("lab", pe$1(this.rgb));
				}
				overwriteGetter(t$1, e$1) {
					return Object.defineProperty(this, t$1, { value: e$1 }), e$1;
				}
				toString() {
					const [t$1, e$1, r$1, n$1] = this.rgb;
					return `rgba(${[
						t$1,
						e$1,
						r$1
					].map(((t$2) => Math.round(255 * t$2))).join(",")},${n$1})`;
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					switch (n$1) {
						case "rgb": {
							const [n$2, i$1, s$1, o] = Ee$1(t$1.rgb, e$1.rgb, r$1);
							return new Te$1(n$2, i$1, s$1, o, !1);
						}
						case "hcl": {
							const [n$2, i$1, s$1, o] = t$1.hcl, [a$1, l$1, u$1, c$1] = e$1.hcl;
							let h$1, p$1;
							if (isNaN(n$2) || isNaN(a$1)) isNaN(n$2) ? isNaN(a$1) ? h$1 = NaN : (h$1 = a$1, 1 !== s$1 && 0 !== s$1 || (p$1 = l$1)) : (h$1 = n$2, 1 !== u$1 && 0 !== u$1 || (p$1 = i$1));
							else {
								let t$2 = a$1 - n$2;
								a$1 > n$2 && t$2 > 180 ? t$2 -= 360 : a$1 < n$2 && n$2 - a$1 > 180 && (t$2 += 360), h$1 = n$2 + r$1 * t$2;
							}
							const [f$1, d$1, y$1, m$1] = function([t$2, e$2, r$2, n$3]) {
								return t$2 = isNaN(t$2) ? 0 : t$2 * ue$1, ye$1([
									r$2,
									Math.cos(t$2) * e$2,
									Math.sin(t$2) * e$2,
									n$3
								]);
							}([
								h$1,
								null != p$1 ? p$1 : ke$1(i$1, l$1, r$1),
								ke$1(s$1, u$1, r$1),
								ke$1(o, c$1, r$1)
							]);
							return new Te$1(f$1, d$1, y$1, m$1, !1);
						}
						case "lab": {
							const [n$2, i$1, s$1, o] = ye$1(Ee$1(t$1.lab, e$1.lab, r$1));
							return new Te$1(n$2, i$1, s$1, o, !1);
						}
					}
				}
			}
			Te$1.black = new Te$1(0, 0, 0, 1), Te$1.white = new Te$1(1, 1, 1, 1), Te$1.transparent = new Te$1(0, 0, 0, 0), Te$1.red = new Te$1(1, 0, 0, 1);
			class Ie$1 {
				constructor(t$1, e$1, r$1) {
					this.sensitivity = t$1 ? e$1 ? "variant" : "case" : e$1 ? "accent" : "base", this.locale = r$1, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
						sensitivity: this.sensitivity,
						usage: "search"
					});
				}
				compare(t$1, e$1) {
					return this.collator.compare(t$1, e$1);
				}
				resolvedLocale() {
					return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
				}
			}
			const Me$1 = [
				"bottom",
				"center",
				"top"
			];
			class Fe$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.text = t$1, this.image = e$1, this.scale = r$1, this.fontStack = n$1, this.textColor = i$1, this.verticalAlign = s$1;
				}
			}
			class De$1 {
				constructor(t$1) {
					this.sections = t$1;
				}
				static fromString(t$1) {
					return new De$1([new Fe$1(t$1, null, null, null, null, null)]);
				}
				isEmpty() {
					return 0 === this.sections.length || !this.sections.some(((t$1) => 0 !== t$1.text.length || t$1.image && 0 !== t$1.image.name.length));
				}
				static factory(t$1) {
					return t$1 instanceof De$1 ? t$1 : De$1.fromString(t$1);
				}
				toString() {
					return 0 === this.sections.length ? "" : this.sections.map(((t$1) => t$1.text)).join("");
				}
			}
			class Pe$1 {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Pe$1) return t$1;
					if ("number" == typeof t$1) return new Pe$1([
						t$1,
						t$1,
						t$1,
						t$1
					]);
					if (Array.isArray(t$1) && !(t$1.length < 1 || t$1.length > 4)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						switch (t$1.length) {
							case 1:
								t$1 = [
									t$1[0],
									t$1[0],
									t$1[0],
									t$1[0]
								];
								break;
							case 2:
								t$1 = [
									t$1[0],
									t$1[1],
									t$1[0],
									t$1[1]
								];
								break;
							case 3: t$1 = [
								t$1[0],
								t$1[1],
								t$1[2],
								t$1[1]
							];
						}
						return new Pe$1(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new Pe$1(Ee$1(t$1.values, e$1.values, r$1));
				}
			}
			class ze$1 {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof ze$1) return t$1;
					if ("number" == typeof t$1) return new ze$1([t$1]);
					if (Array.isArray(t$1)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						return new ze$1(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new ze$1(Ee$1(t$1.values, e$1.values, r$1));
				}
			}
			class Be$1 {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Be$1) return t$1;
					if ("string" == typeof t$1) {
						const e$2 = Te$1.parse(t$1);
						if (!e$2) return;
						return new Be$1([e$2]);
					}
					if (!Array.isArray(t$1)) return;
					const e$1 = [];
					for (const r$1 of t$1) {
						if ("string" != typeof r$1) return;
						const t$2 = Te$1.parse(r$1);
						if (!t$2) return;
						e$1.push(t$2);
					}
					return new Be$1(e$1);
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					const i$1 = [];
					if (t$1.values.length != e$1.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t$1.values.length} vs. ${e$1.values.length}), cannot interpolate.`);
					for (let s$1 = 0; s$1 < t$1.values.length; s$1++) i$1.push(Te$1.interpolate(t$1.values[s$1], e$1.values[s$1], r$1, n$1));
					return new Be$1(i$1);
				}
			}
			class Ve$1 extends Error {
				constructor(t$1) {
					super(t$1), this.name = "RuntimeError";
				}
				toJSON() {
					return this.message;
				}
			}
			const Ce$1 = new Set([
				"center",
				"left",
				"right",
				"top",
				"bottom",
				"top-left",
				"top-right",
				"bottom-left",
				"bottom-right"
			]);
			class Le$1 {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Le$1) return t$1;
					if (Array.isArray(t$1) && !(t$1.length < 1) && t$1.length % 2 == 0) {
						for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
							const r$1 = t$1[e$1], n$1 = t$1[e$1 + 1];
							if ("string" != typeof r$1 || !Ce$1.has(r$1)) return;
							if (!Array.isArray(n$1) || 2 !== n$1.length || "number" != typeof n$1[0] || "number" != typeof n$1[1]) return;
						}
						return new Le$1(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					const n$1 = t$1.values, i$1 = e$1.values;
					if (n$1.length !== i$1.length) throw new Ve$1(`Cannot interpolate values of different length. from: ${t$1.toString()}, to: ${e$1.toString()}`);
					const s$1 = [];
					for (let t$2 = 0; t$2 < n$1.length; t$2 += 2) {
						if (n$1[t$2] !== i$1[t$2]) throw new Ve$1(`Cannot interpolate values containing mismatched anchors. from[${t$2}]: ${n$1[t$2]}, to[${t$2}]: ${i$1[t$2]}`);
						s$1.push(n$1[t$2]);
						const [e$2, o] = n$1[t$2 + 1], [a$1, l$1] = i$1[t$2 + 1];
						s$1.push([ke$1(e$2, a$1, r$1), ke$1(o, l$1, r$1)]);
					}
					return new Le$1(s$1);
				}
			}
			class Oe$1 {
				constructor(t$1) {
					this.name = t$1.name, this.available = t$1.available;
				}
				toString() {
					return this.name;
				}
				static fromString(t$1) {
					return t$1 ? new Oe$1({
						name: t$1,
						available: !1
					}) : null;
				}
			}
			class Re$1 {
				constructor(t$1, e$1, r$1) {
					this.from = t$1, this.to = e$1, this.transition = r$1;
				}
				static interpolate(t$1, e$1, r$1) {
					return new Re$1(t$1, e$1, r$1);
				}
				static parse(t$1) {
					return t$1 instanceof Re$1 ? t$1 : Array.isArray(t$1) && 3 === t$1.length && "string" == typeof t$1[0] && "string" == typeof t$1[1] && "number" == typeof t$1[2] ? new Re$1(t$1[0], t$1[1], t$1[2]) : "object" == typeof t$1 && "string" == typeof t$1.from && "string" == typeof t$1.to && "number" == typeof t$1.transition ? new Re$1(t$1.from, t$1.to, t$1.transition) : "string" == typeof t$1 ? new Re$1(t$1, t$1, 1) : void 0;
				}
			}
			function Ne$1(t$1, e$1, r$1, n$1) {
				return "number" == typeof t$1 && t$1 >= 0 && t$1 <= 255 && "number" == typeof e$1 && e$1 >= 0 && e$1 <= 255 && "number" == typeof r$1 && r$1 >= 0 && r$1 <= 255 ? void 0 === n$1 || "number" == typeof n$1 && n$1 >= 0 && n$1 <= 1 ? null : `Invalid rgba value [${[
					t$1,
					e$1,
					r$1,
					n$1
				].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n$1 ? [
					t$1,
					e$1,
					r$1,
					n$1
				] : [
					t$1,
					e$1,
					r$1
				]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
			}
			function $e$1(t$1) {
				if (null === t$1 || "string" == typeof t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || t$1 instanceof Re$1 || t$1 instanceof Te$1 || t$1 instanceof Ie$1 || t$1 instanceof De$1 || t$1 instanceof Pe$1 || t$1 instanceof ze$1 || t$1 instanceof Be$1 || t$1 instanceof Le$1 || t$1 instanceof Oe$1) return !0;
				if (Array.isArray(t$1)) {
					for (const e$1 of t$1) if (!$e$1(e$1)) return !1;
					return !0;
				}
				if ("object" == typeof t$1) {
					for (const e$1 in t$1) if (!$e$1(t$1[e$1])) return !1;
					return !0;
				}
				return !1;
			}
			function Ue$1(t$1) {
				if (null === t$1) return Vt$1;
				if ("string" == typeof t$1) return Lt$1;
				if ("boolean" == typeof t$1) return Ot$1;
				if ("number" == typeof t$1) return Ct$1;
				if (t$1 instanceof Te$1) return Rt$1;
				if (t$1 instanceof Re$1) return Nt$1;
				if (t$1 instanceof Ie$1) return qt$1;
				if (t$1 instanceof De$1) return jt$1;
				if (t$1 instanceof Pe$1) return Gt$1;
				if (t$1 instanceof ze$1) return Yt$1;
				if (t$1 instanceof Be$1) return Xt$1;
				if (t$1 instanceof Le$1) return Ht$1;
				if (t$1 instanceof Oe$1) return Zt$1;
				if (Array.isArray(t$1)) {
					const e$1 = t$1.length;
					let r$1;
					for (const e$2 of t$1) {
						const t$2 = Ue$1(e$2);
						if (r$1) {
							if (r$1 === t$2) continue;
							r$1 = Ut$1;
							break;
						}
						r$1 = t$2;
					}
					return Kt$1(r$1 || Ut$1, e$1);
				}
				return $t$1;
			}
			function qe$1(t$1) {
				const e$1 = typeof t$1;
				return null === t$1 ? "" : "string" === e$1 || "number" === e$1 || "boolean" === e$1 ? String(t$1) : t$1 instanceof Te$1 || t$1 instanceof Re$1 || t$1 instanceof De$1 || t$1 instanceof Pe$1 || t$1 instanceof ze$1 || t$1 instanceof Be$1 || t$1 instanceof Le$1 || t$1 instanceof Oe$1 ? t$1.toString() : JSON.stringify(t$1);
			}
			class je$1 {
				constructor(t$1, e$1) {
					this.type = t$1, this.value = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'literal' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (!$e$1(t$1[1])) return e$1.error("invalid value");
					const r$1 = t$1[1];
					let n$1 = Ue$1(r$1);
					const i$1 = e$1.expectedType;
					return "array" !== n$1.kind || 0 !== n$1.N || !i$1 || "array" !== i$1.kind || "number" == typeof i$1.N && 0 !== i$1.N || (n$1 = i$1), new je$1(n$1, r$1);
				}
				evaluate() {
					return this.value;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			const Ge$1 = {
				string: Lt$1,
				number: Ct$1,
				boolean: Ot$1,
				object: $t$1
			};
			class Xe {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1, n$1 = 1;
					const i$1 = t$1[0];
					if ("array" === i$1) {
						let i$2, s$2;
						if (t$1.length > 2) {
							const r$2 = t$1[1];
							if ("string" != typeof r$2 || !(r$2 in Ge$1) || "object" === r$2) return e$1.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
							i$2 = Ge$1[r$2], n$1++;
						} else i$2 = Ut$1;
						if (t$1.length > 3) {
							if (null !== t$1[2] && ("number" != typeof t$1[2] || t$1[2] < 0 || t$1[2] !== Math.floor(t$1[2]))) return e$1.error("The length argument to \"array\" must be a positive integer literal", 2);
							s$2 = t$1[2], n$1++;
						}
						r$1 = Kt$1(i$2, s$2);
					} else {
						if (!Ge$1[i$1]) throw new Error(`Types doesn't contain name = ${i$1}`);
						r$1 = Ge$1[i$1];
					}
					const s$1 = [];
					for (; n$1 < t$1.length; n$1++) {
						const r$2 = e$1.parse(t$1[n$1], n$1, Ut$1);
						if (!r$2) return null;
						s$1.push(r$2);
					}
					return new Xe(r$1, s$1);
				}
				evaluate(t$1) {
					for (let e$1 = 0; e$1 < this.args.length; e$1++) {
						const r$1 = this.args[e$1].evaluate(t$1);
						if (!Qt$1(this.type, Ue$1(r$1))) return r$1;
						if (e$1 === this.args.length - 1) throw new Ve$1(`Expected value to be of type ${Wt$1(this.type)}, but found ${Wt$1(Ue$1(r$1))} instead.`);
					}
					throw new Error();
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const Ye = {
				"to-boolean": Ot$1,
				"to-color": Rt$1,
				"to-number": Ct$1,
				"to-string": Lt$1
			};
			class Ze$1 {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[0];
					if (!Ye[r$1]) throw new Error(`Can't parse ${r$1} as it is not part of the known types`);
					if (("to-boolean" === r$1 || "to-string" === r$1) && 2 !== t$1.length) return e$1.error("Expected one argument.");
					const n$1 = Ye[r$1], i$1 = [];
					for (let r$2 = 1; r$2 < t$1.length; r$2++) {
						const n$2 = e$1.parse(t$1[r$2], r$2, Ut$1);
						if (!n$2) return null;
						i$1.push(n$2);
					}
					return new Ze$1(n$1, i$1);
				}
				evaluate(t$1) {
					switch (this.type.kind) {
						case "boolean": return Boolean(this.args[0].evaluate(t$1));
						case "color": {
							let e$1, r$1;
							for (const n$1 of this.args) {
								if (e$1 = n$1.evaluate(t$1), r$1 = null, e$1 instanceof Te$1) return e$1;
								if ("string" == typeof e$1) {
									const r$2 = t$1.parseColor(e$1);
									if (r$2) return r$2;
								} else if (Array.isArray(e$1) && (r$1 = e$1.length < 3 || e$1.length > 4 ? `Invalid rgba value ${JSON.stringify(e$1)}: expected an array containing either three or four numeric values.` : Ne$1(e$1[0], e$1[1], e$1[2], e$1[3]), !r$1)) return new Te$1(e$1[0] / 255, e$1[1] / 255, e$1[2] / 255, e$1[3]);
							}
							throw new Ve$1(r$1 || `Could not parse color from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "padding": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Pe$1.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve$1(`Could not parse padding from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "numberArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = ze$1.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve$1(`Could not parse numberArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "colorArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Be$1.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve$1(`Could not parse colorArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "variableAnchorOffsetCollection": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Le$1.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve$1(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "number": {
							let e$1 = null;
							for (const r$1 of this.args) {
								if (e$1 = r$1.evaluate(t$1), null === e$1) return 0;
								const n$1 = Number(e$1);
								if (!isNaN(n$1)) return n$1;
							}
							throw new Ve$1(`Could not convert ${JSON.stringify(e$1)} to number.`);
						}
						case "formatted": return De$1.fromString(qe$1(this.args[0].evaluate(t$1)));
						case "resolvedImage": return Oe$1.fromString(qe$1(this.args[0].evaluate(t$1)));
						case "projectionDefinition": return this.args[0].evaluate(t$1);
						default: return qe$1(this.args[0].evaluate(t$1));
					}
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const He$1 = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class Ke$1 {
				constructor() {
					this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
				}
				id() {
					return this.feature && "id" in this.feature ? this.feature.id : null;
				}
				geometryType() {
					return this.feature ? "number" == typeof this.feature.type ? He$1[this.feature.type] : this.feature.type : null;
				}
				geometry() {
					return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
				}
				canonicalID() {
					return this.canonical;
				}
				properties() {
					return this.feature && this.feature.properties || {};
				}
				parseColor(t$1) {
					let e$1 = this._parseColorCache.get(t$1);
					return e$1 || (e$1 = Te$1.parse(t$1), this._parseColorCache.set(t$1, e$1)), e$1;
				}
			}
			class We {
				constructor(t$1, e$1, r$1 = [], n$1, i$1 = new Bt$1(), s$1 = []) {
					this.registry = t$1, this.path = r$1, this.key = r$1.map(((t$2) => `[${t$2}]`)).join(""), this.scope = i$1, this.errors = s$1, this.expectedType = n$1, this._isConstant = e$1;
				}
				parse(t$1, e$1, r$1, n$1, i$1 = {}) {
					return e$1 ? this.concat(e$1, r$1, n$1)._parse(t$1, i$1) : this._parse(t$1, i$1);
				}
				_parse(t$1, e$1) {
					function r$1(t$2, e$2, r$2) {
						return "assert" === r$2 ? new Xe(e$2, [t$2]) : "coerce" === r$2 ? new Ze$1(e$2, [t$2]) : t$2;
					}
					if (null !== t$1 && "string" != typeof t$1 && "boolean" != typeof t$1 && "number" != typeof t$1 || (t$1 = ["literal", t$1]), Array.isArray(t$1)) {
						if (0 === t$1.length) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
						const n$1 = t$1[0];
						if ("string" != typeof n$1) return this.error(`Expression name must be a string, but found ${typeof n$1} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
						const i$1 = this.registry[n$1];
						if (i$1) {
							let n$2 = i$1.parse(t$1, this);
							if (!n$2) return null;
							if (this.expectedType) {
								const t$2 = this.expectedType, i$2 = n$2.type;
								if ("string" !== t$2.kind && "number" !== t$2.kind && "boolean" !== t$2.kind && "object" !== t$2.kind && "array" !== t$2.kind || "value" !== i$2.kind) {
									if ("projectionDefinition" === t$2.kind && ["string", "array"].includes(i$2.kind) || [
										"color",
										"formatted",
										"resolvedImage"
									].includes(t$2.kind) && ["value", "string"].includes(i$2.kind) || ["padding", "numberArray"].includes(t$2.kind) && [
										"value",
										"number",
										"array"
									].includes(i$2.kind) || "colorArray" === t$2.kind && [
										"value",
										"string",
										"array"
									].includes(i$2.kind) || "variableAnchorOffsetCollection" === t$2.kind && ["value", "array"].includes(i$2.kind)) n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "coerce");
									else if (this.checkSubtype(t$2, i$2)) return null;
								} else n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "assert");
							}
							if (!(n$2 instanceof je$1) && "resolvedImage" !== n$2.type.kind && this._isConstant(n$2)) {
								const t$2 = new Ke$1();
								try {
									n$2 = new je$1(n$2.type, n$2.evaluate(t$2));
								} catch (t$3) {
									return this.error(t$3.message), null;
								}
							}
							return n$2;
						}
						return this.error(`Unknown expression "${n$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					}
					return this.error(void 0 === t$1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t$1 ? "Bare objects invalid. Use [\"literal\", {...}] instead." : `Expected an array, but found ${typeof t$1} instead.`);
				}
				concat(t$1, e$1, r$1) {
					const n$1 = "number" == typeof t$1 ? this.path.concat(t$1) : this.path, i$1 = r$1 ? this.scope.concat(r$1) : this.scope;
					return new We(this.registry, this._isConstant, n$1, e$1 || null, i$1, this.errors);
				}
				error(t$1, ...e$1) {
					const r$1 = `${this.key}${e$1.map(((t$2) => `[${t$2}]`)).join("")}`;
					this.errors.push(new zt$1(r$1, t$1));
				}
				checkSubtype(t$1, e$1) {
					const r$1 = Qt$1(t$1, e$1);
					return r$1 && this.error(r$1), r$1;
				}
			}
			class Je$1 {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.bindings = [].concat(t$1), this.result = e$1;
				}
				evaluate(t$1) {
					return this.result.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const e$1 of this.bindings) t$1(e$1[1]);
					t$1(this.result);
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = [];
					for (let n$2 = 1; n$2 < t$1.length - 1; n$2 += 2) {
						const i$1 = t$1[n$2];
						if ("string" != typeof i$1) return e$1.error(`Expected string, but found ${typeof i$1} instead.`, n$2);
						if (/[^a-zA-Z0-9_]/.test(i$1)) return e$1.error("Variable names must contain only alphanumeric characters or '_'.", n$2);
						const s$1 = e$1.parse(t$1[n$2 + 1], n$2 + 1);
						if (!s$1) return null;
						r$1.push([i$1, s$1]);
					}
					const n$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, e$1.expectedType, r$1);
					return n$1 ? new Je$1(r$1, n$1) : null;
				}
				outputDefined() {
					return this.result.outputDefined();
				}
			}
			class Qe$1 {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.name = t$1, this.boundExpression = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length || "string" != typeof t$1[1]) return e$1.error("'var' expression requires exactly one string literal argument.");
					const r$1 = t$1[1];
					return e$1.scope.has(r$1) ? new Qe$1(r$1, e$1.scope.get(r$1)) : e$1.error(`Unknown variable "${r$1}". Make sure "${r$1}" has been bound in an enclosing "let" expression before using it.`, 1);
				}
				evaluate(t$1) {
					return this.boundExpression.evaluate(t$1);
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			class tr$1 {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.index = e$1, this.input = r$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ct$1), n$1 = e$1.parse(t$1[2], 2, Kt$1(e$1.expectedType || Ut$1));
					return r$1 && n$1 ? new tr$1(n$1.type.itemType, r$1, n$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.index.evaluate(t$1), r$1 = this.input.evaluate(t$1);
					if (e$1 < 0) throw new Ve$1(`Array index out of bounds: ${e$1} < 0.`);
					if (e$1 >= r$1.length) throw new Ve$1(`Array index out of bounds: ${e$1} > ${r$1.length - 1}.`);
					if (e$1 !== Math.floor(e$1)) throw new Ve$1(`Array index must be an integer, but found ${e$1} instead.`);
					return r$1[e$1];
				}
				eachChild(t$1) {
					t$1(this.index), t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class er$1 {
				constructor(t$1, e$1) {
					this.type = Ot$1, this.needle = t$1, this.haystack = e$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut$1), n$1 = e$1.parse(t$1[2], 2, Ut$1);
					return r$1 && n$1 ? te$1(r$1.type, [
						Ot$1,
						Lt$1,
						Ct$1,
						Vt$1,
						Ut$1
					]) ? new er$1(r$1, n$1) : e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt$1(r$1.type)} instead`) : null;
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!r$1) return !1;
					if (!ee$1(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Ve$1(`Expected first argument to be of type boolean, string, number or null, but found ${Wt$1(Ue$1(e$1))} instead.`);
					if (!ee$1(r$1, ["string", "array"])) throw new Ve$1(`Expected second argument to be of type array or string, but found ${Wt$1(Ue$1(r$1))} instead.`);
					return r$1.indexOf(e$1) >= 0;
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack);
				}
				outputDefined() {
					return !0;
				}
			}
			class rr$1 {
				constructor(t$1, e$1, r$1) {
					this.type = Ct$1, this.needle = t$1, this.haystack = e$1, this.fromIndex = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 2 or 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut$1), n$1 = e$1.parse(t$1[2], 2, Ut$1);
					if (!r$1 || !n$1) return null;
					if (!te$1(r$1.type, [
						Ot$1,
						Lt$1,
						Ct$1,
						Vt$1,
						Ut$1
					])) return e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt$1(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ct$1);
						return i$1 ? new rr$1(r$1, n$1, i$1) : null;
					}
					return new rr$1(r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!ee$1(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Ve$1(`Expected first argument to be of type boolean, string, number or null, but found ${Wt$1(Ue$1(e$1))} instead.`);
					let n$1;
					if (this.fromIndex && (n$1 = this.fromIndex.evaluate(t$1)), ee$1(r$1, ["string"])) {
						const t$2 = r$1.indexOf(e$1, n$1);
						return -1 === t$2 ? -1 : [...r$1.slice(0, t$2)].length;
					}
					if (ee$1(r$1, ["array"])) return r$1.indexOf(e$1, n$1);
					throw new Ve$1(`Expected second argument to be of type array or string, but found ${Wt$1(Ue$1(r$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack), this.fromIndex && t$1(this.fromIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			class nr$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.inputType = t$1, this.type = e$1, this.input = r$1, this.cases = n$1, this.outputs = i$1, this.otherwise = s$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 5) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 1) return e$1.error("Expected an even number of arguments.");
					let r$1, n$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (n$1 = e$1.expectedType);
					const i$1 = {}, s$1 = [];
					for (let o$1 = 2; o$1 < t$1.length - 1; o$1 += 2) {
						let a$2 = t$1[o$1];
						const l$1 = t$1[o$1 + 1];
						Array.isArray(a$2) || (a$2 = [a$2]);
						const u$1 = e$1.concat(o$1);
						if (0 === a$2.length) return u$1.error("Expected at least one branch label.");
						for (const t$2 of a$2) {
							if ("number" != typeof t$2 && "string" != typeof t$2) return u$1.error("Branch labels must be numbers or strings.");
							if ("number" == typeof t$2 && Math.abs(t$2) > Number.MAX_SAFE_INTEGER) return u$1.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
							if ("number" == typeof t$2 && Math.floor(t$2) !== t$2) return u$1.error("Numeric branch labels must be integer values.");
							if (r$1) {
								if (u$1.checkSubtype(r$1, Ue$1(t$2))) return null;
							} else r$1 = Ue$1(t$2);
							if (void 0 !== i$1[String(t$2)]) return u$1.error("Branch labels must be unique.");
							i$1[String(t$2)] = s$1.length;
						}
						const c$1 = e$1.parse(l$1, o$1, n$1);
						if (!c$1) return null;
						n$1 = n$1 || c$1.type, s$1.push(c$1);
					}
					const o = e$1.parse(t$1[1], 1, Ut$1);
					if (!o) return null;
					const a$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, n$1);
					return a$1 ? "value" !== o.type.kind && e$1.concat(1).checkSubtype(r$1, o.type) ? null : new nr$1(r$1, n$1, o, i$1, s$1, a$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					return (Ue$1(e$1) === this.inputType && this.outputs[this.cases[e$1]] || this.otherwise).evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input), this.outputs.forEach(t$1), t$1(this.otherwise);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class ir$1 {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.branches = e$1, this.otherwise = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 0) return e$1.error("Expected an odd number of arguments.");
					let r$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (r$1 = e$1.expectedType);
					const n$1 = [];
					for (let i$2 = 1; i$2 < t$1.length - 1; i$2 += 2) {
						const s$1 = e$1.parse(t$1[i$2], i$2, Ot$1);
						if (!s$1) return null;
						const o = e$1.parse(t$1[i$2 + 1], i$2 + 1, r$1);
						if (!o) return null;
						n$1.push([s$1, o]), r$1 = r$1 || o.type;
					}
					const i$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, r$1);
					if (!i$1) return null;
					if (!r$1) throw new Error("Can't infer output type");
					return new ir$1(r$1, n$1, i$1);
				}
				evaluate(t$1) {
					for (const [e$1, r$1] of this.branches) if (e$1.evaluate(t$1)) return r$1.evaluate(t$1);
					return this.otherwise.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const [e$1, r$1] of this.branches) t$1(e$1), t$1(r$1);
					t$1(this.otherwise);
				}
				outputDefined() {
					return this.branches.every((([t$1, e$1]) => e$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class sr$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.type = t$1, this.input = e$1, this.beginIndex = r$1, this.endIndex = n$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 2 or 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut$1), n$1 = e$1.parse(t$1[2], 2, Ct$1);
					if (!r$1 || !n$1) return null;
					if (!te$1(r$1.type, [
						Kt$1(Ut$1),
						Lt$1,
						Ut$1
					])) return e$1.error(`Expected first argument to be of type array or string, but found ${Wt$1(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ct$1);
						return i$1 ? new sr$1(r$1.type, r$1, n$1, i$1) : null;
					}
					return new sr$1(r$1.type, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = this.beginIndex.evaluate(t$1);
					let n$1;
					if (this.endIndex && (n$1 = this.endIndex.evaluate(t$1)), ee$1(e$1, ["string"])) return [...e$1].slice(r$1, n$1).join("");
					if (ee$1(e$1, ["array"])) return e$1.slice(r$1, n$1);
					throw new Ve$1(`Expected first argument to be of type array or string, but found ${Wt$1(Ue$1(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input), t$1(this.beginIndex), this.endIndex && t$1(this.endIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			function or$1(t$1, e$1) {
				const r$1 = t$1.length - 1;
				let n$1, i$1, s$1 = 0, o = r$1, a$1 = 0;
				for (; s$1 <= o;) if (a$1 = Math.floor((s$1 + o) / 2), n$1 = t$1[a$1], i$1 = t$1[a$1 + 1], n$1 <= e$1) {
					if (a$1 === r$1 || e$1 < i$1) return a$1;
					s$1 = a$1 + 1;
				} else {
					if (!(n$1 > e$1)) throw new Ve$1("Input is not a number.");
					o = a$1 - 1;
				}
				return 0;
			}
			class ar$1 {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.input = e$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of r$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static parse(t$1, e$1) {
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ct$1);
					if (!r$1) return null;
					const n$1 = [];
					let i$1 = null;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (i$1 = e$1.expectedType);
					for (let r$2 = 1; r$2 < t$1.length; r$2 += 2) {
						const s$1 = 1 === r$2 ? -Infinity : t$1[r$2], o = t$1[r$2 + 1], a$1 = r$2, l$1 = r$2 + 1;
						if ("number" != typeof s$1) return e$1.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", a$1);
						if (n$1.length && n$1[n$1.length - 1][0] >= s$1) return e$1.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", a$1);
						const u$1 = e$1.parse(o, l$1, i$1);
						if (!u$1) return null;
						i$1 = i$1 || u$1.type, n$1.push([s$1, u$1]);
					}
					return new ar$1(i$1, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					return n$1 >= e$1[i$1 - 1] ? r$1[i$1 - 1].evaluate(t$1) : r$1[or$1(e$1, n$1)].evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function lr$1(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var ur$1, cr$1, pr$1 = lr$1(function() {
				if (cr$1) return ur$1;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return cr$1 = 1, ur$1 = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var o = 0, a$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? o = r$1 : a$1 = r$1, r$1 = .5 * (a$1 - o) + o;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, ur$1;
			}());
			class fr$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = t$1, this.operator = e$1, this.interpolation = r$1, this.input = n$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of i$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static interpolationFactor(t$1, e$1, r$1, n$1) {
					let i$1 = 0;
					if ("exponential" === t$1.name) i$1 = dr$1(e$1, t$1.base, r$1, n$1);
					else if ("linear" === t$1.name) i$1 = dr$1(e$1, 1, r$1, n$1);
					else if ("cubic-bezier" === t$1.name) {
						const s$1 = t$1.controlPoints;
						i$1 = new pr$1(s$1[0], s$1[1], s$1[2], s$1[3]).solve(dr$1(e$1, 1, r$1, n$1));
					}
					return i$1;
				}
				static parse(t$1, e$1) {
					let [r$1, n$1, i$1, ...s$1] = t$1;
					if (!Array.isArray(n$1) || 0 === n$1.length) return e$1.error("Expected an interpolation type expression.", 1);
					if ("linear" === n$1[0]) n$1 = { name: "linear" };
					else if ("exponential" === n$1[0]) {
						const t$2 = n$1[1];
						if ("number" != typeof t$2) return e$1.error("Exponential interpolation requires a numeric base.", 1, 1);
						n$1 = {
							name: "exponential",
							base: t$2
						};
					} else {
						if ("cubic-bezier" !== n$1[0]) return e$1.error(`Unknown interpolation type ${String(n$1[0])}`, 1, 0);
						{
							const t$2 = n$1.slice(1);
							if (4 !== t$2.length || t$2.some(((t$3) => "number" != typeof t$3 || t$3 < 0 || t$3 > 1))) return e$1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
							n$1 = {
								name: "cubic-bezier",
								controlPoints: t$2
							};
						}
					}
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					if (i$1 = e$1.parse(i$1, 2, Ct$1), !i$1) return null;
					const o = [];
					let a$1 = null;
					"interpolate-hcl" !== r$1 && "interpolate-lab" !== r$1 || e$1.expectedType == Xt$1 ? e$1.expectedType && "value" !== e$1.expectedType.kind && (a$1 = e$1.expectedType) : a$1 = Rt$1;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 2) {
						const r$2 = s$1[t$2], n$2 = s$1[t$2 + 1], i$2 = t$2 + 3, l$1 = t$2 + 4;
						if ("number" != typeof r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", i$2);
						if (o.length && o[o.length - 1][0] >= r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", i$2);
						const u$1 = e$1.parse(n$2, l$1, a$1);
						if (!u$1) return null;
						a$1 = a$1 || u$1.type, o.push([r$2, u$1]);
					}
					return re$1(a$1, Ct$1) || re$1(a$1, Nt$1) || re$1(a$1, Rt$1) || re$1(a$1, Gt$1) || re$1(a$1, Yt$1) || re$1(a$1, Xt$1) || re$1(a$1, Ht$1) || re$1(a$1, Kt$1(Ct$1)) ? new fr$1(a$1, r$1, n$1, i$1, o) : e$1.error(`Type ${Wt$1(a$1)} is not interpolatable.`);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					if (n$1 >= e$1[i$1 - 1]) return r$1[i$1 - 1].evaluate(t$1);
					const s$1 = or$1(e$1, n$1), o = fr$1.interpolationFactor(this.interpolation, n$1, e$1[s$1], e$1[s$1 + 1]), a$1 = r$1[s$1].evaluate(t$1), l$1 = r$1[s$1 + 1].evaluate(t$1);
					switch (this.operator) {
						case "interpolate": switch (this.type.kind) {
							case "number": return ke$1(a$1, l$1, o);
							case "color": return Te$1.interpolate(a$1, l$1, o);
							case "padding": return Pe$1.interpolate(a$1, l$1, o);
							case "colorArray": return Be$1.interpolate(a$1, l$1, o);
							case "numberArray": return ze$1.interpolate(a$1, l$1, o);
							case "variableAnchorOffsetCollection": return Le$1.interpolate(a$1, l$1, o);
							case "array": return Ee$1(a$1, l$1, o);
							case "projectionDefinition": return Re$1.interpolate(a$1, l$1, o);
						}
						case "interpolate-hcl": switch (this.type.kind) {
							case "color": return Te$1.interpolate(a$1, l$1, o, "hcl");
							case "colorArray": return Be$1.interpolate(a$1, l$1, o, "hcl");
						}
						case "interpolate-lab": switch (this.type.kind) {
							case "color": return Te$1.interpolate(a$1, l$1, o, "lab");
							case "colorArray": return Be$1.interpolate(a$1, l$1, o, "lab");
						}
					}
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function dr$1(t$1, e$1, r$1, n$1) {
				const i$1 = n$1 - r$1, s$1 = t$1 - r$1;
				return 0 === i$1 ? 0 : 1 === e$1 ? s$1 / i$1 : (Math.pow(e$1, s$1) - 1) / (Math.pow(e$1, i$1) - 1);
			}
			const yr$1 = {
				color: Te$1.interpolate,
				number: ke$1,
				padding: Pe$1.interpolate,
				numberArray: ze$1.interpolate,
				colorArray: Be$1.interpolate,
				variableAnchorOffsetCollection: Le$1.interpolate,
				array: Ee$1
			};
			class mr$1 {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1 = null;
					const n$1 = e$1.expectedType;
					n$1 && "value" !== n$1.kind && (r$1 = n$1);
					const i$1 = [];
					for (const n$2 of t$1.slice(1)) {
						const t$2 = e$1.parse(n$2, 1 + i$1.length, r$1, void 0, { typeAnnotation: "omit" });
						if (!t$2) return null;
						r$1 = r$1 || t$2.type, i$1.push(t$2);
					}
					if (!r$1) throw new Error("No output type");
					return new mr$1(n$1 && i$1.some(((t$2) => Qt$1(n$1, t$2.type))) ? Ut$1 : r$1, i$1);
				}
				evaluate(t$1) {
					let e$1, r$1 = null, n$1 = 0;
					for (const i$1 of this.args) if (n$1++, r$1 = i$1.evaluate(t$1), r$1 && r$1 instanceof Oe$1 && !r$1.available && (e$1 || (e$1 = r$1.name), r$1 = null, n$1 === this.args.length && (r$1 = e$1)), null !== r$1) break;
					return r$1;
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			function gr$1(t$1, e$1) {
				return "==" === t$1 || "!=" === t$1 ? "boolean" === e$1.kind || "string" === e$1.kind || "number" === e$1.kind || "null" === e$1.kind || "value" === e$1.kind : "string" === e$1.kind || "number" === e$1.kind || "value" === e$1.kind;
			}
			function xr$1(t$1, e$1, r$1, n$1) {
				return 0 === n$1.compare(e$1, r$1);
			}
			function vr(t$1, e$1, r$1) {
				const n$1 = "==" !== t$1 && "!=" !== t$1;
				return class i$1 {
					constructor(t$2, e$2, r$2) {
						this.type = Ot$1, this.lhs = t$2, this.rhs = e$2, this.collator = r$2, this.hasUntypedArgument = "value" === t$2.type.kind || "value" === e$2.type.kind;
					}
					static parse(t$2, e$2) {
						if (3 !== t$2.length && 4 !== t$2.length) return e$2.error("Expected two or three arguments.");
						const r$2 = t$2[0];
						let s$1 = e$2.parse(t$2[1], 1, Ut$1);
						if (!s$1) return null;
						if (!gr$1(r$2, s$1.type)) return e$2.concat(1).error(`"${r$2}" comparisons are not supported for type '${Wt$1(s$1.type)}'.`);
						let o = e$2.parse(t$2[2], 2, Ut$1);
						if (!o) return null;
						if (!gr$1(r$2, o.type)) return e$2.concat(2).error(`"${r$2}" comparisons are not supported for type '${Wt$1(o.type)}'.`);
						if (s$1.type.kind !== o.type.kind && "value" !== s$1.type.kind && "value" !== o.type.kind) return e$2.error(`Cannot compare types '${Wt$1(s$1.type)}' and '${Wt$1(o.type)}'.`);
						n$1 && ("value" === s$1.type.kind && "value" !== o.type.kind ? s$1 = new Xe(o.type, [s$1]) : "value" !== s$1.type.kind && "value" === o.type.kind && (o = new Xe(s$1.type, [o])));
						let a$1 = null;
						if (4 === t$2.length) {
							if ("string" !== s$1.type.kind && "string" !== o.type.kind && "value" !== s$1.type.kind && "value" !== o.type.kind) return e$2.error("Cannot use collator to compare non-string types.");
							if (a$1 = e$2.parse(t$2[3], 3, qt$1), !a$1) return null;
						}
						return new i$1(s$1, o, a$1);
					}
					evaluate(i$2) {
						const s$1 = this.lhs.evaluate(i$2), o = this.rhs.evaluate(i$2);
						if (n$1 && this.hasUntypedArgument) {
							const e$2 = Ue$1(s$1), r$2 = Ue$1(o);
							if (e$2.kind !== r$2.kind || "string" !== e$2.kind && "number" !== e$2.kind) throw new Ve$1(`Expected arguments for "${t$1}" to be (string, string) or (number, number), but found (${e$2.kind}, ${r$2.kind}) instead.`);
						}
						if (this.collator && !n$1 && this.hasUntypedArgument) {
							const t$2 = Ue$1(s$1), r$2 = Ue$1(o);
							if ("string" !== t$2.kind || "string" !== r$2.kind) return e$1(i$2, s$1, o);
						}
						return this.collator ? r$1(i$2, s$1, o, this.collator.evaluate(i$2)) : e$1(i$2, s$1, o);
					}
					eachChild(t$2) {
						t$2(this.lhs), t$2(this.rhs), this.collator && t$2(this.collator);
					}
					outputDefined() {
						return !0;
					}
				};
			}
			const br = vr("==", (function(t$1, e$1, r$1) {
				return e$1 === r$1;
			}), xr$1), wr$1 = vr("!=", (function(t$1, e$1, r$1) {
				return e$1 !== r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return !xr$1(0, e$1, r$1, n$1);
			})), _r$1 = vr("<", (function(t$1, e$1, r$1) {
				return e$1 < r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) < 0;
			})), Ar$1 = vr(">", (function(t$1, e$1, r$1) {
				return e$1 > r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) > 0;
			})), Sr$1 = vr("<=", (function(t$1, e$1, r$1) {
				return e$1 <= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) <= 0;
			})), kr$1 = vr(">=", (function(t$1, e$1, r$1) {
				return e$1 >= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) >= 0;
			}));
			class Er$1 {
				constructor(t$1, e$1, r$1) {
					this.type = qt$1, this.locale = r$1, this.caseSensitive = t$1, this.diacriticSensitive = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected one argument.");
					const r$1 = t$1[1];
					if ("object" != typeof r$1 || Array.isArray(r$1)) return e$1.error("Collator options argument must be an object.");
					const n$1 = e$1.parse(void 0 !== r$1["case-sensitive"] && r$1["case-sensitive"], 1, Ot$1);
					if (!n$1) return null;
					const i$1 = e$1.parse(void 0 !== r$1["diacritic-sensitive"] && r$1["diacritic-sensitive"], 1, Ot$1);
					if (!i$1) return null;
					let s$1 = null;
					return r$1.locale && (s$1 = e$1.parse(r$1.locale, 1, Lt$1), !s$1) ? null : new Er$1(n$1, i$1, s$1);
				}
				evaluate(t$1) {
					return new Ie$1(this.caseSensitive.evaluate(t$1), this.diacriticSensitive.evaluate(t$1), this.locale ? this.locale.evaluate(t$1) : null);
				}
				eachChild(t$1) {
					t$1(this.caseSensitive), t$1(this.diacriticSensitive), this.locale && t$1(this.locale);
				}
				outputDefined() {
					return !1;
				}
			}
			class Tr$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = Lt$1, this.number = t$1, this.locale = e$1, this.currency = r$1, this.minFractionDigits = n$1, this.maxFractionDigits = i$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ct$1);
					if (!r$1) return null;
					const n$1 = t$1[2];
					if ("object" != typeof n$1 || Array.isArray(n$1)) return e$1.error("NumberFormat options argument must be an object.");
					let i$1 = null;
					if (n$1.locale && (i$1 = e$1.parse(n$1.locale, 1, Lt$1), !i$1)) return null;
					let s$1 = null;
					if (n$1.currency && (s$1 = e$1.parse(n$1.currency, 1, Lt$1), !s$1)) return null;
					let o = null;
					if (n$1["min-fraction-digits"] && (o = e$1.parse(n$1["min-fraction-digits"], 1, Ct$1), !o)) return null;
					let a$1 = null;
					return n$1["max-fraction-digits"] && (a$1 = e$1.parse(n$1["max-fraction-digits"], 1, Ct$1), !a$1) ? null : new Tr$1(r$1, i$1, s$1, o, a$1);
				}
				evaluate(t$1) {
					return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t$1) : [], {
						style: this.currency ? "currency" : "decimal",
						currency: this.currency ? this.currency.evaluate(t$1) : void 0,
						minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t$1) : void 0,
						maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t$1) : void 0
					}).format(this.number.evaluate(t$1));
				}
				eachChild(t$1) {
					t$1(this.number), this.locale && t$1(this.locale), this.currency && t$1(this.currency), this.minFractionDigits && t$1(this.minFractionDigits), this.maxFractionDigits && t$1(this.maxFractionDigits);
				}
				outputDefined() {
					return !1;
				}
			}
			class Ir$1 {
				constructor(t$1) {
					this.type = jt$1, this.sections = t$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[1];
					if (!Array.isArray(r$1) && "object" == typeof r$1) return e$1.error("First argument must be an image or text section.");
					const n$1 = [];
					let i$1 = !1;
					for (let r$2 = 1; r$2 <= t$1.length - 1; ++r$2) {
						const s$1 = t$1[r$2];
						if (i$1 && "object" == typeof s$1 && !Array.isArray(s$1)) {
							i$1 = !1;
							let t$2 = null;
							if (s$1["font-scale"] && (t$2 = e$1.parse(s$1["font-scale"], 1, Ct$1), !t$2)) return null;
							let r$3 = null;
							if (s$1["text-font"] && (r$3 = e$1.parse(s$1["text-font"], 1, Kt$1(Lt$1)), !r$3)) return null;
							let o = null;
							if (s$1["text-color"] && (o = e$1.parse(s$1["text-color"], 1, Rt$1), !o)) return null;
							let a$1 = null;
							if (s$1["vertical-align"]) {
								if ("string" == typeof s$1["vertical-align"] && !Me$1.includes(s$1["vertical-align"])) return e$1.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s$1["vertical-align"]}' instead.`);
								if (a$1 = e$1.parse(s$1["vertical-align"], 1, Lt$1), !a$1) return null;
							}
							const l$1 = n$1[n$1.length - 1];
							l$1.scale = t$2, l$1.font = r$3, l$1.textColor = o, l$1.verticalAlign = a$1;
						} else {
							const s$2 = e$1.parse(t$1[r$2], 1, Ut$1);
							if (!s$2) return null;
							const o = s$2.type.kind;
							if ("string" !== o && "value" !== o && "null" !== o && "resolvedImage" !== o) return e$1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
							i$1 = !0, n$1.push({
								content: s$2,
								scale: null,
								font: null,
								textColor: null,
								verticalAlign: null
							});
						}
					}
					return new Ir$1(n$1);
				}
				evaluate(t$1) {
					return new De$1(this.sections.map(((e$1) => {
						const r$1 = e$1.content.evaluate(t$1);
						return Ue$1(r$1) === Zt$1 ? new Fe$1("", r$1, null, null, null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null) : new Fe$1(qe$1(r$1), null, e$1.scale ? e$1.scale.evaluate(t$1) : null, e$1.font ? e$1.font.evaluate(t$1).join(",") : null, e$1.textColor ? e$1.textColor.evaluate(t$1) : null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null);
					})));
				}
				eachChild(t$1) {
					for (const e$1 of this.sections) t$1(e$1.content), e$1.scale && t$1(e$1.scale), e$1.font && t$1(e$1.font), e$1.textColor && t$1(e$1.textColor), e$1.verticalAlign && t$1(e$1.verticalAlign);
				}
				outputDefined() {
					return !1;
				}
			}
			class Mr$1 {
				constructor(t$1) {
					this.type = Zt$1, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Lt$1);
					return r$1 ? new Mr$1(r$1) : e$1.error("No image name provided.");
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = Oe$1.fromString(e$1);
					return r$1 && t$1.availableImages && (r$1.available = t$1.availableImages.indexOf(e$1) > -1), r$1;
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class Fr$1 {
				constructor(t$1) {
					this.type = Ct$1, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1);
					return r$1 ? "array" !== r$1.type.kind && "string" !== r$1.type.kind && "value" !== r$1.type.kind ? e$1.error(`Expected argument of type string or array, but found ${Wt$1(r$1.type)} instead.`) : new Fr$1(r$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					if ("string" == typeof e$1) return [...e$1].length;
					if (Array.isArray(e$1)) return e$1.length;
					throw new Ve$1(`Expected value to be of type string or array, but found ${Wt$1(Ue$1(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			const Dr$1 = 8192;
			function Pr$1(t$1, e$1) {
				const r$1 = (180 + t$1[0]) / 360, n$1 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1[1] * Math.PI / 360))) / 360, i$1 = Math.pow(2, e$1.z);
				return [Math.round(r$1 * i$1 * Dr$1), Math.round(n$1 * i$1 * Dr$1)];
			}
			function zr$1(t$1, e$1) {
				const r$1 = Math.pow(2, e$1.z);
				return [(i$1 = (t$1[0] / Dr$1 + e$1.x) / r$1, 360 * i$1 - 180), (n$1 = (t$1[1] / Dr$1 + e$1.y) / r$1, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n$1) * Math.PI / 180)) - 90)];
				var n$1, i$1;
			}
			function Br$1(t$1, e$1) {
				t$1[0] = Math.min(t$1[0], e$1[0]), t$1[1] = Math.min(t$1[1], e$1[1]), t$1[2] = Math.max(t$1[2], e$1[0]), t$1[3] = Math.max(t$1[3], e$1[1]);
			}
			function Vr$1(t$1, e$1) {
				return !(t$1[0] <= e$1[0] || t$1[2] >= e$1[2] || t$1[1] <= e$1[1] || t$1[3] >= e$1[3]);
			}
			function Cr$1(t$1, e$1, r$1) {
				const n$1 = t$1[0] - e$1[0], i$1 = t$1[1] - e$1[1], s$1 = t$1[0] - r$1[0], o = t$1[1] - r$1[1];
				return n$1 * o - s$1 * i$1 == 0 && n$1 * s$1 <= 0 && i$1 * o <= 0;
			}
			function Lr$1(t$1, e$1, r$1, n$1) {
				return 0 != (i$1 = [n$1[0] - r$1[0], n$1[1] - r$1[1]])[0] * (s$1 = [e$1[0] - t$1[0], e$1[1] - t$1[1]])[1] - i$1[1] * s$1[0] && !(!qr$1(t$1, e$1, r$1, n$1) || !qr$1(r$1, n$1, t$1, e$1));
				var i$1, s$1;
			}
			function Or$1(t$1, e$1, r$1) {
				for (const n$1 of r$1) for (let r$2 = 0; r$2 < n$1.length - 1; ++r$2) if (Lr$1(t$1, e$1, n$1[r$2], n$1[r$2 + 1])) return !0;
				return !1;
			}
			function Rr$1(t$1, e$1, r$1 = !1) {
				let n$1 = !1;
				for (const a$1 of e$1) for (let e$2 = 0; e$2 < a$1.length - 1; e$2++) {
					if (Cr$1(t$1, a$1[e$2], a$1[e$2 + 1])) return r$1;
					(s$1 = a$1[e$2])[1] > (i$1 = t$1)[1] != (o = a$1[e$2 + 1])[1] > i$1[1] && i$1[0] < (o[0] - s$1[0]) * (i$1[1] - s$1[1]) / (o[1] - s$1[1]) + s$1[0] && (n$1 = !n$1);
				}
				var i$1, s$1, o;
				return n$1;
			}
			function Nr$1(t$1, e$1) {
				for (const r$1 of e$1) if (Rr$1(t$1, r$1)) return !0;
				return !1;
			}
			function $r$1(t$1, e$1) {
				for (const r$1 of t$1) if (!Rr$1(r$1, e$1)) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; ++r$1) if (Or$1(t$1[r$1], t$1[r$1 + 1], e$1)) return !1;
				return !0;
			}
			function Ur$1(t$1, e$1) {
				for (const r$1 of e$1) if ($r$1(t$1, r$1)) return !0;
				return !1;
			}
			function qr$1(t$1, e$1, r$1, n$1) {
				const i$1 = n$1[0] - r$1[0], s$1 = n$1[1] - r$1[1], o = (t$1[0] - r$1[0]) * s$1 - i$1 * (t$1[1] - r$1[1]), a$1 = (e$1[0] - r$1[0]) * s$1 - i$1 * (e$1[1] - r$1[1]);
				return o > 0 && a$1 < 0 || o < 0 && a$1 > 0;
			}
			function jr$1(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = [];
					for (let n$2 = 0; n$2 < t$1[i$1].length; n$2++) {
						const o = Pr$1(t$1[i$1][n$2], r$1);
						Br$1(e$1, o), s$1.push(o);
					}
					n$1.push(s$1);
				}
				return n$1;
			}
			function Gr$1(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = jr$1(t$1[i$1], e$1, r$1);
					n$1.push(s$1);
				}
				return n$1;
			}
			function Xr$1(t$1, e$1, r$1, n$1) {
				if (t$1[0] < r$1[0] || t$1[0] > r$1[2]) {
					const e$2 = .5 * n$1;
					let i$1 = t$1[0] - r$1[0] > e$2 ? -n$1 : r$1[0] - t$1[0] > e$2 ? n$1 : 0;
					0 === i$1 && (i$1 = t$1[0] - r$1[2] > e$2 ? -n$1 : r$1[2] - t$1[0] > e$2 ? n$1 : 0), t$1[0] += i$1;
				}
				Br$1(e$1, t$1);
			}
			function Yr$1(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Dr$1, s$1 = [n$1.x * Dr$1, n$1.y * Dr$1], o = [];
				for (const n$2 of t$1) for (const t$2 of n$2) {
					const n$3 = [t$2.x + s$1[0], t$2.y + s$1[1]];
					Xr$1(n$3, e$1, r$1, i$1), o.push(n$3);
				}
				return o;
			}
			function Zr$1(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Dr$1, s$1 = [n$1.x * Dr$1, n$1.y * Dr$1], o = [];
				for (const r$2 of t$1) {
					const t$2 = [];
					for (const n$2 of r$2) {
						const r$3 = [n$2.x + s$1[0], n$2.y + s$1[1]];
						Br$1(e$1, r$3), t$2.push(r$3);
					}
					o.push(t$2);
				}
				if (e$1[2] - e$1[0] <= i$1 / 2) {
					(a$1 = e$1)[0] = a$1[1] = Infinity, a$1[2] = a$1[3] = -Infinity;
					for (const t$2 of o) for (const n$2 of t$2) Xr$1(n$2, e$1, r$1, i$1);
				}
				var a$1;
				return o;
			}
			class Hr$1 {
				constructor(t$1, e$1) {
					this.type = Ot$1, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'within' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if ($e$1(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) {
							const t$2 = [];
							for (const r$1 of e$2.features) {
								const { type: e$3, coordinates: n$1 } = r$1.geometry;
								"Polygon" === e$3 && t$2.push(n$1), "MultiPolygon" === e$3 && t$2.push(...n$1);
							}
							if (t$2.length) return new Hr$1(e$2, {
								type: "MultiPolygon",
								coordinates: t$2
							});
						} else if ("Feature" === e$2.type) {
							const t$2 = e$2.geometry.type;
							if ("Polygon" === t$2 || "MultiPolygon" === t$2) return new Hr$1(e$2, e$2.geometry);
						} else if ("Polygon" === e$2.type || "MultiPolygon" === e$2.type) return new Hr$1(e$2, e$2);
					}
					return e$1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = jr$1(e$1.coordinates, n$1, i$1), o = Yr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr$1(r$1, n$1)) return !1;
								for (const t$3 of o) if (!Rr$1(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = Gr$1(e$1.coordinates, n$1, i$1), o = Yr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr$1(r$1, n$1)) return !1;
								for (const t$3 of o) if (!Nr$1(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = jr$1(e$1.coordinates, n$1, i$1), o = Zr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr$1(r$1, n$1)) return !1;
								for (const t$3 of o) if (!$r$1(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = Gr$1(e$1.coordinates, n$1, i$1), o = Zr$1(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr$1(r$1, n$1)) return !1;
								for (const t$3 of o) if (!Ur$1(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
					}
					return !1;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			let Kr$1 = class {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			};
			function Wr$1(t$1, e$1, r$1 = 0, n$1 = t$1.length - 1, i$1 = Qr$1) {
				for (; n$1 > r$1;) {
					if (n$1 - r$1 > 600) {
						const s$2 = n$1 - r$1 + 1, o$1 = e$1 - r$1 + 1, a$2 = Math.log(s$2), l$1 = .5 * Math.exp(2 * a$2 / 3), u$1 = .5 * Math.sqrt(a$2 * l$1 * (s$2 - l$1) / s$2) * (o$1 - s$2 / 2 < 0 ? -1 : 1);
						Wr$1(t$1, e$1, Math.max(r$1, Math.floor(e$1 - o$1 * l$1 / s$2 + u$1)), Math.min(n$1, Math.floor(e$1 + (s$2 - o$1) * l$1 / s$2 + u$1)), i$1);
					}
					const s$1 = t$1[e$1];
					let o = r$1, a$1 = n$1;
					for (Jr$1(t$1, r$1, e$1), i$1(t$1[n$1], s$1) > 0 && Jr$1(t$1, r$1, n$1); o < a$1;) {
						for (Jr$1(t$1, o, a$1), o++, a$1--; i$1(t$1[o], s$1) < 0;) o++;
						for (; i$1(t$1[a$1], s$1) > 0;) a$1--;
					}
					0 === i$1(t$1[r$1], s$1) ? Jr$1(t$1, r$1, a$1) : (a$1++, Jr$1(t$1, a$1, n$1)), a$1 <= e$1 && (r$1 = a$1 + 1), e$1 <= a$1 && (n$1 = a$1 - 1);
				}
			}
			function Jr$1(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function Qr$1(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function tn$1(t$1, e$1) {
				if (t$1.length <= 1) return [t$1];
				const r$1 = [];
				let n$1, i$1;
				for (const e$2 of t$1) {
					const t$2 = rn$1(e$2);
					0 !== t$2 && (e$2.area = Math.abs(t$2), void 0 === i$1 && (i$1 = t$2 < 0), i$1 === t$2 < 0 ? (n$1 && r$1.push(n$1), n$1 = [e$2]) : n$1.push(e$2));
				}
				if (n$1 && r$1.push(n$1), e$1 > 1) for (let t$2 = 0; t$2 < r$1.length; t$2++) r$1[t$2].length <= e$1 || (Wr$1(r$1[t$2], e$1, 1, r$1[t$2].length - 1, en$1), r$1[t$2] = r$1[t$2].slice(0, e$1));
				return r$1;
			}
			function en$1(t$1, e$1) {
				return e$1.area - t$1.area;
			}
			function rn$1(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, o = s$1 - 1; i$1 < s$1; o = i$1++) r$1 = t$1[i$1], n$1 = t$1[o], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			const nn$1 = 1 / 298.257223563, sn$1 = nn$1 * (2 - nn$1), on$1 = Math.PI / 180;
			class an$1 {
				constructor(t$1) {
					const e$1 = 6378.137 * on$1 * 1e3, r$1 = Math.cos(t$1 * on$1), n$1 = 1 / (1 - sn$1 * (1 - r$1 * r$1)), i$1 = Math.sqrt(n$1);
					this.kx = e$1 * i$1 * r$1, this.ky = e$1 * i$1 * n$1 * (1 - sn$1);
				}
				distance(t$1, e$1) {
					const r$1 = this.wrap(t$1[0] - e$1[0]) * this.kx, n$1 = (t$1[1] - e$1[1]) * this.ky;
					return Math.sqrt(r$1 * r$1 + n$1 * n$1);
				}
				pointOnLine(t$1, e$1) {
					let r$1, n$1, i$1, s$1, o = Infinity;
					for (let a$1 = 0; a$1 < t$1.length - 1; a$1++) {
						let l$1 = t$1[a$1][0], u$1 = t$1[a$1][1], c$1 = this.wrap(t$1[a$1 + 1][0] - l$1) * this.kx, h$1 = (t$1[a$1 + 1][1] - u$1) * this.ky, p$1 = 0;
						0 === c$1 && 0 === h$1 || (p$1 = (this.wrap(e$1[0] - l$1) * this.kx * c$1 + (e$1[1] - u$1) * this.ky * h$1) / (c$1 * c$1 + h$1 * h$1), p$1 > 1 ? (l$1 = t$1[a$1 + 1][0], u$1 = t$1[a$1 + 1][1]) : p$1 > 0 && (l$1 += c$1 / this.kx * p$1, u$1 += h$1 / this.ky * p$1)), c$1 = this.wrap(e$1[0] - l$1) * this.kx, h$1 = (e$1[1] - u$1) * this.ky;
						const f$1 = c$1 * c$1 + h$1 * h$1;
						f$1 < o && (o = f$1, r$1 = l$1, n$1 = u$1, i$1 = a$1, s$1 = p$1);
					}
					return {
						point: [r$1, n$1],
						index: i$1,
						t: Math.max(0, Math.min(1, s$1))
					};
				}
				wrap(t$1) {
					for (; t$1 < -180;) t$1 += 360;
					for (; t$1 > 180;) t$1 -= 360;
					return t$1;
				}
			}
			function ln$1(t$1, e$1) {
				return e$1[0] - t$1[0];
			}
			function un$1(t$1) {
				return t$1[1] - t$1[0] + 1;
			}
			function cn$1(t$1, e$1) {
				return t$1[1] >= t$1[0] && t$1[1] < e$1;
			}
			function hn$1(t$1, e$1) {
				if (t$1[0] > t$1[1]) return [null, null];
				const r$1 = un$1(t$1);
				if (e$1) {
					if (2 === r$1) return [t$1, null];
					const e$2 = Math.floor(r$1 / 2);
					return [[t$1[0], t$1[0] + e$2], [t$1[0] + e$2, t$1[1]]];
				}
				if (1 === r$1) return [t$1, null];
				const n$1 = Math.floor(r$1 / 2) - 1;
				return [[t$1[0], t$1[0] + n$1], [t$1[0] + n$1 + 1, t$1[1]]];
			}
			function pn$1(t$1, e$1) {
				if (!cn$1(e$1, t$1.length)) return [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				const r$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (let n$1 = e$1[0]; n$1 <= e$1[1]; ++n$1) Br$1(r$1, t$1[n$1]);
				return r$1;
			}
			function fn$1(t$1) {
				const e$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (const r$1 of t$1) for (const t$2 of r$1) Br$1(e$1, t$2);
				return e$1;
			}
			function dn$1(t$1) {
				return t$1[0] !== -Infinity && t$1[1] !== -Infinity && t$1[2] !== Infinity && t$1[3] !== Infinity;
			}
			function yn$1(t$1, e$1, r$1) {
				if (!dn$1(t$1) || !dn$1(e$1)) return NaN;
				let n$1 = 0, i$1 = 0;
				return t$1[2] < e$1[0] && (n$1 = e$1[0] - t$1[2]), t$1[0] > e$1[2] && (n$1 = t$1[0] - e$1[2]), t$1[1] > e$1[3] && (i$1 = t$1[1] - e$1[3]), t$1[3] < e$1[1] && (i$1 = e$1[1] - t$1[3]), r$1.distance([0, 0], [n$1, i$1]);
			}
			function mn$1(t$1, e$1, r$1) {
				const n$1 = r$1.pointOnLine(e$1, t$1);
				return r$1.distance(t$1, n$1.point);
			}
			function gn$1(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = Math.min(mn$1(t$1, [r$1, n$1], i$1), mn$1(e$1, [r$1, n$1], i$1)), o = Math.min(mn$1(r$1, [t$1, e$1], i$1), mn$1(n$1, [t$1, e$1], i$1));
				return Math.min(s$1, o);
			}
			function xn$1(t$1, e$1, r$1, n$1, i$1) {
				if (!cn$1(e$1, t$1.length) || !cn$1(n$1, r$1.length)) return Infinity;
				let s$1 = Infinity;
				for (let o = e$1[0]; o < e$1[1]; ++o) {
					const e$2 = t$1[o], a$1 = t$1[o + 1];
					for (let t$2 = n$1[0]; t$2 < n$1[1]; ++t$2) {
						const n$2 = r$1[t$2], o$1 = r$1[t$2 + 1];
						if (Lr$1(e$2, a$1, n$2, o$1)) return 0;
						s$1 = Math.min(s$1, gn$1(e$2, a$1, n$2, o$1, i$1));
					}
				}
				return s$1;
			}
			function vn$1(t$1, e$1, r$1, n$1, i$1) {
				if (!cn$1(e$1, t$1.length) || !cn$1(n$1, r$1.length)) return NaN;
				let s$1 = Infinity;
				for (let o = e$1[0]; o <= e$1[1]; ++o) for (let e$2 = n$1[0]; e$2 <= n$1[1]; ++e$2) if (s$1 = Math.min(s$1, i$1.distance(t$1[o], r$1[e$2])), 0 === s$1) return s$1;
				return s$1;
			}
			function bn$1(t$1, e$1, r$1) {
				if (Rr$1(t$1, e$1, !0)) return 0;
				let n$1 = Infinity;
				for (const i$1 of e$1) {
					const e$2 = i$1[0], s$1 = i$1[i$1.length - 1];
					if (e$2 !== s$1 && (n$1 = Math.min(n$1, mn$1(t$1, [s$1, e$2], r$1)), 0 === n$1)) return n$1;
					const o = r$1.pointOnLine(i$1, t$1);
					if (n$1 = Math.min(n$1, r$1.distance(t$1, o.point)), 0 === n$1) return n$1;
				}
				return n$1;
			}
			function wn$1(t$1, e$1, r$1, n$1) {
				if (!cn$1(e$1, t$1.length)) return NaN;
				for (let n$2 = e$1[0]; n$2 <= e$1[1]; ++n$2) if (Rr$1(t$1[n$2], r$1, !0)) return 0;
				let i$1 = Infinity;
				for (let s$1 = e$1[0]; s$1 < e$1[1]; ++s$1) {
					const e$2 = t$1[s$1], o = t$1[s$1 + 1];
					for (const t$2 of r$1) for (let r$2 = 0, s$2 = t$2.length, a$1 = s$2 - 1; r$2 < s$2; a$1 = r$2++) {
						const s$3 = t$2[a$1], l$1 = t$2[r$2];
						if (Lr$1(e$2, o, s$3, l$1)) return 0;
						i$1 = Math.min(i$1, gn$1(e$2, o, s$3, l$1, n$1));
					}
				}
				return i$1;
			}
			function _n$1(t$1, e$1) {
				for (const r$1 of t$1) for (const t$2 of r$1) if (Rr$1(t$2, e$1, !0)) return !0;
				return !1;
			}
			function An$1(t$1, e$1, r$1, n$1 = Infinity) {
				const i$1 = fn$1(t$1), s$1 = fn$1(e$1);
				if (n$1 !== Infinity && yn$1(i$1, s$1, r$1) >= n$1) return n$1;
				if (Vr$1(i$1, s$1)) {
					if (_n$1(t$1, e$1)) return 0;
				} else if (_n$1(e$1, t$1)) return 0;
				let o = Infinity;
				for (const n$2 of t$1) for (let t$2 = 0, i$2 = n$2.length, s$2 = i$2 - 1; t$2 < i$2; s$2 = t$2++) {
					const i$3 = n$2[s$2], a$1 = n$2[t$2];
					for (const t$3 of e$1) for (let e$2 = 0, n$3 = t$3.length, s$3 = n$3 - 1; e$2 < n$3; s$3 = e$2++) {
						const n$4 = t$3[s$3], l$1 = t$3[e$2];
						if (Lr$1(i$3, a$1, n$4, l$1)) return 0;
						o = Math.min(o, gn$1(i$3, a$1, n$4, l$1, r$1));
					}
				}
				return o;
			}
			function Sn$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (!s$1) return;
				const o = yn$1(pn$1(n$1, s$1), i$1, r$1);
				o < e$1 && t$1.push([
					o,
					s$1,
					[0, 0]
				]);
			}
			function kn$1(t$1, e$1, r$1, n$1, i$1, s$1, o) {
				if (!s$1 || !o) return;
				const a$1 = yn$1(pn$1(n$1, s$1), pn$1(i$1, o), r$1);
				a$1 < e$1 && t$1.push([
					a$1,
					s$1,
					o
				]);
			}
			function En$1(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				let s$1 = Math.min(n$1.distance(t$1[0], r$1[0][0]), i$1);
				if (0 === s$1) return s$1;
				const o = new Kr$1([[
					0,
					[0, t$1.length - 1],
					[0, 0]
				]], ln$1), a$1 = fn$1(r$1);
				for (; o.length > 0;) {
					const i$2 = o.pop();
					if (i$2[0] >= s$1) continue;
					const l$1 = i$2[1], u$1 = e$1 ? 50 : 100;
					if (un$1(l$1) <= u$1) {
						if (!cn$1(l$1, t$1.length)) return NaN;
						if (e$1) {
							const e$2 = wn$1(t$1, l$1, r$1, n$1);
							if (isNaN(e$2) || 0 === e$2) return e$2;
							s$1 = Math.min(s$1, e$2);
						} else for (let e$2 = l$1[0]; e$2 <= l$1[1]; ++e$2) {
							const i$3 = bn$1(t$1[e$2], r$1, n$1);
							if (s$1 = Math.min(s$1, i$3), 0 === s$1) return 0;
						}
					} else {
						const r$2 = hn$1(l$1, e$1);
						Sn$1(o, s$1, n$1, t$1, a$1, r$2[0]), Sn$1(o, s$1, n$1, t$1, a$1, r$2[1]);
					}
				}
				return s$1;
			}
			function Tn$1(t$1, e$1, r$1, n$1, i$1, s$1 = Infinity) {
				let o = Math.min(s$1, i$1.distance(t$1[0], r$1[0]));
				if (0 === o) return o;
				const a$1 = new Kr$1([[
					0,
					[0, t$1.length - 1],
					[0, r$1.length - 1]
				]], ln$1);
				for (; a$1.length > 0;) {
					const s$2 = a$1.pop();
					if (s$2[0] >= o) continue;
					const l$1 = s$2[1], u$1 = s$2[2], c$1 = e$1 ? 50 : 100, h$1 = n$1 ? 50 : 100;
					if (un$1(l$1) <= c$1 && un$1(u$1) <= h$1) {
						if (!cn$1(l$1, t$1.length) && cn$1(u$1, r$1.length)) return NaN;
						let s$3;
						if (e$1 && n$1) s$3 = xn$1(t$1, l$1, r$1, u$1, i$1), o = Math.min(o, s$3);
						else if (e$1 && !n$1) {
							const e$2 = t$1.slice(l$1[0], l$1[1] + 1);
							for (let t$2 = u$1[0]; t$2 <= u$1[1]; ++t$2) if (s$3 = mn$1(r$1[t$2], e$2, i$1), o = Math.min(o, s$3), 0 === o) return o;
						} else if (!e$1 && n$1) {
							const e$2 = r$1.slice(u$1[0], u$1[1] + 1);
							for (let r$2 = l$1[0]; r$2 <= l$1[1]; ++r$2) if (s$3 = mn$1(t$1[r$2], e$2, i$1), o = Math.min(o, s$3), 0 === o) return o;
						} else s$3 = vn$1(t$1, l$1, r$1, u$1, i$1), o = Math.min(o, s$3);
					} else {
						const s$3 = hn$1(l$1, e$1), c$2 = hn$1(u$1, n$1);
						kn$1(a$1, o, i$1, t$1, r$1, s$3[0], c$2[0]), kn$1(a$1, o, i$1, t$1, r$1, s$3[0], c$2[1]), kn$1(a$1, o, i$1, t$1, r$1, s$3[1], c$2[0]), kn$1(a$1, o, i$1, t$1, r$1, s$3[1], c$2[1]);
					}
				}
				return o;
			}
			function In$1(t$1) {
				return "MultiPolygon" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Polygon",
					coordinates: t$2
				}))) : "MultiLineString" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "LineString",
					coordinates: t$2
				}))) : "MultiPoint" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Point",
					coordinates: t$2
				}))) : [t$1];
			}
			class Mn$1 {
				constructor(t$1, e$1) {
					this.type = Ct$1, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'distance' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if ($e$1(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) return new Mn$1(e$2, e$2.features.map(((t$2) => In$1(t$2.geometry))).flat());
						if ("Feature" === e$2.type) return new Mn$1(e$2, In$1(e$2.geometry));
						if ("type" in e$2 && "coordinates" in e$2) return new Mn$1(e$2, In$1(e$2));
					}
					return e$1.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => zr$1([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new an$1(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Tn$1(n$1, !1, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Tn$1(n$1, !1, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, En$1(n$1, !1, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => zr$1([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new an$1(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Tn$1(n$1, !0, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Tn$1(n$1, !0, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, En$1(n$1, !0, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("Polygon" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry();
							if (0 === r$1.length || 0 === r$1[0].length) return NaN;
							const n$1 = tn$1(r$1, 0).map(((e$2) => e$2.map(((e$3) => e$3.map(((e$4) => zr$1([e$4.x, e$4.y], t$2.canonical))))))), i$1 = new an$1(n$1[0][0][0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) for (const e$2 of n$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, En$1([t$3.coordinates], !1, e$2, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, En$1(t$3.coordinates, !0, e$2, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, An$1(e$2, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
					}
					return NaN;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			class Fn$1 {
				constructor(t$1) {
					this.type = Ut$1, this.key = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = t$1[1];
					return null == r$1 ? e$1.error("Global state property must be defined.") : "string" != typeof r$1 ? e$1.error(`Global state property must be string, but found ${typeof t$1[1]} instead.`) : new Fn$1(r$1);
				}
				evaluate(t$1) {
					var e$1;
					const r$1 = null === (e$1 = t$1.globals) || void 0 === e$1 ? void 0 : e$1.globalState;
					return r$1 && 0 !== Object.keys(r$1).length ? ve$1(r$1, this.key) : null;
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			const Dn$1 = {
				"==": br,
				"!=": wr$1,
				">": Ar$1,
				"<": _r$1,
				">=": kr$1,
				"<=": Sr$1,
				array: Xe,
				at: tr$1,
				boolean: Xe,
				case: ir$1,
				coalesce: mr$1,
				collator: Er$1,
				format: Ir$1,
				image: Mr$1,
				in: er$1,
				"index-of": rr$1,
				interpolate: fr$1,
				"interpolate-hcl": fr$1,
				"interpolate-lab": fr$1,
				length: Fr$1,
				let: Je$1,
				literal: je$1,
				match: nr$1,
				number: Xe,
				"number-format": Tr$1,
				object: Xe,
				slice: sr$1,
				step: ar$1,
				string: Xe,
				"to-boolean": Ze$1,
				"to-color": Ze$1,
				"to-number": Ze$1,
				"to-string": Ze$1,
				var: Qe$1,
				within: Hr$1,
				distance: Mn$1,
				"global-state": Fn$1
			};
			class Pn$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.name = t$1, this.type = e$1, this._evaluate = r$1, this.args = n$1;
				}
				evaluate(t$1) {
					return this._evaluate(t$1, this.args);
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return !1;
				}
				static parse(t$1, e$1) {
					const r$1 = t$1[0], n$1 = Pn$1.definitions[r$1];
					if (!n$1) return e$1.error(`Unknown expression "${r$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					const i$1 = Array.isArray(n$1) ? n$1[0] : n$1.type, s$1 = Array.isArray(n$1) ? [[n$1[1], n$1[2]]] : n$1.overloads, o = s$1.filter((([e$2]) => !Array.isArray(e$2) || e$2.length === t$1.length - 1));
					let a$1 = null;
					for (const [n$2, s$2] of o) {
						a$1 = new We(e$1.registry, Ln$1, e$1.path, null, e$1.scope);
						const o$1 = [];
						let l$1 = !1;
						for (let e$2 = 1; e$2 < t$1.length; e$2++) {
							const r$2 = t$1[e$2], i$2 = Array.isArray(n$2) ? n$2[e$2 - 1] : n$2.type, s$3 = a$1.parse(r$2, 1 + o$1.length, i$2);
							if (!s$3) {
								l$1 = !0;
								break;
							}
							o$1.push(s$3);
						}
						if (!l$1) if (Array.isArray(n$2) && n$2.length !== o$1.length) a$1.error(`Expected ${n$2.length} arguments, but found ${o$1.length} instead.`);
						else {
							for (let t$2 = 0; t$2 < o$1.length; t$2++) {
								const e$2 = Array.isArray(n$2) ? n$2[t$2] : n$2.type, r$2 = o$1[t$2];
								a$1.concat(t$2 + 1).checkSubtype(e$2, r$2.type);
							}
							if (0 === a$1.errors.length) return new Pn$1(r$1, i$1, s$2, o$1);
						}
					}
					if (1 === o.length) e$1.errors.push(...a$1.errors);
					else {
						const r$2 = (o.length ? o : s$1).map((([t$2]) => {
							return e$2 = t$2, Array.isArray(e$2) ? `(${e$2.map(Wt$1).join(", ")})` : `(${Wt$1(e$2.type)}...)`;
							var e$2;
						})).join(" | "), n$2 = [];
						for (let r$3 = 1; r$3 < t$1.length; r$3++) {
							const i$2 = e$1.parse(t$1[r$3], 1 + n$2.length);
							if (!i$2) return null;
							n$2.push(Wt$1(i$2.type));
						}
						e$1.error(`Expected arguments of type ${r$2}, but found (${n$2.join(", ")}) instead.`);
					}
					return null;
				}
				static register(t$1, e$1) {
					Pn$1.definitions = e$1;
					for (const r$1 in e$1) t$1[r$1] = Pn$1;
				}
			}
			function zn(t$1, [e$1, r$1, n$1, i$1]) {
				e$1 = e$1.evaluate(t$1), r$1 = r$1.evaluate(t$1), n$1 = n$1.evaluate(t$1);
				const s$1 = i$1 ? i$1.evaluate(t$1) : 1, o = Ne$1(e$1, r$1, n$1, s$1);
				if (o) throw new Ve$1(o);
				return new Te$1(e$1 / 255, r$1 / 255, n$1 / 255, s$1, !1);
			}
			function Bn$1(t$1, e$1) {
				return t$1 in e$1;
			}
			function Vn$1(t$1, e$1) {
				const r$1 = e$1[t$1];
				return void 0 === r$1 ? null : r$1;
			}
			function Cn$1(t$1) {
				return { type: t$1 };
			}
			function Ln$1(t$1) {
				if (t$1 instanceof Qe$1) return Ln$1(t$1.boundExpression);
				if (t$1 instanceof Pn$1 && "error" === t$1.name) return !1;
				if (t$1 instanceof Er$1) return !1;
				if (t$1 instanceof Hr$1) return !1;
				if (t$1 instanceof Mn$1) return !1;
				if (t$1 instanceof Fn$1) return !1;
				const e$1 = t$1 instanceof Ze$1 || t$1 instanceof Xe;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 = e$1 ? r$1 && Ln$1(t$2) : r$1 && t$2 instanceof je$1;
				})), !!r$1 && On(t$1) && Nn$1(t$1, [
					"zoom",
					"heatmap-density",
					"elevation",
					"line-progress",
					"accumulated",
					"is-supported-script"
				]);
			}
			function On(t$1) {
				if (t$1 instanceof Pn$1) {
					if ("get" === t$1.name && 1 === t$1.args.length) return !1;
					if ("feature-state" === t$1.name) return !1;
					if ("has" === t$1.name && 1 === t$1.args.length) return !1;
					if ("properties" === t$1.name || "geometry-type" === t$1.name || "id" === t$1.name) return !1;
					if (/^filter-/.test(t$1.name)) return !1;
				}
				if (t$1 instanceof Hr$1) return !1;
				if (t$1 instanceof Mn$1) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !On(t$2) && (e$1 = !1);
				})), e$1;
			}
			function Rn(t$1) {
				if (t$1 instanceof Pn$1 && "feature-state" === t$1.name) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !Rn(t$2) && (e$1 = !1);
				})), e$1;
			}
			function Nn$1(t$1, e$1) {
				if (t$1 instanceof Pn$1 && e$1.indexOf(t$1.name) >= 0) return !1;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 && !Nn$1(t$2, e$1) && (r$1 = !1);
				})), r$1;
			}
			function $n$1(t$1) {
				return {
					result: "success",
					value: t$1
				};
			}
			function Un$1(t$1) {
				return {
					result: "error",
					value: t$1
				};
			}
			function qn$1(t$1) {
				return "data-driven" === t$1["property-type"] || "cross-faded-data-driven" === t$1["property-type"];
			}
			function jn$1(t$1) {
				return !!t$1.expression && t$1.expression.parameters.indexOf("zoom") > -1;
			}
			function Gn$1(t$1) {
				return !!t$1.expression && t$1.expression.interpolated;
			}
			function Xn$1(t$1) {
				return t$1 instanceof Number ? "number" : t$1 instanceof String ? "string" : t$1 instanceof Boolean ? "boolean" : Array.isArray(t$1) ? "array" : null === t$1 ? "null" : typeof t$1;
			}
			function Yn$1(t$1) {
				return "object" == typeof t$1 && null !== t$1 && !Array.isArray(t$1) && Ue$1(t$1) === $t$1;
			}
			function Zn$1(t$1) {
				return t$1;
			}
			function Hn$1(t$1, e$1) {
				const r$1 = t$1.stops && "object" == typeof t$1.stops[0][0], n$1 = r$1 || !(r$1 || void 0 !== t$1.property), i$1 = t$1.type || (Gn$1(e$1) ? "exponential" : "interval"), s$1 = function(t$2) {
					switch (t$2.type) {
						case "color": return Te$1.parse;
						case "padding": return Pe$1.parse;
						case "numberArray": return ze$1.parse;
						case "colorArray": return Be$1.parse;
						default: return null;
					}
				}(e$1);
				if (s$1 && ((t$1 = Pt$1({}, t$1)).stops && (t$1.stops = t$1.stops.map(((t$2) => [t$2[0], s$1(t$2[1])]))), t$1.default = s$1(t$1.default ? t$1.default : e$1.default)), t$1.colorSpace && "rgb" !== (o = t$1.colorSpace) && "hcl" !== o && "lab" !== o) throw new Error(`Unknown color space: "${t$1.colorSpace}"`);
				var o;
				const a$1 = function(t$2) {
					switch (t$2) {
						case "exponential": return Qn$1;
						case "interval": return Jn$1;
						case "categorical": return Wn$1;
						case "identity": return ti$1;
						default: throw new Error(`Unknown function type "${t$2}"`);
					}
				}(i$1);
				let l$1, u$1;
				if ("categorical" === i$1) {
					l$1 = Object.create(null);
					for (const e$2 of t$1.stops) l$1[e$2[0]] = e$2[1];
					u$1 = typeof t$1.stops[0][0];
				}
				if (r$1) {
					const r$2 = {}, n$2 = [];
					for (let e$2 = 0; e$2 < t$1.stops.length; e$2++) {
						const i$3 = t$1.stops[e$2], s$3 = i$3[0].zoom;
						void 0 === r$2[s$3] && (r$2[s$3] = {
							zoom: s$3,
							type: t$1.type,
							property: t$1.property,
							default: t$1.default,
							stops: []
						}, n$2.push(s$3)), r$2[s$3].stops.push([i$3[0].value, i$3[1]]);
					}
					const i$2 = [];
					for (const t$2 of n$2) i$2.push([r$2[t$2].zoom, Hn$1(r$2[t$2], e$1)]);
					const s$2 = { name: "linear" };
					return {
						kind: "composite",
						interpolationType: s$2,
						interpolationFactor: fr$1.interpolationFactor.bind(void 0, s$2),
						zoomStops: i$2.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }, n$3) => Qn$1({
							stops: i$2,
							base: t$1.base
						}, e$1, r$3).evaluate(r$3, n$3)
					};
				}
				if (n$1) {
					const r$2 = "exponential" === i$1 ? {
						name: "exponential",
						base: void 0 !== t$1.base ? t$1.base : 1
					} : null;
					return {
						kind: "camera",
						interpolationType: r$2,
						interpolationFactor: fr$1.interpolationFactor.bind(void 0, r$2),
						zoomStops: t$1.stops.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }) => a$1(t$1, e$1, r$3, l$1, u$1)
					};
				}
				return {
					kind: "source",
					evaluate(r$2, n$2) {
						const i$2 = n$2 && n$2.properties ? n$2.properties[t$1.property] : void 0;
						return void 0 === i$2 ? Kn$1(t$1.default, e$1.default) : a$1(t$1, e$1, i$2, l$1, u$1);
					}
				};
			}
			function Kn$1(t$1, e$1, r$1) {
				return void 0 !== t$1 ? t$1 : void 0 !== e$1 ? e$1 : void 0 !== r$1 ? r$1 : void 0;
			}
			function Wn$1(t$1, e$1, r$1, n$1, i$1) {
				return Kn$1(typeof r$1 === i$1 ? n$1[r$1] : void 0, t$1.default, e$1.default);
			}
			function Jn$1(t$1, e$1, r$1) {
				if ("number" !== Xn$1(r$1)) return Kn$1(t$1.default, e$1.default);
				const n$1 = t$1.stops.length;
				if (1 === n$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[n$1 - 1][0]) return t$1.stops[n$1 - 1][1];
				const i$1 = or$1(t$1.stops.map(((t$2) => t$2[0])), r$1);
				return t$1.stops[i$1][1];
			}
			function Qn$1(t$1, e$1, r$1) {
				const n$1 = void 0 !== t$1.base ? t$1.base : 1;
				if ("number" !== Xn$1(r$1)) return Kn$1(t$1.default, e$1.default);
				const i$1 = t$1.stops.length;
				if (1 === i$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[i$1 - 1][0]) return t$1.stops[i$1 - 1][1];
				const s$1 = or$1(t$1.stops.map(((t$2) => t$2[0])), r$1), o = function(t$2, e$2, r$2, n$2) {
					const i$2 = n$2 - r$2, s$2 = t$2 - r$2;
					return 0 === i$2 ? 0 : 1 === e$2 ? s$2 / i$2 : (Math.pow(e$2, s$2) - 1) / (Math.pow(e$2, i$2) - 1);
				}(r$1, n$1, t$1.stops[s$1][0], t$1.stops[s$1 + 1][0]), a$1 = t$1.stops[s$1][1], l$1 = t$1.stops[s$1 + 1][1], u$1 = yr$1[e$1.type] || Zn$1;
				return "function" == typeof a$1.evaluate ? { evaluate(...e$2) {
					const r$2 = a$1.evaluate.apply(void 0, e$2), n$2 = l$1.evaluate.apply(void 0, e$2);
					if (void 0 !== r$2 && void 0 !== n$2) return u$1(r$2, n$2, o, t$1.colorSpace);
				} } : u$1(a$1, l$1, o, t$1.colorSpace);
			}
			function ti$1(t$1, e$1, r$1) {
				switch (e$1.type) {
					case "color":
						r$1 = Te$1.parse(r$1);
						break;
					case "formatted":
						r$1 = De$1.fromString(r$1.toString());
						break;
					case "resolvedImage":
						r$1 = Oe$1.fromString(r$1.toString());
						break;
					case "padding":
						r$1 = Pe$1.parse(r$1);
						break;
					case "colorArray":
						r$1 = Be$1.parse(r$1);
						break;
					case "numberArray":
						r$1 = ze$1.parse(r$1);
						break;
					default: Xn$1(r$1) === e$1.type || "enum" === e$1.type && e$1.values[r$1] || (r$1 = void 0);
				}
				return Kn$1(r$1, t$1.default, e$1.default);
			}
			Pn$1.register(Dn$1, {
				error: [
					{ kind: "error" },
					[Lt$1],
					(t$1, [e$1]) => {
						throw new Ve$1(e$1.evaluate(t$1));
					}
				],
				typeof: [
					Lt$1,
					[Ut$1],
					(t$1, [e$1]) => Wt$1(Ue$1(e$1.evaluate(t$1)))
				],
				"to-rgba": [
					Kt$1(Ct$1, 4),
					[Rt$1],
					(t$1, [e$1]) => {
						const [r$1, n$1, i$1, s$1] = e$1.evaluate(t$1).rgb;
						return [
							255 * r$1,
							255 * n$1,
							255 * i$1,
							s$1
						];
					}
				],
				rgb: [
					Rt$1,
					[
						Ct$1,
						Ct$1,
						Ct$1
					],
					zn
				],
				rgba: [
					Rt$1,
					[
						Ct$1,
						Ct$1,
						Ct$1,
						Ct$1
					],
					zn
				],
				has: {
					type: Ot$1,
					overloads: [[[Lt$1], (t$1, [e$1]) => Bn$1(e$1.evaluate(t$1), t$1.properties())], [[Lt$1, $t$1], (t$1, [e$1, r$1]) => Bn$1(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				get: {
					type: Ut$1,
					overloads: [[[Lt$1], (t$1, [e$1]) => Vn$1(e$1.evaluate(t$1), t$1.properties())], [[Lt$1, $t$1], (t$1, [e$1, r$1]) => Vn$1(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				"feature-state": [
					Ut$1,
					[Lt$1],
					(t$1, [e$1]) => Vn$1(e$1.evaluate(t$1), t$1.featureState || {})
				],
				properties: [
					$t$1,
					[],
					(t$1) => t$1.properties()
				],
				"geometry-type": [
					Lt$1,
					[],
					(t$1) => t$1.geometryType()
				],
				id: [
					Ut$1,
					[],
					(t$1) => t$1.id()
				],
				zoom: [
					Ct$1,
					[],
					(t$1) => t$1.globals.zoom
				],
				"heatmap-density": [
					Ct$1,
					[],
					(t$1) => t$1.globals.heatmapDensity || 0
				],
				elevation: [
					Ct$1,
					[],
					(t$1) => t$1.globals.elevation || 0
				],
				"line-progress": [
					Ct$1,
					[],
					(t$1) => t$1.globals.lineProgress || 0
				],
				accumulated: [
					Ut$1,
					[],
					(t$1) => void 0 === t$1.globals.accumulated ? null : t$1.globals.accumulated
				],
				"+": [
					Ct$1,
					Cn$1(Ct$1),
					(t$1, e$1) => {
						let r$1 = 0;
						for (const n$1 of e$1) r$1 += n$1.evaluate(t$1);
						return r$1;
					}
				],
				"*": [
					Ct$1,
					Cn$1(Ct$1),
					(t$1, e$1) => {
						let r$1 = 1;
						for (const n$1 of e$1) r$1 *= n$1.evaluate(t$1);
						return r$1;
					}
				],
				"-": {
					type: Ct$1,
					overloads: [[[Ct$1, Ct$1], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) - r$1.evaluate(t$1)], [[Ct$1], (t$1, [e$1]) => -e$1.evaluate(t$1)]]
				},
				"/": [
					Ct$1,
					[Ct$1, Ct$1],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) / r$1.evaluate(t$1)
				],
				"%": [
					Ct$1,
					[Ct$1, Ct$1],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) % r$1.evaluate(t$1)
				],
				ln2: [
					Ct$1,
					[],
					() => Math.LN2
				],
				pi: [
					Ct$1,
					[],
					() => Math.PI
				],
				e: [
					Ct$1,
					[],
					() => Math.E
				],
				"^": [
					Ct$1,
					[Ct$1, Ct$1],
					(t$1, [e$1, r$1]) => Math.pow(e$1.evaluate(t$1), r$1.evaluate(t$1))
				],
				sqrt: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.sqrt(e$1.evaluate(t$1))
				],
				log10: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN10
				],
				ln: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1))
				],
				log2: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN2
				],
				sin: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.sin(e$1.evaluate(t$1))
				],
				cos: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.cos(e$1.evaluate(t$1))
				],
				tan: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.tan(e$1.evaluate(t$1))
				],
				asin: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.asin(e$1.evaluate(t$1))
				],
				acos: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.acos(e$1.evaluate(t$1))
				],
				atan: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.atan(e$1.evaluate(t$1))
				],
				min: [
					Ct$1,
					Cn$1(Ct$1),
					(t$1, e$1) => Math.min(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				max: [
					Ct$1,
					Cn$1(Ct$1),
					(t$1, e$1) => Math.max(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				abs: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.abs(e$1.evaluate(t$1))
				],
				round: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => {
						const r$1 = e$1.evaluate(t$1);
						return r$1 < 0 ? -Math.round(-r$1) : Math.round(r$1);
					}
				],
				floor: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.floor(e$1.evaluate(t$1))
				],
				ceil: [
					Ct$1,
					[Ct$1],
					(t$1, [e$1]) => Math.ceil(e$1.evaluate(t$1))
				],
				"filter-==": [
					Ot$1,
					[Lt$1, Ut$1],
					(t$1, [e$1, r$1]) => t$1.properties()[e$1.value] === r$1.value
				],
				"filter-id-==": [
					Ot$1,
					[Ut$1],
					(t$1, [e$1]) => t$1.id() === e$1.value
				],
				"filter-type-==": [
					Ot$1,
					[Lt$1],
					(t$1, [e$1]) => t$1.geometryType() === e$1.value
				],
				"filter-<": [
					Ot$1,
					[Lt$1, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 < i$1;
					}
				],
				"filter-id-<": [
					Ot$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 < n$1;
					}
				],
				"filter->": [
					Ot$1,
					[Lt$1, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 > i$1;
					}
				],
				"filter-id->": [
					Ot$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 > n$1;
					}
				],
				"filter-<=": [
					Ot$1,
					[Lt$1, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 <= i$1;
					}
				],
				"filter-id-<=": [
					Ot$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 <= n$1;
					}
				],
				"filter->=": [
					Ot$1,
					[Lt$1, Ut$1],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 >= i$1;
					}
				],
				"filter-id->=": [
					Ot$1,
					[Ut$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 >= n$1;
					}
				],
				"filter-has": [
					Ot$1,
					[Ut$1],
					(t$1, [e$1]) => e$1.value in t$1.properties()
				],
				"filter-has-id": [
					Ot$1,
					[],
					(t$1) => null !== t$1.id() && void 0 !== t$1.id()
				],
				"filter-type-in": [
					Ot$1,
					[Kt$1(Lt$1)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.geometryType()) >= 0
				],
				"filter-id-in": [
					Ot$1,
					[Kt$1(Ut$1)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.id()) >= 0
				],
				"filter-in-small": [
					Ot$1,
					[Lt$1, Kt$1(Ut$1)],
					(t$1, [e$1, r$1]) => r$1.value.indexOf(t$1.properties()[e$1.value]) >= 0
				],
				"filter-in-large": [
					Ot$1,
					[Lt$1, Kt$1(Ut$1)],
					(t$1, [e$1, r$1]) => function(t$2, e$2, r$2, n$1) {
						for (; r$2 <= n$1;) {
							const i$1 = r$2 + n$1 >> 1;
							if (e$2[i$1] === t$2) return !0;
							e$2[i$1] > t$2 ? n$1 = i$1 - 1 : r$2 = i$1 + 1;
						}
						return !1;
					}(t$1.properties()[e$1.value], r$1.value, 0, r$1.value.length - 1)
				],
				all: {
					type: Ot$1,
					overloads: [[[Ot$1, Ot$1], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) && r$1.evaluate(t$1)], [Cn$1(Ot$1), (t$1, e$1) => {
						for (const r$1 of e$1) if (!r$1.evaluate(t$1)) return !1;
						return !0;
					}]]
				},
				any: {
					type: Ot$1,
					overloads: [[[Ot$1, Ot$1], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) || r$1.evaluate(t$1)], [Cn$1(Ot$1), (t$1, e$1) => {
						for (const r$1 of e$1) if (r$1.evaluate(t$1)) return !0;
						return !1;
					}]]
				},
				"!": [
					Ot$1,
					[Ot$1],
					(t$1, [e$1]) => !e$1.evaluate(t$1)
				],
				"is-supported-script": [
					Ot$1,
					[Lt$1],
					(t$1, [e$1]) => {
						const r$1 = t$1.globals && t$1.globals.isSupportedScript;
						return !r$1 || r$1(e$1.evaluate(t$1));
					}
				],
				upcase: [
					Lt$1,
					[Lt$1],
					(t$1, [e$1]) => e$1.evaluate(t$1).toUpperCase()
				],
				downcase: [
					Lt$1,
					[Lt$1],
					(t$1, [e$1]) => e$1.evaluate(t$1).toLowerCase()
				],
				concat: [
					Lt$1,
					Cn$1(Ut$1),
					(t$1, e$1) => e$1.map(((e$2) => qe$1(e$2.evaluate(t$1)))).join("")
				],
				"resolved-locale": [
					Lt$1,
					[qt$1],
					(t$1, [e$1]) => e$1.evaluate(t$1).resolvedLocale()
				]
			});
			class ei$1 {
				constructor(t$1, e$1, r$1) {
					this.expression = t$1, this._warningHistory = {}, this._evaluator = new Ke$1(), this._defaultValue = e$1 ? function(t$2) {
						if ("color" === t$2.type && Yn$1(t$2.default)) return new Te$1(0, 0, 0, 0);
						switch (t$2.type) {
							case "color": return Te$1.parse(t$2.default) || null;
							case "padding": return Pe$1.parse(t$2.default) || null;
							case "numberArray": return ze$1.parse(t$2.default) || null;
							case "colorArray": return Be$1.parse(t$2.default) || null;
							case "variableAnchorOffsetCollection": return Le$1.parse(t$2.default) || null;
							case "projectionDefinition": return Re$1.parse(t$2.default) || null;
							default: return void 0 === t$2.default ? null : t$2.default;
						}
					}(e$1) : null, this._enumValues = e$1 && "enum" === e$1.type ? e$1.values : null, this._globalState = r$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._evaluator.globals = t$1, this._evaluator.feature = e$1, this._evaluator.featureState = r$1, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1, this.expression.evaluate(this._evaluator);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					this._globalState && (t$1 = ci(t$1, this._globalState)), this._evaluator.globals = t$1, this._evaluator.feature = e$1 || null, this._evaluator.featureState = r$1 || null, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1 || null;
					try {
						const t$2 = this.expression.evaluate(this._evaluator);
						if (null == t$2 || "number" == typeof t$2 && t$2 != t$2) return this._defaultValue;
						if (this._enumValues && !(t$2 in this._enumValues)) throw new Ve$1(`Expected value to be one of ${Object.keys(this._enumValues).map(((t$3) => JSON.stringify(t$3))).join(", ")}, but found ${JSON.stringify(t$2)} instead.`);
						return t$2;
					} catch (t$2) {
						return this._warningHistory[t$2.message] || (this._warningHistory[t$2.message] = !0, "undefined" != typeof console && console.warn(t$2.message)), this._defaultValue;
					}
				}
			}
			function ri$1(t$1) {
				return Array.isArray(t$1) && t$1.length > 0 && "string" == typeof t$1[0] && t$1[0] in Dn$1;
			}
			function ni$1(t$1, e$1, r$1) {
				const n$1 = new We(Dn$1, Ln$1, [], e$1 ? function(t$2) {
					const e$2 = {
						color: Rt$1,
						string: Lt$1,
						number: Ct$1,
						enum: Lt$1,
						boolean: Ot$1,
						formatted: jt$1,
						padding: Gt$1,
						numberArray: Yt$1,
						colorArray: Xt$1,
						projectionDefinition: Nt$1,
						resolvedImage: Zt$1,
						variableAnchorOffsetCollection: Ht$1
					};
					return "array" === t$2.type ? Kt$1(e$2[t$2.value] || Ut$1, t$2.length) : e$2[t$2.type];
				}(e$1) : void 0), i$1 = n$1.parse(t$1, void 0, void 0, void 0, e$1 && "string" === e$1.type ? { typeAnnotation: "coerce" } : void 0);
				return i$1 ? $n$1(new ei$1(i$1, e$1, r$1)) : Un$1(n$1.errors);
			}
			class ii$1 {
				constructor(t$1, e$1, r$1) {
					this.kind = t$1, this._styleExpression = e$1, this.isStateDependent = "constant" !== t$1 && !Rn(e$1.expression), this.globalStateRefs = ui(e$1.expression), this._globalState = r$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
			}
			class si$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.kind = t$1, this.zoomStops = r$1, this._styleExpression = e$1, this.isStateDependent = "camera" !== t$1 && !Rn(e$1.expression), this.globalStateRefs = ui(e$1.expression), this.interpolationType = n$1, this._globalState = i$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				interpolationFactor(t$1, e$1, r$1) {
					return this.interpolationType ? fr$1.interpolationFactor(this.interpolationType, t$1, e$1, r$1) : 0;
				}
			}
			function oi$1(t$1, e$1, r$1) {
				const n$1 = ni$1(t$1, e$1, r$1);
				if ("error" === n$1.result) return n$1;
				const i$1 = n$1.value.expression, s$1 = On(i$1);
				if (!s$1 && !qn$1(e$1)) return Un$1([new zt$1("", "data expressions not supported")]);
				const o = Nn$1(i$1, ["zoom"]);
				if (!o && !jn$1(e$1)) return Un$1([new zt$1("", "zoom expressions not supported")]);
				const a$1 = li(i$1);
				return a$1 || o ? a$1 instanceof zt$1 ? Un$1([a$1]) : a$1 instanceof fr$1 && !Gn$1(e$1) ? Un$1([new zt$1("", "\"interpolate\" expressions cannot be used with this property")]) : $n$1(a$1 ? new si$1(s$1 ? "camera" : "composite", n$1.value, a$1.labels, a$1 instanceof fr$1 ? a$1.interpolation : void 0, r$1) : new ii$1(s$1 ? "constant" : "source", n$1.value, r$1)) : Un$1([new zt$1("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.")]);
			}
			class ai$1 {
				constructor(t$1, e$1) {
					this._parameters = t$1, this._specification = e$1, Pt$1(this, Hn$1(this._parameters, this._specification));
				}
				static deserialize(t$1) {
					return new ai$1(t$1._parameters, t$1._specification);
				}
				static serialize(t$1) {
					return {
						_parameters: t$1._parameters,
						_specification: t$1._specification
					};
				}
			}
			function li(t$1) {
				let e$1 = null;
				if (t$1 instanceof Je$1) e$1 = li(t$1.result);
				else if (t$1 instanceof mr$1) {
					for (const r$1 of t$1.args) if (e$1 = li(r$1), e$1) break;
				} else (t$1 instanceof ar$1 || t$1 instanceof fr$1) && t$1.input instanceof Pn$1 && "zoom" === t$1.input.name && (e$1 = t$1);
				return e$1 instanceof zt$1 || t$1.eachChild(((t$2) => {
					const r$1 = li(t$2);
					r$1 instanceof zt$1 ? e$1 = r$1 : !e$1 && r$1 ? e$1 = new zt$1("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.") : e$1 && r$1 && e$1 !== r$1 && (e$1 = new zt$1("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
				})), e$1;
			}
			function ui(t$1, e$1 = /* @__PURE__ */ new Set()) {
				return t$1 instanceof Fn$1 && e$1.add(t$1.key), t$1.eachChild(((t$2) => {
					ui(t$2, e$1);
				})), e$1;
			}
			function ci(t$1, e$1) {
				const { zoom: r$1, heatmapDensity: n$1, elevation: i$1, lineProgress: s$1, isSupportedScript: o, accumulated: a$1 } = null != t$1 ? t$1 : {};
				return {
					zoom: r$1,
					heatmapDensity: n$1,
					elevation: i$1,
					lineProgress: s$1,
					isSupportedScript: o,
					accumulated: a$1,
					globalState: e$1
				};
			}
			function hi(t$1) {
				if (!0 === t$1 || !1 === t$1) return !0;
				if (!Array.isArray(t$1) || 0 === t$1.length) return !1;
				switch (t$1[0]) {
					case "has": return t$1.length >= 2 && "$id" !== t$1[1] && "$type" !== t$1[1];
					case "in": return t$1.length >= 3 && ("string" != typeof t$1[1] || Array.isArray(t$1[2]));
					case "!in":
					case "!has":
					case "none": return !1;
					case "==":
					case "!=":
					case ">":
					case ">=":
					case "<":
					case "<=": return 3 !== t$1.length || Array.isArray(t$1[1]) || Array.isArray(t$1[2]);
					case "any":
					case "all":
						for (const e$1 of t$1.slice(1)) if (!hi(e$1) && "boolean" != typeof e$1) return !1;
						return !0;
					default: return !0;
				}
			}
			const pi = {
				type: "boolean",
				default: !1,
				transition: !1,
				"property-type": "data-driven",
				expression: {
					interpolated: !1,
					parameters: ["zoom", "feature"]
				}
			};
			function fi(t$1, e$1) {
				if (null == t$1) return {
					filter: () => !0,
					needGeometry: !1,
					getGlobalStateRefs: () => /* @__PURE__ */ new Set()
				};
				hi(t$1) || (t$1 = mi$1(t$1));
				const r$1 = ni$1(t$1, pi, e$1);
				if ("error" === r$1.result) throw new Error(r$1.value.map(((t$2) => `${t$2.key}: ${t$2.message}`)).join(", "));
				return {
					filter: (t$2, e$2, n$1) => r$1.value.evaluate(t$2, e$2, {}, n$1),
					needGeometry: yi$1(t$1),
					getGlobalStateRefs: () => ui(r$1.value.expression)
				};
			}
			function di(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function yi$1(t$1) {
				if (!Array.isArray(t$1)) return !1;
				if ("within" === t$1[0] || "distance" === t$1[0]) return !0;
				for (let e$1 = 1; e$1 < t$1.length; e$1++) if (yi$1(t$1[e$1])) return !0;
				return !1;
			}
			function mi$1(t$1) {
				if (!t$1) return !0;
				const e$1 = t$1[0];
				return t$1.length <= 1 ? "any" !== e$1 : "==" === e$1 ? gi(t$1[1], t$1[2], "==") : "!=" === e$1 ? bi(gi(t$1[1], t$1[2], "==")) : "<" === e$1 || ">" === e$1 || "<=" === e$1 || ">=" === e$1 ? gi(t$1[1], t$1[2], e$1) : "any" === e$1 ? (r$1 = t$1.slice(1), ["any"].concat(r$1.map(mi$1))) : "all" === e$1 ? ["all"].concat(t$1.slice(1).map(mi$1)) : "none" === e$1 ? ["all"].concat(t$1.slice(1).map(mi$1).map(bi)) : "in" === e$1 ? xi(t$1[1], t$1.slice(2)) : "!in" === e$1 ? bi(xi(t$1[1], t$1.slice(2))) : "has" === e$1 ? vi$1(t$1[1]) : "!has" !== e$1 || bi(vi$1(t$1[1]));
				var r$1;
			}
			function gi(t$1, e$1, r$1) {
				switch (t$1) {
					case "$type": return [`filter-type-${r$1}`, e$1];
					case "$id": return [`filter-id-${r$1}`, e$1];
					default: return [
						`filter-${r$1}`,
						t$1,
						e$1
					];
				}
			}
			function xi(t$1, e$1) {
				if (0 === e$1.length) return !1;
				switch (t$1) {
					case "$type": return ["filter-type-in", ["literal", e$1]];
					case "$id": return ["filter-id-in", ["literal", e$1]];
					default: return e$1.length > 200 && !e$1.some(((t$2) => typeof t$2 != typeof e$1[0])) ? [
						"filter-in-large",
						t$1,
						["literal", e$1.sort(di)]
					] : [
						"filter-in-small",
						t$1,
						["literal", e$1]
					];
				}
			}
			function vi$1(t$1) {
				switch (t$1) {
					case "$type": return !0;
					case "$id": return ["filter-has-id"];
					default: return ["filter-has", t$1];
				}
			}
			function bi(t$1) {
				return ["!", t$1];
			}
			function wi(t$1) {
				const e$1 = typeof t$1;
				if ("number" === e$1 || "boolean" === e$1 || "string" === e$1 || null == t$1) return JSON.stringify(t$1);
				if (Array.isArray(t$1)) {
					let e$2 = "[";
					for (const r$2 of t$1) e$2 += `${wi(r$2)},`;
					return `${e$2}]`;
				}
				const r$1 = Object.keys(t$1).sort();
				let n$1 = "{";
				for (let e$2 = 0; e$2 < r$1.length; e$2++) n$1 += `${JSON.stringify(r$1[e$2])}:${wi(t$1[r$1[e$2]])},`;
				return `${n$1}}`;
			}
			function _i$1(t$1) {
				let e$1 = "";
				for (const r$1 of bt$1) e$1 += `/${wi(t$1[r$1])}`;
				return e$1;
			}
			function Ai$1(t$1) {
				const e$1 = t$1.value;
				return e$1 ? [new Dt$1(t$1.key, e$1, "constants have been deprecated as of v8")] : [];
			}
			function Si(t$1) {
				return t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean ? t$1.valueOf() : t$1;
			}
			function ki(t$1) {
				if (Array.isArray(t$1)) return t$1.map(ki);
				if (t$1 instanceof Object && !(t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean)) {
					const e$1 = {};
					for (const r$1 in t$1) e$1[r$1] = ki(t$1[r$1]);
					return e$1;
				}
				return Si(t$1);
			}
			function Ei$1(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec || {}, i$1 = t$1.objectElementValidators || {}, s$1 = t$1.style, o = t$1.styleSpec, a$1 = t$1.validateSpec;
				let l$1 = [];
				const u$1 = Xn$1(r$1);
				if ("object" !== u$1) return [new Dt$1(e$1, r$1, `object expected, ${u$1} found`)];
				for (const t$2 in r$1) {
					const u$2 = t$2.split(".")[0], c$1 = ve$1(n$1, u$2) || n$1["*"];
					let h$1;
					if (ve$1(i$1, u$2)) h$1 = i$1[u$2];
					else if (ve$1(n$1, u$2)) h$1 = a$1;
					else if (i$1["*"]) h$1 = i$1["*"];
					else {
						if (!n$1["*"]) {
							l$1.push(new Dt$1(e$1, r$1[t$2], `unknown property "${t$2}"`));
							continue;
						}
						h$1 = a$1;
					}
					l$1 = l$1.concat(h$1({
						key: (e$1 ? `${e$1}.` : e$1) + t$2,
						value: r$1[t$2],
						valueSpec: c$1,
						style: s$1,
						styleSpec: o,
						object: r$1,
						objectKey: t$2,
						validateSpec: a$1
					}, r$1));
				}
				for (const t$2 in n$1) i$1[t$2] || n$1[t$2].required && void 0 === n$1[t$2].default && void 0 === r$1[t$2] && l$1.push(new Dt$1(e$1, r$1, `missing required property "${t$2}"`));
				return l$1;
			}
			function Ti$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.style, i$1 = t$1.styleSpec, s$1 = t$1.key, o = t$1.arrayElementValidator || t$1.validateSpec;
				if ("array" !== Xn$1(e$1)) return [new Dt$1(s$1, e$1, `array expected, ${Xn$1(e$1)} found`)];
				if (r$1.length && e$1.length !== r$1.length) return [new Dt$1(s$1, e$1, `array length ${r$1.length} expected, length ${e$1.length} found`)];
				if (r$1["min-length"] && e$1.length < r$1["min-length"]) return [new Dt$1(s$1, e$1, `array length at least ${r$1["min-length"]} expected, length ${e$1.length} found`)];
				let a$1 = {
					type: r$1.value,
					values: r$1.values
				};
				i$1.$version < 7 && (a$1.function = r$1.function), "object" === Xn$1(r$1.value) && (a$1 = r$1.value);
				let l$1 = [];
				for (let r$2 = 0; r$2 < e$1.length; r$2++) l$1 = l$1.concat(o({
					array: e$1,
					arrayIndex: r$2,
					value: e$1[r$2],
					valueSpec: a$1,
					validateSpec: t$1.validateSpec,
					style: n$1,
					styleSpec: i$1,
					key: `${s$1}[${r$2}]`
				}));
				return l$1;
			}
			function Ii$1(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec;
				let i$1 = Xn$1(r$1);
				return "number" === i$1 && r$1 != r$1 && (i$1 = "NaN"), "number" !== i$1 ? [new Dt$1(e$1, r$1, `number expected, ${i$1} found`)] : "minimum" in n$1 && r$1 < n$1.minimum ? [new Dt$1(e$1, r$1, `${r$1} is less than the minimum value ${n$1.minimum}`)] : "maximum" in n$1 && r$1 > n$1.maximum ? [new Dt$1(e$1, r$1, `${r$1} is greater than the maximum value ${n$1.maximum}`)] : [];
			}
			function Mi$1(t$1) {
				const e$1 = t$1.valueSpec, r$1 = Si(t$1.value.type);
				let n$1, i$1, s$1, o = {};
				const a$1 = "categorical" !== r$1 && void 0 === t$1.value.property, l$1 = !a$1, u$1 = "array" === Xn$1(t$1.value.stops) && "array" === Xn$1(t$1.value.stops[0]) && "object" === Xn$1(t$1.value.stops[0][0]), c$1 = Ei$1({
					key: t$1.key,
					value: t$1.value,
					valueSpec: t$1.styleSpec.function,
					validateSpec: t$1.validateSpec,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					objectElementValidators: {
						stops: function(t$2) {
							if ("identity" === r$1) return [new Dt$1(t$2.key, t$2.value, "identity function may not have a \"stops\" property")];
							let e$2 = [];
							const n$2 = t$2.value;
							return e$2 = e$2.concat(Ti$1({
								key: t$2.key,
								value: n$2,
								valueSpec: t$2.valueSpec,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec,
								arrayElementValidator: h$1
							})), "array" === Xn$1(n$2) && 0 === n$2.length && e$2.push(new Dt$1(t$2.key, n$2, "array must have at least one stop")), e$2;
						},
						default: function(t$2) {
							return t$2.validateSpec({
								key: t$2.key,
								value: t$2.value,
								valueSpec: e$1,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec
							});
						}
					}
				});
				return "identity" === r$1 && a$1 && c$1.push(new Dt$1(t$1.key, t$1.value, "missing required property \"property\"")), "identity" === r$1 || t$1.value.stops || c$1.push(new Dt$1(t$1.key, t$1.value, "missing required property \"stops\"")), "exponential" === r$1 && t$1.valueSpec.expression && !Gn$1(t$1.valueSpec) && c$1.push(new Dt$1(t$1.key, t$1.value, "exponential functions not supported")), t$1.styleSpec.$version >= 8 && (l$1 && !qn$1(t$1.valueSpec) ? c$1.push(new Dt$1(t$1.key, t$1.value, "property functions not supported")) : a$1 && !jn$1(t$1.valueSpec) && c$1.push(new Dt$1(t$1.key, t$1.value, "zoom functions not supported"))), "categorical" !== r$1 && !u$1 || void 0 !== t$1.value.property || c$1.push(new Dt$1(t$1.key, t$1.value, "\"property\" property is required")), c$1;
				function h$1(t$2) {
					let r$2 = [];
					const n$2 = t$2.value, a$2 = t$2.key;
					if ("array" !== Xn$1(n$2)) return [new Dt$1(a$2, n$2, `array expected, ${Xn$1(n$2)} found`)];
					if (2 !== n$2.length) return [new Dt$1(a$2, n$2, `array length 2 expected, length ${n$2.length} found`)];
					if (u$1) {
						if ("object" !== Xn$1(n$2[0])) return [new Dt$1(a$2, n$2, `object expected, ${Xn$1(n$2[0])} found`)];
						if (void 0 === n$2[0].zoom) return [new Dt$1(a$2, n$2, "object stop key must have zoom")];
						if (void 0 === n$2[0].value) return [new Dt$1(a$2, n$2, "object stop key must have value")];
						if (s$1 && s$1 > Si(n$2[0].zoom)) return [new Dt$1(a$2, n$2[0].zoom, "stop zoom values must appear in ascending order")];
						Si(n$2[0].zoom) !== s$1 && (s$1 = Si(n$2[0].zoom), i$1 = void 0, o = {}), r$2 = r$2.concat(Ei$1({
							key: `${a$2}[0]`,
							value: n$2[0],
							valueSpec: { zoom: {} },
							validateSpec: t$2.validateSpec,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							objectElementValidators: {
								zoom: Ii$1,
								value: p$1
							}
						}));
					} else r$2 = r$2.concat(p$1({
						key: `${a$2}[0]`,
						value: n$2[0],
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}, n$2));
					return ri$1(ki(n$2[1])) ? r$2.concat([new Dt$1(`${a$2}[1]`, n$2[1], "expressions are not allowed in function stops.")]) : r$2.concat(t$2.validateSpec({
						key: `${a$2}[1]`,
						value: n$2[1],
						valueSpec: e$1,
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}));
				}
				function p$1(t$2, s$2) {
					const a$2 = Xn$1(t$2.value), l$2 = Si(t$2.value), u$2 = null !== t$2.value ? t$2.value : s$2;
					if (n$1) {
						if (a$2 !== n$1) return [new Dt$1(t$2.key, u$2, `${a$2} stop domain type must match previous stop domain type ${n$1}`)];
					} else n$1 = a$2;
					if ("number" !== a$2 && "string" !== a$2 && "boolean" !== a$2) return [new Dt$1(t$2.key, u$2, "stop domain value must be a number, string, or boolean")];
					if ("number" !== a$2 && "categorical" !== r$1) {
						let n$2 = `number expected, ${a$2} found`;
						return qn$1(e$1) && void 0 === r$1 && (n$2 += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new Dt$1(t$2.key, u$2, n$2)];
					}
					return "categorical" !== r$1 || "number" !== a$2 || isFinite(l$2) && Math.floor(l$2) === l$2 ? "categorical" !== r$1 && "number" === a$2 && void 0 !== i$1 && l$2 < i$1 ? [new Dt$1(t$2.key, u$2, "stop domain values must appear in ascending order")] : (i$1 = l$2, "categorical" === r$1 && l$2 in o ? [new Dt$1(t$2.key, u$2, "stop domain values must be unique")] : (o[l$2] = !0, [])) : [new Dt$1(t$2.key, u$2, `integer expected, found ${l$2}`)];
				}
			}
			function Fi$1(t$1) {
				const e$1 = ("property" === t$1.expressionContext ? oi$1 : ni$1)(ki(t$1.value), t$1.valueSpec);
				if ("error" === e$1.result) return e$1.value.map(((e$2) => new Dt$1(`${t$1.key}${e$2.key}`, t$1.value, e$2.message)));
				const r$1 = e$1.value.expression || e$1.value._styleExpression.expression;
				if ("property" === t$1.expressionContext && "text-font" === t$1.propertyKey && !r$1.outputDefined()) return [new Dt$1(t$1.key, t$1.value, `Invalid data expression for "${t$1.propertyKey}". Output values must be contained as literals within the expression.`)];
				if ("property" === t$1.expressionContext && "layout" === t$1.propertyType && !Rn(r$1)) return [new Dt$1(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with layout properties.")];
				if ("filter" === t$1.expressionContext && !Rn(r$1)) return [new Dt$1(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with filters.")];
				if (t$1.expressionContext && 0 === t$1.expressionContext.indexOf("cluster")) {
					if (!Nn$1(r$1, ["zoom", "feature-state"])) return [new Dt$1(t$1.key, t$1.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
					if ("cluster-initial" === t$1.expressionContext && !On(r$1)) return [new Dt$1(t$1.key, t$1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
				}
				return [];
			}
			function Di$1(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = Xn$1(r$1);
				return "string" !== n$1 ? [new Dt$1(e$1, r$1, `color expected, ${n$1} found`)] : Te$1.parse(String(r$1)) ? [] : [new Dt$1(e$1, r$1, `color expected, "${r$1}" found`)];
			}
			function Pi$1(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec, i$1 = [];
				return Array.isArray(n$1.values) ? -1 === n$1.values.indexOf(Si(r$1)) && i$1.push(new Dt$1(e$1, r$1, `expected one of [${n$1.values.join(", ")}], ${JSON.stringify(r$1)} found`)) : -1 === Object.keys(n$1.values).indexOf(Si(r$1)) && i$1.push(new Dt$1(e$1, r$1, `expected one of [${Object.keys(n$1.values).join(", ")}], ${JSON.stringify(r$1)} found`)), i$1;
			}
			function zi$1(t$1) {
				return hi(ki(t$1.value)) ? Fi$1(Pt$1({}, t$1, {
					expressionContext: "filter",
					valueSpec: { value: "boolean" }
				})) : Bi$1(t$1);
			}
			function Bi$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key;
				if ("array" !== Xn$1(e$1)) return [new Dt$1(r$1, e$1, `array expected, ${Xn$1(e$1)} found`)];
				const n$1 = t$1.styleSpec;
				let i$1, s$1 = [];
				if (e$1.length < 1) return [new Dt$1(r$1, e$1, "filter array must have at least 1 element")];
				switch (s$1 = s$1.concat(Pi$1({
					key: `${r$1}[0]`,
					value: e$1[0],
					valueSpec: n$1.filter_operator,
					style: t$1.style,
					styleSpec: t$1.styleSpec
				})), Si(e$1[0])) {
					case "<":
					case "<=":
					case ">":
					case ">=": e$1.length >= 2 && "$type" === Si(e$1[1]) && s$1.push(new Dt$1(r$1, e$1, `"$type" cannot be use with operator "${e$1[0]}"`));
					case "==":
					case "!=": 3 !== e$1.length && s$1.push(new Dt$1(r$1, e$1, `filter array for operator "${e$1[0]}" must have 3 elements`));
					case "in":
					case "!in":
						e$1.length >= 2 && (i$1 = Xn$1(e$1[1]), "string" !== i$1 && s$1.push(new Dt$1(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`)));
						for (let o = 2; o < e$1.length; o++) i$1 = Xn$1(e$1[o]), "$type" === Si(e$1[1]) ? s$1 = s$1.concat(Pi$1({
							key: `${r$1}[${o}]`,
							value: e$1[o],
							valueSpec: n$1.geometry_type,
							style: t$1.style,
							styleSpec: t$1.styleSpec
						})) : "string" !== i$1 && "number" !== i$1 && "boolean" !== i$1 && s$1.push(new Dt$1(`${r$1}[${o}]`, e$1[o], `string, number, or boolean expected, ${i$1} found`));
						break;
					case "any":
					case "all":
					case "none":
						for (let n$2 = 1; n$2 < e$1.length; n$2++) s$1 = s$1.concat(Bi$1({
							key: `${r$1}[${n$2}]`,
							value: e$1[n$2],
							style: t$1.style,
							styleSpec: t$1.styleSpec
						}));
						break;
					case "has":
					case "!has": i$1 = Xn$1(e$1[1]), 2 !== e$1.length ? s$1.push(new Dt$1(r$1, e$1, `filter array for "${e$1[0]}" operator must have 2 elements`)) : "string" !== i$1 && s$1.push(new Dt$1(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`));
				}
				return s$1;
			}
			function Vi$1(t$1, e$1) {
				const r$1 = t$1.key, n$1 = t$1.validateSpec, i$1 = t$1.style, s$1 = t$1.styleSpec, o = t$1.value, a$1 = t$1.objectKey, l$1 = s$1[`${e$1}_${t$1.layerType}`];
				if (!l$1) return [];
				const u$1 = a$1.match(/^(.*)-transition$/);
				if ("paint" === e$1 && u$1 && l$1[u$1[1]] && l$1[u$1[1]].transition) return n$1({
					key: r$1,
					value: o,
					valueSpec: s$1.transition,
					style: i$1,
					styleSpec: s$1
				});
				const c$1 = t$1.valueSpec || l$1[a$1];
				if (!c$1) return [new Dt$1(r$1, o, `unknown property "${a$1}"`)];
				let h$1;
				if ("string" === Xn$1(o) && qn$1(c$1) && !c$1.tokens && (h$1 = /^{([^}]+)}$/.exec(o))) return [new Dt$1(r$1, o, `"${a$1}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h$1[1])} }\`.`)];
				const p$1 = [];
				return "symbol" === t$1.layerType && "text-font" === a$1 && Yn$1(ki(o)) && "identity" === Si(o.type) && p$1.push(new Dt$1(r$1, o, "\"text-font\" does not support identity functions")), p$1.concat(n$1({
					key: t$1.key,
					value: o,
					valueSpec: c$1,
					style: i$1,
					styleSpec: s$1,
					expressionContext: "property",
					propertyType: e$1,
					propertyKey: a$1
				}));
			}
			function Ci$1(t$1) {
				return Vi$1(t$1, "paint");
			}
			function Li(t$1) {
				return Vi$1(t$1, "layout");
			}
			function Oi$1(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key, i$1 = t$1.style, s$1 = t$1.styleSpec;
				if ("object" !== Xn$1(r$1)) return [new Dt$1(n$1, r$1, `object expected, ${Xn$1(r$1)} found`)];
				r$1.type || r$1.ref || e$1.push(new Dt$1(n$1, r$1, "either \"type\" or \"ref\" is required"));
				let o = Si(r$1.type);
				const a$1 = Si(r$1.ref);
				if (r$1.id) {
					const s$2 = Si(r$1.id);
					for (let o$1 = 0; o$1 < t$1.arrayIndex; o$1++) {
						const t$2 = i$1.layers[o$1];
						Si(t$2.id) === s$2 && e$1.push(new Dt$1(n$1, r$1.id, `duplicate layer id "${r$1.id}", previously used at line ${t$2.id.__line__}`));
					}
				}
				if ("ref" in r$1) {
					let t$2;
					[
						"type",
						"source",
						"source-layer",
						"filter",
						"layout"
					].forEach(((t$3) => {
						t$3 in r$1 && e$1.push(new Dt$1(n$1, r$1[t$3], `"${t$3}" is prohibited for ref layers`));
					})), i$1.layers.forEach(((e$2) => {
						Si(e$2.id) === a$1 && (t$2 = e$2);
					})), t$2 ? t$2.ref ? e$1.push(new Dt$1(n$1, r$1.ref, "ref cannot reference another ref layer")) : o = Si(t$2.type) : e$1.push(new Dt$1(n$1, r$1.ref, `ref layer "${a$1}" not found`));
				} else if ("background" !== o) if (r$1.source) {
					const t$2 = i$1.sources && i$1.sources[r$1.source], s$2 = t$2 && Si(t$2.type);
					t$2 ? "vector" === s$2 && "raster" === o ? e$1.push(new Dt$1(n$1, r$1.source, `layer "${r$1.id}" requires a raster source`)) : "raster-dem" !== s$2 && "hillshade" === o || "raster-dem" !== s$2 && "color-relief" === o ? e$1.push(new Dt$1(n$1, r$1.source, `layer "${r$1.id}" requires a raster-dem source`)) : "raster" === s$2 && "raster" !== o ? e$1.push(new Dt$1(n$1, r$1.source, `layer "${r$1.id}" requires a vector source`)) : "vector" !== s$2 || r$1["source-layer"] ? "raster-dem" === s$2 && "hillshade" !== o && "color-relief" !== o ? e$1.push(new Dt$1(n$1, r$1.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : "line" !== o || !r$1.paint || !r$1.paint["line-gradient"] || "geojson" === s$2 && t$2.lineMetrics || e$1.push(new Dt$1(n$1, r$1, `layer "${r$1.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e$1.push(new Dt$1(n$1, r$1, `layer "${r$1.id}" must specify a "source-layer"`)) : e$1.push(new Dt$1(n$1, r$1.source, `source "${r$1.source}" not found`));
				} else e$1.push(new Dt$1(n$1, r$1, "missing required property \"source\""));
				return e$1 = e$1.concat(Ei$1({
					key: n$1,
					value: r$1,
					valueSpec: s$1.layer,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					validateSpec: t$1.validateSpec,
					objectElementValidators: {
						"*": () => [],
						type: () => t$1.validateSpec({
							key: `${n$1}.type`,
							value: r$1.type,
							valueSpec: s$1.layer.type,
							style: t$1.style,
							styleSpec: t$1.styleSpec,
							validateSpec: t$1.validateSpec,
							object: r$1,
							objectKey: "type"
						}),
						filter: zi$1,
						layout: (t$2) => Ei$1({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Li(Pt$1({ layerType: o }, t$3)) }
						}),
						paint: (t$2) => Ei$1({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Ci$1(Pt$1({ layerType: o }, t$3)) }
						})
					}
				})), e$1;
			}
			function Ri$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Xn$1(e$1);
				return "string" !== n$1 ? [new Dt$1(r$1, e$1, `string expected, ${n$1} found`)] : [];
			}
			const Ni$1 = { promoteId: function({ key: t$1, value: e$1 }) {
				if ("string" === Xn$1(e$1)) return Ri$1({
					key: t$1,
					value: e$1
				});
				{
					const r$1 = [];
					for (const n$1 in e$1) r$1.push(...Ri$1({
						key: `${t$1}.${n$1}`,
						value: e$1[n$1]
					}));
					return r$1;
				}
			} };
			function $i$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = t$1.styleSpec, i$1 = t$1.style, s$1 = t$1.validateSpec;
				if (!e$1.type) return [new Dt$1(r$1, e$1, "\"type\" is required")];
				const o = Si(e$1.type);
				let a$1;
				switch (o) {
					case "vector":
					case "raster": return a$1 = Ei$1({
						key: r$1,
						value: e$1,
						valueSpec: n$1[`source_${o.replace("-", "_")}`],
						style: t$1.style,
						styleSpec: n$1,
						objectElementValidators: Ni$1,
						validateSpec: s$1
					}), a$1;
					case "raster-dem": return a$1 = function(t$2) {
						var e$2;
						const r$2 = null !== (e$2 = t$2.sourceName) && void 0 !== e$2 ? e$2 : "", n$2 = t$2.value, i$2 = t$2.styleSpec, s$2 = i$2.source_raster_dem, o$1 = t$2.style;
						let a$2 = [];
						const l$1 = Xn$1(n$2);
						if (void 0 === n$2) return a$2;
						if ("object" !== l$1) return a$2.push(new Dt$1("source_raster_dem", n$2, `object expected, ${l$1} found`)), a$2;
						const u$1 = "custom" === Si(n$2.encoding), c$1 = [
							"redFactor",
							"greenFactor",
							"blueFactor",
							"baseShift"
						], h$1 = t$2.value.encoding ? `"${t$2.value.encoding}"` : "Default";
						for (const e$3 in n$2) !u$1 && c$1.includes(e$3) ? a$2.push(new Dt$1(e$3, n$2[e$3], `In "${r$2}": "${e$3}" is only valid when "encoding" is set to "custom". ${h$1} encoding found`)) : s$2[e$3] ? a$2 = a$2.concat(t$2.validateSpec({
							key: e$3,
							value: n$2[e$3],
							valueSpec: s$2[e$3],
							validateSpec: t$2.validateSpec,
							style: o$1,
							styleSpec: i$2
						})) : a$2.push(new Dt$1(e$3, n$2[e$3], `unknown property "${e$3}"`));
						return a$2;
					}({
						sourceName: r$1,
						value: e$1,
						style: t$1.style,
						styleSpec: n$1,
						validateSpec: s$1
					}), a$1;
					case "geojson":
						if (a$1 = Ei$1({
							key: r$1,
							value: e$1,
							valueSpec: n$1.source_geojson,
							style: i$1,
							styleSpec: n$1,
							validateSpec: s$1,
							objectElementValidators: Ni$1
						}), e$1.cluster) for (const t$2 in e$1.clusterProperties) {
							const [n$2, i$2] = e$1.clusterProperties[t$2], s$2 = "string" == typeof n$2 ? [
								n$2,
								["accumulated"],
								["get", t$2]
							] : n$2;
							a$1.push(...Fi$1({
								key: `${r$1}.${t$2}.map`,
								value: i$2,
								expressionContext: "cluster-map"
							})), a$1.push(...Fi$1({
								key: `${r$1}.${t$2}.reduce`,
								value: s$2,
								expressionContext: "cluster-reduce"
							}));
						}
						return a$1;
					case "video": return Ei$1({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_video,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "image": return Ei$1({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_image,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "canvas": return [new Dt$1(r$1, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
					default: return Pi$1({
						key: `${r$1}.type`,
						value: e$1.type,
						valueSpec: { values: [
							"vector",
							"raster",
							"raster-dem",
							"geojson",
							"video",
							"image"
						] }
					});
				}
			}
			function Ui$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.light, i$1 = t$1.style;
				let s$1 = [];
				const o = Xn$1(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== o) return s$1 = s$1.concat([new Dt$1("light", e$1, `object expected, ${o} found`)]), s$1;
				for (const o$1 in e$1) {
					const a$1 = o$1.match(/^(.*)-transition$/);
					s$1 = s$1.concat(a$1 && n$1[a$1[1]] && n$1[a$1[1]].transition ? t$1.validateSpec({
						key: o$1,
						value: e$1[o$1],
						valueSpec: r$1.transition,
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : n$1[o$1] ? t$1.validateSpec({
						key: o$1,
						value: e$1[o$1],
						valueSpec: n$1[o$1],
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : [new Dt$1(o$1, e$1[o$1], `unknown property "${o$1}"`)]);
				}
				return s$1;
			}
			function qi$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.sky, i$1 = t$1.style, s$1 = Xn$1(e$1);
				if (void 0 === e$1) return [];
				if ("object" !== s$1) return [new Dt$1("sky", e$1, `object expected, ${s$1} found`)];
				let o = [];
				for (const s$2 in e$1) o = o.concat(n$1[s$2] ? t$1.validateSpec({
					key: s$2,
					value: e$1[s$2],
					valueSpec: n$1[s$2],
					style: i$1,
					styleSpec: r$1
				}) : [new Dt$1(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
				return o;
			}
			function ji$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.terrain, i$1 = t$1.style;
				let s$1 = [];
				const o = Xn$1(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== o) return s$1 = s$1.concat([new Dt$1("terrain", e$1, `object expected, ${o} found`)]), s$1;
				for (const o$1 in e$1) s$1 = s$1.concat(n$1[o$1] ? t$1.validateSpec({
					key: o$1,
					value: e$1[o$1],
					valueSpec: n$1[o$1],
					validateSpec: t$1.validateSpec,
					style: i$1,
					styleSpec: r$1
				}) : [new Dt$1(o$1, e$1[o$1], `unknown property "${o$1}"`)]);
				return s$1;
			}
			function Gi$1(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key;
				if (Array.isArray(r$1)) {
					const i$1 = [], s$1 = [];
					for (const o in r$1) r$1[o].id && i$1.includes(r$1[o].id) && e$1.push(new Dt$1(n$1, r$1, `all the sprites' ids must be unique, but ${r$1[o].id} is duplicated`)), i$1.push(r$1[o].id), r$1[o].url && s$1.includes(r$1[o].url) && e$1.push(new Dt$1(n$1, r$1, `all the sprites' URLs must be unique, but ${r$1[o].url} is duplicated`)), s$1.push(r$1[o].url), e$1 = e$1.concat(Ei$1({
						key: `${n$1}[${o}]`,
						value: r$1[o],
						valueSpec: {
							id: {
								type: "string",
								required: !0
							},
							url: {
								type: "string",
								required: !0
							}
						},
						validateSpec: t$1.validateSpec
					}));
					return e$1;
				}
				return Ri$1({
					key: n$1,
					value: r$1
				});
			}
			function Xi$1(t$1) {
				return e$1 = t$1.value, Boolean(e$1) && e$1.constructor === Object ? [] : [new Dt$1(t$1.key, t$1.value, `object expected, ${Xn$1(t$1.value)} found`)];
				var e$1;
			}
			const Yi$1 = {
				"*": () => [],
				array: Ti$1,
				boolean: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.key, n$1 = Xn$1(e$1);
					return "boolean" !== n$1 ? [new Dt$1(r$1, e$1, `boolean expected, ${n$1} found`)] : [];
				},
				number: Ii$1,
				color: Di$1,
				constants: Ai$1,
				enum: Pi$1,
				filter: zi$1,
				function: Mi$1,
				layer: Oi$1,
				object: Ei$1,
				source: $i$1,
				light: Ui$1,
				sky: qi$1,
				terrain: ji$1,
				projection: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.projection, i$1 = t$1.style, s$1 = Xn$1(e$1);
					if (void 0 === e$1) return [];
					if ("object" !== s$1) return [new Dt$1("projection", e$1, `object expected, ${s$1} found`)];
					let o = [];
					for (const s$2 in e$1) o = o.concat(n$1[s$2] ? t$1.validateSpec({
						key: s$2,
						value: e$1[s$2],
						valueSpec: n$1[s$2],
						style: i$1,
						styleSpec: r$1
					}) : [new Dt$1(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
					return o;
				},
				projectionDefinition: function(t$1) {
					const e$1 = t$1.key;
					let r$1 = t$1.value;
					r$1 = r$1 instanceof String ? r$1.valueOf() : r$1;
					const n$1 = Xn$1(r$1);
					return "array" !== n$1 || function(t$2) {
						return Array.isArray(t$2) && 3 === t$2.length && "string" == typeof t$2[0] && "string" == typeof t$2[1] && "number" == typeof t$2[2];
					}(r$1) || function(t$2) {
						return !![
							"interpolate",
							"step",
							"literal"
						].includes(t$2[0]);
					}(r$1) ? ["array", "string"].includes(n$1) ? [] : [new Dt$1(e$1, r$1, `projection expected, invalid type "${n$1}" found`)] : [new Dt$1(e$1, r$1, `projection expected, invalid array ${JSON.stringify(r$1)} found`)];
				},
				string: Ri$1,
				formatted: function(t$1) {
					return 0 === Ri$1(t$1).length ? [] : Fi$1(t$1);
				},
				resolvedImage: function(t$1) {
					return 0 === Ri$1(t$1).length ? [] : Fi$1(t$1);
				},
				padding: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Xn$1(r$1)) {
						if (r$1.length < 1 || r$1.length > 4) return [new Dt$1(e$1, r$1, `padding requires 1 to 4 values; ${r$1.length} values found`)];
						const n$1 = { type: "number" };
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Ii$1({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				numberArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Xn$1(r$1)) {
						const n$1 = { type: "number" };
						if (r$1.length < 1) return [new Dt$1(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Ii$1({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				colorArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Xn$1(r$1)) {
						if (r$1.length < 1) return [new Dt$1(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let t$2 = [];
						for (let n$1 = 0; n$1 < r$1.length; n$1++) t$2 = t$2.concat(Di$1({
							key: `${e$1}[${n$1}]`,
							value: r$1[n$1]
						}));
						return t$2;
					}
					return Di$1({
						key: e$1,
						value: r$1
					});
				},
				variableAnchorOffsetCollection: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value, n$1 = Xn$1(r$1), i$1 = t$1.styleSpec;
					if ("array" !== n$1 || r$1.length < 1 || r$1.length % 2 != 0) return [new Dt$1(e$1, r$1, "variableAnchorOffsetCollection requires a non-empty array of even length")];
					let s$1 = [];
					for (let n$2 = 0; n$2 < r$1.length; n$2 += 2) s$1 = s$1.concat(Pi$1({
						key: `${e$1}[${n$2}]`,
						value: r$1[n$2],
						valueSpec: i$1.layout_symbol["text-anchor"]
					})), s$1 = s$1.concat(Ti$1({
						key: `${e$1}[${n$2 + 1}]`,
						value: r$1[n$2 + 1],
						valueSpec: {
							length: 2,
							value: "number"
						},
						validateSpec: t$1.validateSpec,
						style: t$1.style,
						styleSpec: i$1
					}));
					return s$1;
				},
				sprite: Gi$1,
				state: Xi$1
			};
			function Zi$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.styleSpec;
				return t$1.validateSpec = Zi$1, r$1.expression && Yn$1(Si(e$1)) ? Mi$1(t$1) : r$1.expression && ri$1(ki(e$1)) ? Fi$1(t$1) : r$1.type && Yi$1[r$1.type] ? Yi$1[r$1.type](t$1) : Ei$1(Pt$1({}, t$1, { valueSpec: r$1.type ? n$1[r$1.type] : r$1 }));
			}
			function Hi$1(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Ri$1(t$1);
				return n$1.length || (-1 === e$1.indexOf("{fontstack}") && n$1.push(new Dt$1(r$1, e$1, "\"glyphs\" url must include a \"{fontstack}\" token")), -1 === e$1.indexOf("{range}") && n$1.push(new Dt$1(r$1, e$1, "\"glyphs\" url must include a \"{range}\" token"))), n$1;
			}
			function Ki$1(t$1, e$1 = vt$1) {
				let r$1 = [];
				return r$1 = r$1.concat(Zi$1({
					key: "",
					value: t$1,
					valueSpec: e$1.$root,
					styleSpec: e$1,
					style: t$1,
					validateSpec: Zi$1,
					objectElementValidators: {
						glyphs: Hi$1,
						"*": () => []
					}
				})), t$1.constants && (r$1 = r$1.concat(Ai$1({
					key: "constants",
					value: t$1.constants
				}))), Ji$1(r$1);
			}
			function Wi$1(t$1) {
				return function(e$1) {
					return t$1(Object.assign({}, e$1, { validateSpec: Zi$1 }));
				};
			}
			function Ji$1(t$1) {
				return [].concat(t$1).sort(((t$2, e$1) => t$2.line - e$1.line));
			}
			function Qi$1(t$1) {
				return function(...e$1) {
					return Ji$1(t$1.apply(this, e$1));
				};
			}
			Ki$1.source = Qi$1(Wi$1($i$1)), Ki$1.sprite = Qi$1(Wi$1(Gi$1)), Ki$1.glyphs = Qi$1(Wi$1(Hi$1)), Ki$1.light = Qi$1(Wi$1(Ui$1)), Ki$1.sky = Qi$1(Wi$1(qi$1)), Ki$1.terrain = Qi$1(Wi$1(ji$1)), Ki$1.state = Qi$1(Wi$1(Xi$1)), Ki$1.layer = Qi$1(Wi$1(Oi$1)), Ki$1.filter = Qi$1(Wi$1(zi$1)), Ki$1.paintProperty = Qi$1(Wi$1(Ci$1)), Ki$1.layoutProperty = Qi$1(Wi$1(Li));
			const ts$1 = vt$1, es$1 = Ki$1, rs$1 = es$1.light, ns$1 = es$1.sky, is$1 = es$1.paintProperty, ss$1 = es$1.layoutProperty;
			function os$1(t$1, e$1) {
				let r$1 = !1;
				if (e$1 && e$1.length) for (const n$1 of e$1) t$1.fire(new gt$1(new Error(n$1.message))), r$1 = !0;
				return r$1;
			}
			class as$1 {
				constructor(t$1, e$1, r$1) {
					const n$1 = this.cells = [];
					if (t$1 instanceof ArrayBuffer) {
						this.arrayBuffer = t$1;
						const i$2 = new Int32Array(this.arrayBuffer);
						t$1 = i$2[0], this.d = (e$1 = i$2[1]) + 2 * (r$1 = i$2[2]);
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) {
							const e$2 = i$2[3 + t$2], r$2 = i$2[3 + t$2 + 1];
							n$1.push(e$2 === r$2 ? null : i$2.subarray(e$2, r$2));
						}
						const s$1 = i$2[3 + n$1.length + 1];
						this.keys = i$2.subarray(i$2[3 + n$1.length], s$1), this.bboxes = i$2.subarray(s$1), this.insert = this._insertReadonly;
					} else {
						this.d = e$1 + 2 * r$1;
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) n$1.push([]);
						this.keys = [], this.bboxes = [];
					}
					this.n = e$1, this.extent = t$1, this.padding = r$1, this.scale = e$1 / t$1, this.uid = 0;
					const i$1 = r$1 / e$1 * t$1;
					this.min = -i$1, this.max = t$1 + i$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1) {
					this._forEachCell(e$1, r$1, n$1, i$1, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t$1), this.bboxes.push(e$1), this.bboxes.push(r$1), this.bboxes.push(n$1), this.bboxes.push(i$1);
				}
				_insertReadonly() {
					throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
				}
				_insertCell(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.cells[i$1].push(s$1);
				}
				query(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.min, o = this.max;
					if (t$1 <= s$1 && e$1 <= s$1 && o <= r$1 && o <= n$1 && !i$1) return Array.prototype.slice.call(this.keys);
					{
						const s$2 = [];
						return this._forEachCell(t$1, e$1, r$1, n$1, this._queryCell, s$2, {}, i$1), s$2;
					}
				}
				_queryCell(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
					const l$1 = this.cells[i$1];
					if (null !== l$1) {
						const i$2 = this.keys, u$1 = this.bboxes;
						for (let c$1 = 0; c$1 < l$1.length; c$1++) {
							const h$1 = l$1[c$1];
							if (void 0 === o[h$1]) {
								const l$2 = 4 * h$1;
								(a$1 ? a$1(u$1[l$2 + 0], u$1[l$2 + 1], u$1[l$2 + 2], u$1[l$2 + 3]) : t$1 <= u$1[l$2 + 2] && e$1 <= u$1[l$2 + 3] && r$1 >= u$1[l$2 + 0] && n$1 >= u$1[l$2 + 1]) ? (o[h$1] = !0, s$1.push(i$2[h$1])) : o[h$1] = !1;
							}
						}
					}
				}
				_forEachCell(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
					const l$1 = this._convertToCellCoord(t$1), u$1 = this._convertToCellCoord(e$1), c$1 = this._convertToCellCoord(r$1), h$1 = this._convertToCellCoord(n$1);
					for (let p$1 = l$1; p$1 <= c$1; p$1++) for (let l$2 = u$1; l$2 <= h$1; l$2++) {
						const u$2 = this.d * l$2 + p$1;
						if ((!a$1 || a$1(this._convertFromCellCoord(p$1), this._convertFromCellCoord(l$2), this._convertFromCellCoord(p$1 + 1), this._convertFromCellCoord(l$2 + 1))) && i$1.call(this, t$1, e$1, r$1, n$1, u$2, s$1, o, a$1)) return;
					}
				}
				_convertFromCellCoord(t$1) {
					return (t$1 - this.padding) / this.scale;
				}
				_convertToCellCoord(t$1) {
					return Math.max(0, Math.min(this.d - 1, Math.floor(t$1 * this.scale) + this.padding));
				}
				toArrayBuffer() {
					if (this.arrayBuffer) return this.arrayBuffer;
					const t$1 = this.cells, e$1 = 3 + this.cells.length + 1 + 1;
					let r$1 = 0;
					for (let t$2 = 0; t$2 < this.cells.length; t$2++) r$1 += this.cells[t$2].length;
					const n$1 = new Int32Array(e$1 + r$1 + this.keys.length + this.bboxes.length);
					n$1[0] = this.extent, n$1[1] = this.n, n$1[2] = this.padding;
					let i$1 = e$1;
					for (let e$2 = 0; e$2 < t$1.length; e$2++) {
						const r$2 = t$1[e$2];
						n$1[3 + e$2] = i$1, n$1.set(r$2, i$1), i$1 += r$2.length;
					}
					return n$1[3 + t$1.length] = i$1, n$1.set(this.keys, i$1), i$1 += this.keys.length, n$1[3 + t$1.length + 1] = i$1, n$1.set(this.bboxes, i$1), i$1 += this.bboxes.length, n$1.buffer;
				}
				static serialize(t$1, e$1) {
					const r$1 = t$1.toArrayBuffer();
					return e$1 && e$1.push(r$1), { buffer: r$1 };
				}
				static deserialize(t$1) {
					return new as$1(t$1.buffer);
				}
			}
			const ls$1 = {};
			function us$1(t$1, e$1, r$1 = {}) {
				if (ls$1[t$1]) throw new Error(`${t$1} is already registered.`);
				Object.defineProperty(e$1, "_classRegistryKey", {
					value: t$1,
					writeable: !1
				}), ls$1[t$1] = {
					klass: e$1,
					omit: r$1.omit || [],
					shallow: r$1.shallow || []
				};
			}
			us$1("Object", Object), us$1("Set", Set), us$1("TransferableGridIndex", as$1), us$1("Color", Te$1), us$1("Error", Error), us$1("AJAXError", ct$1), us$1("ResolvedImage", Oe$1), us$1("StylePropertyFunction", ai$1), us$1("StyleExpression", ei$1, { omit: ["_evaluator"] }), us$1("ZoomDependentExpression", si$1), us$1("ZoomConstantExpression", ii$1), us$1("CompoundExpression", Pn$1, { omit: ["_evaluate"] });
			for (const t$1 in Dn$1) Dn$1[t$1]._classRegistryKey || us$1(`Expression_${t$1}`, Dn$1[t$1]);
			function cs$1(t$1) {
				return t$1 && "undefined" != typeof ArrayBuffer && (t$1 instanceof ArrayBuffer || t$1.constructor && "ArrayBuffer" === t$1.constructor.name);
			}
			function hs$1(t$1) {
				return t$1.$name || t$1.constructor._classRegistryKey;
			}
			function ps$1(t$1) {
				return !function(t$2) {
					if (null === t$2 || "object" != typeof t$2) return !1;
					const e$1 = hs$1(t$2);
					return !(!e$1 || "Object" === e$1);
				}(t$1) && (null == t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || "string" == typeof t$1 || t$1 instanceof Boolean || t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Date || t$1 instanceof RegExp || t$1 instanceof Blob || t$1 instanceof Error || cs$1(t$1) || Z$1(t$1) || ArrayBuffer.isView(t$1) || t$1 instanceof ImageData);
			}
			function fs$1(t$1, e$1) {
				if (ps$1(t$1)) return (cs$1(t$1) || Z$1(t$1)) && e$1 && e$1.push(t$1), ArrayBuffer.isView(t$1) && e$1 && e$1.push(t$1.buffer), t$1 instanceof ImageData && e$1 && e$1.push(t$1.data.buffer), t$1;
				if (Array.isArray(t$1)) {
					const r$2 = [];
					for (const n$2 of t$1) r$2.push(fs$1(n$2, e$1));
					return r$2;
				}
				if ("object" != typeof t$1) throw new Error("can't serialize object of type " + typeof t$1);
				const r$1 = hs$1(t$1);
				if (!r$1) throw new Error(`can't serialize object of unregistered class ${t$1.constructor.name}`);
				if (!ls$1[r$1]) throw new Error(`${r$1} is not registered.`);
				const { klass: n$1 } = ls$1[r$1], i$1 = n$1.serialize ? n$1.serialize(t$1, e$1) : {};
				if (n$1.serialize) {
					if (e$1 && i$1 === e$1[e$1.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
				} else {
					for (const n$2 in t$1) {
						if (!t$1.hasOwnProperty(n$2)) continue;
						if (ls$1[r$1].omit.indexOf(n$2) >= 0) continue;
						const s$1 = t$1[n$2];
						i$1[n$2] = ls$1[r$1].shallow.indexOf(n$2) >= 0 ? s$1 : fs$1(s$1, e$1);
					}
					t$1 instanceof Error && (i$1.message = t$1.message);
				}
				if (i$1.$name) throw new Error("$name property is reserved for worker serialization logic.");
				return "Object" !== r$1 && (i$1.$name = r$1), i$1;
			}
			function ds$1(t$1) {
				if (ps$1(t$1)) return t$1;
				if (Array.isArray(t$1)) return t$1.map(ds$1);
				if ("object" != typeof t$1) throw new Error("can't deserialize object of type " + typeof t$1);
				const e$1 = hs$1(t$1) || "Object";
				if (!ls$1[e$1]) throw new Error(`can't deserialize unregistered class ${e$1}`);
				const { klass: r$1 } = ls$1[e$1];
				if (!r$1) throw new Error(`can't deserialize unregistered class ${e$1}`);
				if (r$1.deserialize) return r$1.deserialize(t$1);
				const n$1 = Object.create(r$1.prototype);
				for (const r$2 of Object.keys(t$1)) {
					if ("$name" === r$2) continue;
					const i$1 = t$1[r$2];
					n$1[r$2] = ls$1[e$1].shallow.indexOf(r$2) >= 0 ? i$1 : ds$1(i$1);
				}
				return n$1;
			}
			class ys$1 {
				constructor() {
					this.first = !0;
				}
				update(t$1, e$1) {
					const r$1 = Math.floor(t$1);
					return this.first ? (this.first = !1, this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = 0, this.lastZoom = t$1, this.lastFloorZoom = r$1, !0) : (this.lastFloorZoom > r$1 ? (this.lastIntegerZoom = r$1 + 1, this.lastIntegerZoomTime = e$1) : this.lastFloorZoom < r$1 && (this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = e$1), t$1 !== this.lastZoom && (this.lastZoom = t$1, this.lastFloorZoom = r$1, !0));
				}
			}
			function ms$1(t$1) {
				return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t$1));
			}
			function gs$1(t$1) {
				return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t$1));
			}
			function xs$1(t$1) {
				return /\s/u.test(String.fromCodePoint(t$1));
			}
			function vs$1(t$1) {
				for (const e$1 of t$1) if (gs$1(e$1.codePointAt(0))) return !0;
				return !1;
			}
			function bs$1(t$1) {
				for (const e$1 of t$1) if (!As$1(e$1.codePointAt(0))) return !1;
				return !0;
			}
			function ws$1(t$1) {
				const e$1 = t$1.map(((t$2) => {
					try {
						return new RegExp(`\\p{sc=${t$2}}`, "u").source;
					} catch (t$3) {
						return null;
					}
				})).filter(((t$2) => t$2));
				return new RegExp(e$1.join("|"), "u");
			}
			const _s$1 = ws$1([
				"Arab",
				"Dupl",
				"Mong",
				"Ougr",
				"Syrc"
			]);
			function As$1(t$1) {
				return !_s$1.test(String.fromCodePoint(t$1));
			}
			function Ss$1(t$1) {
				return !(gs$1(t$1) || (e$1 = t$1, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(e$1))));
				var e$1;
			}
			const ks$1 = ws$1([
				"Adlm",
				"Arab",
				"Armi",
				"Avst",
				"Chrs",
				"Cprt",
				"Egyp",
				"Elym",
				"Gara",
				"Hatr",
				"Hebr",
				"Hung",
				"Khar",
				"Lydi",
				"Mand",
				"Mani",
				"Mend",
				"Merc",
				"Mero",
				"Narb",
				"Nbat",
				"Nkoo",
				"Orkh",
				"Palm",
				"Phli",
				"Phlp",
				"Phnx",
				"Prti",
				"Rohg",
				"Samr",
				"Sarb",
				"Sogo",
				"Syrc",
				"Thaa",
				"Todr",
				"Yezi"
			]);
			function Es$1(t$1) {
				return ks$1.test(String.fromCodePoint(t$1));
			}
			function Ts$1(t$1, e$1) {
				return !(!e$1 && Es$1(t$1) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(t$1)));
			}
			function Is$1(t$1) {
				for (const e$1 of t$1) if (Es$1(e$1.codePointAt(0))) return !0;
				return !1;
			}
			const Ms$1 = new class {
				constructor() {
					this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {};
				}
				setState(t$1) {
					this.pluginStatus = t$1.pluginStatus, this.pluginURL = t$1.pluginURL;
				}
				getState() {
					return {
						pluginStatus: this.pluginStatus,
						pluginURL: this.pluginURL
					};
				}
				setMethods(t$1) {
					if (Ms$1.isParsed()) throw new Error("RTL text plugin already registered.");
					this.applyArabicShaping = t$1.applyArabicShaping, this.processBidirectionalText = t$1.processBidirectionalText, this.processStyledBidirectionalText = t$1.processStyledBidirectionalText, this.loadScriptResolve();
				}
				isParsed() {
					return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
				}
				getRTLTextPluginStatus() {
					return this.pluginStatus;
				}
				syncState(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if (this.isParsed()) return this.getState();
						if ("loading" !== t$1.pluginStatus) return this.setState(t$1), t$1;
						const e$1 = t$1.pluginURL, n$1 = new Promise(((t$2) => {
							this.loadScriptResolve = t$2;
						}));
						r$1(e$1);
						const i$1 = new Promise(((t$2) => setTimeout((() => t$2()), this.TIMEOUT)));
						if (yield Promise.race([n$1, i$1]), this.isParsed()) {
							const t$2 = {
								pluginStatus: "loaded",
								pluginURL: e$1
							};
							return this.setState(t$2), t$2;
						}
						throw this.setState({
							pluginStatus: "error",
							pluginURL: ""
						}), /* @__PURE__ */ new Error(`RTL Text Plugin failed to import scripts from ${e$1}`);
					}));
				}
			}();
			class Fs$1 {
				constructor(t$1, e$1) {
					this.isSupportedScript = Ds$1, this.zoom = t$1, e$1 ? (this.now = e$1.now || 0, this.fadeDuration = e$1.fadeDuration || 0, this.zoomHistory = e$1.zoomHistory || new ys$1(), this.transition = e$1.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ys$1(), this.transition = {});
				}
				crossFadingFactor() {
					return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
				}
				getCrossfadeParameters() {
					const t$1 = this.zoom, e$1 = t$1 - Math.floor(t$1), r$1 = this.crossFadingFactor();
					return t$1 > this.zoomHistory.lastIntegerZoom ? {
						fromScale: 2,
						toScale: 1,
						t: e$1 + (1 - e$1) * r$1
					} : {
						fromScale: .5,
						toScale: 1,
						t: 1 - (1 - r$1) * e$1
					};
				}
			}
			function Ds$1(t$1) {
				return function(t$2, e$1) {
					for (const r$1 of t$2) if (!Ts$1(r$1.codePointAt(0), e$1)) return !1;
					return !0;
				}(t$1, "loaded" === Ms$1.getRTLTextPluginStatus());
			}
			const Ps$1 = "-transition";
			class zs$1 {
				constructor(t$1, e$1, r$1) {
					this.property = t$1, this.value = e$1, this.expression = function(t$2, e$2, r$2) {
						if (Yn$1(t$2)) return new ai$1(t$2, e$2);
						if (ri$1(t$2)) {
							const n$1 = oi$1(t$2, e$2, r$2);
							if ("error" === n$1.result) throw new Error(n$1.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", "));
							return n$1.value;
						}
						{
							let r$3 = t$2;
							return "color" === e$2.type && "string" == typeof t$2 ? r$3 = Te$1.parse(t$2) : "padding" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "numberArray" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "colorArray" !== e$2.type || "string" != typeof t$2 && !Array.isArray(t$2) ? "variableAnchorOffsetCollection" === e$2.type && Array.isArray(t$2) ? r$3 = Le$1.parse(t$2) : "projectionDefinition" === e$2.type && "string" == typeof t$2 && (r$3 = Re$1.parse(t$2)) : r$3 = Be$1.parse(t$2) : r$3 = ze$1.parse(t$2) : r$3 = Pe$1.parse(t$2), {
								globalStateRefs: /* @__PURE__ */ new Set(),
								_globalState: null,
								kind: "constant",
								evaluate: () => r$3
							};
						}
					}(void 0 === e$1 ? t$1.specification.default : e$1, t$1.specification, r$1);
				}
				isDataDriven() {
					return "source" === this.expression.kind || "composite" === this.expression.kind;
				}
				getGlobalStateRefs() {
					return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					return this.property.possiblyEvaluate(this, t$1, e$1, r$1);
				}
			}
			class Bs$1 {
				constructor(t$1, e$1) {
					this.property = t$1, this.value = new zs$1(t$1, void 0, e$1);
				}
				transitioned(t$1, e$1) {
					return new Cs$1(this.property, this.value, e$1, O$1({}, t$1.transition, this.transition), t$1.now);
				}
				untransitioned() {
					return new Cs$1(this.property, this.value, null, {}, 0);
				}
			}
			class Vs$1 {
				constructor(t$1, e$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitionablePropertyValues), this._globalState = e$1;
				}
				getValue(t$1) {
					return U$1(this._values[t$1].value.value);
				}
				setValue(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Bs$1(this._values[t$1].property, this._globalState)), this._values[t$1].value = new zs$1(this._values[t$1].property, null === e$1 ? void 0 : U$1(e$1), this._globalState);
				}
				getTransition(t$1) {
					return U$1(this._values[t$1].transition);
				}
				setTransition(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Bs$1(this._values[t$1].property, this._globalState)), this._values[t$1].transition = U$1(e$1) || void 0;
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
						const n$1 = this.getTransition(e$1);
						void 0 !== n$1 && (t$1[`${e$1}${Ps$1}`] = n$1);
					}
					return t$1;
				}
				transitioned(t$1, e$1) {
					const r$1 = new Ls$1(this._properties);
					for (const n$1 of Object.keys(this._values)) r$1._values[n$1] = this._values[n$1].transitioned(t$1, e$1._values[n$1]);
					return r$1;
				}
				untransitioned() {
					const t$1 = new Ls$1(this._properties);
					for (const e$1 of Object.keys(this._values)) t$1._values[e$1] = this._values[e$1].untransitioned();
					return t$1;
				}
			}
			class Cs$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.property = t$1, this.value = e$1, this.begin = i$1 + n$1.delay || 0, this.end = this.begin + n$1.duration || 0, t$1.specification.transition && (n$1.delay || n$1.duration) && (this.prior = r$1);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = t$1.now || 0, i$1 = this.value.possiblyEvaluate(t$1, e$1, r$1), s$1 = this.prior;
					if (s$1) {
						if (n$1 > this.end) return this.prior = null, i$1;
						if (this.value.isDataDriven()) return this.prior = null, i$1;
						if (n$1 < this.begin) return s$1.possiblyEvaluate(t$1, e$1, r$1);
						{
							const o = (n$1 - this.begin) / (this.end - this.begin);
							return this.property.interpolate(s$1.possiblyEvaluate(t$1, e$1, r$1), i$1, z$1(o));
						}
					}
					return i$1;
				}
			}
			class Ls$1 {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitioningPropertyValues);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new Ns$1(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
				hasTransition() {
					for (const t$1 of Object.keys(this._values)) if (this._values[t$1].prior) return !0;
					return !1;
				}
			}
			class Os$1 {
				constructor(t$1, e$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPropertyValues), this._globalState = e$1;
				}
				hasValue(t$1) {
					return void 0 !== this._values[t$1].value;
				}
				getValue(t$1) {
					return U$1(this._values[t$1].value);
				}
				setValue(t$1, e$1) {
					this._values[t$1] = new zs$1(this._values[t$1].property, null === e$1 ? void 0 : U$1(e$1), this._globalState);
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
					}
					return t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new Ns$1(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
			}
			class Rs$1 {
				constructor(t$1, e$1, r$1) {
					this.property = t$1, this.value = e$1, this.parameters = r$1;
				}
				isConstant() {
					return "constant" === this.value.kind;
				}
				constantOr(t$1) {
					return "constant" === this.value.kind ? this.value.value : t$1;
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return this.property.evaluate(this.value, this.parameters, t$1, e$1, r$1, n$1);
				}
			}
			class Ns$1 {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPossiblyEvaluatedValues);
				}
				get(t$1) {
					return this._values[t$1];
				}
			}
			class $s$1 {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1) {
					if (t$1.isDataDriven()) throw new Error("Value should not be data driven");
					return t$1.expression.evaluate(e$1);
				}
				interpolate(t$1, e$1, r$1) {
					const n$1 = yr$1[this.specification.type];
					return n$1 ? n$1(t$1, e$1, r$1) : t$1;
				}
			}
			class Us$1 {
				constructor(t$1, e$1) {
					this.specification = t$1, this.overrides = e$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return new Rs$1(this, "constant" === t$1.expression.kind || "camera" === t$1.expression.kind ? {
						kind: "constant",
						value: t$1.expression.evaluate(e$1, null, {}, r$1, n$1)
					} : t$1.expression, e$1);
				}
				interpolate(t$1, e$1, r$1) {
					if ("constant" !== t$1.value.kind || "constant" !== e$1.value.kind) return t$1;
					if (void 0 === t$1.value.value || void 0 === e$1.value.value) return new Rs$1(this, {
						kind: "constant",
						value: void 0
					}, t$1.parameters);
					const n$1 = yr$1[this.specification.type];
					if (n$1) {
						const i$1 = n$1(t$1.value.value, e$1.value.value, r$1);
						return new Rs$1(this, {
							kind: "constant",
							value: i$1
						}, t$1.parameters);
					}
					return t$1;
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return "constant" === t$1.kind ? t$1.value : t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
				}
			}
			class qs$1 extends Us$1 {
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 === t$1.value) return new Rs$1(this, {
						kind: "constant",
						value: void 0
					}, e$1);
					if ("constant" === t$1.expression.kind) {
						const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1), s$1 = "resolvedImage" === t$1.property.specification.type && "string" != typeof i$1 ? i$1.name : i$1, o = this._calculate(s$1, s$1, s$1, e$1);
						return new Rs$1(this, {
							kind: "constant",
							value: o
						}, e$1);
					}
					if ("camera" === t$1.expression.kind) {
						const r$2 = this._calculate(t$1.expression.evaluate({ zoom: e$1.zoom - 1 }), t$1.expression.evaluate({ zoom: e$1.zoom }), t$1.expression.evaluate({ zoom: e$1.zoom + 1 }), e$1);
						return new Rs$1(this, {
							kind: "constant",
							value: r$2
						}, e$1);
					}
					return new Rs$1(this, t$1.expression, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					if ("source" === t$1.kind) {
						const o = t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
						return this._calculate(o, o, o, e$1);
					}
					return "composite" === t$1.kind ? this._calculate(t$1.evaluate({ zoom: Math.floor(e$1.zoom) - 1 }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) + 1 }, r$1, n$1), e$1) : t$1.value;
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class js$1 {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 !== t$1.value) {
						if ("constant" === t$1.expression.kind) {
							const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
							return this._calculate(i$1, i$1, i$1, e$1);
						}
						return this._calculate(t$1.expression.evaluate(new Fs$1(Math.floor(e$1.zoom - 1), e$1)), t$1.expression.evaluate(new Fs$1(Math.floor(e$1.zoom), e$1)), t$1.expression.evaluate(new Fs$1(Math.floor(e$1.zoom + 1), e$1)), e$1);
					}
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class Gs$1 {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return !!t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
				}
				interpolate() {
					return !1;
				}
			}
			class Xs$1 {
				constructor(t$1) {
					this.properties = t$1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
					for (const e$1 in t$1) {
						const r$1 = t$1[e$1];
						r$1.specification.overridable && this.overridableProperties.push(e$1);
						const n$1 = this.defaultPropertyValues[e$1] = new zs$1(r$1, void 0, void 0), i$1 = this.defaultTransitionablePropertyValues[e$1] = new Bs$1(r$1, void 0);
						this.defaultTransitioningPropertyValues[e$1] = i$1.untransitioned(), this.defaultPossiblyEvaluatedValues[e$1] = n$1.possiblyEvaluate({});
					}
				}
			}
			us$1("DataDrivenProperty", Us$1), us$1("DataConstantProperty", $s$1), us$1("CrossFadedDataDrivenProperty", qs$1), us$1("CrossFadedProperty", js$1), us$1("ColorRampProperty", Gs$1);
			class Ys$1 extends xt$1 {
				constructor(t$1, e$1, r$1) {
					if (super(), this.id = t$1.id, this.type = t$1.type, this._globalState = r$1, this._featureFilter = {
						filter: () => !0,
						needGeometry: !1,
						getGlobalStateRefs: () => /* @__PURE__ */ new Set()
					}, "custom" !== t$1.type && (this.metadata = t$1.metadata, this.minzoom = t$1.minzoom, this.maxzoom = t$1.maxzoom, "background" !== t$1.type && (this.source = t$1.source, this.sourceLayer = t$1["source-layer"], this.filter = t$1.filter, this._featureFilter = fi(t$1.filter, r$1)), e$1.layout && (this._unevaluatedLayout = new Os$1(e$1.layout, r$1)), e$1.paint)) {
						this._transitionablePaint = new Vs$1(e$1.paint, r$1);
						for (const e$2 in t$1.paint) this.setPaintProperty(e$2, t$1.paint[e$2], { validate: !1 });
						for (const e$2 in t$1.layout) this.setLayoutProperty(e$2, t$1.layout[e$2], { validate: !1 });
						this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ns$1(e$1.paint);
					}
				}
				setFilter(t$1) {
					this.filter = t$1, this._featureFilter = fi(t$1, this._globalState);
				}
				getCrossfadeParameters() {
					return this._crossfadeParameters;
				}
				getLayoutProperty(t$1) {
					return "visibility" === t$1 ? this.visibility : this._unevaluatedLayout.getValue(t$1);
				}
				getLayoutAffectingGlobalStateRefs() {
					const t$1 = /* @__PURE__ */ new Set();
					if (this._unevaluatedLayout) for (const e$1 in this._unevaluatedLayout._values) {
						const r$1 = this._unevaluatedLayout._values[e$1];
						for (const e$2 of r$1.getGlobalStateRefs()) t$1.add(e$2);
					}
					for (const e$1 of this._featureFilter.getGlobalStateRefs()) t$1.add(e$1);
					return t$1;
				}
				getPaintAffectingGlobalStateRefs() {
					var t$1;
					const e$1 = new globalThis.Map();
					if (this._transitionablePaint) for (const r$1 in this._transitionablePaint._values) {
						const n$1 = this._transitionablePaint._values[r$1].value;
						for (const i$1 of n$1.getGlobalStateRefs()) {
							const s$1 = null !== (t$1 = e$1.get(i$1)) && void 0 !== t$1 ? t$1 : [];
							s$1.push({
								name: r$1,
								value: n$1.value
							}), e$1.set(i$1, s$1);
						}
					}
					return e$1;
				}
				setLayoutProperty(t$1, e$1, r$1 = {}) {
					null != e$1 && this._validate(ss$1, `layers.${this.id}.layout.${t$1}`, t$1, e$1, r$1) || ("visibility" !== t$1 ? this._unevaluatedLayout.setValue(t$1, e$1) : this.visibility = e$1);
				}
				getPaintProperty(t$1) {
					return t$1.endsWith(Ps$1) ? this._transitionablePaint.getTransition(t$1.slice(0, -11)) : this._transitionablePaint.getValue(t$1);
				}
				setPaintProperty(t$1, e$1, r$1 = {}) {
					if (null != e$1 && this._validate(is$1, `layers.${this.id}.paint.${t$1}`, t$1, e$1, r$1)) return !1;
					if (t$1.endsWith(Ps$1)) return this._transitionablePaint.setTransition(t$1.slice(0, -11), e$1 || void 0), !1;
					{
						const r$2 = this._transitionablePaint._values[t$1], n$1 = "cross-faded-data-driven" === r$2.property.specification["property-type"], i$1 = r$2.value.isDataDriven(), s$1 = r$2.value;
						this._transitionablePaint.setValue(t$1, e$1), this._handleSpecialPaintPropertyUpdate(t$1);
						const o = this._transitionablePaint._values[t$1].value;
						return o.isDataDriven() || i$1 || n$1 || this._handleOverridablePaintPropertyUpdate(t$1, s$1, o);
					}
				}
				_handleSpecialPaintPropertyUpdate(t$1) {}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !1;
				}
				isHidden(t$1, e$1 = !1) {
					return !!(this.minzoom && t$1 < (e$1 ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t$1 >= this.maxzoom) || "none" === this.visibility;
				}
				updateTransitions(t$1) {
					this._transitioningPaint = this._transitionablePaint.transitioned(t$1, this._transitioningPaint);
				}
				hasTransition() {
					return this._transitioningPaint.hasTransition();
				}
				recalculate(t$1, e$1) {
					t$1.getCrossfadeParameters && (this._crossfadeParameters = t$1.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t$1, void 0, e$1)), this.paint = this._transitioningPaint.possiblyEvaluate(t$1, void 0, e$1);
				}
				serialize() {
					const t$1 = {
						id: this.id,
						type: this.type,
						source: this.source,
						"source-layer": this.sourceLayer,
						metadata: this.metadata,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						filter: this.filter,
						layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
						paint: this._transitionablePaint && this._transitionablePaint.serialize()
					};
					return this.visibility && (t$1.layout = t$1.layout || {}, t$1.layout.visibility = this.visibility), $$1(t$1, ((t$2, e$1) => !(void 0 === t$2 || "layout" === e$1 && !Object.keys(t$2).length || "paint" === e$1 && !Object.keys(t$2).length)));
				}
				_validate(t$1, e$1, r$1, n$1, i$1 = {}) {
					return (!i$1 || !1 !== i$1.validate) && os$1(this, t$1.call(es$1, {
						key: e$1,
						layerType: this.type,
						objectKey: r$1,
						value: n$1,
						styleSpec: vt$1,
						style: {
							glyphs: !0,
							sprite: !0
						}
					}));
				}
				is3D() {
					return !1;
				}
				isTileClipped() {
					return !1;
				}
				hasOffscreenPass() {
					return !1;
				}
				resize() {}
				isStateDependent() {
					for (const t$1 in this.paint._values) {
						const e$1 = this.paint.get(t$1);
						if (e$1 instanceof Rs$1 && qn$1(e$1.property.specification) && ("source" === e$1.value.kind || "composite" === e$1.value.kind) && e$1.value.isStateDependent) return !0;
					}
					return !1;
				}
			}
			let Zs$1;
			var Hs$1 = { get paint() {
				return Zs$1 = Zs$1 || new Xs$1({
					"raster-opacity": new $s$1(vt$1.paint_raster["raster-opacity"]),
					"raster-hue-rotate": new $s$1(vt$1.paint_raster["raster-hue-rotate"]),
					"raster-brightness-min": new $s$1(vt$1.paint_raster["raster-brightness-min"]),
					"raster-brightness-max": new $s$1(vt$1.paint_raster["raster-brightness-max"]),
					"raster-saturation": new $s$1(vt$1.paint_raster["raster-saturation"]),
					"raster-contrast": new $s$1(vt$1.paint_raster["raster-contrast"]),
					"raster-resampling": new $s$1(vt$1.paint_raster["raster-resampling"]),
					"raster-fade-duration": new $s$1(vt$1.paint_raster["raster-fade-duration"])
				});
			} };
			class Ks$1 extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, Hs$1, e$1);
				}
			}
			const Ws$1 = {
				Int8: Int8Array,
				Uint8: Uint8Array,
				Int16: Int16Array,
				Uint16: Uint16Array,
				Int32: Int32Array,
				Uint32: Uint32Array,
				Float32: Float32Array
			};
			class Js {
				constructor(t$1, e$1) {
					this._structArray = t$1, this._pos1 = e$1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
				}
			}
			class Qs$1 {
				constructor() {
					this.isTransferred = !1, this.capacity = -1, this.resize(0);
				}
				static serialize(t$1, e$1) {
					return t$1._trim(), e$1 && (t$1.isTransferred = !0, e$1.push(t$1.arrayBuffer)), {
						length: t$1.length,
						arrayBuffer: t$1.arrayBuffer
					};
				}
				static deserialize(t$1) {
					const e$1 = Object.create(this.prototype);
					return e$1.arrayBuffer = t$1.arrayBuffer, e$1.length = t$1.length, e$1.capacity = t$1.arrayBuffer.byteLength / e$1.bytesPerElement, e$1._refreshViews(), e$1;
				}
				_trim() {
					this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
				}
				clear() {
					this.length = 0;
				}
				resize(t$1) {
					this.reserve(t$1), this.length = t$1;
				}
				reserve(t$1) {
					if (t$1 > this.capacity) {
						this.capacity = Math.max(t$1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
						const e$1 = this.uint8;
						this._refreshViews(), e$1 && this.uint8.set(e$1);
					}
				}
				_refreshViews() {
					throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
				}
			}
			function to$1(t$1, e$1 = 1) {
				let r$1 = 0, n$1 = 0;
				return {
					members: t$1.map(((t$2) => {
						const i$1 = Ws$1[t$2.type].BYTES_PER_ELEMENT, s$1 = r$1 = eo$1(r$1, Math.max(e$1, i$1)), o = t$2.components || 1;
						return n$1 = Math.max(n$1, i$1), r$1 += i$1 * o, {
							name: t$2.name,
							type: t$2.type,
							components: o,
							offset: s$1
						};
					})),
					size: eo$1(r$1, Math.max(n$1, e$1)),
					alignment: e$1
				};
			}
			function eo$1(t$1, e$1) {
				return Math.ceil(t$1 / e$1) * e$1;
			}
			class ro$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.int16[n$1 + 0] = e$1, this.int16[n$1 + 1] = r$1, t$1;
				}
			}
			ro$1.prototype.bytesPerElement = 4, us$1("StructArrayLayout2i4", ro$1);
			class no$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.int16[i$1 + 0] = e$1, this.int16[i$1 + 1] = r$1, this.int16[i$1 + 2] = n$1, t$1;
				}
			}
			no$1.prototype.bytesPerElement = 6, us$1("StructArrayLayout3i6", no$1);
			class io$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.int16[s$1 + 0] = e$1, this.int16[s$1 + 1] = r$1, this.int16[s$1 + 2] = n$1, this.int16[s$1 + 3] = i$1, t$1;
				}
			}
			io$1.prototype.bytesPerElement = 8, us$1("StructArrayLayout4i8", io$1);
			class so$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o = this.length;
					return this.resize(o + 1), this.emplace(o, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					const a$1 = 6 * t$1;
					return this.int16[a$1 + 0] = e$1, this.int16[a$1 + 1] = r$1, this.int16[a$1 + 2] = n$1, this.int16[a$1 + 3] = i$1, this.int16[a$1 + 4] = s$1, this.int16[a$1 + 5] = o, t$1;
				}
			}
			so$1.prototype.bytesPerElement = 12, us$1("StructArrayLayout2i4i12", so$1);
			class oo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o = this.length;
					return this.resize(o + 1), this.emplace(o, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					const a$1 = 4 * t$1, l$1 = 8 * t$1;
					return this.int16[a$1 + 0] = e$1, this.int16[a$1 + 1] = r$1, this.uint8[l$1 + 4] = n$1, this.uint8[l$1 + 5] = i$1, this.uint8[l$1 + 6] = s$1, this.uint8[l$1 + 7] = o, t$1;
				}
			}
			oo$1.prototype.bytesPerElement = 8, us$1("StructArrayLayout2i4ub8", oo$1);
			class ao$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.float32[n$1 + 0] = e$1, this.float32[n$1 + 1] = r$1, t$1;
				}
			}
			ao$1.prototype.bytesPerElement = 8, us$1("StructArrayLayout2f8", ao$1);
			class lo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1) {
					const c$1 = this.length;
					return this.resize(c$1 + 1), this.emplace(c$1, t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1) {
					const h$1 = 10 * t$1;
					return this.uint16[h$1 + 0] = e$1, this.uint16[h$1 + 1] = r$1, this.uint16[h$1 + 2] = n$1, this.uint16[h$1 + 3] = i$1, this.uint16[h$1 + 4] = s$1, this.uint16[h$1 + 5] = o, this.uint16[h$1 + 6] = a$1, this.uint16[h$1 + 7] = l$1, this.uint16[h$1 + 8] = u$1, this.uint16[h$1 + 9] = c$1, t$1;
				}
			}
			lo$1.prototype.bytesPerElement = 20, us$1("StructArrayLayout10ui20", lo$1);
			class uo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
					const l$1 = this.length;
					return this.resize(l$1 + 1), this.emplace(l$1, t$1, e$1, r$1, n$1, i$1, s$1, o, a$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1) {
					const u$1 = 8 * t$1;
					return this.uint16[u$1 + 0] = e$1, this.uint16[u$1 + 1] = r$1, this.uint16[u$1 + 2] = n$1, this.uint16[u$1 + 3] = i$1, this.uint16[u$1 + 4] = s$1, this.uint16[u$1 + 5] = o, this.uint16[u$1 + 6] = a$1, this.uint16[u$1 + 7] = l$1, t$1;
				}
			}
			uo$1.prototype.bytesPerElement = 16, us$1("StructArrayLayout8ui16", uo$1);
			class co$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1) {
					const p$1 = this.length;
					return this.resize(p$1 + 1), this.emplace(p$1, t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = 12 * t$1;
					return this.int16[f$1 + 0] = e$1, this.int16[f$1 + 1] = r$1, this.int16[f$1 + 2] = n$1, this.int16[f$1 + 3] = i$1, this.uint16[f$1 + 4] = s$1, this.uint16[f$1 + 5] = o, this.uint16[f$1 + 6] = a$1, this.uint16[f$1 + 7] = l$1, this.int16[f$1 + 8] = u$1, this.int16[f$1 + 9] = c$1, this.int16[f$1 + 10] = h$1, this.int16[f$1 + 11] = p$1, t$1;
				}
			}
			co$1.prototype.bytesPerElement = 24, us$1("StructArrayLayout4i4ui4i24", co$1);
			class ho$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.float32[i$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			ho$1.prototype.bytesPerElement = 12, us$1("StructArrayLayout3f12", ho$1);
			class po$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			po$1.prototype.bytesPerElement = 4, us$1("StructArrayLayout1ul4", po$1);
			class fo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1) {
					const u$1 = this.length;
					return this.resize(u$1 + 1), this.emplace(u$1, t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1) {
					const c$1 = 10 * t$1, h$1 = 5 * t$1;
					return this.int16[c$1 + 0] = e$1, this.int16[c$1 + 1] = r$1, this.int16[c$1 + 2] = n$1, this.int16[c$1 + 3] = i$1, this.int16[c$1 + 4] = s$1, this.int16[c$1 + 5] = o, this.uint32[h$1 + 3] = a$1, this.uint16[c$1 + 8] = l$1, this.uint16[c$1 + 9] = u$1, t$1;
				}
			}
			fo$1.prototype.bytesPerElement = 20, us$1("StructArrayLayout6i1ul2ui20", fo$1);
			class yo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o = this.length;
					return this.resize(o + 1), this.emplace(o, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					const a$1 = 6 * t$1;
					return this.int16[a$1 + 0] = e$1, this.int16[a$1 + 1] = r$1, this.int16[a$1 + 2] = n$1, this.int16[a$1 + 3] = i$1, this.int16[a$1 + 4] = s$1, this.int16[a$1 + 5] = o, t$1;
				}
			}
			yo$1.prototype.bytesPerElement = 12, us$1("StructArrayLayout2i2i2i12", yo$1);
			class mo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o = 4 * t$1, a$1 = 8 * t$1;
					return this.float32[o + 0] = e$1, this.float32[o + 1] = r$1, this.float32[o + 2] = n$1, this.int16[a$1 + 6] = i$1, this.int16[a$1 + 7] = s$1, t$1;
				}
			}
			mo$1.prototype.bytesPerElement = 16, us$1("StructArrayLayout2f1f2i16", mo$1);
			class go$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o = this.length;
					return this.resize(o + 1), this.emplace(o, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					const a$1 = 16 * t$1, l$1 = 4 * t$1, u$1 = 8 * t$1;
					return this.uint8[a$1 + 0] = e$1, this.uint8[a$1 + 1] = r$1, this.float32[l$1 + 1] = n$1, this.float32[l$1 + 2] = i$1, this.int16[u$1 + 6] = s$1, this.int16[u$1 + 7] = o, t$1;
				}
			}
			go$1.prototype.bytesPerElement = 16, us$1("StructArrayLayout2ub2f2i16", go$1);
			class xo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[i$1 + 0] = e$1, this.uint16[i$1 + 1] = r$1, this.uint16[i$1 + 2] = n$1, t$1;
				}
			}
			xo$1.prototype.bytesPerElement = 6, us$1("StructArrayLayout3ui6", xo$1);
			class vo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1) {
					const g$2 = this.length;
					return this.resize(g$2 + 1), this.emplace(g$2, t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2) {
					const x$1 = 24 * t$1, v$1 = 12 * t$1, b$1 = 48 * t$1;
					return this.int16[x$1 + 0] = e$1, this.int16[x$1 + 1] = r$1, this.uint16[x$1 + 2] = n$1, this.uint16[x$1 + 3] = i$1, this.uint32[v$1 + 2] = s$1, this.uint32[v$1 + 3] = o, this.uint32[v$1 + 4] = a$1, this.uint16[x$1 + 10] = l$1, this.uint16[x$1 + 11] = u$1, this.uint16[x$1 + 12] = c$1, this.float32[v$1 + 7] = h$1, this.float32[v$1 + 8] = p$1, this.uint8[b$1 + 36] = f$1, this.uint8[b$1 + 37] = d$1, this.uint8[b$1 + 38] = y$1, this.uint32[v$1 + 10] = m$1, this.int16[x$1 + 22] = g$2, t$1;
				}
			}
			vo$1.prototype.bytesPerElement = 48, us$1("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", vo$1);
			class bo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2, x$1, v$1, b$1, w$2, _$2, A$2, S$2, k$2, E$1, T$1) {
					const I$2 = this.length;
					return this.resize(I$2 + 1), this.emplace(I$2, t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2, x$1, v$1, b$1, w$2, _$2, A$2, S$2, k$2, E$1, T$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$2, x$1, v$1, b$1, w$2, _$2, A$2, S$2, k$2, E$1, T$1, I$2) {
					const M$2 = 32 * t$1, F$2 = 16 * t$1;
					return this.int16[M$2 + 0] = e$1, this.int16[M$2 + 1] = r$1, this.int16[M$2 + 2] = n$1, this.int16[M$2 + 3] = i$1, this.int16[M$2 + 4] = s$1, this.int16[M$2 + 5] = o, this.int16[M$2 + 6] = a$1, this.int16[M$2 + 7] = l$1, this.uint16[M$2 + 8] = u$1, this.uint16[M$2 + 9] = c$1, this.uint16[M$2 + 10] = h$1, this.uint16[M$2 + 11] = p$1, this.uint16[M$2 + 12] = f$1, this.uint16[M$2 + 13] = d$1, this.uint16[M$2 + 14] = y$1, this.uint16[M$2 + 15] = m$1, this.uint16[M$2 + 16] = g$2, this.uint16[M$2 + 17] = x$1, this.uint16[M$2 + 18] = v$1, this.uint16[M$2 + 19] = b$1, this.uint16[M$2 + 20] = w$2, this.uint16[M$2 + 21] = _$2, this.uint16[M$2 + 22] = A$2, this.uint32[F$2 + 12] = S$2, this.float32[F$2 + 13] = k$2, this.float32[F$2 + 14] = E$1, this.uint16[M$2 + 30] = T$1, this.uint16[M$2 + 31] = I$2, t$1;
				}
			}
			bo$1.prototype.bytesPerElement = 64, us$1("StructArrayLayout8i15ui1ul2f2ui64", bo$1);
			class wo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.float32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			wo$1.prototype.bytesPerElement = 4, us$1("StructArrayLayout1f4", wo$1);
			class _o$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[6 * t$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			_o$1.prototype.bytesPerElement = 12, us$1("StructArrayLayout1ui2f12", _o$1);
			class Ao$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 4 * t$1;
					return this.uint32[2 * t$1 + 0] = e$1, this.uint16[i$1 + 2] = r$1, this.uint16[i$1 + 3] = n$1, t$1;
				}
			}
			Ao$1.prototype.bytesPerElement = 8, us$1("StructArrayLayout1ul2ui8", Ao$1);
			class So$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.uint16[n$1 + 0] = e$1, this.uint16[n$1 + 1] = r$1, t$1;
				}
			}
			So$1.prototype.bytesPerElement = 4, us$1("StructArrayLayout2ui4", So$1);
			class ko$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint16[1 * t$1 + 0] = e$1, t$1;
				}
			}
			ko$1.prototype.bytesPerElement = 2, us$1("StructArrayLayout1ui2", ko$1);
			class Eo$1 extends Qs$1 {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.float32[s$1 + 0] = e$1, this.float32[s$1 + 1] = r$1, this.float32[s$1 + 2] = n$1, this.float32[s$1 + 3] = i$1, t$1;
				}
			}
			Eo$1.prototype.bytesPerElement = 16, us$1("StructArrayLayout4f16", Eo$1);
			class To$1 extends Js {
				get anchorPointX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorPointY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get x1() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get y1() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get x2() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get y2() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get anchorPoint() {
					return new r(this.anchorPointX, this.anchorPointY);
				}
			}
			To$1.prototype.size = 20;
			class Io$1 extends fo$1 {
				get(t$1) {
					return new To$1(this, t$1);
				}
			}
			us$1("CollisionBoxArray", Io$1);
			class Mo$1 extends Js {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get glyphStartIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get numGlyphs() {
					return this._structArray.uint16[this._pos2 + 3];
				}
				get vertexStartIndex() {
					return this._structArray.uint32[this._pos4 + 2];
				}
				get lineStartIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get lineLength() {
					return this._structArray.uint32[this._pos4 + 4];
				}
				get segment() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get lowerSize() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get upperSize() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get lineOffsetX() {
					return this._structArray.float32[this._pos4 + 7];
				}
				get lineOffsetY() {
					return this._structArray.float32[this._pos4 + 8];
				}
				get writingMode() {
					return this._structArray.uint8[this._pos1 + 36];
				}
				get placedOrientation() {
					return this._structArray.uint8[this._pos1 + 37];
				}
				set placedOrientation(t$1) {
					this._structArray.uint8[this._pos1 + 37] = t$1;
				}
				get hidden() {
					return this._structArray.uint8[this._pos1 + 38];
				}
				set hidden(t$1) {
					this._structArray.uint8[this._pos1 + 38] = t$1;
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 10];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 10] = t$1;
				}
				get associatedIconIndex() {
					return this._structArray.int16[this._pos2 + 22];
				}
			}
			Mo$1.prototype.size = 48;
			class Fo$1 extends vo$1 {
				get(t$1) {
					return new Mo$1(this, t$1);
				}
			}
			us$1("PlacedSymbolArray", Fo$1);
			class Do$1 extends Js {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get rightJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get centerJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get leftJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get verticalPlacedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get placedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 6];
				}
				get verticalPlacedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 7];
				}
				get key() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get textBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get textBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get verticalTextBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get verticalTextBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get iconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 13];
				}
				get iconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 14];
				}
				get verticalIconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 15];
				}
				get verticalIconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 16];
				}
				get featureIndex() {
					return this._structArray.uint16[this._pos2 + 17];
				}
				get numHorizontalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get numVerticalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 19];
				}
				get numIconVertices() {
					return this._structArray.uint16[this._pos2 + 20];
				}
				get numVerticalIconVertices() {
					return this._structArray.uint16[this._pos2 + 21];
				}
				get useRuntimeCollisionCircles() {
					return this._structArray.uint16[this._pos2 + 22];
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 12];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 12] = t$1;
				}
				get textBoxScale() {
					return this._structArray.float32[this._pos4 + 13];
				}
				get collisionCircleDiameter() {
					return this._structArray.float32[this._pos4 + 14];
				}
				get textAnchorOffsetStartIndex() {
					return this._structArray.uint16[this._pos2 + 30];
				}
				get textAnchorOffsetEndIndex() {
					return this._structArray.uint16[this._pos2 + 31];
				}
			}
			Do$1.prototype.size = 64;
			class Po$1 extends bo$1 {
				get(t$1) {
					return new Do$1(this, t$1);
				}
			}
			us$1("SymbolInstanceArray", Po$1);
			class zo$1 extends wo$1 {
				getoffsetX(t$1) {
					return this.float32[1 * t$1 + 0];
				}
			}
			us$1("GlyphOffsetArray", zo$1);
			class Bo$1 extends no$1 {
				getx(t$1) {
					return this.int16[3 * t$1 + 0];
				}
				gety(t$1) {
					return this.int16[3 * t$1 + 1];
				}
				gettileUnitDistanceFromAnchor(t$1) {
					return this.int16[3 * t$1 + 2];
				}
			}
			us$1("SymbolLineVertexArray", Bo$1);
			class Vo$1 extends Js {
				get textAnchor() {
					return this._structArray.uint16[this._pos2 + 0];
				}
				get textOffset0() {
					return this._structArray.float32[this._pos4 + 1];
				}
				get textOffset1() {
					return this._structArray.float32[this._pos4 + 2];
				}
			}
			Vo$1.prototype.size = 12;
			class Co$1 extends _o$1 {
				get(t$1) {
					return new Vo$1(this, t$1);
				}
			}
			us$1("TextAnchorOffsetArray", Co$1);
			class Lo$1 extends Js {
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 0];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 3];
				}
			}
			Lo$1.prototype.size = 8;
			class Oo$1 extends Ao$1 {
				get(t$1) {
					return new Lo$1(this, t$1);
				}
			}
			us$1("FeatureIndexArray", Oo$1);
			class Ro extends ro$1 {}
			class No$1 extends ro$1 {}
			class $o$1 extends ro$1 {}
			class Uo$1 extends so$1 {}
			class qo$1 extends oo$1 {}
			class jo$1 extends ao$1 {}
			class Go$1 extends lo$1 {}
			class Xo$1 extends uo$1 {}
			class Yo$1 extends co$1 {}
			class Zo$1 extends ho$1 {}
			class Ho$1 extends po$1 {}
			class Ko$1 extends yo$1 {}
			class Wo$1 extends go$1 {}
			class Jo$1 extends xo$1 {}
			class Qo$1 extends So$1 {}
			const { members: ea$1 } = to$1([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			class ra$1 {
				constructor(t$1 = []) {
					this._forceNewSegmentOnNextPrepare = !1, this.segments = t$1;
				}
				prepareSegment(t$1, e$1, r$1, n$1) {
					const i$1 = this.segments[this.segments.length - 1];
					return t$1 > ra$1.MAX_VERTEX_ARRAY_LENGTH && j$1(`Max vertices per segment is ${ra$1.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t$1}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${ra$1.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i$1 || i$1.vertexLength + t$1 > ra$1.MAX_VERTEX_ARRAY_LENGTH || i$1.sortKey !== n$1 ? this.createNewSegment(e$1, r$1, n$1) : i$1;
				}
				createNewSegment(t$1, e$1, r$1) {
					const n$1 = {
						vertexOffset: t$1.length,
						primitiveOffset: e$1.length,
						vertexLength: 0,
						primitiveLength: 0,
						vaos: {}
					};
					return void 0 !== r$1 && (n$1.sortKey = r$1), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(n$1), n$1;
				}
				getOrCreateLatestSegment(t$1, e$1, r$1) {
					return this.prepareSegment(0, t$1, e$1, r$1);
				}
				forceNewSegmentOnNextPrepare() {
					this._forceNewSegmentOnNextPrepare = !0;
				}
				get() {
					return this.segments;
				}
				destroy() {
					for (const t$1 of this.segments) for (const e$1 in t$1.vaos) t$1.vaos[e$1].destroy();
				}
				static simpleSegment(t$1, e$1, r$1, n$1) {
					return new ra$1([{
						vertexOffset: t$1,
						primitiveOffset: e$1,
						vertexLength: r$1,
						primitiveLength: n$1,
						vaos: {},
						sortKey: 0
					}]);
				}
			}
			function na$1(t$1, e$1) {
				return 256 * (t$1 = C(Math.floor(t$1), 0, 255)) + C(Math.floor(e$1), 0, 255);
			}
			ra$1.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, us$1("SegmentVector", ra$1);
			const ia$1 = to$1([
				{
					name: "a_pattern_from",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pattern_to",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_from",
					components: 1,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_to",
					components: 1,
					type: "Uint16"
				}
			]), sa$1 = to$1([{
				name: "a_dasharray_from",
				components: 4,
				type: "Uint16"
			}, {
				name: "a_dasharray_to",
				components: 4,
				type: "Uint16"
			}]);
			var oa$1, aa$1, la$1, ua$1 = { exports: {} }, ca$1 = { exports: {} }, ha$1 = { exports: {} }, fa$1 = n(function() {
				if (la$1) return ua$1.exports;
				la$1 = 1;
				var t$1 = (oa$1 || (oa$1 = 1, ca$1.exports = function(t$2, e$2) {
					var r$1, n$1, i$1, s$1, o, a$1, l$1, u$1;
					for (n$1 = t$2.length - (r$1 = 3 & t$2.length), i$1 = e$2, o = 3432918353, a$1 = 461845907, u$1 = 0; u$1 < n$1;) l$1 = 255 & t$2.charCodeAt(u$1) | (255 & t$2.charCodeAt(++u$1)) << 8 | (255 & t$2.charCodeAt(++u$1)) << 16 | (255 & t$2.charCodeAt(++u$1)) << 24, ++u$1, i$1 = 27492 + (65535 & (s$1 = 5 * (65535 & (i$1 = (i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & l$1) * o + (((l$1 >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * a$1 + (((l$1 >>> 16) * a$1 & 65535) << 16) & 4294967295) << 13 | i$1 >>> 19)) + ((5 * (i$1 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s$1 >>> 16) & 65535) << 16);
					switch (l$1 = 0, r$1) {
						case 3: l$1 ^= (255 & t$2.charCodeAt(u$1 + 2)) << 16;
						case 2: l$1 ^= (255 & t$2.charCodeAt(u$1 + 1)) << 8;
						case 1: i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & (l$1 ^= 255 & t$2.charCodeAt(u$1))) * o + (((l$1 >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * a$1 + (((l$1 >>> 16) * a$1 & 65535) << 16) & 4294967295;
					}
					return i$1 ^= t$2.length, i$1 = 2246822507 * (65535 & (i$1 ^= i$1 >>> 16)) + ((2246822507 * (i$1 >>> 16) & 65535) << 16) & 4294967295, i$1 = 3266489909 * (65535 & (i$1 ^= i$1 >>> 13)) + ((3266489909 * (i$1 >>> 16) & 65535) << 16) & 4294967295, (i$1 ^= i$1 >>> 16) >>> 0;
				}), ca$1.exports), e$1 = (aa$1 || (aa$1 = 1, ha$1.exports = function(t$2, e$2) {
					for (var r$1, n$1 = t$2.length, i$1 = e$2 ^ n$1, s$1 = 0; n$1 >= 4;) r$1 = 1540483477 * (65535 & (r$1 = 255 & t$2.charCodeAt(s$1) | (255 & t$2.charCodeAt(++s$1)) << 8 | (255 & t$2.charCodeAt(++s$1)) << 16 | (255 & t$2.charCodeAt(++s$1)) << 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16), i$1 = 1540483477 * (65535 & i$1) + ((1540483477 * (i$1 >>> 16) & 65535) << 16) ^ (r$1 = 1540483477 * (65535 & (r$1 ^= r$1 >>> 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16)), n$1 -= 4, ++s$1;
					switch (n$1) {
						case 3: i$1 ^= (255 & t$2.charCodeAt(s$1 + 2)) << 16;
						case 2: i$1 ^= (255 & t$2.charCodeAt(s$1 + 1)) << 8;
						case 1: i$1 = 1540483477 * (65535 & (i$1 ^= 255 & t$2.charCodeAt(s$1))) + ((1540483477 * (i$1 >>> 16) & 65535) << 16);
					}
					return i$1 = 1540483477 * (65535 & (i$1 ^= i$1 >>> 13)) + ((1540483477 * (i$1 >>> 16) & 65535) << 16), (i$1 ^= i$1 >>> 15) >>> 0;
				}), ha$1.exports);
				return ua$1.exports = t$1, ua$1.exports.murmur3 = t$1, ua$1.exports.murmur2 = e$1, ua$1.exports;
			}());
			class da$1 {
				constructor() {
					this.ids = [], this.positions = [], this.indexed = !1;
				}
				add(t$1, e$1, r$1, n$1) {
					this.ids.push(ya$1(t$1)), this.positions.push(e$1, r$1, n$1);
				}
				getPositions(t$1) {
					if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
					const e$1 = ya$1(t$1);
					let r$1 = 0, n$1 = this.ids.length - 1;
					for (; r$1 < n$1;) {
						const t$2 = r$1 + n$1 >> 1;
						this.ids[t$2] >= e$1 ? n$1 = t$2 : r$1 = t$2 + 1;
					}
					const i$1 = [];
					for (; this.ids[r$1] === e$1;) i$1.push({
						index: this.positions[3 * r$1],
						start: this.positions[3 * r$1 + 1],
						end: this.positions[3 * r$1 + 2]
					}), r$1++;
					return i$1;
				}
				static serialize(t$1, e$1) {
					const r$1 = new Float64Array(t$1.ids), n$1 = new Uint32Array(t$1.positions);
					return ma$1(r$1, n$1, 0, r$1.length - 1), e$1 && e$1.push(r$1.buffer, n$1.buffer), {
						ids: r$1,
						positions: n$1
					};
				}
				static deserialize(t$1) {
					const e$1 = new da$1();
					return e$1.ids = t$1.ids, e$1.positions = t$1.positions, e$1.indexed = !0, e$1;
				}
			}
			function ya$1(t$1) {
				const e$1 = +t$1;
				return !isNaN(e$1) && e$1 <= Number.MAX_SAFE_INTEGER ? e$1 : fa$1(String(t$1));
			}
			function ma$1(t$1, e$1, r$1, n$1) {
				for (; r$1 < n$1;) {
					const i$1 = t$1[r$1 + n$1 >> 1];
					let s$1 = r$1 - 1, o = n$1 + 1;
					for (;;) {
						do
							s$1++;
						while (t$1[s$1] < i$1);
						do
							o--;
						while (t$1[o] > i$1);
						if (s$1 >= o) break;
						ga$1(t$1, s$1, o), ga$1(e$1, 3 * s$1, 3 * o), ga$1(e$1, 3 * s$1 + 1, 3 * o + 1), ga$1(e$1, 3 * s$1 + 2, 3 * o + 2);
					}
					o - r$1 < n$1 - o ? (ma$1(t$1, e$1, r$1, o), r$1 = o + 1) : (ma$1(t$1, e$1, o + 1, n$1), n$1 = o);
				}
			}
			function ga$1(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			us$1("FeaturePositionMap", da$1);
			class xa$1 {
				constructor(t$1, e$1) {
					this.gl = t$1.gl, this.location = e$1;
				}
			}
			class va$1 extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1f(this.location, t$1));
				}
			}
			class ba$1 extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] && t$1[3] === this.current[3] || (this.current = t$1, this.gl.uniform4f(this.location, t$1[0], t$1[1], t$1[2], t$1[3]));
				}
			}
			class wa$1 extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = Te$1.transparent;
				}
				set(t$1) {
					t$1.r === this.current.r && t$1.g === this.current.g && t$1.b === this.current.b && t$1.a === this.current.a || (this.current = t$1, this.gl.uniform4f(this.location, t$1.r, t$1.g, t$1.b, t$1.a));
				}
			}
			const _a$1 = new Float32Array(16);
			function Aa$1(t$1) {
				return [na$1(255 * t$1.r, 255 * t$1.g), na$1(255 * t$1.b, 255 * t$1.a)];
			}
			class Sa$1 {
				constructor(t$1, e$1, r$1) {
					this.value = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.type = r$1;
				}
				setUniform(t$1, e$1, r$1) {
					t$1.set(r$1.constantOr(this.value));
				}
				getBinding(t$1, e$1, r$1) {
					return "color" === this.type ? new wa$1(t$1, e$1) : new va$1(t$1, e$1);
				}
			}
			class ka$1 {
				constructor(t$1, e$1) {
					this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
				}
				setConstantPatternPositions(t$1, e$1) {
					this.pixelRatioFrom = e$1.pixelRatio, this.pixelRatioTo = t$1.pixelRatio, this.patternFrom = e$1.tlbr, this.patternTo = t$1.tlbr;
				}
				setConstantDashPositions(t$1, e$1) {
					this.dashTo = [
						0,
						t$1.y,
						t$1.height,
						t$1.width
					], this.dashFrom = [
						0,
						e$1.y,
						e$1.height,
						e$1.width
					];
				}
				setUniform(t$1, e$1, r$1, n$1) {
					let i$1 = null;
					"u_pattern_to" === n$1 ? i$1 = this.patternTo : "u_pattern_from" === n$1 ? i$1 = this.patternFrom : "u_dasharray_to" === n$1 ? i$1 = this.dashTo : "u_dasharray_from" === n$1 ? i$1 = this.dashFrom : "u_pixel_ratio_to" === n$1 ? i$1 = this.pixelRatioTo : "u_pixel_ratio_from" === n$1 && (i$1 = this.pixelRatioFrom), null !== i$1 && t$1.set(i$1);
				}
				getBinding(t$1, e$1, r$1) {
					return "u_pattern" === r$1.substr(0, 9) || "u_dasharray_" === r$1.substr(0, 12) ? new ba$1(t$1, e$1) : new va$1(t$1, e$1);
				}
			}
			class Ea$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.expression = t$1, this.type = r$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 2 : 1,
						offset: 0
					}))), this.paintVertexArray = new n$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.paintVertexArray.length, i$1 = this.expression.evaluate(new Fs$1(0, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection);
					this.paintVertexArray.resize(t$1), this._setPaintValue(n$1, t$1, i$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.expression.evaluate(new Fs$1(0, i$1), r$1, n$1);
					this._setPaintValue(t$1, e$1, s$1);
				}
				_setPaintValue(t$1, e$1, r$1) {
					if ("color" === this.type) {
						const n$1 = Aa$1(r$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, n$1[0], n$1[1]);
					} else {
						for (let n$1 = t$1; n$1 < e$1; n$1++) this.paintVertexArray.emplace(n$1, r$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
			}
			class Ta$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}_t`)), this.type = r$1, this.useIntegerZoom = n$1, this.zoom = i$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 4 : 2,
						offset: 0
					}))), this.paintVertexArray = new s$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.expression.evaluate(new Fs$1(this.zoom, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection), i$1 = this.expression.evaluate(new Fs$1(this.zoom + 1, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection), s$1 = this.paintVertexArray.length;
					this.paintVertexArray.resize(t$1), this._setPaintValue(s$1, t$1, n$1, i$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.expression.evaluate(new Fs$1(this.zoom, i$1), r$1, n$1), o = this.expression.evaluate(new Fs$1(this.zoom + 1, i$1), r$1, n$1);
					this._setPaintValue(t$1, e$1, s$1, o);
				}
				_setPaintValue(t$1, e$1, r$1, n$1) {
					if ("color" === this.type) {
						const i$1 = Aa$1(r$1), s$1 = Aa$1(n$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, i$1[0], i$1[1], s$1[0], s$1[1]);
					} else {
						for (let i$1 = t$1; i$1 < e$1; i$1++) this.paintVertexArray.emplace(i$1, r$1, n$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1), Math.abs(n$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
				setUniform(t$1, e$1) {
					const r$1 = this.useIntegerZoom ? Math.floor(e$1.zoom) : e$1.zoom, n$1 = C(this.expression.interpolationFactor(r$1, this.zoom, this.zoom + 1), 0, 1);
					t$1.set(n$1);
				}
				getBinding(t$1, e$1, r$1) {
					return new va$1(t$1, e$1);
				}
			}
			class Ia$1 {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.type = e$1, this.useIntegerZoom = r$1, this.zoom = n$1, this.layerId = s$1, this.zoomInPaintVertexArray = new i$1(), this.zoomOutPaintVertexArray = new i$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.zoomInPaintVertexArray.length;
					this.zoomInPaintVertexArray.resize(t$1), this.zoomOutPaintVertexArray.resize(t$1), this._setPaintValues(n$1, t$1, this.getPositionIds(e$1), r$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					this._setPaintValues(t$1, e$1, this.getPositionIds(r$1), i$1);
				}
				_setPaintValues(t$1, e$1, r$1, n$1) {
					const i$1 = this.getPositions(n$1);
					if (!i$1 || !r$1) return;
					const s$1 = i$1[r$1.min], o = i$1[r$1.mid], a$1 = i$1[r$1.max];
					if (s$1 && o && a$1) for (let r$2 = t$1; r$2 < e$1; r$2++) this.emplace(this.zoomInPaintVertexArray, r$2, o, s$1), this.emplace(this.zoomOutPaintVertexArray, r$2, o, a$1);
				}
				upload(t$1) {
					if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
						const e$1 = this.getVertexAttributes();
						this.zoomInPaintVertexBuffer = t$1.createVertexBuffer(this.zoomInPaintVertexArray, e$1, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t$1.createVertexBuffer(this.zoomOutPaintVertexArray, e$1, this.expression.isStateDependent);
					}
				}
				destroy() {
					this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
				}
			}
			class Ma$1 extends Ia$1 {
				getPositions(t$1) {
					return t$1.imagePositions;
				}
				getPositionIds(t$1) {
					return t$1.patterns && t$1.patterns[this.layerId];
				}
				getVertexAttributes() {
					return ia$1.members;
				}
				emplace(t$1, e$1, r$1, n$1) {
					t$1.emplace(e$1, r$1.tlbr[0], r$1.tlbr[1], r$1.tlbr[2], r$1.tlbr[3], n$1.tlbr[0], n$1.tlbr[1], n$1.tlbr[2], n$1.tlbr[3], r$1.pixelRatio, n$1.pixelRatio);
				}
			}
			class Fa$1 extends Ia$1 {
				getPositions(t$1) {
					return t$1.dashPositions;
				}
				getPositionIds(t$1) {
					return t$1.dashes && t$1.dashes[this.layerId];
				}
				getVertexAttributes() {
					return sa$1.members;
				}
				emplace(t$1, e$1, r$1, n$1) {
					t$1.emplace(e$1, 0, r$1.y, r$1.height, r$1.width, 0, n$1.y, n$1.height, n$1.width);
				}
			}
			class Da$1 {
				constructor(t$1, e$1, r$1) {
					this.binders = {}, this._buffers = [];
					const n$1 = [];
					for (const i$1 in t$1.paint._values) {
						if (!r$1(i$1)) continue;
						const s$1 = t$1.paint.get(i$1);
						if (!(s$1 instanceof Rs$1 && qn$1(s$1.property.specification))) continue;
						const o = za$1(i$1, t$1.type), a$1 = s$1.value, l$1 = s$1.property.specification.type, u$1 = s$1.property.useIntegerZoom, c$1 = s$1.property.specification["property-type"], h$1 = "cross-faded" === c$1 || "cross-faded-data-driven" === c$1;
						if ("constant" === a$1.kind) this.binders[i$1] = h$1 ? new ka$1(a$1.value, o) : new Sa$1(a$1.value, o, l$1), n$1.push(`/u_${i$1}`);
						else if ("source" === a$1.kind || h$1) {
							const r$2 = Ba$1(i$1, l$1, "source");
							this.binders[i$1] = h$1 ? "line-dasharray" === i$1 ? new Fa$1(a$1, l$1, u$1, e$1, r$2, t$1.id) : new Ma$1(a$1, l$1, u$1, e$1, r$2, t$1.id) : new Ea$1(a$1, o, l$1, r$2), n$1.push(`/a_${i$1}`);
						} else {
							const t$2 = Ba$1(i$1, l$1, "composite");
							this.binders[i$1] = new Ta$1(a$1, o, l$1, u$1, e$1, t$2), n$1.push(`/z_${i$1}`);
						}
					}
					this.cacheKey = n$1.sort().join("");
				}
				getMaxValue(t$1) {
					const e$1 = this.binders[t$1];
					return e$1 instanceof Ea$1 || e$1 instanceof Ta$1 ? e$1.maxValue : 0;
				}
				populatePaintArrays(t$1, e$1, r$1) {
					for (const n$1 in this.binders) {
						const i$1 = this.binders[n$1];
						(i$1 instanceof Ea$1 || i$1 instanceof Ta$1 || i$1 instanceof Ia$1) && i$1.populatePaintArray(t$1, e$1, r$1);
					}
				}
				setConstantPatternPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof ka$1 && n$1.setConstantPatternPositions(t$1, e$1);
					}
				}
				setConstantDashPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof ka$1 && n$1.setConstantDashPositions(t$1, e$1);
					}
				}
				updatePaintArrays(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = !1;
					for (const o in t$1) {
						const a$1 = e$1.getPositions(o);
						for (const e$2 of a$1) {
							const a$2 = r$1.feature(e$2.index);
							for (const r$2 in this.binders) {
								const l$1 = this.binders[r$2];
								if ((l$1 instanceof Ea$1 || l$1 instanceof Ta$1 || l$1 instanceof Ia$1) && !0 === l$1.expression.isStateDependent) l$1.expression = n$1.paint.get(r$2).value, l$1.updatePaintArray(e$2.start, e$2.end, a$2, t$1[o], i$1), s$1 = !0;
							}
						}
					}
					return s$1;
				}
				defines() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof Sa$1 || r$1 instanceof ka$1) && t$1.push(...r$1.uniformNames.map(((t$2) => `#define HAS_UNIFORM_${t$2}`)));
					}
					return t$1;
				}
				getBinderAttributes() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof Ea$1 || r$1 instanceof Ta$1) for (let e$2 = 0; e$2 < r$1.paintVertexAttributes.length; e$2++) t$1.push(r$1.paintVertexAttributes[e$2].name);
						else if (r$1 instanceof Ia$1) {
							const e$2 = r$1.getVertexAttributes();
							for (const r$2 of e$2) t$1.push(r$2.name);
						}
					}
					return t$1;
				}
				getBinderUniforms() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof Sa$1 || r$1 instanceof ka$1 || r$1 instanceof Ta$1) for (const e$2 of r$1.uniformNames) t$1.push(e$2);
					}
					return t$1;
				}
				getPaintVertexBuffers() {
					return this._buffers;
				}
				getUniforms(t$1, e$1) {
					const r$1 = [];
					for (const n$1 in this.binders) {
						const i$1 = this.binders[n$1];
						if (i$1 instanceof Sa$1 || i$1 instanceof ka$1 || i$1 instanceof Ta$1) {
							for (const s$1 of i$1.uniformNames) if (e$1[s$1]) {
								const o = i$1.getBinding(t$1, e$1[s$1], s$1);
								r$1.push({
									name: s$1,
									property: n$1,
									binding: o
								});
							}
						}
					}
					return r$1;
				}
				setUniforms(t$1, e$1, r$1, n$1) {
					for (const { name: t$2, property: i$1, binding: s$1 } of e$1) this.binders[i$1].setUniform(s$1, n$1, r$1.get(i$1), t$2);
				}
				updatePaintBuffers(t$1) {
					this._buffers = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (t$1 && r$1 instanceof Ia$1) {
							const e$2 = 2 === t$1.fromScale ? r$1.zoomInPaintVertexBuffer : r$1.zoomOutPaintVertexBuffer;
							e$2 && this._buffers.push(e$2);
						} else (r$1 instanceof Ea$1 || r$1 instanceof Ta$1) && r$1.paintVertexBuffer && this._buffers.push(r$1.paintVertexBuffer);
					}
				}
				upload(t$1) {
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof Ea$1 || r$1 instanceof Ta$1 || r$1 instanceof Ia$1) && r$1.upload(t$1);
					}
					this.updatePaintBuffers();
				}
				destroy() {
					for (const t$1 in this.binders) {
						const e$1 = this.binders[t$1];
						(e$1 instanceof Ea$1 || e$1 instanceof Ta$1 || e$1 instanceof Ia$1) && e$1.destroy();
					}
				}
			}
			class Pa$1 {
				constructor(t$1, e$1, r$1 = () => !0) {
					this.programConfigurations = {};
					for (const n$1 of t$1) this.programConfigurations[n$1.id] = new Da$1(n$1, e$1, r$1);
					this.needsUpload = !1, this._featureMap = new da$1(), this._bufferOffset = 0;
				}
				populatePaintArrays(t$1, e$1, r$1, n$1) {
					for (const r$2 in this.programConfigurations) this.programConfigurations[r$2].populatePaintArrays(t$1, e$1, n$1);
					void 0 !== e$1.id && this._featureMap.add(e$1.id, r$1, this._bufferOffset, t$1), this._bufferOffset = t$1, this.needsUpload = !0;
				}
				updatePaintArrays(t$1, e$1, r$1, n$1) {
					for (const i$1 of r$1) this.needsUpload = this.programConfigurations[i$1.id].updatePaintArrays(t$1, this._featureMap, e$1, i$1, n$1) || this.needsUpload;
				}
				get(t$1) {
					return this.programConfigurations[t$1];
				}
				upload(t$1) {
					if (this.needsUpload) {
						for (const e$1 in this.programConfigurations) this.programConfigurations[e$1].upload(t$1);
						this.needsUpload = !1;
					}
				}
				destroy() {
					for (const t$1 in this.programConfigurations) this.programConfigurations[t$1].destroy();
				}
			}
			function za$1(t$1, e$1) {
				return {
					"text-opacity": ["opacity"],
					"icon-opacity": ["opacity"],
					"text-color": ["fill_color"],
					"icon-color": ["fill_color"],
					"text-halo-color": ["halo_color"],
					"icon-halo-color": ["halo_color"],
					"text-halo-blur": ["halo_blur"],
					"icon-halo-blur": ["halo_blur"],
					"text-halo-width": ["halo_width"],
					"icon-halo-width": ["halo_width"],
					"line-gap-width": ["gapwidth"],
					"line-dasharray": ["dasharray_to", "dasharray_from"],
					"line-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-extrusion-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					]
				}[t$1] || [t$1.replace(`${e$1}-`, "").replace(/-/g, "_")];
			}
			function Ba$1(t$1, e$1, r$1) {
				const n$1 = {
					color: {
						source: ao$1,
						composite: Eo$1
					},
					number: {
						source: wo$1,
						composite: ao$1
					}
				}, i$1 = function(t$2) {
					return {
						"line-pattern": {
							source: Go$1,
							composite: Go$1
						},
						"fill-pattern": {
							source: Go$1,
							composite: Go$1
						},
						"fill-extrusion-pattern": {
							source: Go$1,
							composite: Go$1
						},
						"line-dasharray": {
							source: Xo$1,
							composite: Xo$1
						}
					}[t$2];
				}(t$1);
				return i$1 && i$1[r$1] || n$1[e$1][r$1];
			}
			us$1("ConstantBinder", Sa$1), us$1("CrossFadedConstantBinder", ka$1), us$1("SourceExpressionBinder", Ea$1), us$1("CrossFadedPatternBinder", Ma$1), us$1("CrossFadedDasharrayBinder", Fa$1), us$1("CompositeExpressionBinder", Ta$1), us$1("ProgramConfiguration", Da$1, { omit: ["_buffers"] }), us$1("ProgramConfigurationSet", Pa$1);
			const Va$1 = Math.pow(2, 14) - 1, Ca$1 = -Va$1 - 1;
			function La$1(t$1) {
				const e$1 = M$1 / t$1.extent, r$1 = t$1.loadGeometry();
				for (let t$2 = 0; t$2 < r$1.length; t$2++) {
					const n$1 = r$1[t$2];
					for (let t$3 = 0; t$3 < n$1.length; t$3++) {
						const r$2 = n$1[t$3], i$1 = Math.round(r$2.x * e$1), s$1 = Math.round(r$2.y * e$1);
						r$2.x = C(i$1, Ca$1, Va$1), r$2.y = C(s$1, Ca$1, Va$1), (i$1 < r$2.x || i$1 > r$2.x + 1 || s$1 < r$2.y || s$1 > r$2.y + 1) && j$1("Geometry exceeds allowed extent, reduce your vector tile buffer size");
					}
				}
				return r$1;
			}
			function Oa$1(t$1, e$1) {
				return {
					type: t$1.type,
					id: t$1.id,
					properties: t$1.properties,
					geometry: e$1 ? La$1(t$1) : []
				};
			}
			const Ra$1 = -32768;
			function Na$1(t$1, e$1, r$1, n$1, i$1) {
				t$1.emplaceBack(Ra$1 + 8 * e$1 + n$1, Ra$1 + 8 * r$1 + i$1);
			}
			class $a$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.layoutVertexArray = new No$1(), this.indexArray = new Jo$1(), this.segments = new ra$1(), this.programConfigurations = new Pa$1(t$1.layers, t$1.zoom), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					const n$1 = this.layers[0], i$1 = [];
					let s$1 = null, o = !1, a$1 = "heatmap" === n$1.type;
					if ("circle" === n$1.type) {
						const t$2 = n$1;
						s$1 = t$2.layout.get("circle-sort-key"), o = !s$1.isConstant(), a$1 = a$1 || "map" === t$2.paint.get("circle-pitch-alignment");
					}
					const l$1 = a$1 ? e$1.subdivisionGranularity.circle : 1;
					for (const { feature: e$2, id: n$2, index: a$2, sourceLayerIndex: l$2 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = Oa$1(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Fs$1(this.zoom), u$1, r$1)) continue;
						const c$1 = o ? s$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: n$2,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$2,
							index: a$2,
							geometry: t$2 ? u$1.geometry : La$1(e$2),
							patterns: {},
							sortKey: c$1
						};
						i$1.push(h$1);
					}
					o && i$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of i$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: o$1 } = n$2, a$2 = t$1[s$2].feature;
						this.addFeature(n$2, i$2, s$2, r$1, l$1), e$1.featureIndex.insert(a$2, i$2, s$2, o$1, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, ea$1), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1 = 1) {
					let s$1;
					switch (i$1) {
						case 1:
							s$1 = [0, 7];
							break;
						case 3:
							s$1 = [
								0,
								2,
								5,
								7
							];
							break;
						case 5:
							s$1 = [
								0,
								1,
								3,
								4,
								6,
								7
							];
							break;
						case 7:
							s$1 = [
								0,
								1,
								2,
								3,
								4,
								5,
								6,
								7
							];
							break;
						default: throw new Error(`Invalid circle bucket granularity: ${i$1}; valid values are 1, 3, 5, 7.`);
					}
					const o = s$1.length;
					for (const r$2 of e$1) for (const e$2 of r$2) {
						const r$3 = e$2.x, n$2 = e$2.y;
						if (r$3 < 0 || r$3 >= M$1 || n$2 < 0 || n$2 >= M$1) continue;
						const i$2 = this.segments.prepareSegment(o * o, this.layoutVertexArray, this.indexArray, t$1.sortKey), a$1 = i$2.vertexLength;
						for (let t$2 = 0; t$2 < o; t$2++) for (let e$3 = 0; e$3 < o; e$3++) Na$1(this.layoutVertexArray, r$3, n$2, s$1[e$3], s$1[t$2]);
						for (let t$2 = 0; t$2 < o - 1; t$2++) for (let e$3 = 0; e$3 < o - 1; e$3++) {
							const r$4 = a$1 + t$2 * o + e$3, n$3 = a$1 + (t$2 + 1) * o + e$3;
							this.indexArray.emplaceBack(r$4, n$3 + 1, r$4 + 1), this.indexArray.emplaceBack(r$4, n$3, n$3 + 1);
						}
						i$2.vertexLength += o * o, i$2.primitiveLength += (o - 1) * (o - 1) * 2;
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: {},
						canonical: n$1
					});
				}
			}
			function Ua$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (Wa$1(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (Wa$1(t$1, e$1[r$1])) return !0;
				return !!Xa$1(t$1, e$1);
			}
			function qa$1(t$1, e$1, r$1) {
				return !!Wa$1(t$1, e$1) || !!Za$1(e$1, t$1, r$1);
			}
			function ja$1(t$1, e$1) {
				if (1 === t$1.length) return Ka$1(e$1, t$1[0]);
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					for (let e$2 = 0; e$2 < n$1.length; e$2++) if (Wa$1(t$1, n$1[e$2])) return !0;
				}
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (Ka$1(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (Xa$1(t$1, e$1[r$1])) return !0;
				return !1;
			}
			function Ga$1(t$1, e$1, r$1) {
				if (t$1.length > 1) {
					if (Xa$1(t$1, e$1)) return !0;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (Za$1(e$1[n$1], t$1, r$1)) return !0;
				}
				for (let n$1 = 0; n$1 < t$1.length; n$1++) if (Za$1(t$1[n$1], e$1, r$1)) return !0;
				return !1;
			}
			function Xa$1(t$1, e$1) {
				if (0 === t$1.length || 0 === e$1.length) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) {
					const n$1 = t$1[r$1], i$1 = t$1[r$1 + 1];
					for (let t$2 = 0; t$2 < e$1.length - 1; t$2++) if (Ya$1(n$1, i$1, e$1[t$2], e$1[t$2 + 1])) return !0;
				}
				return !1;
			}
			function Ya$1(t$1, e$1, r$1, n$1) {
				return G$1(t$1, r$1, n$1) !== G$1(e$1, r$1, n$1) && G$1(t$1, e$1, r$1) !== G$1(t$1, e$1, n$1);
			}
			function Za$1(t$1, e$1, r$1) {
				const n$1 = r$1 * r$1;
				if (1 === e$1.length) return t$1.distSqr(e$1[0]) < n$1;
				for (let r$2 = 1; r$2 < e$1.length; r$2++) if (Ha$1(t$1, e$1[r$2 - 1], e$1[r$2]) < n$1) return !0;
				return !1;
			}
			function Ha$1(t$1, e$1, r$1) {
				const n$1 = e$1.distSqr(r$1);
				if (0 === n$1) return t$1.distSqr(e$1);
				const i$1 = ((t$1.x - e$1.x) * (r$1.x - e$1.x) + (t$1.y - e$1.y) * (r$1.y - e$1.y)) / n$1;
				return t$1.distSqr(i$1 < 0 ? e$1 : i$1 > 1 ? r$1 : r$1.sub(e$1)._mult(i$1)._add(e$1));
			}
			function Ka$1(t$1, e$1) {
				let r$1, n$1, i$1, s$1 = !1;
				for (let o = 0; o < t$1.length; o++) {
					r$1 = t$1[o];
					for (let t$2 = 0, o$1 = r$1.length - 1; t$2 < r$1.length; o$1 = t$2++) n$1 = r$1[t$2], i$1 = r$1[o$1], n$1.y > e$1.y != i$1.y > e$1.y && e$1.x < (i$1.x - n$1.x) * (e$1.y - n$1.y) / (i$1.y - n$1.y) + n$1.x && (s$1 = !s$1);
				}
				return s$1;
			}
			function Wa$1(t$1, e$1) {
				let r$1 = !1;
				for (let n$1 = 0, i$1 = t$1.length - 1; n$1 < t$1.length; i$1 = n$1++) {
					const s$1 = t$1[n$1], o = t$1[i$1];
					s$1.y > e$1.y != o.y > e$1.y && e$1.x < (o.x - s$1.x) * (e$1.y - s$1.y) / (o.y - s$1.y) + s$1.x && (r$1 = !r$1);
				}
				return r$1;
			}
			function Ja$1(t$1, e$1, r$1) {
				const n$1 = r$1[0], i$1 = r$1[2];
				if (t$1.x < n$1.x && e$1.x < n$1.x || t$1.x > i$1.x && e$1.x > i$1.x || t$1.y < n$1.y && e$1.y < n$1.y || t$1.y > i$1.y && e$1.y > i$1.y) return !1;
				const s$1 = G$1(t$1, e$1, r$1[0]);
				return s$1 !== G$1(t$1, e$1, r$1[1]) || s$1 !== G$1(t$1, e$1, r$1[2]) || s$1 !== G$1(t$1, e$1, r$1[3]);
			}
			function Qa(t$1, e$1, r$1) {
				const n$1 = e$1.paint.get(t$1).value;
				return "constant" === n$1.kind ? n$1.value : r$1.programConfigurations.get(e$1.id).getMaxValue(t$1);
			}
			function tl$1(t$1) {
				return Math.sqrt(t$1[0] * t$1[0] + t$1[1] * t$1[1]);
			}
			function el$1(t$1, e$1, n$1, i$1, s$1) {
				if (!e$1[0] && !e$1[1]) return t$1;
				const o = r.convert(e$1)._mult(s$1);
				"viewport" === n$1 && o._rotate(-i$1);
				const a$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2++) a$1.push(t$1[e$2].sub(o));
				return a$1;
			}
			function rl$1(t$1) {
				const e$1 = [];
				for (let r$1 = 0; r$1 < t$1.length; r$1++) {
					const n$1 = t$1[r$1], i$1 = e$1.at(-1);
					(0 === r$1 || i$1 && !n$1.equals(i$1)) && e$1.push(n$1);
				}
				return e$1;
			}
			function nl$1({ queryGeometry: t$1, size: e$1 }, r$1) {
				return qa$1(t$1, r$1, e$1);
			}
			function il$1({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				return qa$1(t$1, s$1, e$1 * (r$1.projectTileCoordinates(s$1.x, s$1.y, n$1, i$1).signedDistanceFromCamera / r$1.cameraToCenterDistance));
			}
			function sl$1({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				const o = r$1.projectTileCoordinates(s$1.x, s$1.y, n$1, i$1).signedDistanceFromCamera, a$1 = e$1 * (r$1.cameraToCenterDistance / o);
				return qa$1(t$1, ll$1(s$1, r$1, n$1, i$1), a$1);
			}
			function ol$1({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				return qa$1(t$1, ll$1(s$1, r$1, n$1, i$1), e$1);
			}
			function al$1({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1, pitchAlignment: s$1 = "map", pitchScale: o = "map" }, a$1) {
				const l$1 = "map" === s$1 ? "map" === o ? nl$1 : il$1 : "map" === o ? sl$1 : ol$1, u$1 = {
					queryGeometry: t$1,
					size: e$1,
					transform: r$1,
					unwrappedTileID: n$1,
					getElevation: i$1
				};
				for (const t$2 of a$1) for (const e$2 of t$2) if (l$1(u$1, e$2)) return !0;
				return !1;
			}
			function ll$1(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.projectTileCoordinates(t$1.x, t$1.y, n$1, i$1).point;
				return new r((.5 * s$1.x + .5) * e$1.width, (.5 * -s$1.y + .5) * e$1.height);
			}
			let ul$1, cl$1;
			us$1("CircleBucket", $a$1, { omit: ["layers"] });
			var hl$1 = {
				get paint() {
					return cl$1 = cl$1 || new Xs$1({
						"circle-radius": new Us$1(vt$1.paint_circle["circle-radius"]),
						"circle-color": new Us$1(vt$1.paint_circle["circle-color"]),
						"circle-blur": new Us$1(vt$1.paint_circle["circle-blur"]),
						"circle-opacity": new Us$1(vt$1.paint_circle["circle-opacity"]),
						"circle-translate": new $s$1(vt$1.paint_circle["circle-translate"]),
						"circle-translate-anchor": new $s$1(vt$1.paint_circle["circle-translate-anchor"]),
						"circle-pitch-scale": new $s$1(vt$1.paint_circle["circle-pitch-scale"]),
						"circle-pitch-alignment": new $s$1(vt$1.paint_circle["circle-pitch-alignment"]),
						"circle-stroke-width": new Us$1(vt$1.paint_circle["circle-stroke-width"]),
						"circle-stroke-color": new Us$1(vt$1.paint_circle["circle-stroke-color"]),
						"circle-stroke-opacity": new Us$1(vt$1.paint_circle["circle-stroke-opacity"])
					});
				},
				get layout() {
					return ul$1 = ul$1 || new Xs$1({ "circle-sort-key": new Us$1(vt$1.layout_circle["circle-sort-key"]) });
				}
			};
			class pl$1 extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, hl$1, e$1);
				}
				createBucket(t$1) {
					return new $a$1(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1;
					return Qa("circle-radius", this, e$1) + Qa("circle-stroke-width", this, e$1) + tl$1(this.paint.get("circle-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: r$1, geometry: n$1, transform: i$1, pixelsToTileUnits: s$1, unwrappedTileID: o, getElevation: a$1 }) {
					const l$1 = el$1(t$1, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i$1.bearingInRadians, s$1), u$1 = this.paint.get("circle-radius").evaluate(e$1, r$1) + this.paint.get("circle-stroke-width").evaluate(e$1, r$1), c$1 = this.paint.get("circle-pitch-scale"), h$1 = this.paint.get("circle-pitch-alignment");
					let p$1, f$1;
					return "map" === h$1 ? (p$1 = l$1, f$1 = u$1 * s$1) : (p$1 = function(t$2, e$2, r$2, n$2) {
						return t$2.map(((t$3) => ll$1(t$3, e$2, r$2, n$2)));
					}(l$1, i$1, o, a$1), f$1 = u$1), al$1({
						queryGeometry: p$1,
						size: f$1,
						transform: i$1,
						unwrappedTileID: o,
						getElevation: a$1,
						pitchAlignment: h$1,
						pitchScale: c$1
					}, n$1);
				}
			}
			class fl$1 extends $a$1 {}
			let dl$1;
			us$1("HeatmapBucket", fl$1, { omit: ["layers"] });
			var yl$1 = { get paint() {
				return dl$1 = dl$1 || new Xs$1({
					"heatmap-radius": new Us$1(vt$1.paint_heatmap["heatmap-radius"]),
					"heatmap-weight": new Us$1(vt$1.paint_heatmap["heatmap-weight"]),
					"heatmap-intensity": new $s$1(vt$1.paint_heatmap["heatmap-intensity"]),
					"heatmap-color": new Gs$1(vt$1.paint_heatmap["heatmap-color"]),
					"heatmap-opacity": new $s$1(vt$1.paint_heatmap["heatmap-opacity"])
				});
			} };
			function ml$1(t$1, { width: e$1, height: r$1 }, n$1, i$1) {
				if (i$1) {
					if (i$1 instanceof Uint8ClampedArray) i$1 = new Uint8Array(i$1.buffer);
					else if (i$1.length !== e$1 * r$1 * n$1) throw new RangeError(`mismatched image size. expected: ${i$1.length} but got: ${e$1 * r$1 * n$1}`);
				} else i$1 = new Uint8Array(e$1 * r$1 * n$1);
				return t$1.width = e$1, t$1.height = r$1, t$1.data = i$1, t$1;
			}
			function gl$1(t$1, { width: e$1, height: r$1 }, n$1) {
				if (e$1 === t$1.width && r$1 === t$1.height) return;
				const i$1 = ml$1({}, {
					width: e$1,
					height: r$1
				}, n$1);
				xl$1(t$1, i$1, {
					x: 0,
					y: 0
				}, {
					x: 0,
					y: 0
				}, {
					width: Math.min(t$1.width, e$1),
					height: Math.min(t$1.height, r$1)
				}, n$1), t$1.width = e$1, t$1.height = r$1, t$1.data = i$1.data;
			}
			function xl$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (0 === i$1.width || 0 === i$1.height) return e$1;
				if (i$1.width > t$1.width || i$1.height > t$1.height || r$1.x > t$1.width - i$1.width || r$1.y > t$1.height - i$1.height) throw new RangeError("out of range source coordinates for image copy");
				if (i$1.width > e$1.width || i$1.height > e$1.height || n$1.x > e$1.width - i$1.width || n$1.y > e$1.height - i$1.height) throw new RangeError("out of range destination coordinates for image copy");
				const o = t$1.data, a$1 = e$1.data;
				if (o === a$1) throw new Error("srcData equals dstData, so image is already copied");
				for (let l$1 = 0; l$1 < i$1.height; l$1++) {
					const u$1 = ((r$1.y + l$1) * t$1.width + r$1.x) * s$1, c$1 = ((n$1.y + l$1) * e$1.width + n$1.x) * s$1;
					for (let t$2 = 0; t$2 < i$1.width * s$1; t$2++) a$1[c$1 + t$2] = o[u$1 + t$2];
				}
				return e$1;
			}
			class vl$1 {
				constructor(t$1, e$1) {
					ml$1(this, t$1, 1, e$1);
				}
				resize(t$1) {
					gl$1(this, t$1, 1);
				}
				clone() {
					return new vl$1({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					xl$1(t$1, e$1, r$1, n$1, i$1, 1);
				}
			}
			class bl$1 {
				constructor(t$1, e$1) {
					ml$1(this, t$1, 4, e$1);
				}
				resize(t$1) {
					gl$1(this, t$1, 4);
				}
				replace(t$1, e$1) {
					e$1 ? this.data.set(t$1) : this.data = t$1 instanceof Uint8ClampedArray ? new Uint8Array(t$1.buffer) : t$1;
				}
				clone() {
					return new bl$1({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					xl$1(t$1, e$1, r$1, n$1, i$1, 4);
				}
				setPixel(t$1, e$1, r$1) {
					const n$1 = 4 * (t$1 * this.width + e$1);
					this.data[n$1 + 0] = Math.round(255 * r$1.r / r$1.a), this.data[n$1 + 1] = Math.round(255 * r$1.g / r$1.a), this.data[n$1 + 2] = Math.round(255 * r$1.b / r$1.a), this.data[n$1 + 3] = Math.round(255 * r$1.a);
				}
			}
			function wl$1(t$1) {
				const e$1 = {}, r$1 = t$1.resolution || 256, n$1 = t$1.clips ? t$1.clips.length : 1, i$1 = t$1.image || new bl$1({
					width: r$1,
					height: n$1
				});
				if (Math.log(r$1) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r$1}`);
				const s$1 = (n$2, s$2, o) => {
					e$1[t$1.evaluationKey] = o;
					const a$1 = t$1.expression.evaluate(e$1);
					i$1.setPixel(n$2 / 4 / r$1, s$2 / 4, a$1);
				};
				if (t$1.clips) for (let e$2 = 0, i$2 = 0; e$2 < n$1; ++e$2, i$2 += 4 * r$1) for (let n$2 = 0, o = 0; n$2 < r$1; n$2++, o += 4) {
					const a$1 = n$2 / (r$1 - 1), { start: l$1, end: u$1 } = t$1.clips[e$2];
					s$1(i$2, o, l$1 * (1 - a$1) + u$1 * a$1);
				}
				else for (let t$2 = 0, e$2 = 0; t$2 < r$1; t$2++, e$2 += 4) s$1(0, e$2, t$2 / (r$1 - 1));
				return i$1;
			}
			us$1("AlphaImage", vl$1), us$1("RGBAImage", bl$1);
			const _l$1 = "big-fb";
			class Al$1 extends Ys$1 {
				createBucket(t$1) {
					return new fl$1(t$1);
				}
				constructor(t$1, e$1) {
					super(t$1, yl$1, e$1), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					"heatmap-color" === t$1 && this._updateColorRamp();
				}
				_updateColorRamp() {
					this.colorRamp = wl$1({
						expression: this._transitionablePaint._values["heatmap-color"].value.expression,
						evaluationKey: "heatmapDensity",
						image: this.colorRamp
					}), this.colorRampTexture = null;
				}
				resize() {
					this.heatmapFbos.has(_l$1) && this.heatmapFbos.delete(_l$1);
				}
				queryRadius(t$1) {
					return Qa("heatmap-radius", this, t$1);
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: r$1, geometry: n$1, transform: i$1, pixelsToTileUnits: s$1, unwrappedTileID: o, getElevation: a$1 }) {
					return al$1({
						queryGeometry: t$1,
						size: this.paint.get("heatmap-radius").evaluate(e$1, r$1) * s$1,
						transform: i$1,
						unwrappedTileID: o,
						getElevation: a$1
					}, n$1);
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
				}
			}
			let Sl$1;
			var kl$1 = { get paint() {
				return Sl$1 = Sl$1 || new Xs$1({
					"hillshade-illumination-direction": new $s$1(vt$1.paint_hillshade["hillshade-illumination-direction"]),
					"hillshade-illumination-altitude": new $s$1(vt$1.paint_hillshade["hillshade-illumination-altitude"]),
					"hillshade-illumination-anchor": new $s$1(vt$1.paint_hillshade["hillshade-illumination-anchor"]),
					"hillshade-exaggeration": new $s$1(vt$1.paint_hillshade["hillshade-exaggeration"]),
					"hillshade-shadow-color": new $s$1(vt$1.paint_hillshade["hillshade-shadow-color"]),
					"hillshade-highlight-color": new $s$1(vt$1.paint_hillshade["hillshade-highlight-color"]),
					"hillshade-accent-color": new $s$1(vt$1.paint_hillshade["hillshade-accent-color"]),
					"hillshade-method": new $s$1(vt$1.paint_hillshade["hillshade-method"])
				});
			} };
			class El$1 extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, kl$1, e$1), this.recalculate({
						zoom: 0,
						zoomHistory: {}
					}, void 0);
				}
				getIlluminationProperties() {
					let t$1 = this.paint.get("hillshade-illumination-direction").values, e$1 = this.paint.get("hillshade-illumination-altitude").values, r$1 = this.paint.get("hillshade-highlight-color").values, n$1 = this.paint.get("hillshade-shadow-color").values;
					const i$1 = Math.max(t$1.length, e$1.length, r$1.length, n$1.length);
					t$1 = t$1.concat(Array(i$1 - t$1.length).fill(t$1.at(-1))), e$1 = e$1.concat(Array(i$1 - e$1.length).fill(e$1.at(-1))), r$1 = r$1.concat(Array(i$1 - r$1.length).fill(r$1.at(-1))), n$1 = n$1.concat(Array(i$1 - n$1.length).fill(n$1.at(-1)));
					const s$1 = e$1.map(tt$1);
					return {
						directionRadians: t$1.map(tt$1),
						altitudeRadians: s$1,
						shadowColor: n$1,
						highlightColor: r$1
					};
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
				}
			}
			let Tl$1;
			var Il$1 = { get paint() {
				return Tl$1 = Tl$1 || new Xs$1({
					"color-relief-opacity": new $s$1(vt$1["paint_color-relief"]["color-relief-opacity"]),
					"color-relief-color": new Gs$1(vt$1["paint_color-relief"]["color-relief-color"])
				});
			} };
			class Ml$1 {
				constructor(t$1, e$1, r$1, n$1) {
					this.context = t$1, this.format = r$1, this.texture = t$1.gl.createTexture(), this.update(e$1, n$1);
				}
				update(t$1, e$1, r$1) {
					const { width: n$1, height: i$1 } = t$1, s$1 = !(this.size && this.size[0] === n$1 && this.size[1] === i$1 || r$1), { context: o } = this, { gl: a$1 } = o;
					if (this.useMipmap = Boolean(e$1 && e$1.useMipmap), a$1.bindTexture(a$1.TEXTURE_2D, this.texture), o.pixelStoreUnpackFlipY.set(!1), o.pixelStoreUnpack.set(1), o.pixelStoreUnpackPremultiplyAlpha.set(this.format === a$1.RGBA && (!e$1 || !1 !== e$1.premultiply)), s$1) this.size = [n$1, i$1], t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Z$1(t$1) ? a$1.texImage2D(a$1.TEXTURE_2D, 0, this.format, this.format, a$1.UNSIGNED_BYTE, t$1) : a$1.texImage2D(a$1.TEXTURE_2D, 0, this.format, n$1, i$1, 0, this.format, a$1.UNSIGNED_BYTE, t$1.data);
					else {
						const { x: e$2, y: s$2 } = r$1 || {
							x: 0,
							y: 0
						};
						t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Z$1(t$1) ? a$1.texSubImage2D(a$1.TEXTURE_2D, 0, e$2, s$2, a$1.RGBA, a$1.UNSIGNED_BYTE, t$1) : a$1.texSubImage2D(a$1.TEXTURE_2D, 0, e$2, s$2, n$1, i$1, a$1.RGBA, a$1.UNSIGNED_BYTE, t$1.data);
					}
					this.useMipmap && this.isSizePowerOfTwo() && a$1.generateMipmap(a$1.TEXTURE_2D), o.pixelStoreUnpackFlipY.setDefault(), o.pixelStoreUnpack.setDefault(), o.pixelStoreUnpackPremultiplyAlpha.setDefault();
				}
				bind(t$1, e$1, r$1) {
					const { context: n$1 } = this, { gl: i$1 } = n$1;
					i$1.bindTexture(i$1.TEXTURE_2D, this.texture), r$1 !== i$1.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r$1 = i$1.LINEAR), t$1 !== this.filter && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MAG_FILTER, t$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MIN_FILTER, r$1 || t$1), this.filter = t$1), e$1 !== this.wrap && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_S, e$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_T, e$1), this.wrap = e$1);
				}
				isSizePowerOfTwo() {
					return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
				}
				destroy() {
					const { gl: t$1 } = this.context;
					t$1.deleteTexture(this.texture), this.texture = null;
				}
			}
			class Fl$1 {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = 1, s$1 = 1, o = 0) {
					if (this.uid = t$1, e$1.height !== e$1.width) throw new RangeError("DEM tiles must be square");
					if (r$1 && ![
						"mapbox",
						"terrarium",
						"custom"
					].includes(r$1)) return void j$1(`"${r$1}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
					this.stride = e$1.height;
					const a$1 = this.dim = e$1.height - 2;
					switch (this.data = new Uint32Array(e$1.data.buffer), r$1) {
						case "terrarium":
							this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
							break;
						case "custom":
							this.redFactor = n$1, this.greenFactor = i$1, this.blueFactor = s$1, this.baseShift = o;
							break;
						default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4;
					}
					for (let t$2 = 0; t$2 < a$1; t$2++) this.data[this._idx(-1, t$2)] = this.data[this._idx(0, t$2)], this.data[this._idx(a$1, t$2)] = this.data[this._idx(a$1 - 1, t$2)], this.data[this._idx(t$2, -1)] = this.data[this._idx(t$2, 0)], this.data[this._idx(t$2, a$1)] = this.data[this._idx(t$2, a$1 - 1)];
					this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(a$1, -1)] = this.data[this._idx(a$1 - 1, 0)], this.data[this._idx(-1, a$1)] = this.data[this._idx(0, a$1 - 1)], this.data[this._idx(a$1, a$1)] = this.data[this._idx(a$1 - 1, a$1 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
					for (let t$2 = 0; t$2 < a$1; t$2++) for (let e$2 = 0; e$2 < a$1; e$2++) {
						const r$2 = this.get(t$2, e$2);
						r$2 > this.max && (this.max = r$2), r$2 < this.min && (this.min = r$2);
					}
				}
				get(t$1, e$1) {
					const r$1 = new Uint8Array(this.data.buffer), n$1 = 4 * this._idx(t$1, e$1);
					return this.unpack(r$1[n$1], r$1[n$1 + 1], r$1[n$1 + 2]);
				}
				getUnpackVector() {
					return [
						this.redFactor,
						this.greenFactor,
						this.blueFactor,
						this.baseShift
					];
				}
				_idx(t$1, e$1) {
					if (t$1 < -1 || t$1 >= this.dim + 1 || e$1 < -1 || e$1 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
					return (e$1 + 1) * this.stride + (t$1 + 1);
				}
				unpack(t$1, e$1, r$1) {
					return t$1 * this.redFactor + e$1 * this.greenFactor + r$1 * this.blueFactor - this.baseShift;
				}
				pack(t$1) {
					return Dl$1(t$1, this.getUnpackVector());
				}
				getPixels() {
					return new bl$1({
						width: this.stride,
						height: this.stride
					}, new Uint8Array(this.data.buffer));
				}
				backfillBorder(t$1, e$1, r$1) {
					if (this.dim !== t$1.dim) throw new Error("dem dimension mismatch");
					let n$1 = e$1 * this.dim, i$1 = e$1 * this.dim + this.dim, s$1 = r$1 * this.dim, o = r$1 * this.dim + this.dim;
					switch (e$1) {
						case -1:
							n$1 = i$1 - 1;
							break;
						case 1: i$1 = n$1 + 1;
					}
					switch (r$1) {
						case -1:
							s$1 = o - 1;
							break;
						case 1: o = s$1 + 1;
					}
					const a$1 = -e$1 * this.dim, l$1 = -r$1 * this.dim;
					for (let e$2 = s$1; e$2 < o; e$2++) for (let r$2 = n$1; r$2 < i$1; r$2++) this.data[this._idx(r$2, e$2)] = t$1.data[this._idx(r$2 + a$1, e$2 + l$1)];
				}
			}
			function Dl$1(t$1, e$1) {
				const r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o = Math.min(r$1, n$1, i$1), a$1 = Math.round((t$1 + s$1) / o);
				return {
					r: Math.floor(a$1 * o / r$1) % 256,
					g: Math.floor(a$1 * o / n$1) % 256,
					b: Math.floor(a$1 * o / i$1) % 256
				};
			}
			us$1("DEMData", Fl$1);
			class Pl$1 extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, Il$1, e$1);
				}
				_createColorRamp(t$1) {
					const e$1 = {
						elevationStops: [],
						colorStops: []
					}, r$1 = this._transitionablePaint._values["color-relief-color"].value.expression;
					if (r$1 instanceof ii$1 && r$1._styleExpression.expression instanceof fr$1) {
						this.colorRampExpression = r$1;
						const t$2 = r$1._styleExpression.expression;
						e$1.elevationStops = t$2.labels, e$1.colorStops = [];
						for (const r$2 of e$1.elevationStops) e$1.colorStops.push(t$2.evaluate({ globals: { elevation: r$2 } }));
					}
					if (e$1.elevationStops.length < 1 && (e$1.elevationStops = [0], e$1.colorStops = [Te$1.transparent]), e$1.elevationStops.length < 2 && (e$1.elevationStops.push(e$1.elevationStops[0] + 1), e$1.colorStops.push(e$1.colorStops[0])), e$1.elevationStops.length <= t$1) return e$1;
					const n$1 = {
						elevationStops: [],
						colorStops: []
					}, i$1 = (e$1.elevationStops.length - 1) / (t$1 - 1);
					for (let t$2 = 0; t$2 < e$1.elevationStops.length - .5; t$2 += i$1) n$1.elevationStops.push(e$1.elevationStops[Math.round(t$2)]), n$1.colorStops.push(e$1.colorStops[Math.round(t$2)]);
					return j$1(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t$1}, provided: ${e$1.elevationStops.length}`), n$1;
				}
				_colorRampChanged() {
					return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
				}
				getColorRampTextures(t$1, e$1, r$1) {
					if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
					const n$1 = this._createColorRamp(e$1), i$1 = new bl$1({
						width: n$1.colorStops.length,
						height: 1
					}), s$1 = new bl$1({
						width: n$1.colorStops.length,
						height: 1
					});
					for (let t$2 = 0; t$2 < n$1.elevationStops.length; t$2++) {
						const e$2 = Dl$1(n$1.elevationStops[t$2], r$1);
						s$1.setPixel(0, t$2, new Te$1(e$2.r / 255, e$2.g / 255, e$2.b / 255, 1)), i$1.setPixel(0, t$2, n$1.colorStops[t$2]);
					}
					return this.colorRampTextures = {
						elevationTexture: new Ml$1(t$1, s$1, t$1.gl.RGBA),
						colorTexture: new Ml$1(t$1, i$1, t$1.gl.RGBA)
					}, this.colorRampTextures;
				}
				hasOffscreenPass() {
					return "none" !== this.visibility && !!this.colorRampTextures;
				}
			}
			const { members: Bl$1 } = to$1([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			function Vl$1(t$1, e$1, r$1) {
				const n$1 = r$1.patternDependencies;
				let i$1 = !1;
				for (const r$2 of e$1) {
					const e$2 = r$2.paint.get(`${t$1}-pattern`);
					e$2.isConstant() || (i$1 = !0);
					const s$1 = e$2.constantOr(null);
					s$1 && (i$1 = !0, n$1[s$1.to] = !0, n$1[s$1.from] = !0);
				}
				return i$1;
			}
			function Cl$1(t$1, e$1, r$1, n$1, i$1) {
				const { zoom: s$1 } = n$1, o = i$1.patternDependencies;
				for (const n$2 of e$1) {
					const e$2 = n$2.paint.get(`${t$1}-pattern`).value;
					if ("constant" !== e$2.kind) {
						let t$2 = e$2.evaluate({ zoom: s$1 - 1 }, r$1, {}, i$1.availableImages), a$1 = e$2.evaluate({ zoom: s$1 }, r$1, {}, i$1.availableImages), l$1 = e$2.evaluate({ zoom: s$1 + 1 }, r$1, {}, i$1.availableImages);
						t$2 = t$2 && t$2.name ? t$2.name : t$2, a$1 = a$1 && a$1.name ? a$1.name : a$1, l$1 = l$1 && l$1.name ? l$1.name : l$1, o[t$2] = !0, o[a$1] = !0, o[l$1] = !0, r$1.patterns[n$2.id] = {
							min: t$2,
							mid: a$1,
							max: l$1
						};
					}
				}
				return r$1;
			}
			function Ll$1(t$1, e$1, r$1, n$1, i$1) {
				let s$1;
				if (i$1 === function(t$2, e$2, r$2, n$2) {
					let i$2 = 0;
					for (let s$2 = e$2, o = r$2 - n$2; s$2 < r$2; s$2 += n$2) i$2 += (t$2[o] - t$2[s$2]) * (t$2[s$2 + 1] + t$2[o + 1]), o = s$2;
					return i$2;
				}(t$1, e$1, r$1, n$1) > 0) for (let i$2 = e$1; i$2 < r$1; i$2 += n$1) s$1 = su$1(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				else for (let i$2 = r$1 - n$1; i$2 >= e$1; i$2 -= n$1) s$1 = su$1(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				return s$1 && Ql$1(s$1, s$1.next) && (ou$1(s$1), s$1 = s$1.next), s$1;
			}
			function Ol$1(t$1, e$1) {
				if (!t$1) return t$1;
				e$1 || (e$1 = t$1);
				let r$1, n$1 = t$1;
				do
					if (r$1 = !1, n$1.steiner || !Ql$1(n$1, n$1.next) && 0 !== Jl$1(n$1.prev, n$1, n$1.next)) n$1 = n$1.next;
					else {
						if (ou$1(n$1), n$1 = e$1 = n$1.prev, n$1 === n$1.next) break;
						r$1 = !0;
					}
				while (r$1 || n$1 !== e$1);
				return e$1;
			}
			function Rl$1(t$1, e$1, r$1, n$1, i$1, s$1, o) {
				if (!t$1) return;
				!o && s$1 && function(t$2, e$2, r$2, n$2) {
					let i$2 = t$2;
					do
						0 === i$2.z && (i$2.z = Yl$1(i$2.x, i$2.y, e$2, r$2, n$2)), i$2.prevZ = i$2.prev, i$2.nextZ = i$2.next, i$2 = i$2.next;
					while (i$2 !== t$2);
					i$2.prevZ.nextZ = null, i$2.prevZ = null, function(t$3) {
						let e$3, r$3 = 1;
						do {
							let n$3, i$3 = t$3;
							t$3 = null;
							let s$2 = null;
							for (e$3 = 0; i$3;) {
								e$3++;
								let o$1 = i$3, a$2 = 0;
								for (let t$4 = 0; t$4 < r$3 && (a$2++, o$1 = o$1.nextZ, o$1); t$4++);
								let l$1 = r$3;
								for (; a$2 > 0 || l$1 > 0 && o$1;) 0 !== a$2 && (0 === l$1 || !o$1 || i$3.z <= o$1.z) ? (n$3 = i$3, i$3 = i$3.nextZ, a$2--) : (n$3 = o$1, o$1 = o$1.nextZ, l$1--), s$2 ? s$2.nextZ = n$3 : t$3 = n$3, n$3.prevZ = s$2, s$2 = n$3;
								i$3 = o$1;
							}
							s$2.nextZ = null, r$3 *= 2;
						} while (e$3 > 1);
					}(i$2);
				}(t$1, n$1, i$1, s$1);
				let a$1 = t$1;
				for (; t$1.prev !== t$1.next;) {
					const l$1 = t$1.prev, u$1 = t$1.next;
					if (s$1 ? $l$1(t$1, n$1, i$1, s$1) : Nl$1(t$1)) e$1.push(l$1.i, t$1.i, u$1.i), ou$1(t$1), t$1 = u$1.next, a$1 = u$1.next;
					else if ((t$1 = u$1) === a$1) {
						o ? 1 === o ? Rl$1(t$1 = Ul$1(Ol$1(t$1), e$1), e$1, r$1, n$1, i$1, s$1, 2) : 2 === o && ql$1(t$1, e$1, r$1, n$1, i$1, s$1) : Rl$1(Ol$1(t$1), e$1, r$1, n$1, i$1, s$1, 1);
						break;
					}
				}
			}
			function Nl$1(t$1) {
				const e$1 = t$1.prev, r$1 = t$1, n$1 = t$1.next;
				if (Jl$1(e$1, r$1, n$1) >= 0) return !1;
				const i$1 = e$1.x, s$1 = r$1.x, o = n$1.x, a$1 = e$1.y, l$1 = r$1.y, u$1 = n$1.y, c$1 = Math.min(i$1, s$1, o), h$1 = Math.min(a$1, l$1, u$1), p$1 = Math.max(i$1, s$1, o), f$1 = Math.max(a$1, l$1, u$1);
				let d$1 = n$1.next;
				for (; d$1 !== e$1;) {
					if (d$1.x >= c$1 && d$1.x <= p$1 && d$1.y >= h$1 && d$1.y <= f$1 && Kl$1(i$1, a$1, s$1, l$1, o, u$1, d$1.x, d$1.y) && Jl$1(d$1.prev, d$1, d$1.next) >= 0) return !1;
					d$1 = d$1.next;
				}
				return !0;
			}
			function $l$1(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.prev, s$1 = t$1, o = t$1.next;
				if (Jl$1(i$1, s$1, o) >= 0) return !1;
				const a$1 = i$1.x, l$1 = s$1.x, u$1 = o.x, c$1 = i$1.y, h$1 = s$1.y, p$1 = o.y, f$1 = Math.min(a$1, l$1, u$1), d$1 = Math.min(c$1, h$1, p$1), y$1 = Math.max(a$1, l$1, u$1), m$1 = Math.max(c$1, h$1, p$1), g$2 = Yl$1(f$1, d$1, e$1, r$1, n$1), x$1 = Yl$1(y$1, m$1, e$1, r$1, n$1);
				let v$1 = t$1.prevZ, b$1 = t$1.nextZ;
				for (; v$1 && v$1.z >= g$2 && b$1 && b$1.z <= x$1;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== o && Kl$1(a$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Jl$1(v$1.prev, v$1, v$1.next) >= 0) return !1;
					if (v$1 = v$1.prevZ, b$1.x >= f$1 && b$1.x <= y$1 && b$1.y >= d$1 && b$1.y <= m$1 && b$1 !== i$1 && b$1 !== o && Kl$1(a$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && Jl$1(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				for (; v$1 && v$1.z >= g$2;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== o && Kl$1(a$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Jl$1(v$1.prev, v$1, v$1.next) >= 0) return !1;
					v$1 = v$1.prevZ;
				}
				for (; b$1 && b$1.z <= x$1;) {
					if (b$1.x >= f$1 && b$1.x <= y$1 && b$1.y >= d$1 && b$1.y <= m$1 && b$1 !== i$1 && b$1 !== o && Kl$1(a$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && Jl$1(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				return !0;
			}
			function Ul$1(t$1, e$1) {
				let r$1 = t$1;
				do {
					const n$1 = r$1.prev, i$1 = r$1.next.next;
					!Ql$1(n$1, i$1) && tu$1(n$1, r$1, r$1.next, i$1) && nu$1(n$1, i$1) && nu$1(i$1, n$1) && (e$1.push(n$1.i, r$1.i, i$1.i), ou$1(r$1), ou$1(r$1.next), r$1 = t$1 = i$1), r$1 = r$1.next;
				} while (r$1 !== t$1);
				return Ol$1(r$1);
			}
			function ql$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				let o = t$1;
				do {
					let t$2 = o.next.next;
					for (; t$2 !== o.prev;) {
						if (o.i !== t$2.i && Wl$1(o, t$2)) {
							let a$1 = iu$1(o, t$2);
							o = Ol$1(o, o.next), a$1 = Ol$1(a$1, a$1.next), Rl$1(o, e$1, r$1, n$1, i$1, s$1, 0), Rl$1(a$1, e$1, r$1, n$1, i$1, s$1, 0);
							return;
						}
						t$2 = t$2.next;
					}
					o = o.next;
				} while (o !== t$1);
			}
			function jl$1(t$1, e$1) {
				let r$1 = t$1.x - e$1.x;
				return 0 === r$1 && (r$1 = t$1.y - e$1.y, 0 === r$1) && (r$1 = (t$1.next.y - t$1.y) / (t$1.next.x - t$1.x) - (e$1.next.y - e$1.y) / (e$1.next.x - e$1.x)), r$1;
			}
			function Gl$1(t$1, e$1) {
				const r$1 = function(t$2, e$2) {
					let r$2 = e$2;
					const n$2 = t$2.x, i$1 = t$2.y;
					let s$1, o = -Infinity;
					if (Ql$1(t$2, r$2)) return r$2;
					do {
						if (Ql$1(t$2, r$2.next)) return r$2.next;
						if (i$1 <= r$2.y && i$1 >= r$2.next.y && r$2.next.y !== r$2.y) {
							const t$3 = r$2.x + (i$1 - r$2.y) * (r$2.next.x - r$2.x) / (r$2.next.y - r$2.y);
							if (t$3 <= n$2 && t$3 > o && (o = t$3, s$1 = r$2.x < r$2.next.x ? r$2 : r$2.next, t$3 === n$2)) return s$1;
						}
						r$2 = r$2.next;
					} while (r$2 !== e$2);
					if (!s$1) return null;
					const a$1 = s$1, l$1 = s$1.x, u$1 = s$1.y;
					let c$1 = Infinity;
					r$2 = s$1;
					do {
						if (n$2 >= r$2.x && r$2.x >= l$1 && n$2 !== r$2.x && Hl$1(i$1 < u$1 ? n$2 : o, i$1, l$1, u$1, i$1 < u$1 ? o : n$2, i$1, r$2.x, r$2.y)) {
							const e$3 = Math.abs(i$1 - r$2.y) / (n$2 - r$2.x);
							nu$1(r$2, t$2) && (e$3 < c$1 || e$3 === c$1 && (r$2.x > s$1.x || r$2.x === s$1.x && Xl$1(s$1, r$2))) && (s$1 = r$2, c$1 = e$3);
						}
						r$2 = r$2.next;
					} while (r$2 !== a$1);
					return s$1;
				}(t$1, e$1);
				if (!r$1) return e$1;
				const n$1 = iu$1(r$1, t$1);
				return Ol$1(n$1, n$1.next), Ol$1(r$1, r$1.next);
			}
			function Xl$1(t$1, e$1) {
				return Jl$1(t$1.prev, t$1, e$1.prev) < 0 && Jl$1(e$1.next, t$1, t$1.next) < 0;
			}
			function Yl$1(t$1, e$1, r$1, n$1, i$1) {
				return (t$1 = 1431655765 & ((t$1 = 858993459 & ((t$1 = 252645135 & ((t$1 = 16711935 & ((t$1 = (t$1 - r$1) * i$1 | 0) | t$1 << 8)) | t$1 << 4)) | t$1 << 2)) | t$1 << 1)) | (e$1 = 1431655765 & ((e$1 = 858993459 & ((e$1 = 252645135 & ((e$1 = 16711935 & ((e$1 = (e$1 - n$1) * i$1 | 0) | e$1 << 8)) | e$1 << 4)) | e$1 << 2)) | e$1 << 1)) << 1;
			}
			function Zl$1(t$1) {
				let e$1 = t$1, r$1 = t$1;
				do
					(e$1.x < r$1.x || e$1.x === r$1.x && e$1.y < r$1.y) && (r$1 = e$1), e$1 = e$1.next;
				while (e$1 !== t$1);
				return r$1;
			}
			function Hl$1(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
				return (i$1 - o) * (e$1 - a$1) >= (t$1 - o) * (s$1 - a$1) && (t$1 - o) * (n$1 - a$1) >= (r$1 - o) * (e$1 - a$1) && (r$1 - o) * (s$1 - a$1) >= (i$1 - o) * (n$1 - a$1);
			}
			function Kl$1(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
				return !(t$1 === o && e$1 === a$1) && Hl$1(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1);
			}
			function Wl$1(t$1, e$1) {
				return t$1.next.i !== e$1.i && t$1.prev.i !== e$1.i && !function(t$2, e$2) {
					let r$1 = t$2;
					do {
						if (r$1.i !== t$2.i && r$1.next.i !== t$2.i && r$1.i !== e$2.i && r$1.next.i !== e$2.i && tu$1(r$1, r$1.next, t$2, e$2)) return !0;
						r$1 = r$1.next;
					} while (r$1 !== t$2);
					return !1;
				}(t$1, e$1) && (nu$1(t$1, e$1) && nu$1(e$1, t$1) && function(t$2, e$2) {
					let r$1 = t$2, n$1 = !1;
					const i$1 = (t$2.x + e$2.x) / 2, s$1 = (t$2.y + e$2.y) / 2;
					do
						r$1.y > s$1 != r$1.next.y > s$1 && r$1.next.y !== r$1.y && i$1 < (r$1.next.x - r$1.x) * (s$1 - r$1.y) / (r$1.next.y - r$1.y) + r$1.x && (n$1 = !n$1), r$1 = r$1.next;
					while (r$1 !== t$2);
					return n$1;
				}(t$1, e$1) && (Jl$1(t$1.prev, t$1, e$1.prev) || Jl$1(t$1, e$1.prev, e$1)) || Ql$1(t$1, e$1) && Jl$1(t$1.prev, t$1, t$1.next) > 0 && Jl$1(e$1.prev, e$1, e$1.next) > 0);
			}
			function Jl$1(t$1, e$1, r$1) {
				return (e$1.y - t$1.y) * (r$1.x - e$1.x) - (e$1.x - t$1.x) * (r$1.y - e$1.y);
			}
			function Ql$1(t$1, e$1) {
				return t$1.x === e$1.x && t$1.y === e$1.y;
			}
			function tu$1(t$1, e$1, r$1, n$1) {
				const i$1 = ru$1(Jl$1(t$1, e$1, r$1)), s$1 = ru$1(Jl$1(t$1, e$1, n$1)), o = ru$1(Jl$1(r$1, n$1, t$1)), a$1 = ru$1(Jl$1(r$1, n$1, e$1));
				return i$1 !== s$1 && o !== a$1 || !(0 !== i$1 || !eu$1(t$1, r$1, e$1)) || !(0 !== s$1 || !eu$1(t$1, n$1, e$1)) || !(0 !== o || !eu$1(r$1, t$1, n$1)) || !(0 !== a$1 || !eu$1(r$1, e$1, n$1));
			}
			function eu$1(t$1, e$1, r$1) {
				return e$1.x <= Math.max(t$1.x, r$1.x) && e$1.x >= Math.min(t$1.x, r$1.x) && e$1.y <= Math.max(t$1.y, r$1.y) && e$1.y >= Math.min(t$1.y, r$1.y);
			}
			function ru$1(t$1) {
				return t$1 > 0 ? 1 : t$1 < 0 ? -1 : 0;
			}
			function nu$1(t$1, e$1) {
				return Jl$1(t$1.prev, t$1, t$1.next) < 0 ? Jl$1(t$1, e$1, t$1.next) >= 0 && Jl$1(t$1, t$1.prev, e$1) >= 0 : Jl$1(t$1, e$1, t$1.prev) < 0 || Jl$1(t$1, t$1.next, e$1) < 0;
			}
			function iu$1(t$1, e$1) {
				const r$1 = au$1(t$1.i, t$1.x, t$1.y), n$1 = au$1(e$1.i, e$1.x, e$1.y), i$1 = t$1.next, s$1 = e$1.prev;
				return t$1.next = e$1, e$1.prev = t$1, r$1.next = i$1, i$1.prev = r$1, n$1.next = r$1, r$1.prev = n$1, s$1.next = n$1, n$1.prev = s$1, n$1;
			}
			function su$1(t$1, e$1, r$1, n$1) {
				const i$1 = au$1(t$1, e$1, r$1);
				return n$1 ? (i$1.next = n$1.next, i$1.prev = n$1, n$1.next.prev = i$1, n$1.next = i$1) : (i$1.prev = i$1, i$1.next = i$1), i$1;
			}
			function ou$1(t$1) {
				t$1.next.prev = t$1.prev, t$1.prev.next = t$1.next, t$1.prevZ && (t$1.prevZ.nextZ = t$1.nextZ), t$1.nextZ && (t$1.nextZ.prevZ = t$1.prevZ);
			}
			function au$1(t$1, e$1, r$1) {
				return {
					i: t$1,
					x: e$1,
					y: r$1,
					prev: null,
					next: null,
					z: 0,
					prevZ: null,
					nextZ: null,
					steiner: !1
				};
			}
			class lu$1 {
				constructor(t$1, e$1) {
					if (e$1 > t$1) throw new Error("Min granularity must not be greater than base granularity.");
					this._baseZoomGranularity = t$1, this._minGranularity = e$1;
				}
				getGranularityForZoomLevel(t$1) {
					return Math.max(Math.floor(this._baseZoomGranularity / (1 << t$1)), this._minGranularity, 1);
				}
			}
			class uu$1 {
				constructor(t$1) {
					this.fill = t$1.fill, this.line = t$1.line, this.tile = t$1.tile, this.stencil = t$1.stencil, this.circle = t$1.circle;
				}
			}
			uu$1.noSubdivision = new uu$1({
				fill: new lu$1(0, 0),
				line: new lu$1(0, 0),
				tile: new lu$1(0, 0),
				stencil: new lu$1(0, 0),
				circle: 1
			}), us$1("SubdivisionGranularityExpression", lu$1), us$1("SubdivisionGranularitySetting", uu$1);
			const cu$1 = -32768, hu$1 = 32767;
			class pu$1 {
				constructor(t$1, e$1) {
					this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t$1, this._granularityCellSize = M$1 / t$1, this._canonical = e$1;
				}
				_getKey(t$1, e$1) {
					return (t$1 += 32768) << 16 | e$1 + 32768;
				}
				_vertexToIndex(t$1, e$1) {
					if (t$1 < -32768 || e$1 < -32768 || t$1 > 32767 || e$1 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
					const r$1 = 0 | Math.round(t$1), n$1 = 0 | Math.round(e$1), i$1 = this._getKey(r$1, n$1);
					if (this._vertexDictionary.has(i$1)) return this._vertexDictionary.get(i$1);
					const s$1 = this._vertexBuffer.length / 2;
					return this._vertexDictionary.set(i$1, s$1), this._vertexBuffer.push(r$1, n$1), s$1;
				}
				_subdivideTrianglesScanline(t$1) {
					if (this._granularity < 2) return function(t$2, e$2) {
						const r$2 = [];
						for (let n$1 = 0; n$1 < e$2.length; n$1 += 3) {
							const i$1 = e$2[n$1], s$1 = e$2[n$1 + 1], o = e$2[n$1 + 2], a$1 = t$2[2 * i$1], l$1 = t$2[2 * i$1 + 1];
							(t$2[2 * s$1] - a$1) * (t$2[2 * o + 1] - l$1) - (t$2[2 * s$1 + 1] - l$1) * (t$2[2 * o] - a$1) > 0 ? (r$2.push(i$1), r$2.push(o), r$2.push(s$1)) : (r$2.push(i$1), r$2.push(s$1), r$2.push(o));
						}
						return r$2;
					}(this._vertexBuffer, t$1);
					const e$1 = [], r$1 = t$1.length;
					for (let n$1 = 0; n$1 < r$1; n$1 += 3) {
						const r$2 = [
							t$1[n$1 + 0],
							t$1[n$1 + 1],
							t$1[n$1 + 2]
						], i$1 = [
							this._vertexBuffer[2 * t$1[n$1 + 0] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 0] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 1]
						];
						let s$1 = Infinity, o = Infinity, a$1 = -Infinity, l$1 = -Infinity;
						for (let t$2 = 0; t$2 < 3; t$2++) {
							const e$2 = i$1[2 * t$2], r$3 = i$1[2 * t$2 + 1];
							s$1 = Math.min(s$1, e$2), a$1 = Math.max(a$1, e$2), o = Math.min(o, r$3), l$1 = Math.max(l$1, r$3);
						}
						if (s$1 === a$1 || o === l$1) continue;
						const u$1 = Math.floor(s$1 / this._granularityCellSize), c$1 = Math.ceil(a$1 / this._granularityCellSize), h$1 = Math.floor(o / this._granularityCellSize), p$1 = Math.ceil(l$1 / this._granularityCellSize);
						if (u$1 !== c$1 || h$1 !== p$1) for (let t$2 = h$1; t$2 < p$1; t$2++) {
							const n$2 = this._scanlineGenerateVertexRingForCellRow(t$2, i$1, r$2);
							yu$1(this._vertexBuffer, n$2, e$1);
						}
						else e$1.push(...r$2);
					}
					return e$1;
				}
				_scanlineGenerateVertexRingForCellRow(t$1, e$1, r$1) {
					const n$1 = t$1 * this._granularityCellSize, i$1 = n$1 + this._granularityCellSize, s$1 = [];
					for (let t$2 = 0; t$2 < 3; t$2++) {
						const o = e$1[2 * t$2], a$1 = e$1[2 * t$2 + 1], l$1 = e$1[2 * (t$2 + 1) % 6], u$1 = e$1[(2 * (t$2 + 1) + 1) % 6], c$1 = e$1[2 * (t$2 + 2) % 6], h$1 = e$1[(2 * (t$2 + 2) + 1) % 6], p$1 = l$1 - o, f$1 = u$1 - a$1, d$1 = 0 === p$1, y$1 = 0 === f$1, m$1 = (n$1 - a$1) / f$1, g$2 = (i$1 - a$1) / f$1, x$1 = Math.min(m$1, g$2), v$1 = Math.max(m$1, g$2);
						if (!y$1 && (x$1 >= 1 || v$1 <= 0) || y$1 && (a$1 < n$1 || a$1 > i$1)) {
							u$1 >= n$1 && u$1 <= i$1 && s$1.push(r$1[(t$2 + 1) % 3]);
							continue;
						}
						!y$1 && x$1 > 0 && s$1.push(this._vertexToIndex(o + p$1 * x$1, a$1 + f$1 * x$1));
						const b$1 = o + p$1 * Math.max(x$1, 0), w$2 = o + p$1 * Math.min(v$1, 1);
						d$1 || this._generateIntraEdgeVertices(s$1, o, a$1, l$1, u$1, b$1, w$2), !y$1 && v$1 < 1 && s$1.push(this._vertexToIndex(o + p$1 * v$1, a$1 + f$1 * v$1)), (y$1 || u$1 >= n$1 && u$1 <= i$1) && s$1.push(r$1[(t$2 + 1) % 3]), !y$1 && (u$1 <= n$1 || u$1 >= i$1) && this._generateInterEdgeVertices(s$1, o, a$1, l$1, u$1, c$1, h$1, w$2, n$1, i$1);
					}
					return s$1;
				}
				_generateIntraEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					const a$1 = n$1 - e$1, l$1 = i$1 - r$1, u$1 = 0 === l$1, c$1 = u$1 ? Math.min(e$1, n$1) : Math.min(s$1, o), h$1 = u$1 ? Math.max(e$1, n$1) : Math.max(s$1, o), p$1 = Math.floor(c$1 / this._granularityCellSize) + 1, f$1 = Math.ceil(h$1 / this._granularityCellSize) - 1;
					if (u$1 ? e$1 < n$1 : s$1 < o) for (let n$2 = p$1; n$2 <= f$1; n$2++) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / a$1));
					}
					else for (let n$2 = f$1; n$2 >= p$1; n$2--) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / a$1));
					}
				}
				_generateInterEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1) {
					const c$1 = i$1 - r$1, h$1 = s$1 - n$1, p$1 = o - i$1, f$1 = (l$1 - i$1) / p$1, d$1 = (u$1 - i$1) / p$1, y$1 = Math.min(f$1, d$1), m$1 = Math.max(f$1, d$1), g$2 = n$1 + h$1 * y$1;
					let x$1 = Math.floor(Math.min(g$2, a$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(g$2, a$1) / this._granularityCellSize) - 1, b$1 = a$1 < g$2;
					const w$2 = 0 === p$1;
					if (w$2 && (o === l$1 || o === u$1)) return;
					if (w$2 || y$1 >= 1 || m$1 <= 0) {
						const t$2 = r$1 - o, n$2 = s$1 + (e$1 - s$1) * Math.min((l$1 - o) / t$2, (u$1 - o) / t$2);
						x$1 = Math.floor(Math.min(n$2, a$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(n$2, a$1) / this._granularityCellSize) - 1, b$1 = a$1 < n$2;
					}
					const _$2 = c$1 > 0 ? u$1 : l$1;
					if (b$1) for (let e$2 = x$1; e$2 <= v$1; e$2++) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$2));
					else for (let e$2 = v$1; e$2 >= x$1; e$2--) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$2));
				}
				_generateOutline(t$1) {
					const e$1 = [];
					for (const r$1 of t$1) {
						const t$2 = du$1(r$1, this._granularity, !0), n$1 = this._pointArrayToIndices(t$2), i$1 = [];
						for (let t$3 = 1; t$3 < n$1.length; t$3++) i$1.push(n$1[t$3 - 1]), i$1.push(n$1[t$3]);
						e$1.push(i$1);
					}
					return e$1;
				}
				_handlePoles(t$1) {
					let e$1 = !1, r$1 = !1;
					this._canonical && (0 === this._canonical.y && (e$1 = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (r$1 = !0)), (e$1 || r$1) && this._fillPoles(t$1, e$1, r$1);
				}
				_ensureNoPoleVertices() {
					const t$1 = this._vertexBuffer;
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
						const r$1 = t$1[e$1 + 1];
						r$1 === cu$1 && (t$1[e$1 + 1] = -32767), r$1 === hu$1 && (t$1[e$1 + 1] = 32766);
					}
				}
				_generatePoleQuad(t$1, e$1, r$1, n$1, i$1, s$1) {
					n$1 > i$1 != (s$1 === cu$1) ? (t$1.push(e$1), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(this._vertexToIndex(n$1, s$1))) : (t$1.push(r$1), t$1.push(e$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)));
				}
				_fillPoles(t$1, e$1, r$1) {
					const n$1 = this._vertexBuffer, i$1 = M$1, s$1 = t$1.length;
					for (let o = 2; o < s$1; o += 3) {
						const s$2 = t$1[o - 2], a$1 = t$1[o - 1], l$1 = t$1[o], u$1 = n$1[2 * s$2], c$1 = n$1[2 * s$2 + 1], h$1 = n$1[2 * a$1], p$1 = n$1[2 * a$1 + 1], f$1 = n$1[2 * l$1], d$1 = n$1[2 * l$1 + 1];
						e$1 && (0 === c$1 && 0 === p$1 && this._generatePoleQuad(t$1, s$2, a$1, u$1, h$1, cu$1), 0 === p$1 && 0 === d$1 && this._generatePoleQuad(t$1, a$1, l$1, h$1, f$1, cu$1), 0 === d$1 && 0 === c$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, cu$1)), r$1 && (c$1 === i$1 && p$1 === i$1 && this._generatePoleQuad(t$1, s$2, a$1, u$1, h$1, hu$1), p$1 === i$1 && d$1 === i$1 && this._generatePoleQuad(t$1, a$1, l$1, h$1, f$1, hu$1), d$1 === i$1 && c$1 === i$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, hu$1));
					}
				}
				_initializeVertices(t$1) {
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) this._vertexToIndex(t$1[e$1], t$1[e$1 + 1]);
				}
				subdividePolygonInternal(t$1, e$1) {
					if (this._used) throw new Error("Subdivision: multiple use not allowed.");
					this._used = !0;
					const { flattened: r$1, holeIndices: n$1 } = function(t$2) {
						const e$2 = [], r$2 = [];
						for (const n$2 of t$2) if (0 !== n$2.length) {
							n$2 !== t$2[0] && e$2.push(r$2.length / 2);
							for (let t$3 = 0; t$3 < n$2.length; t$3++) r$2.push(n$2[t$3].x), r$2.push(n$2[t$3].y);
						}
						return {
							flattened: r$2,
							holeIndices: e$2
						};
					}(t$1);
					let i$1;
					this._initializeVertices(r$1);
					try {
						const t$2 = function(t$3, e$3, r$2 = 2) {
							const n$2 = e$3 && e$3.length, i$2 = n$2 ? e$3[0] * r$2 : t$3.length;
							let s$2 = Ll$1(t$3, 0, i$2, r$2, !0);
							const o = [];
							if (!s$2 || s$2.next === s$2.prev) return o;
							let a$1, l$1, u$1;
							if (n$2 && (s$2 = function(t$4, e$4, r$3, n$3) {
								const i$3 = [];
								for (let r$4 = 0, s$3 = e$4.length; r$4 < s$3; r$4++) {
									const o$1 = Ll$1(t$4, e$4[r$4] * n$3, r$4 < s$3 - 1 ? e$4[r$4 + 1] * n$3 : t$4.length, n$3, !1);
									o$1 === o$1.next && (o$1.steiner = !0), i$3.push(Zl$1(o$1));
								}
								i$3.sort(jl$1);
								for (let t$5 = 0; t$5 < i$3.length; t$5++) r$3 = Gl$1(i$3[t$5], r$3);
								return r$3;
							}(t$3, e$3, s$2, r$2)), t$3.length > 80 * r$2) {
								a$1 = t$3[0], l$1 = t$3[1];
								let e$4 = a$1, n$3 = l$1;
								for (let s$3 = r$2; s$3 < i$2; s$3 += r$2) {
									const r$3 = t$3[s$3], i$3 = t$3[s$3 + 1];
									r$3 < a$1 && (a$1 = r$3), i$3 < l$1 && (l$1 = i$3), r$3 > e$4 && (e$4 = r$3), i$3 > n$3 && (n$3 = i$3);
								}
								u$1 = Math.max(e$4 - a$1, n$3 - l$1), u$1 = 0 !== u$1 ? 32767 / u$1 : 0;
							}
							return Rl$1(s$2, o, r$2, a$1, l$1, u$1, 0), o;
						}(r$1, n$1), e$2 = this._convertIndices(r$1, t$2);
						i$1 = this._subdivideTrianglesScanline(e$2);
					} catch (t$2) {
						console.error(t$2);
					}
					let s$1 = [];
					return e$1 && (s$1 = this._generateOutline(t$1)), this._ensureNoPoleVertices(), this._handlePoles(i$1), {
						verticesFlattened: this._vertexBuffer,
						indicesTriangles: i$1,
						indicesLineList: s$1
					};
				}
				_convertIndices(t$1, e$1) {
					const r$1 = [];
					for (let n$1 = 0; n$1 < e$1.length; n$1++) r$1.push(this._vertexToIndex(t$1[2 * e$1[n$1]], t$1[2 * e$1[n$1] + 1]));
					return r$1;
				}
				_pointArrayToIndices(t$1) {
					const e$1 = [];
					for (let r$1 = 0; r$1 < t$1.length; r$1++) {
						const n$1 = t$1[r$1];
						e$1.push(this._vertexToIndex(n$1.x, n$1.y));
					}
					return e$1;
				}
			}
			function fu$1(t$1, e$1, r$1, n$1 = !0) {
				return new pu$1(r$1, e$1).subdividePolygonInternal(t$1, n$1);
			}
			function du$1(t$1, e$1, n$1 = !1) {
				if (!t$1 || t$1.length < 1) return [];
				if (t$1.length < 2) return [];
				const i$1 = t$1[0], s$1 = t$1[t$1.length - 1], o = n$1 && (i$1.x !== s$1.x || i$1.y !== s$1.y);
				if (e$1 < 2) return o ? [...t$1, t$1[0]] : [...t$1];
				const a$1 = Math.floor(M$1 / e$1), l$1 = [];
				l$1.push(new r(t$1[0].x, t$1[0].y));
				const u$1 = t$1.length, c$1 = o ? u$1 : u$1 - 1;
				for (let e$2 = 0; e$2 < c$1; e$2++) {
					const n$2 = t$1[e$2], i$2 = e$2 < u$1 - 1 ? t$1[e$2 + 1] : t$1[0], s$2 = n$2.x, o$1 = n$2.y, c$2 = i$2.x, h$1 = i$2.y, p$1 = s$2 !== c$2, f$1 = o$1 !== h$1;
					if (!p$1 && !f$1) continue;
					const d$1 = c$2 - s$2, y$1 = h$1 - o$1, m$1 = Math.abs(d$1), g$2 = Math.abs(y$1);
					let x$1 = s$2, v$1 = o$1;
					for (;;) {
						const t$2 = d$1 > 0 ? (Math.floor(x$1 / a$1) + 1) * a$1 : (Math.ceil(x$1 / a$1) - 1) * a$1, e$3 = y$1 > 0 ? (Math.floor(v$1 / a$1) + 1) * a$1 : (Math.ceil(v$1 / a$1) - 1) * a$1, n$3 = Math.abs(x$1 - t$2), i$3 = Math.abs(v$1 - e$3), s$3 = Math.abs(x$1 - c$2), o$2 = Math.abs(v$1 - h$1), u$2 = p$1 ? n$3 / m$1 : Number.POSITIVE_INFINITY, b$2 = f$1 ? i$3 / g$2 : Number.POSITIVE_INFINITY;
						if ((s$3 <= n$3 || !p$1) && (o$2 <= i$3 || !f$1)) break;
						if (u$2 < b$2 && p$1 || !f$1) {
							x$1 = t$2, v$1 += y$1 * u$2;
							const e$4 = new r(x$1, Math.round(v$1));
							l$1[l$1.length - 1].x === e$4.x && l$1[l$1.length - 1].y === e$4.y || l$1.push(e$4);
						} else {
							x$1 += d$1 * b$2, v$1 = e$3;
							const t$3 = new r(Math.round(x$1), v$1);
							l$1[l$1.length - 1].x === t$3.x && l$1[l$1.length - 1].y === t$3.y || l$1.push(t$3);
						}
					}
					const b$1 = new r(c$2, h$1);
					l$1[l$1.length - 1].x === b$1.x && l$1[l$1.length - 1].y === b$1.y || l$1.push(b$1);
				}
				return l$1;
			}
			function yu$1(t$1, e$1, r$1) {
				if (0 === e$1.length) throw new Error("Subdivision vertex ring is empty.");
				let n$1 = 0, i$1 = t$1[2 * e$1[0]];
				for (let r$2 = 1; r$2 < e$1.length; r$2++) {
					const s$2 = t$1[2 * e$1[r$2]];
					s$2 < i$1 && (i$1 = s$2, n$1 = r$2);
				}
				const s$1 = e$1.length;
				let o = n$1, a$1 = (o + 1) % s$1;
				for (;;) {
					const n$2 = o - 1 >= 0 ? o - 1 : s$1 - 1, i$2 = (a$1 + 1) % s$1, l$1 = t$1[2 * e$1[n$2]], u$1 = t$1[2 * e$1[i$2]], c$1 = t$1[2 * e$1[o]], h$1 = t$1[2 * e$1[o] + 1], p$1 = t$1[2 * e$1[a$1] + 1];
					let f$1 = !1;
					if (l$1 < u$1) f$1 = !0;
					else if (l$1 > u$1) f$1 = !1;
					else {
						const r$2 = p$1 - h$1, s$2 = -(t$1[2 * e$1[a$1]] - c$1), o$1 = h$1 < p$1 ? 1 : -1;
						((l$1 - c$1) * r$2 + (t$1[2 * e$1[n$2] + 1] - h$1) * s$2) * o$1 > ((u$1 - c$1) * r$2 + (t$1[2 * e$1[i$2] + 1] - h$1) * s$2) * o$1 && (f$1 = !0);
					}
					if (f$1) {
						const t$2 = e$1[n$2], i$3 = e$1[o], l$2 = e$1[a$1];
						t$2 !== i$3 && t$2 !== l$2 && i$3 !== l$2 && r$1.push(l$2, i$3, t$2), o--, o < 0 && (o = s$1 - 1);
					} else {
						const t$2 = e$1[i$2], n$3 = e$1[o], l$2 = e$1[a$1];
						t$2 !== n$3 && t$2 !== l$2 && n$3 !== l$2 && r$1.push(l$2, n$3, t$2), a$1++, a$1 >= s$1 && (a$1 = 0);
					}
					if (n$2 === i$2) break;
				}
			}
			function mu$1(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1) {
				const u$1 = i$1.length / 2, c$1 = o && a$1 && l$1;
				if (u$1 < ra$1.MAX_VERTEX_ARRAY_LENGTH) {
					const h$1 = e$1.prepareSegment(u$1, r$1, n$1), p$1 = h$1.vertexLength;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 3) n$1.emplaceBack(p$1 + s$1[t$2], p$1 + s$1[t$2 + 1], p$1 + s$1[t$2 + 2]);
					let f$1, d$1;
					h$1.vertexLength += u$1, h$1.primitiveLength += s$1.length / 3, c$1 && (d$1 = o.prepareSegment(u$1, r$1, a$1), f$1 = d$1.vertexLength, d$1.vertexLength += u$1);
					for (let e$2 = 0; e$2 < i$1.length; e$2 += 2) t$1(i$1[e$2], i$1[e$2 + 1]);
					if (c$1) for (let t$2 = 0; t$2 < l$1.length; t$2++) {
						const e$2 = l$1[t$2];
						for (let t$3 = 1; t$3 < e$2.length; t$3 += 2) a$1.emplaceBack(f$1 + e$2[t$3 - 1], f$1 + e$2[t$3]);
						d$1.primitiveLength += e$2.length / 2;
					}
				} else (function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const o$1 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) o$1.push(-1);
					const a$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 2; h$1 < i$2.length; h$1 += 3) {
						const p$1 = i$2[h$1 - 2], f$1 = i$2[h$1 - 1], d$1 = i$2[h$1];
						let y$1 = o$1[p$1] < l$2, m$1 = o$1[f$1] < l$2, g$2 = o$1[d$1] < l$2;
						u$2.vertexLength + ((y$1 ? 1 : 0) + (m$1 ? 1 : 0) + (g$2 ? 1 : 0)) > ra$1.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = a$2.count, y$1 = !0, m$1 = !0, g$2 = !0, c$2 = 0);
						const x$1 = gu$1(o$1, n$2, s$2, a$2, p$1, y$1, u$2), v$1 = gu$1(o$1, n$2, s$2, a$2, f$1, m$1, u$2), b$1 = gu$1(o$1, n$2, s$2, a$2, d$1, g$2, u$2);
						r$2.emplaceBack(c$2 + x$1 - l$2, c$2 + v$1 - l$2, c$2 + b$1 - l$2), u$2.primitiveLength++;
					}
				})(e$1, r$1, n$1, i$1, s$1, t$1), c$1 && function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const o$1 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) o$1.push(-1);
					const a$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 0; h$1 < i$2.length; h$1++) {
						const p$1 = i$2[h$1];
						for (let f$1 = 1; f$1 < i$2[h$1].length; f$1 += 2) {
							const i$3 = p$1[f$1 - 1], h$2 = p$1[f$1];
							let d$1 = o$1[i$3] < l$2, y$1 = o$1[h$2] < l$2;
							u$2.vertexLength + ((d$1 ? 1 : 0) + (y$1 ? 1 : 0)) > ra$1.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = a$2.count, d$1 = !0, y$1 = !0, c$2 = 0);
							const m$1 = gu$1(o$1, n$2, s$2, a$2, i$3, d$1, u$2), g$2 = gu$1(o$1, n$2, s$2, a$2, h$2, y$1, u$2);
							r$2.emplaceBack(c$2 + m$1 - l$2, c$2 + g$2 - l$2), u$2.primitiveLength++;
						}
					}
				}(o, r$1, a$1, i$1, l$1, t$1), e$1.forceNewSegmentOnNextPrepare(), o?.forceNewSegmentOnNextPrepare();
			}
			function gu$1(t$1, e$1, r$1, n$1, i$1, s$1, o) {
				if (s$1) {
					const s$2 = n$1.count;
					return r$1(e$1[2 * i$1], e$1[2 * i$1 + 1]), t$1[i$1] = n$1.count, n$1.count++, o.vertexLength++, s$2;
				}
				return t$1[i$1];
			}
			class xu$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new $o$1(), this.indexArray = new Jo$1(), this.indexArray2 = new Qo$1(), this.programConfigurations = new Pa$1(t$1.layers, t$1.zoom), this.segments = new ra$1(), this.segments2 = new ra$1(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasDependencies = Vl$1("fill", this.layers, e$1);
					const n$1 = this.layers[0].layout.get("fill-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: o, id: a$1, index: l$1, sourceLayerIndex: u$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, c$1 = Oa$1(o, t$2);
						if (!this.layers[0]._featureFilter.filter(new Fs$1(this.zoom), c$1, r$1)) continue;
						const h$1 = i$1 ? n$1.evaluate(c$1, {}, r$1, e$1.availableImages) : void 0, p$1 = {
							id: a$1,
							properties: o.properties,
							type: o.type,
							sourceLayerIndex: u$1,
							index: l$1,
							geometry: t$2 ? c$1.geometry : La$1(o),
							patterns: {},
							sortKey: h$1
						};
						s$1.push(p$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: o } = n$2;
						if (this.hasDependencies) {
							const t$2 = Cl$1("fill", this.layers, n$2, { zoom: this.zoom }, e$1);
							this.patternFeatures.push(t$2);
						} else this.addFeature(n$2, i$2, s$2, r$1, {}, e$1.subdivisionGranularity);
						e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, o, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.patternFeatures) this.addFeature(n$1, n$1.geometry, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Bl$1), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t$1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const t$2 of tn$1(e$1, 500)) {
						const e$2 = fu$1(t$2, n$1, s$1.fill.getGranularityForZoomLevel(n$1.z)), r$2 = this.layoutVertexArray;
						mu$1(((t$3, e$3) => {
							r$2.emplaceBack(t$3, e$3);
						}), this.segments, this.layoutVertexArray, this.indexArray, e$2.verticesFlattened, e$2.indicesTriangles, this.segments2, this.indexArray2, e$2.indicesLineList);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						canonical: n$1
					});
				}
			}
			let vu$1, bu$1;
			us$1("FillBucket", xu$1, { omit: ["layers", "patternFeatures"] });
			var wu$1 = {
				get paint() {
					return bu$1 = bu$1 || new Xs$1({
						"fill-antialias": new $s$1(vt$1.paint_fill["fill-antialias"]),
						"fill-opacity": new Us$1(vt$1.paint_fill["fill-opacity"]),
						"fill-color": new Us$1(vt$1.paint_fill["fill-color"]),
						"fill-outline-color": new Us$1(vt$1.paint_fill["fill-outline-color"]),
						"fill-translate": new $s$1(vt$1.paint_fill["fill-translate"]),
						"fill-translate-anchor": new $s$1(vt$1.paint_fill["fill-translate-anchor"]),
						"fill-pattern": new qs$1(vt$1.paint_fill["fill-pattern"])
					});
				},
				get layout() {
					return vu$1 = vu$1 || new Xs$1({ "fill-sort-key": new Us$1(vt$1.layout_fill["fill-sort-key"]) });
				}
			};
			class _u$1 extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, wu$1, e$1);
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1);
					const r$1 = this.paint._values["fill-outline-color"];
					"constant" === r$1.value.kind && void 0 === r$1.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
				}
				createBucket(t$1) {
					return new xu$1(t$1);
				}
				queryRadius() {
					return tl$1(this.paint.get("fill-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, geometry: e$1, transform: r$1, pixelsToTileUnits: n$1 }) {
					return ja$1(el$1(t$1, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r$1.bearingInRadians, n$1), e$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			const Au$1 = to$1([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}, {
				name: "a_normal_ed",
				components: 4,
				type: "Int16"
			}], 4), Su$1 = to$1([{
				name: "a_centroid",
				components: 2,
				type: "Int16"
			}], 4), { members: ku$1 } = Au$1;
			class Eu$1 {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.properties = {}, this.extent = r$1, this.type = 0, this.id = void 0, this._pbf = t$1, this._geometry = -1, this._keys = n$1, this._values = i$1, t$1.readFields(Tu, this, e$1);
				}
				loadGeometry() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos, n$1 = [];
					let i$1, s$1 = 1, o = 0, a$1 = 0, l$1 = 0;
					for (; t$1.pos < e$1;) {
						if (o <= 0) {
							const e$2 = t$1.readVarint();
							s$1 = 7 & e$2, o = e$2 >> 3;
						}
						if (o--, 1 === s$1 || 2 === s$1) a$1 += t$1.readSVarint(), l$1 += t$1.readSVarint(), 1 === s$1 && (i$1 && n$1.push(i$1), i$1 = []), i$1 && i$1.push(new r(a$1, l$1));
						else {
							if (7 !== s$1) throw new Error(`unknown command ${s$1}`);
							i$1 && i$1.push(i$1[0].clone());
						}
					}
					return i$1 && n$1.push(i$1), n$1;
				}
				bbox() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos;
					let r$1 = 1, n$1 = 0, i$1 = 0, s$1 = 0, o = Infinity, a$1 = -Infinity, l$1 = Infinity, u$1 = -Infinity;
					for (; t$1.pos < e$1;) {
						if (n$1 <= 0) {
							const e$2 = t$1.readVarint();
							r$1 = 7 & e$2, n$1 = e$2 >> 3;
						}
						if (n$1--, 1 === r$1 || 2 === r$1) i$1 += t$1.readSVarint(), s$1 += t$1.readSVarint(), i$1 < o && (o = i$1), i$1 > a$1 && (a$1 = i$1), s$1 < l$1 && (l$1 = s$1), s$1 > u$1 && (u$1 = s$1);
						else if (7 !== r$1) throw new Error(`unknown command ${r$1}`);
					}
					return [
						o,
						l$1,
						a$1,
						u$1
					];
				}
				toGeoJSON(t$1, e$1, r$1) {
					const n$1 = this.extent * Math.pow(2, r$1), i$1 = this.extent * t$1, s$1 = this.extent * e$1, o = this.loadGeometry();
					function a$1(t$2) {
						return [360 * (t$2.x + i$1) / n$1 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t$2.y + s$1) / n$1) * Math.PI)) - 90];
					}
					function l$1(t$2) {
						return t$2.map(a$1);
					}
					let u$1;
					if (1 === this.type) {
						const t$2 = [];
						for (const e$3 of o) t$2.push(e$3[0]);
						const e$2 = l$1(t$2);
						u$1 = 1 === t$2.length ? {
							type: "Point",
							coordinates: e$2[0]
						} : {
							type: "MultiPoint",
							coordinates: e$2
						};
					} else if (2 === this.type) {
						const t$2 = o.map(l$1);
						u$1 = 1 === t$2.length ? {
							type: "LineString",
							coordinates: t$2[0]
						} : {
							type: "MultiLineString",
							coordinates: t$2
						};
					} else {
						if (3 !== this.type) throw new Error("unknown feature type");
						{
							const t$2 = Iu$1(o), e$2 = [];
							for (const r$2 of t$2) e$2.push(r$2.map(l$1));
							u$1 = 1 === e$2.length ? {
								type: "Polygon",
								coordinates: e$2[0]
							} : {
								type: "MultiPolygon",
								coordinates: e$2
							};
						}
					}
					const c$1 = {
						type: "Feature",
						geometry: u$1,
						properties: this.properties
					};
					return null != this.id && (c$1.id = this.id), c$1;
				}
			}
			function Tu(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? function(t$2, e$2) {
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = e$2._keys[t$2.readVarint()], n$1 = e$2._values[t$2.readVarint()];
						e$2.properties[r$3] = n$1;
					}
				}(r$1, e$1) : 3 === t$1 ? e$1.type = r$1.readVarint() : 4 === t$1 && (e$1._geometry = r$1.pos);
			}
			function Iu$1(t$1) {
				const e$1 = t$1.length;
				if (e$1 <= 1) return [t$1];
				const r$1 = [];
				let n$1, i$1;
				for (let s$1 = 0; s$1 < e$1; s$1++) {
					const e$2 = Mu$1(t$1[s$1]);
					0 !== e$2 && (void 0 === i$1 && (i$1 = e$2 < 0), i$1 === e$2 < 0 ? (n$1 && r$1.push(n$1), n$1 = [t$1[s$1]]) : n$1 && n$1.push(t$1[s$1]));
				}
				return n$1 && r$1.push(n$1), r$1;
			}
			function Mu$1(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, o = s$1 - 1; i$1 < s$1; o = i$1++) r$1 = t$1[i$1], n$1 = t$1[o], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			Eu$1.types = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class Fu$1 {
				constructor(t$1, e$1) {
					this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t$1, this._keys = [], this._values = [], this._features = [], t$1.readFields(Du$1, this, e$1), this.length = this._features.length;
				}
				feature(t$1) {
					if (t$1 < 0 || t$1 >= this._features.length) throw new Error("feature index out of bounds");
					this._pbf.pos = this._features[t$1];
					const e$1 = this._pbf.readVarint() + this._pbf.pos;
					return new Eu$1(this._pbf, e$1, this.extent, this._keys, this._values);
				}
			}
			function Du$1(t$1, e$1, r$1) {
				15 === t$1 ? e$1.version = r$1.readVarint() : 1 === t$1 ? e$1.name = r$1.readString() : 5 === t$1 ? e$1.extent = r$1.readVarint() : 2 === t$1 ? e$1._features.push(r$1.pos) : 3 === t$1 ? e$1._keys.push(r$1.readString()) : 4 === t$1 && e$1._values.push(function(t$2) {
					let e$2 = null;
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = t$2.readVarint() >> 3;
						e$2 = 1 === r$3 ? t$2.readString() : 2 === r$3 ? t$2.readFloat() : 3 === r$3 ? t$2.readDouble() : 4 === r$3 ? t$2.readVarint64() : 5 === r$3 ? t$2.readVarint() : 6 === r$3 ? t$2.readSVarint() : 7 === r$3 ? t$2.readBoolean() : null;
					}
					if (null == e$2) throw new Error("unknown feature value");
					return e$2;
				}(r$1));
			}
			class Pu$1 {
				constructor(t$1, e$1) {
					this.layers = t$1.readFields(zu$1, {}, e$1);
				}
			}
			function zu$1(t$1, e$1, r$1) {
				if (3 === t$1) {
					const t$2 = new Fu$1(r$1, r$1.readVarint() + r$1.pos);
					t$2.length && (e$1[t$2.name] = t$2);
				}
			}
			const Bu$1 = Math.pow(2, 13);
			function Vu$1(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
				t$1.emplaceBack(e$1, r$1, 2 * Math.floor(n$1 * Bu$1) + o, i$1 * Bu$1 * 2, s$1 * Bu$1 * 2, Math.round(a$1));
			}
			class Cu$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.layoutVertexArray = new Uo$1(), this.centroidVertexArray = new Ro(), this.indexArray = new Jo$1(), this.programConfigurations = new Pa$1(t$1.layers, t$1.zoom), this.segments = new ra$1(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.features = [], this.hasDependencies = Vl$1("fill-extrusion", this.layers, e$1);
					for (const { feature: n$1, id: i$1, index: s$1, sourceLayerIndex: o } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, a$1 = Oa$1(n$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new Fs$1(this.zoom), a$1, r$1)) continue;
						const l$1 = {
							id: i$1,
							sourceLayerIndex: o,
							index: s$1,
							geometry: t$2 ? a$1.geometry : La$1(n$1),
							properties: n$1.properties,
							type: n$1.type,
							patterns: {}
						};
						this.hasDependencies ? this.features.push(Cl$1("fill-extrusion", this.layers, l$1, { zoom: this.zoom }, e$1)) : this.addFeature(l$1, l$1.geometry, s$1, r$1, {}, e$1.subdivisionGranularity), e$1.featureIndex.insert(n$1, l$1.geometry, s$1, o, this.index, !0);
					}
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.features) {
						const { geometry: i$1 } = n$1;
						this.addFeature(n$1, i$1, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, ku$1), this.centroidVertexBuffer = t$1.createVertexBuffer(this.centroidVertexArray, Su$1.members, !0), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const r$2 of tn$1(e$1, 500)) {
						const e$2 = {
							x: 0,
							y: 0,
							sampleCount: 0
						}, i$2 = this.layoutVertexArray.length;
						this.processPolygon(e$2, n$1, t$1, r$2, s$1);
						const o = this.layoutVertexArray.length - i$2, a$1 = Math.floor(e$2.x / e$2.sampleCount), l$1 = Math.floor(e$2.y / e$2.sampleCount);
						for (let t$2 = 0; t$2 < o; t$2++) this.centroidVertexArray.emplaceBack(a$1, l$1);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						canonical: n$1
					});
				}
				processPolygon(t$1, e$1, r$1, n$1, i$1) {
					if (n$1.length < 1) return;
					if (Ru$1(n$1[0])) return;
					for (const e$2 of n$1) 0 !== e$2.length && Lu$1(t$1, e$2);
					const s$1 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, o = i$1.fill.getGranularityForZoomLevel(e$1.z), a$1 = "Polygon" === Eu$1.types[r$1.type];
					for (const t$2 of n$1) {
						if (0 === t$2.length) continue;
						if (Ru$1(t$2)) continue;
						const e$2 = du$1(t$2, o, a$1);
						this._generateSideFaces(e$2, s$1);
					}
					if (!a$1) return;
					const l$1 = fu$1(n$1, e$1, o, !1), u$1 = this.layoutVertexArray;
					mu$1(((t$2, e$2) => {
						Vu$1(u$1, t$2, e$2, 0, 0, 1, 1, 0);
					}), this.segments, this.layoutVertexArray, this.indexArray, l$1.verticesFlattened, l$1.indicesTriangles);
				}
				_generateSideFaces(t$1, e$1) {
					let r$1 = 0;
					for (let n$1 = 1; n$1 < t$1.length; n$1++) {
						const i$1 = t$1[n$1], s$1 = t$1[n$1 - 1];
						if (Ou$1(i$1, s$1)) continue;
						e$1.segment.vertexLength + 4 > ra$1.MAX_VERTEX_ARRAY_LENGTH && (e$1.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
						const o = i$1.sub(s$1)._perp()._unit(), a$1 = s$1.dist(i$1);
						r$1 + a$1 > 32768 && (r$1 = 0), Vu$1(this.layoutVertexArray, i$1.x, i$1.y, o.x, o.y, 0, 0, r$1), Vu$1(this.layoutVertexArray, i$1.x, i$1.y, o.x, o.y, 0, 1, r$1), r$1 += a$1, Vu$1(this.layoutVertexArray, s$1.x, s$1.y, o.x, o.y, 0, 0, r$1), Vu$1(this.layoutVertexArray, s$1.x, s$1.y, o.x, o.y, 0, 1, r$1);
						const l$1 = e$1.segment.vertexLength;
						this.indexArray.emplaceBack(l$1, l$1 + 2, l$1 + 1), this.indexArray.emplaceBack(l$1 + 1, l$1 + 2, l$1 + 3), e$1.segment.vertexLength += 4, e$1.segment.primitiveLength += 2;
					}
				}
			}
			function Lu$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					r$1 === e$1.length - 1 && e$1[0].x === n$1.x && e$1[0].y === n$1.y || (t$1.x += n$1.x, t$1.y += n$1.y, t$1.sampleCount++);
				}
			}
			function Ou$1(t$1, e$1) {
				return t$1.x === e$1.x && (t$1.x < 0 || t$1.x > M$1) || t$1.y === e$1.y && (t$1.y < 0 || t$1.y > M$1);
			}
			function Ru$1(t$1) {
				return t$1.every(((t$2) => t$2.x < 0)) || t$1.every(((t$2) => t$2.x > M$1)) || t$1.every(((t$2) => t$2.y < 0)) || t$1.every(((t$2) => t$2.y > M$1));
			}
			let Nu$1;
			us$1("FillExtrusionBucket", Cu$1, { omit: ["layers", "features"] });
			var $u$1 = { get paint() {
				return Nu$1 = Nu$1 || new Xs$1({
					"fill-extrusion-opacity": new $s$1(vt$1["paint_fill-extrusion"]["fill-extrusion-opacity"]),
					"fill-extrusion-color": new Us$1(vt$1["paint_fill-extrusion"]["fill-extrusion-color"]),
					"fill-extrusion-translate": new $s$1(vt$1["paint_fill-extrusion"]["fill-extrusion-translate"]),
					"fill-extrusion-translate-anchor": new $s$1(vt$1["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
					"fill-extrusion-pattern": new qs$1(vt$1["paint_fill-extrusion"]["fill-extrusion-pattern"]),
					"fill-extrusion-height": new Us$1(vt$1["paint_fill-extrusion"]["fill-extrusion-height"]),
					"fill-extrusion-base": new Us$1(vt$1["paint_fill-extrusion"]["fill-extrusion-base"]),
					"fill-extrusion-vertical-gradient": new $s$1(vt$1["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
				});
			} };
			class Uu$1 extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, $u$1, e$1);
				}
				createBucket(t$1) {
					return new Cu$1(t$1);
				}
				queryRadius() {
					return tl$1(this.paint.get("fill-extrusion-translate"));
				}
				is3D() {
					return !0;
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: o, pixelPosMatrix: a$1 }) {
					const l$1 = el$1(t$1, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -s$1.bearingInRadians, o), u$1 = this.paint.get("fill-extrusion-height").evaluate(e$1, n$1), c$1 = this.paint.get("fill-extrusion-base").evaluate(e$1, n$1), h$1 = function(t$2, e$2) {
						const n$2 = [];
						for (const i$2 of t$2) {
							const t$3 = [
								i$2.x,
								i$2.y,
								0,
								1
							];
							S$1(t$3, t$3, e$2), n$2.push(new r(t$3[0] / t$3[3], t$3[1] / t$3[3]));
						}
						return n$2;
					}(l$1, a$1), p$1 = function(t$2, e$2, n$2, i$2) {
						const s$2 = [], o$1 = [], a$2 = i$2[8] * e$2, l$2 = i$2[9] * e$2, u$2 = i$2[10] * e$2, c$2 = i$2[11] * e$2, h$2 = i$2[8] * n$2, p$2 = i$2[9] * n$2, f$1 = i$2[10] * n$2, d$1 = i$2[11] * n$2;
						for (const e$3 of t$2) {
							const t$3 = [], n$3 = [];
							for (const s$3 of e$3) {
								const e$4 = s$3.x, o$2 = s$3.y, y$1 = i$2[0] * e$4 + i$2[4] * o$2 + i$2[12], m$1 = i$2[1] * e$4 + i$2[5] * o$2 + i$2[13], g$2 = i$2[2] * e$4 + i$2[6] * o$2 + i$2[14], x$1 = i$2[3] * e$4 + i$2[7] * o$2 + i$2[15], v$1 = g$2 + u$2, b$1 = x$1 + c$2, w$2 = y$1 + h$2, _$2 = m$1 + p$2, A$2 = g$2 + f$1, S$2 = x$1 + d$1, k$2 = new r((y$1 + a$2) / b$1, (m$1 + l$2) / b$1);
								k$2.z = v$1 / b$1, t$3.push(k$2);
								const E$1 = new r(w$2 / S$2, _$2 / S$2);
								E$1.z = A$2 / S$2, n$3.push(E$1);
							}
							s$2.push(t$3), o$1.push(n$3);
						}
						return [s$2, o$1];
					}(i$1, c$1, u$1, a$1);
					return function(t$2, e$2, r$1) {
						let n$2 = Infinity;
						ja$1(r$1, e$2) && (n$2 = ju$1(r$1, e$2[0]));
						for (let i$2 = 0; i$2 < e$2.length; i$2++) {
							const s$2 = e$2[i$2], o$1 = t$2[i$2];
							for (let t$3 = 0; t$3 < s$2.length - 1; t$3++) {
								const e$3 = s$2[t$3], i$3 = [
									e$3,
									s$2[t$3 + 1],
									o$1[t$3 + 1],
									o$1[t$3],
									e$3
								];
								Ua$1(r$1, i$3) && (n$2 = Math.min(n$2, ju$1(r$1, i$3)));
							}
						}
						return n$2 !== Infinity && n$2;
					}(p$1[0], p$1[1], h$1);
				}
			}
			function qu$1(t$1, e$1) {
				return t$1.x * e$1.x + t$1.y * e$1.y;
			}
			function ju$1(t$1, e$1) {
				if (1 === t$1.length) {
					let r$1 = 0;
					const n$1 = e$1[r$1++];
					let i$1;
					for (; !i$1 || n$1.equals(i$1);) if (i$1 = e$1[r$1++], !i$1) return Infinity;
					for (; r$1 < e$1.length; r$1++) {
						const s$1 = e$1[r$1], o = t$1[0], a$1 = i$1.sub(n$1), l$1 = s$1.sub(n$1), u$1 = o.sub(n$1), c$1 = qu$1(a$1, a$1), h$1 = qu$1(a$1, l$1), p$1 = qu$1(l$1, l$1), f$1 = qu$1(u$1, a$1), d$1 = qu$1(u$1, l$1), y$1 = c$1 * p$1 - h$1 * h$1, m$1 = (p$1 * f$1 - h$1 * d$1) / y$1, g$2 = (c$1 * d$1 - h$1 * f$1) / y$1, x$1 = n$1.z * (1 - m$1 - g$2) + i$1.z * m$1 + s$1.z * g$2;
						if (isFinite(x$1)) return x$1;
					}
					return Infinity;
				}
				{
					let t$2 = Infinity;
					for (const r$1 of e$1) t$2 = Math.min(t$2, r$1.z);
					return t$2;
				}
			}
			const { members: Xu$1 } = to$1([{
				name: "a_pos_normal",
				components: 2,
				type: "Int16"
			}, {
				name: "a_data",
				components: 4,
				type: "Uint8"
			}], 4), { members: Zu$1 } = to$1([{
				name: "a_uv_x",
				components: 1,
				type: "Float32"
			}, {
				name: "a_split_index",
				components: 1,
				type: "Float32"
			}]), Hu$1 = Math.cos(Math.PI / 180 * 37.5), Ku$1 = Math.pow(2, 14) / .5;
			class Wu$1 {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((t$2) => {
						this.gradients[t$2.id] = {};
					})), this.layoutVertexArray = new qo$1(), this.layoutVertexArray2 = new jo$1(), this.indexArray = new Jo$1(), this.programConfigurations = new Pa$1(t$1.layers, t$1.zoom), this.segments = new ra$1(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasDependencies = Vl$1("line", this.layers, e$1) || this.hasLineDasharray(this.layers);
					const n$1 = this.layers[0].layout.get("line-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: e$2, id: o, index: a$1, sourceLayerIndex: l$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = Oa$1(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Fs$1(this.zoom), u$1, r$1)) continue;
						const c$1 = i$1 ? n$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: o,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$1,
							index: a$1,
							geometry: t$2 ? u$1.geometry : La$1(e$2),
							patterns: {},
							dashes: {},
							sortKey: c$1
						};
						s$1.push(h$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: o } = n$2;
						this.hasDependencies ? (Vl$1("line", this.layers, e$1) ? Cl$1("line", this.layers, n$2, { zoom: this.zoom }, e$1) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, n$2, this.zoom, e$1), this.patternFeatures.push(n$2)) : this.addFeature(n$2, i$2, s$2, r$1, {}, {}, e$1.subdivisionGranularity), e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, o, this.index);
					}
				}
				update(t$1, e$1, r$1, n$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, {
						imagePositions: r$1,
						dashPositions: n$1
					});
				}
				addFeatures(t$1, e$1, r$1, n$1) {
					for (const i$1 of this.patternFeatures) this.addFeature(i$1, i$1.geometry, i$1.index, e$1, r$1, n$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t$1.createVertexBuffer(this.layoutVertexArray2, Zu$1)), this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Xu$1), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				lineFeatureClips(t$1) {
					if (t$1.properties && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_end")) return {
						start: +t$1.properties.mapbox_clip_start,
						end: +t$1.properties.mapbox_clip_end
					};
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					const a$1 = this.layers[0].layout, l$1 = a$1.get("line-join").evaluate(t$1, {}), u$1 = a$1.get("line-cap"), c$1 = a$1.get("line-miter-limit"), h$1 = a$1.get("line-round-limit");
					this.lineClips = this.lineFeatureClips(t$1);
					for (const r$2 of e$1) this.addLine(r$2, t$1, l$1, u$1, c$1, h$1, n$1, o);
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						dashPositions: s$1,
						canonical: n$1
					});
				}
				addLine(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
					if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t$1 = du$1(t$1, o ? a$1.line.getGranularityForZoomLevel(o.z) : 1), this.lineClips) {
						this.lineClipsArray.push(this.lineClips);
						for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) this.totalDistance += t$1[e$2].dist(t$1[e$2 + 1]);
						this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
					}
					const l$1 = "Polygon" === Eu$1.types[e$1.type];
					let u$1 = t$1.length;
					for (; u$1 >= 2 && t$1[u$1 - 1].equals(t$1[u$1 - 2]);) u$1--;
					let c$1 = 0;
					for (; c$1 < u$1 - 1 && t$1[c$1].equals(t$1[c$1 + 1]);) c$1++;
					if (u$1 < (l$1 ? 3 : 2)) return;
					"bevel" === r$1 && (i$1 = 1.05);
					const h$1 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p$1 = this.segments.prepareSegment(10 * u$1, this.layoutVertexArray, this.indexArray);
					let f$1, d$1, y$1, m$1, g$2;
					this.e1 = this.e2 = -1, l$1 && (f$1 = t$1[u$1 - 2], g$2 = t$1[c$1].sub(f$1)._unit()._perp());
					for (let e$2 = c$1; e$2 < u$1; e$2++) {
						if (y$1 = e$2 === u$1 - 1 ? l$1 ? t$1[c$1 + 1] : void 0 : t$1[e$2 + 1], y$1 && t$1[e$2].equals(y$1)) continue;
						g$2 && (m$1 = g$2), f$1 && (d$1 = f$1), f$1 = t$1[e$2], g$2 = y$1 ? y$1.sub(f$1)._unit()._perp() : m$1, m$1 = m$1 || g$2;
						let o$1 = m$1.add(g$2);
						0 === o$1.x && 0 === o$1.y || o$1._unit();
						const a$2 = m$1.x * g$2.x + m$1.y * g$2.y, x$1 = o$1.x * g$2.x + o$1.y * g$2.y, v$1 = 0 !== x$1 ? 1 / x$1 : Infinity, b$1 = 2 * Math.sqrt(2 - 2 * x$1), w$2 = x$1 < Hu$1 && d$1 && y$1, _$2 = m$1.x * g$2.y - m$1.y * g$2.x > 0;
						if (w$2 && e$2 > c$1) {
							const t$2 = f$1.dist(d$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.sub(f$1.sub(d$1)._mult(h$1 / t$2)._round());
								this.updateDistance(d$1, e$3), this.addCurrentVertex(e$3, m$1, 0, 0, p$1), d$1 = e$3;
							}
						}
						const A$2 = d$1 && y$1;
						let S$2 = A$2 ? r$1 : l$1 ? "butt" : n$1;
						if (A$2 && "round" === S$2 && (v$1 < s$1 ? S$2 = "miter" : v$1 <= 2 && (S$2 = "fakeround")), "miter" === S$2 && v$1 > i$1 && (S$2 = "bevel"), "bevel" === S$2 && (v$1 > 2 && (S$2 = "flipbevel"), v$1 < i$1 && (S$2 = "miter")), d$1 && this.updateDistance(d$1, f$1), "miter" === S$2) o$1._mult(v$1), this.addCurrentVertex(f$1, o$1, 0, 0, p$1);
						else if ("flipbevel" === S$2) {
							if (v$1 > 100) o$1 = g$2.mult(-1);
							else {
								const t$2 = v$1 * m$1.add(g$2).mag() / m$1.sub(g$2).mag();
								o$1._perp()._mult(t$2 * (_$2 ? -1 : 1));
							}
							this.addCurrentVertex(f$1, o$1, 0, 0, p$1), this.addCurrentVertex(f$1, o$1.mult(-1), 0, 0, p$1);
						} else if ("bevel" === S$2 || "fakeround" === S$2) {
							const t$2 = -Math.sqrt(v$1 * v$1 - 1), e$3 = _$2 ? t$2 : 0, r$2 = _$2 ? 0 : t$2;
							if (d$1 && this.addCurrentVertex(f$1, m$1, e$3, r$2, p$1), "fakeround" === S$2) {
								const t$3 = Math.round(180 * b$1 / Math.PI / 20);
								for (let e$4 = 1; e$4 < t$3; e$4++) {
									let r$3 = e$4 / t$3;
									if (.5 !== r$3) {
										const t$4 = r$3 - .5;
										r$3 += r$3 * t$4 * (r$3 - 1) * ((1.0904 + a$2 * (a$2 * (3.55645 - 1.43519 * a$2) - 3.2452)) * t$4 * t$4 + (.848013 + a$2 * (.215638 * a$2 - 1.06021)));
									}
									const n$2 = g$2.sub(m$1)._mult(r$3)._add(m$1)._unit()._mult(_$2 ? -1 : 1);
									this.addHalfVertex(f$1, n$2.x, n$2.y, !1, _$2, 0, p$1);
								}
							}
							y$1 && this.addCurrentVertex(f$1, g$2, -e$3, -r$2, p$1);
						} else if ("butt" === S$2) this.addCurrentVertex(f$1, o$1, 0, 0, p$1);
						else if ("square" === S$2) {
							const t$2 = d$1 ? 1 : -1;
							this.addCurrentVertex(f$1, o$1, t$2, t$2, p$1);
						} else "round" === S$2 && (d$1 && (this.addCurrentVertex(f$1, m$1, 0, 0, p$1), this.addCurrentVertex(f$1, m$1, 1, 1, p$1, !0)), y$1 && (this.addCurrentVertex(f$1, g$2, -1, -1, p$1, !0), this.addCurrentVertex(f$1, g$2, 0, 0, p$1)));
						if (w$2 && e$2 < u$1 - 1) {
							const t$2 = f$1.dist(y$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.add(y$1.sub(f$1)._mult(h$1 / t$2)._round());
								this.updateDistance(f$1, e$3), this.addCurrentVertex(e$3, g$2, 0, 0, p$1), f$1 = e$3;
							}
						}
					}
				}
				addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1 = !1) {
					const o = e$1.y * n$1 - e$1.x, a$1 = -e$1.y - e$1.x * n$1;
					this.addHalfVertex(t$1, e$1.x + e$1.y * r$1, e$1.y - e$1.x * r$1, s$1, !1, r$1, i$1), this.addHalfVertex(t$1, o, a$1, s$1, !0, -n$1, i$1), this.distance > Ku$1 / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1));
				}
				addHalfVertex({ x: t$1, y: e$1 }, r$1, n$1, i$1, s$1, o, a$1) {
					const l$1 = .5 * (this.lineClips ? this.scaledDistance * (Ku$1 - 1) : this.scaledDistance);
					this.layoutVertexArray.emplaceBack((t$1 << 1) + (i$1 ? 1 : 0), (e$1 << 1) + (s$1 ? 1 : 0), Math.round(63 * r$1) + 128, Math.round(63 * n$1) + 128, 1 + (0 === o ? 0 : o < 0 ? -1 : 1) | (63 & l$1) << 2, l$1 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
					const u$1 = a$1.vertexLength++;
					this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u$1, this.e2), a$1.primitiveLength++), s$1 ? this.e2 = u$1 : this.e1 = u$1;
				}
				updateScaledDistance() {
					this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
				}
				updateDistance(t$1, e$1) {
					this.distance += t$1.dist(e$1), this.updateScaledDistance();
				}
				hasLineDasharray(t$1) {
					for (const e$1 of t$1) {
						const t$2 = e$1.paint.get("line-dasharray");
						if (t$2 && !t$2.isConstant()) return !0;
					}
					return !1;
				}
				addLineDashDependencies(t$1, e$1, r$1, n$1) {
					for (const i$1 of t$1) {
						const t$2 = i$1.paint.get("line-dasharray");
						if (!t$2 || "constant" === t$2.value.kind) continue;
						const s$1 = "round" === i$1.layout.get("line-cap"), o = {
							dasharray: t$2.value.evaluate({ zoom: r$1 - 1 }, e$1, {}),
							round: s$1
						}, a$1 = {
							dasharray: t$2.value.evaluate({ zoom: r$1 }, e$1, {}),
							round: s$1
						}, l$1 = {
							dasharray: t$2.value.evaluate({ zoom: r$1 + 1 }, e$1, {}),
							round: s$1
						}, u$1 = `${o.dasharray.join(",")},${o.round}`, c$1 = `${a$1.dasharray.join(",")},${a$1.round}`, h$1 = `${l$1.dasharray.join(",")},${l$1.round}`;
						n$1.dashDependencies[u$1] = o, n$1.dashDependencies[c$1] = a$1, n$1.dashDependencies[h$1] = l$1, e$1.dashes[i$1.id] = {
							min: u$1,
							mid: c$1,
							max: h$1
						};
					}
				}
			}
			let Ju$1, Qu$1;
			us$1("LineBucket", Wu$1, { omit: ["layers", "patternFeatures"] });
			var tc$1 = {
				get paint() {
					return Qu$1 = Qu$1 || new Xs$1({
						"line-opacity": new Us$1(vt$1.paint_line["line-opacity"]),
						"line-color": new Us$1(vt$1.paint_line["line-color"]),
						"line-translate": new $s$1(vt$1.paint_line["line-translate"]),
						"line-translate-anchor": new $s$1(vt$1.paint_line["line-translate-anchor"]),
						"line-width": new Us$1(vt$1.paint_line["line-width"]),
						"line-gap-width": new Us$1(vt$1.paint_line["line-gap-width"]),
						"line-offset": new Us$1(vt$1.paint_line["line-offset"]),
						"line-blur": new Us$1(vt$1.paint_line["line-blur"]),
						"line-dasharray": new qs$1(vt$1.paint_line["line-dasharray"]),
						"line-pattern": new qs$1(vt$1.paint_line["line-pattern"]),
						"line-gradient": new Gs$1(vt$1.paint_line["line-gradient"])
					});
				},
				get layout() {
					return Ju$1 = Ju$1 || new Xs$1({
						"line-cap": new $s$1(vt$1.layout_line["line-cap"]),
						"line-join": new Us$1(vt$1.layout_line["line-join"]),
						"line-miter-limit": new $s$1(vt$1.layout_line["line-miter-limit"]),
						"line-round-limit": new $s$1(vt$1.layout_line["line-round-limit"]),
						"line-sort-key": new Us$1(vt$1.layout_line["line-sort-key"])
					});
				}
			};
			class ec$1 extends Us$1 {
				possiblyEvaluate(t$1, e$1) {
					return e$1 = new Fs$1(Math.floor(e$1.zoom), {
						now: e$1.now,
						fadeDuration: e$1.fadeDuration,
						zoomHistory: e$1.zoomHistory,
						transition: e$1.transition
					}), super.possiblyEvaluate(t$1, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return e$1 = O$1({}, e$1, { zoom: Math.floor(e$1.zoom) }), super.evaluate(t$1, e$1, r$1, n$1);
				}
			}
			let rc$1;
			class nc$1 extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, tc$1, e$1), this.gradientVersion = 0, rc$1 || (rc$1 = new ec$1(tc$1.paint.properties["line-width"].specification), rc$1.useIntegerZoom = !0);
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					if ("line-gradient" === t$1) {
						const t$2 = this.gradientExpression();
						this.stepInterpolant = !!function(t$3) {
							return void 0 !== t$3._styleExpression;
						}(t$2) && t$2._styleExpression.expression instanceof ar$1, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
					}
				}
				gradientExpression() {
					return this._transitionablePaint._values["line-gradient"].value.expression;
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1), this.paint._values["line-floorwidth"] = rc$1.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t$1);
				}
				createBucket(t$1) {
					return new Wu$1(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1, r$1 = ic$1(Qa("line-width", this, e$1), Qa("line-gap-width", this, e$1)), n$1 = Qa("line-offset", this, e$1);
					return r$1 / 2 + Math.abs(n$1) + tl$1(this.paint.get("line-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: o }) {
					const a$1 = el$1(t$1, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -s$1.bearingInRadians, o), l$1 = o / 2 * ic$1(this.paint.get("line-width").evaluate(e$1, n$1), this.paint.get("line-gap-width").evaluate(e$1, n$1)), u$1 = this.paint.get("line-offset").evaluate(e$1, n$1);
					return u$1 && (i$1 = function(t$2, e$2) {
						const n$2 = [];
						for (let i$2 = 0; i$2 < t$2.length; i$2++) {
							const s$2 = rl$1(t$2[i$2]), o$1 = [];
							for (let t$3 = 0; t$3 < s$2.length; t$3++) {
								const n$3 = s$2[t$3], i$3 = s$2[t$3 - 1], a$2 = s$2[t$3 + 1], l$2 = 0 === t$3 ? new r(0, 0) : n$3.sub(i$3)._unit()._perp(), u$2 = t$3 === s$2.length - 1 ? new r(0, 0) : a$2.sub(n$3)._unit()._perp(), c$1 = l$2._add(u$2)._unit(), h$1 = c$1.x * u$2.x + c$1.y * u$2.y;
								0 !== h$1 && c$1._mult(1 / h$1), o$1.push(c$1._mult(e$2)._add(n$3));
							}
							n$2.push(o$1);
						}
						return n$2;
					}(i$1, u$1 * o)), function(t$2, e$2, r$1) {
						for (let n$2 = 0; n$2 < e$2.length; n$2++) {
							const i$2 = e$2[n$2];
							if (t$2.length >= 3) {
								for (let e$3 = 0; e$3 < i$2.length; e$3++) if (Wa$1(t$2, i$2[e$3])) return !0;
							}
							if (Ga$1(t$2, i$2, r$1)) return !0;
						}
						return !1;
					}(a$1, i$1, l$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			function ic$1(t$1, e$1) {
				return e$1 > 0 ? e$1 + 2 * t$1 : t$1;
			}
			const sc$1 = to$1([
				{
					name: "a_pos_offset",
					components: 4,
					type: "Int16"
				},
				{
					name: "a_data",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixeloffset",
					components: 4,
					type: "Int16"
				}
			], 4), oc$1 = to$1([{
				name: "a_projected_pos",
				components: 3,
				type: "Float32"
			}], 4);
			to$1([{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint32"
			}], 4);
			const ac$1 = to$1([
				{
					name: "a_placed",
					components: 2,
					type: "Uint8"
				},
				{
					name: "a_shift",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_box_real",
					components: 2,
					type: "Int16"
				}
			]);
			to$1([
				{
					type: "Int16",
					name: "anchorPointX"
				},
				{
					type: "Int16",
					name: "anchorPointY"
				},
				{
					type: "Int16",
					name: "x1"
				},
				{
					type: "Int16",
					name: "y1"
				},
				{
					type: "Int16",
					name: "x2"
				},
				{
					type: "Int16",
					name: "y2"
				},
				{
					type: "Uint32",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "sourceLayerIndex"
				},
				{
					type: "Uint16",
					name: "bucketIndex"
				}
			]);
			const lc$1 = to$1([
				{
					name: "a_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_anchor_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_extrude",
					components: 2,
					type: "Int16"
				}
			], 4), uc$1 = to$1([
				{
					name: "a_pos",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_radius",
					components: 1,
					type: "Float32"
				},
				{
					name: "a_flags",
					components: 2,
					type: "Int16"
				}
			], 4);
			function cc$1(t$1, e$1, r$1) {
				return t$1.sections.forEach(((t$2) => {
					t$2.text = function(t$3, e$2, r$2) {
						const n$1 = e$2.layout.get("text-transform").evaluate(r$2, {});
						return "uppercase" === n$1 ? t$3 = t$3.toLocaleUpperCase() : "lowercase" === n$1 && (t$3 = t$3.toLocaleLowerCase()), Ms$1.applyArabicShaping && (t$3 = Ms$1.applyArabicShaping(t$3)), t$3;
					}(t$2.text, e$1, r$1);
				})), t$1;
			}
			to$1([{
				name: "triangle",
				components: 3,
				type: "Uint16"
			}]), to$1([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Uint16",
					name: "glyphStartIndex"
				},
				{
					type: "Uint16",
					name: "numGlyphs"
				},
				{
					type: "Uint32",
					name: "vertexStartIndex"
				},
				{
					type: "Uint32",
					name: "lineStartIndex"
				},
				{
					type: "Uint32",
					name: "lineLength"
				},
				{
					type: "Uint16",
					name: "segment"
				},
				{
					type: "Uint16",
					name: "lowerSize"
				},
				{
					type: "Uint16",
					name: "upperSize"
				},
				{
					type: "Float32",
					name: "lineOffsetX"
				},
				{
					type: "Float32",
					name: "lineOffsetY"
				},
				{
					type: "Uint8",
					name: "writingMode"
				},
				{
					type: "Uint8",
					name: "placedOrientation"
				},
				{
					type: "Uint8",
					name: "hidden"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Int16",
					name: "associatedIconIndex"
				}
			]), to$1([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Int16",
					name: "rightJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "centerJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "leftJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "placedIconSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedIconSymbolIndex"
				},
				{
					type: "Uint16",
					name: "key"
				},
				{
					type: "Uint16",
					name: "textBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "textBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "numHorizontalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numIconVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalIconVertices"
				},
				{
					type: "Uint16",
					name: "useRuntimeCollisionCircles"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Float32",
					name: "textBoxScale"
				},
				{
					type: "Float32",
					name: "collisionCircleDiameter"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetStartIndex"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetEndIndex"
				}
			]), to$1([{
				type: "Float32",
				name: "offsetX"
			}]), to$1([
				{
					type: "Int16",
					name: "x"
				},
				{
					type: "Int16",
					name: "y"
				},
				{
					type: "Int16",
					name: "tileUnitDistanceFromAnchor"
				}
			]), to$1([{
				type: "Uint16",
				name: "textAnchor"
			}, {
				type: "Float32",
				components: 2,
				name: "textOffset"
			}]);
			var hc$1 = 24;
			const pc$1 = {
				"!": "",
				"#": "",
				$: "",
				"%": "",
				"&": "",
				"(": "",
				")": "",
				"*": "",
				"+": "",
				",": "",
				"-": "",
				".": "",
				"/": "",
				":": "",
				";": "",
				"<": "",
				"=": "",
				">": "",
				"?": "",
				"@": "",
				"[": "",
				"\\": "",
				"]": "",
				"^": "",
				_: "",
				"`": "",
				"{": "",
				"|": "",
				"}": "",
				"~": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": ""
			}, fc$1 = {
				10: !0,
				32: !0,
				38: !0,
				41: !0,
				43: !0,
				45: !0,
				47: !0,
				173: !0,
				183: !0,
				8203: !0,
				8208: !0,
				8211: !0,
				8231: !0
			}, dc$1 = { 40: !0 };
			function yc$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				if ("fontStack" in e$1) {
					const n$2 = r$1[e$1.fontStack], s$2 = n$2 && n$2[t$1];
					return s$2 ? s$2.metrics.advance * e$1.scale + i$1 : 0;
				}
				{
					const t$2 = n$1[e$1.imageName];
					return t$2 ? t$2.displaySize[0] * e$1.scale * hc$1 / s$1 + i$1 : 0;
				}
			}
			function mc$1(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(t$1 - e$1, 2);
				return n$1 ? t$1 < e$1 ? i$1 / 2 : 2 * i$1 : i$1 + Math.abs(r$1) * r$1;
			}
			function gc$1(t$1, e$1, r$1) {
				let n$1 = 0;
				return 10 === t$1 && (n$1 -= 1e4), r$1 && (n$1 += 150), 40 !== t$1 && 65288 !== t$1 || (n$1 += 50), 41 !== e$1 && 65289 !== e$1 || (n$1 += 50), n$1;
			}
			function xc$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				let o = null, a$1 = mc$1(e$1, r$1, i$1, s$1);
				for (const t$2 of n$1) {
					const n$2 = mc$1(e$1 - t$2.x, r$1, i$1, s$1) + t$2.badness;
					n$2 <= a$1 && (o = t$2, a$1 = n$2);
				}
				return {
					index: t$1,
					x: e$1,
					priorBreak: o,
					badness: a$1
				};
			}
			function vc$1(t$1) {
				return t$1 ? vc$1(t$1.priorBreak).concat(t$1.index) : [];
			}
			class bc$1 {
				constructor(t$1 = "", e$1 = [], r$1 = []) {
					this.text = t$1, this.sections = e$1, this.sectionIndex = r$1, this.imageSectionID = null;
				}
				static fromFeature(t$1, e$1) {
					const r$1 = new bc$1();
					for (let n$1 = 0; n$1 < t$1.sections.length; n$1++) {
						const i$1 = t$1.sections[n$1];
						i$1.image ? r$1.addImageSection(i$1) : r$1.addTextSection(i$1, e$1);
					}
					return r$1;
				}
				length() {
					return [...this.text].length;
				}
				getSection(t$1) {
					return this.sections[this.sectionIndex[t$1]];
				}
				getSectionIndex(t$1) {
					return this.sectionIndex[t$1];
				}
				verticalizePunctuation() {
					this.text = function(t$1) {
						let e$1 = "", r$1 = {
							premature: !0,
							value: void 0
						};
						const n$1 = t$1[Symbol.iterator]();
						let i$1 = n$1.next();
						const s$1 = t$1[Symbol.iterator]();
						s$1.next();
						let o = s$1.next();
						for (; !i$1.done;) e$1 += !o.done && Ss$1(o.value.codePointAt(0)) && !pc$1[o.value] || !r$1.premature && Ss$1(r$1.value.codePointAt(0)) && !pc$1[r$1.value] || !pc$1[i$1.value] ? i$1.value : pc$1[i$1.value], r$1 = {
							value: i$1.value,
							premature: !1
						}, i$1 = n$1.next(), o = s$1.next();
						return e$1;
					}(this.text);
				}
				hasZeroWidthSpaces() {
					return this.text.includes("");
				}
				trim() {
					const t$1 = this.text.match(/^\s*/), e$1 = t$1 ? t$1[0].length : 0, r$1 = this.text.match(/\S\s*$/), n$1 = r$1 ? r$1[0].length - 1 : 0;
					this.text = this.text.substring(e$1, this.text.length - n$1), this.sectionIndex = this.sectionIndex.slice(e$1, this.sectionIndex.length - n$1);
				}
				substring(t$1, e$1) {
					const r$1 = [...this.text].slice(t$1, e$1).join(""), n$1 = this.sectionIndex.slice(t$1, e$1);
					return new bc$1(r$1, this.sections, n$1);
				}
				toCodeUnitIndex(t$1) {
					return [...this.text].slice(0, t$1).join("").length;
				}
				toString() {
					return this.text;
				}
				getMaxScale() {
					return this.sectionIndex.reduce(((t$1, e$1) => Math.max(t$1, this.sections[e$1].scale)), 0);
				}
				getMaxImageSize(t$1) {
					let e$1 = 0, r$1 = 0;
					for (let n$1 = 0; n$1 < this.length(); n$1++) {
						const i$1 = this.getSection(n$1);
						if ("imageName" in i$1) {
							const n$2 = t$1[i$1.imageName];
							if (!n$2) continue;
							const s$1 = n$2.displaySize;
							e$1 = Math.max(e$1, s$1[0]), r$1 = Math.max(r$1, s$1[1]);
						}
					}
					return {
						maxImageWidth: e$1,
						maxImageHeight: r$1
					};
				}
				addTextSection(t$1, e$1) {
					this.text += t$1.text, this.sections.push({
						scale: t$1.scale || 1,
						verticalAlign: t$1.verticalAlign || "bottom",
						fontStack: t$1.fontStack || e$1
					});
					const r$1 = this.sections.length - 1;
					this.sectionIndex.push(...[...t$1.text].map((() => r$1)));
				}
				addImageSection(t$1) {
					const e$1 = t$1.image ? t$1.image.name : "";
					if (0 === e$1.length) return void j$1("Can't add FormattedSection with an empty image.");
					const r$1 = this.getNextImageSectionCharCode();
					r$1 ? (this.text += String.fromCharCode(r$1), this.sections.push({
						scale: 1,
						verticalAlign: t$1.verticalAlign || "bottom",
						imageName: e$1
					}), this.sectionIndex.push(this.sections.length - 1)) : j$1("Reached maximum number of images 6401");
				}
				getNextImageSectionCharCode() {
					return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
				}
				determineLineBreaks(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = [], o = this.determineAverageLineWidth(t$1, e$1, r$1, n$1, i$1), a$1 = this.hasZeroWidthSpaces();
					let l$1 = 0, u$1 = 0;
					const c$1 = this.text[Symbol.iterator]();
					let h$1 = c$1.next();
					const p$1 = this.text[Symbol.iterator]();
					p$1.next();
					let f$1 = p$1.next();
					const d$1 = this.text[Symbol.iterator]();
					d$1.next(), d$1.next();
					let y$1 = d$1.next();
					for (; !h$1.done;) {
						const e$2 = this.getSection(u$1), m$1 = h$1.value.codePointAt(0);
						if (xs$1(m$1) || (l$1 += yc$1(m$1, e$2, r$1, n$1, t$1, i$1)), !f$1.done) {
							const t$2 = ms$1(m$1), r$2 = f$1.value.codePointAt(0);
							(fc$1[m$1] || t$2 || "imageName" in e$2 || !y$1.done && dc$1[r$2]) && s$1.push(xc$1(u$1 + 1, l$1, o, s$1, gc$1(m$1, r$2, t$2 && a$1), !1));
						}
						u$1++, h$1 = c$1.next(), f$1 = p$1.next(), y$1 = d$1.next();
					}
					return vc$1(xc$1(this.length(), l$1, o, s$1, 0, !0));
				}
				determineAverageLineWidth(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = 0, o = 0;
					for (const e$2 of this.text) {
						const a$1 = this.getSection(o);
						s$1 += yc$1(e$2.codePointAt(0), a$1, r$1, n$1, t$1, i$1), o++;
					}
					return s$1 / Math.max(1, Math.ceil(s$1 / e$1));
				}
			}
			const wc$1 = 4294967296, _c$1 = 1 / wc$1, Ac$1 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
			class Sc$1 {
				constructor(t$1 = new Uint8Array(16)) {
					this.buf = ArrayBuffer.isView(t$1) ? t$1 : new Uint8Array(t$1), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
				}
				readFields(t$1, e$1, r$1 = this.length) {
					for (; this.pos < r$1;) {
						const r$2 = this.readVarint(), n$1 = r$2 >> 3, i$1 = this.pos;
						this.type = 7 & r$2, t$1(n$1, e$1, this), this.pos === i$1 && this.skip(r$2);
					}
					return e$1;
				}
				readMessage(t$1, e$1) {
					return this.readFields(t$1, e$1, this.readVarint() + this.pos);
				}
				readFixed32() {
					const t$1 = this.dataView.getUint32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readSFixed32() {
					const t$1 = this.dataView.getInt32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * wc$1;
					return this.pos += 8, t$1;
				}
				readSFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * wc$1;
					return this.pos += 8, t$1;
				}
				readFloat() {
					const t$1 = this.dataView.getFloat32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readDouble() {
					const t$1 = this.dataView.getFloat64(this.pos, !0);
					return this.pos += 8, t$1;
				}
				readVarint(t$1) {
					const e$1 = this.buf;
					let r$1, n$1;
					return n$1 = e$1[this.pos++], r$1 = 127 & n$1, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 7, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 14, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 21, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos], r$1 |= (15 & n$1) << 28, function(t$2, e$2, r$2) {
						const n$2 = r$2.buf;
						let i$1, s$1;
						if (s$1 = n$2[r$2.pos++], i$1 = (112 & s$1) >> 4, s$1 < 128) return kc$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 3, s$1 < 128) return kc$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 10, s$1 < 128) return kc$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 17, s$1 < 128) return kc$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 24, s$1 < 128) return kc$1(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (1 & s$1) << 31, s$1 < 128) return kc$1(t$2, i$1, e$2);
						throw new Error("Expected varint not more than 10 bytes");
					}(r$1, t$1, this)))));
				}
				readVarint64() {
					return this.readVarint(!0);
				}
				readSVarint() {
					const t$1 = this.readVarint();
					return t$1 % 2 == 1 ? (t$1 + 1) / -2 : t$1 / 2;
				}
				readBoolean() {
					return Boolean(this.readVarint());
				}
				readString() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.pos;
					return this.pos = t$1, t$1 - e$1 >= 12 && Ac$1 ? Ac$1.decode(this.buf.subarray(e$1, t$1)) : function(t$2, e$2, r$1) {
						let n$1 = "", i$1 = e$2;
						for (; i$1 < r$1;) {
							const e$3 = t$2[i$1];
							let s$1, o, a$1, l$1 = null, u$1 = e$3 > 239 ? 4 : e$3 > 223 ? 3 : e$3 > 191 ? 2 : 1;
							if (i$1 + u$1 > r$1) break;
							1 === u$1 ? e$3 < 128 && (l$1 = e$3) : 2 === u$1 ? (s$1 = t$2[i$1 + 1], 128 == (192 & s$1) && (l$1 = (31 & e$3) << 6 | 63 & s$1, l$1 <= 127 && (l$1 = null))) : 3 === u$1 ? (s$1 = t$2[i$1 + 1], o = t$2[i$1 + 2], 128 == (192 & s$1) && 128 == (192 & o) && (l$1 = (15 & e$3) << 12 | (63 & s$1) << 6 | 63 & o, (l$1 <= 2047 || l$1 >= 55296 && l$1 <= 57343) && (l$1 = null))) : 4 === u$1 && (s$1 = t$2[i$1 + 1], o = t$2[i$1 + 2], a$1 = t$2[i$1 + 3], 128 == (192 & s$1) && 128 == (192 & o) && 128 == (192 & a$1) && (l$1 = (15 & e$3) << 18 | (63 & s$1) << 12 | (63 & o) << 6 | 63 & a$1, (l$1 <= 65535 || l$1 >= 1114112) && (l$1 = null))), null === l$1 ? (l$1 = 65533, u$1 = 1) : l$1 > 65535 && (l$1 -= 65536, n$1 += String.fromCharCode(l$1 >>> 10 & 1023 | 55296), l$1 = 56320 | 1023 & l$1), n$1 += String.fromCharCode(l$1), i$1 += u$1;
						}
						return n$1;
					}(this.buf, e$1, t$1);
				}
				readBytes() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.buf.subarray(this.pos, t$1);
					return this.pos = t$1, e$1;
				}
				readPackedVarint(t$1 = [], e$1) {
					const r$1 = this.readPackedEnd();
					for (; this.pos < r$1;) t$1.push(this.readVarint(e$1));
					return t$1;
				}
				readPackedSVarint(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSVarint());
					return t$1;
				}
				readPackedBoolean(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readBoolean());
					return t$1;
				}
				readPackedFloat(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFloat());
					return t$1;
				}
				readPackedDouble(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readDouble());
					return t$1;
				}
				readPackedFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed32());
					return t$1;
				}
				readPackedSFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed32());
					return t$1;
				}
				readPackedFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed64());
					return t$1;
				}
				readPackedSFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed64());
					return t$1;
				}
				readPackedEnd() {
					return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
				}
				skip(t$1) {
					const e$1 = 7 & t$1;
					if (0 === e$1) for (; this.buf[this.pos++] > 127;);
					else if (2 === e$1) this.pos = this.readVarint() + this.pos;
					else if (5 === e$1) this.pos += 4;
					else {
						if (1 !== e$1) throw new Error(`Unimplemented type: ${e$1}`);
						this.pos += 8;
					}
				}
				writeTag(t$1, e$1) {
					this.writeVarint(t$1 << 3 | e$1);
				}
				realloc(t$1) {
					let e$1 = this.length || 16;
					for (; e$1 < this.pos + t$1;) e$1 *= 2;
					if (e$1 !== this.length) {
						const t$2 = new Uint8Array(e$1);
						t$2.set(this.buf), this.buf = t$2, this.dataView = new DataView(t$2.buffer), this.length = e$1;
					}
				}
				finish() {
					return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
				}
				writeFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeSFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * _c$1), !0), this.pos += 8;
				}
				writeSFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * _c$1), !0), this.pos += 8;
				}
				writeVarint(t$1) {
					(t$1 = +t$1 || 0) > 268435455 || t$1 < 0 ? function(t$2, e$1) {
						let r$1, n$1;
						if (t$2 >= 0 ? (r$1 = t$2 % 4294967296 | 0, n$1 = t$2 / 4294967296 | 0) : (r$1 = ~(-t$2 % 4294967296), n$1 = ~(-t$2 / 4294967296), 4294967295 ^ r$1 ? r$1 = r$1 + 1 | 0 : (r$1 = 0, n$1 = n$1 + 1 | 0)), t$2 >= 0x10000000000000000 || t$2 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
						e$1.realloc(10), function(t$3, e$2, r$2) {
							r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, r$2.buf[r$2.pos] = 127 & (t$3 >>>= 7);
						}(r$1, 0, e$1), function(t$3, e$2) {
							const r$2 = (7 & t$3) << 4;
							e$2.buf[e$2.pos++] |= r$2 | ((t$3 >>>= 3) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3)))));
						}(n$1, e$1);
					}(t$1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t$1 | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = t$1 >>> 7 & 127))));
				}
				writeSVarint(t$1) {
					this.writeVarint(t$1 < 0 ? 2 * -t$1 - 1 : 2 * t$1);
				}
				writeBoolean(t$1) {
					this.writeVarint(+t$1);
				}
				writeString(t$1) {
					t$1 = String(t$1), this.realloc(4 * t$1.length), this.pos++;
					const e$1 = this.pos;
					this.pos = function(t$2, e$2, r$2) {
						for (let n$1, i$1, s$1 = 0; s$1 < e$2.length; s$1++) {
							if (n$1 = e$2.charCodeAt(s$1), n$1 > 55295 && n$1 < 57344) {
								if (!i$1) {
									n$1 > 56319 || s$1 + 1 === e$2.length ? (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189) : i$1 = n$1;
									continue;
								}
								if (n$1 < 56320) {
									t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = n$1;
									continue;
								}
								n$1 = i$1 - 55296 << 10 | n$1 - 56320 | 65536, i$1 = null;
							} else i$1 && (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = null);
							n$1 < 128 ? t$2[r$2++] = n$1 : (n$1 < 2048 ? t$2[r$2++] = n$1 >> 6 | 192 : (n$1 < 65536 ? t$2[r$2++] = n$1 >> 12 | 224 : (t$2[r$2++] = n$1 >> 18 | 240, t$2[r$2++] = n$1 >> 12 & 63 | 128), t$2[r$2++] = n$1 >> 6 & 63 | 128), t$2[r$2++] = 63 & n$1 | 128);
						}
						return r$2;
					}(this.buf, t$1, this.pos);
					const r$1 = this.pos - e$1;
					r$1 >= 128 && Ec$1(e$1, r$1, this), this.pos = e$1 - 1, this.writeVarint(r$1), this.pos += r$1;
				}
				writeFloat(t$1) {
					this.realloc(4), this.dataView.setFloat32(this.pos, t$1, !0), this.pos += 4;
				}
				writeDouble(t$1) {
					this.realloc(8), this.dataView.setFloat64(this.pos, t$1, !0), this.pos += 8;
				}
				writeBytes(t$1) {
					const e$1 = t$1.length;
					this.writeVarint(e$1), this.realloc(e$1);
					for (let r$1 = 0; r$1 < e$1; r$1++) this.buf[this.pos++] = t$1[r$1];
				}
				writeRawMessage(t$1, e$1) {
					this.pos++;
					const r$1 = this.pos;
					t$1(e$1, this);
					const n$1 = this.pos - r$1;
					n$1 >= 128 && Ec$1(r$1, n$1, this), this.pos = r$1 - 1, this.writeVarint(n$1), this.pos += n$1;
				}
				writeMessage(t$1, e$1, r$1) {
					this.writeTag(t$1, 2), this.writeRawMessage(e$1, r$1);
				}
				writePackedVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Tc$1, e$1);
				}
				writePackedSVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Ic$1, e$1);
				}
				writePackedBoolean(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Dc$1, e$1);
				}
				writePackedFloat(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Mc$1, e$1);
				}
				writePackedDouble(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Fc$1, e$1);
				}
				writePackedFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Pc$1, e$1);
				}
				writePackedSFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, zc$1, e$1);
				}
				writePackedFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Bc$1, e$1);
				}
				writePackedSFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Vc$1, e$1);
				}
				writeBytesField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeBytes(e$1);
				}
				writeFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFixed32(e$1);
				}
				writeSFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeSFixed32(e$1);
				}
				writeFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeFixed64(e$1);
				}
				writeSFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeSFixed64(e$1);
				}
				writeVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeVarint(e$1);
				}
				writeSVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeSVarint(e$1);
				}
				writeStringField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeString(e$1);
				}
				writeFloatField(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFloat(e$1);
				}
				writeDoubleField(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeDouble(e$1);
				}
				writeBooleanField(t$1, e$1) {
					this.writeVarintField(t$1, +e$1);
				}
			}
			function kc$1(t$1, e$1, r$1) {
				return r$1 ? 4294967296 * e$1 + (t$1 >>> 0) : 4294967296 * (e$1 >>> 0) + (t$1 >>> 0);
			}
			function Ec$1(t$1, e$1, r$1) {
				const n$1 = e$1 <= 16383 ? 1 : e$1 <= 2097151 ? 2 : e$1 <= 268435455 ? 3 : Math.floor(Math.log(e$1) / (7 * Math.LN2));
				r$1.realloc(n$1);
				for (let e$2 = r$1.pos - 1; e$2 >= t$1; e$2--) r$1.buf[e$2 + n$1] = r$1.buf[e$2];
			}
			function Tc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeVarint(t$1[r$1]);
			}
			function Ic$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSVarint(t$1[r$1]);
			}
			function Mc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFloat(t$1[r$1]);
			}
			function Fc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeDouble(t$1[r$1]);
			}
			function Dc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeBoolean(t$1[r$1]);
			}
			function Pc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed32(t$1[r$1]);
			}
			function zc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed32(t$1[r$1]);
			}
			function Bc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed64(t$1[r$1]);
			}
			function Vc$1(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed64(t$1[r$1]);
			}
			function Cc$1(t$1, e$1, r$1) {
				1 === t$1 && r$1.readMessage(Lc$1, e$1);
			}
			function Lc$1(t$1, e$1, r$1) {
				if (3 === t$1) {
					const { id: t$2, bitmap: n$1, width: i$1, height: s$1, left: o, top: a$1, advance: l$1 } = r$1.readMessage(Oc$1, {});
					e$1.push({
						id: t$2,
						bitmap: new vl$1({
							width: i$1 + 6,
							height: s$1 + 6
						}, n$1),
						metrics: {
							width: i$1,
							height: s$1,
							left: o,
							top: a$1,
							advance: l$1
						}
					});
				}
			}
			function Oc$1(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? e$1.bitmap = r$1.readBytes() : 3 === t$1 ? e$1.width = r$1.readVarint() : 4 === t$1 ? e$1.height = r$1.readVarint() : 5 === t$1 ? e$1.left = r$1.readSVarint() : 6 === t$1 ? e$1.top = r$1.readSVarint() : 7 === t$1 && (e$1.advance = r$1.readVarint());
			}
			function Rc$1(t$1) {
				let e$1 = 0, r$1 = 0;
				for (const n$2 of t$1) e$1 += n$2.w * n$2.h, r$1 = Math.max(r$1, n$2.w);
				t$1.sort(((t$2, e$2) => e$2.h - t$2.h));
				const n$1 = [{
					x: 0,
					y: 0,
					w: Math.max(Math.ceil(Math.sqrt(e$1 / .95)), r$1),
					h: Infinity
				}];
				let i$1 = 0, s$1 = 0;
				for (const e$2 of t$1) for (let t$2 = n$1.length - 1; t$2 >= 0; t$2--) {
					const r$2 = n$1[t$2];
					if (!(e$2.w > r$2.w || e$2.h > r$2.h)) {
						if (e$2.x = r$2.x, e$2.y = r$2.y, s$1 = Math.max(s$1, e$2.y + e$2.h), i$1 = Math.max(i$1, e$2.x + e$2.w), e$2.w === r$2.w && e$2.h === r$2.h) {
							const e$3 = n$1.pop();
							e$3 && t$2 < n$1.length && (n$1[t$2] = e$3);
						} else e$2.h === r$2.h ? (r$2.x += e$2.w, r$2.w -= e$2.w) : e$2.w === r$2.w ? (r$2.y += e$2.h, r$2.h -= e$2.h) : (n$1.push({
							x: r$2.x + e$2.w,
							y: r$2.y,
							w: r$2.w - e$2.w,
							h: e$2.h
						}), r$2.y += e$2.h, r$2.h -= e$2.h);
						break;
					}
				}
				return {
					w: i$1,
					h: s$1,
					fill: e$1 / (i$1 * s$1) || 0
				};
			}
			class Nc$1 {
				constructor(t$1, { pixelRatio: e$1, version: r$1, stretchX: n$1, stretchY: i$1, content: s$1, textFitWidth: o, textFitHeight: a$1 }) {
					this.paddedRect = t$1, this.pixelRatio = e$1, this.stretchX = n$1, this.stretchY = i$1, this.content = s$1, this.version = r$1, this.textFitWidth = o, this.textFitHeight = a$1;
				}
				get tl() {
					return [this.paddedRect.x + 1, this.paddedRect.y + 1];
				}
				get br() {
					return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
				}
				get tlbr() {
					return this.tl.concat(this.br);
				}
				get displaySize() {
					return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
				}
			}
			class $c$1 {
				constructor(t$1, e$1) {
					const r$1 = {}, n$1 = {};
					this.haveRenderCallbacks = [];
					const i$1 = [];
					this.addImages(t$1, r$1, i$1), this.addImages(e$1, n$1, i$1);
					const { w: s$1, h: o } = Rc$1(i$1), a$1 = new bl$1({
						width: s$1 || 1,
						height: o || 1
					});
					for (const e$2 in t$1) {
						const n$2 = t$1[e$2], i$2 = r$1[e$2].paddedRect;
						bl$1.copy(n$2.data, a$1, {
							x: 0,
							y: 0
						}, {
							x: i$2.x + 1,
							y: i$2.y + 1
						}, n$2.data);
					}
					for (const t$2 in e$1) {
						const r$2 = e$1[t$2], i$2 = n$1[t$2].paddedRect, s$2 = i$2.x + 1, o$1 = i$2.y + 1, l$1 = r$2.data.width, u$1 = r$2.data.height;
						bl$1.copy(r$2.data, a$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: o$1
						}, r$2.data), bl$1.copy(r$2.data, a$1, {
							x: 0,
							y: u$1 - 1
						}, {
							x: s$2,
							y: o$1 - 1
						}, {
							width: l$1,
							height: 1
						}), bl$1.copy(r$2.data, a$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: o$1 + u$1
						}, {
							width: l$1,
							height: 1
						}), bl$1.copy(r$2.data, a$1, {
							x: l$1 - 1,
							y: 0
						}, {
							x: s$2 - 1,
							y: o$1
						}, {
							width: 1,
							height: u$1
						}), bl$1.copy(r$2.data, a$1, {
							x: 0,
							y: 0
						}, {
							x: s$2 + l$1,
							y: o$1
						}, {
							width: 1,
							height: u$1
						});
					}
					this.image = a$1, this.iconPositions = r$1, this.patternPositions = n$1;
				}
				addImages(t$1, e$1, r$1) {
					for (const n$1 in t$1) {
						const i$1 = t$1[n$1], s$1 = {
							x: 0,
							y: 0,
							w: i$1.data.width + 2,
							h: i$1.data.height + 2
						};
						r$1.push(s$1), e$1[n$1] = new Nc$1(s$1, i$1), i$1.hasRenderCallback && this.haveRenderCallbacks.push(n$1);
					}
				}
				patchUpdatedImages(t$1, e$1) {
					t$1.dispatchRenderCallbacks(this.haveRenderCallbacks);
					for (const r$1 in t$1.updatedImages) this.patchUpdatedImage(this.iconPositions[r$1], t$1.getImage(r$1), e$1), this.patchUpdatedImage(this.patternPositions[r$1], t$1.getImage(r$1), e$1);
				}
				patchUpdatedImage(t$1, e$1, r$1) {
					if (!t$1 || !e$1) return;
					if (t$1.version === e$1.version) return;
					t$1.version = e$1.version;
					const [n$1, i$1] = t$1.tl;
					r$1.update(e$1.data, void 0, {
						x: n$1,
						y: i$1
					});
				}
			}
			var Uc$1;
			function qc$1(e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = bc$1.fromFeature(e$1, s$1);
				let g$2;
				p$1 === t.aA.vertical && m$1.verticalizePunctuation();
				let x$1 = m$1.determineLineBreaks(c$1, o, r$1, i$1, d$1);
				const { processBidirectionalText: v$1, processStyledBidirectionalText: b$1 } = Ms$1;
				if (v$1 && 1 === m$1.sections.length) {
					g$2 = [], x$1 = x$1.map(((t$2) => m$1.toCodeUnitIndex(t$2)));
					const t$1 = v$1(m$1.toString(), x$1);
					for (const e$2 of t$1) {
						const t$2 = [...e$2].map((() => 0));
						g$2.push(new bc$1(e$2, m$1.sections, t$2));
					}
				} else if (b$1) {
					g$2 = [], x$1 = x$1.map(((t$2) => m$1.toCodeUnitIndex(t$2)));
					let t$1 = 0;
					const e$2 = [];
					for (const r$3 of m$1.text) e$2.push(...Array(r$3.length).fill(m$1.sectionIndex[t$1])), t$1++;
					const r$2 = b$1(m$1.text, e$2, x$1);
					for (const t$2 of r$2) {
						const e$3 = [];
						let r$3 = "";
						for (const n$2 of t$2[0]) e$3.push(t$2[1][r$3.length]), r$3 += n$2;
						g$2.push(new bc$1(t$2[0], m$1.sections, e$3));
					}
				} else g$2 = function(t$1, e$2) {
					const r$2 = [];
					let n$2 = 0;
					for (const i$2 of e$2) r$2.push(t$1.substring(n$2, i$2)), n$2 = i$2;
					return n$2 < t$1.length() && r$2.push(t$1.substring(n$2, t$1.length())), r$2;
				}(m$1, x$1);
				const w$2 = [], _$2 = {
					positionedLines: w$2,
					text: m$1.toString(),
					top: h$1[1],
					bottom: h$1[1],
					left: h$1[0],
					right: h$1[0],
					writingMode: p$1,
					iconsInText: !1,
					verticalizable: !1
				};
				return function(t$1, e$2, r$2, n$2, i$2, s$2, o$1, a$2, l$2, u$2, c$2, h$2) {
					let p$2 = 0, f$2 = 0, d$2 = 0, y$2 = 0;
					const m$2 = "right" === a$2 ? 1 : "left" === a$2 ? 0 : .5, g$3 = hc$1 / h$2;
					let x$2 = 0;
					for (const o$2 of i$2) {
						o$2.trim();
						const i$3 = o$2.getMaxScale(), a$3 = {
							positionedGlyphs: [],
							lineOffset: 0
						};
						t$1.positionedLines[x$2] = a$3;
						const h$3 = a$3.positionedGlyphs;
						let v$3 = 0;
						if (!o$2.length()) {
							f$2 += s$2, ++x$2;
							continue;
						}
						const b$3 = Gc(n$2, o$2, g$3);
						let w$3 = 0;
						for (const s$3 of o$2.text) {
							const a$4 = o$2.getSection(w$3), d$3 = s$3.codePointAt(0), y$3 = Yc(l$2, c$2, d$3), m$3 = {
								glyph: d$3,
								imageName: null,
								x: p$2,
								y: f$2 + -17,
								vertical: y$3,
								scale: 1,
								fontStack: "",
								sectionIndex: o$2.getSectionIndex(w$3),
								metrics: null,
								rect: null
							};
							let x$3;
							if ("fontStack" in a$4) {
								if (x$3 = Zc(a$4, d$3, y$3, b$3, e$2, r$2), !x$3) continue;
								m$3.fontStack = a$4.fontStack;
							} else {
								if (t$1.iconsInText = !0, a$4.scale *= g$3, x$3 = Hc(a$4, y$3, i$3, b$3, n$2), !x$3) continue;
								v$3 = Math.max(v$3, x$3.imageOffset), m$3.imageName = a$4.imageName;
							}
							const { rect: _$4, metrics: A$2, baselineOffset: S$2 } = x$3;
							m$3.y += S$2, m$3.scale = a$4.scale, m$3.metrics = A$2, m$3.rect = _$4, h$3.push(m$3), y$3 ? (t$1.verticalizable = !0, p$2 += ("imageName" in a$4 ? A$2.advance : hc$1) * a$4.scale + u$2) : p$2 += A$2.advance * a$4.scale + u$2, w$3++;
						}
						0 !== h$3.length && (d$2 = Math.max(p$2 - u$2, d$2), Kc(h$3, 0, h$3.length - 1, m$2)), p$2 = 0, a$3.lineOffset = Math.max(v$3, (i$3 - 1) * hc$1);
						const _$3 = s$2 * i$3 + v$3;
						f$2 += _$3, y$2 = Math.max(_$3, y$2), ++x$2;
					}
					const { horizontalAlign: v$2, verticalAlign: b$2 } = jc$1(o$1);
					(function(t$2, e$3, r$3, n$3, i$3, s$3, o$2, a$3, l$3) {
						const u$3 = (e$3 - r$3) * i$3;
						let c$3 = 0;
						c$3 = s$3 !== o$2 ? -a$3 * n$3 - -17 : -n$3 * l$3 * o$2 + .5 * o$2;
						for (const e$4 of t$2) for (const t$3 of e$4.positionedGlyphs) t$3.x += u$3, t$3.y += c$3;
					})(t$1.positionedLines, m$2, v$2, b$2, d$2, y$2, s$2, f$2, i$2.length), t$1.top += -b$2 * f$2, t$1.bottom = t$1.top + f$2, t$1.left += -v$2 * d$2, t$1.right = t$1.left + d$2;
				}(_$2, r$1, n$1, i$1, g$2, a$1, l$1, u$1, p$1, c$1, f$1, y$1), !function(t$1) {
					for (const e$2 of t$1) if (0 !== e$2.positionedGlyphs.length) return !1;
					return !0;
				}(w$2) && _$2;
			}
			function jc$1(t$1) {
				let e$1 = .5, r$1 = .5;
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right":
						e$1 = 1;
						break;
					case "left":
					case "top-left":
					case "bottom-left": e$1 = 0;
				}
				switch (t$1) {
					case "bottom":
					case "bottom-right":
					case "bottom-left":
						r$1 = 1;
						break;
					case "top":
					case "top-right":
					case "top-left": r$1 = 0;
				}
				return {
					horizontalAlign: e$1,
					verticalAlign: r$1
				};
			}
			function Gc(t$1, e$1, r$1) {
				const n$1 = e$1.getMaxScale() * hc$1, { maxImageWidth: i$1, maxImageHeight: s$1 } = e$1.getMaxImageSize(t$1), o = Math.max(n$1, s$1 * r$1);
				return {
					verticalLineContentWidth: Math.max(n$1, i$1 * r$1),
					horizontalLineContentHeight: o
				};
			}
			function Xc(t$1) {
				switch (t$1) {
					case "top": return 0;
					case "center": return .5;
					default: return 1;
				}
			}
			function Yc(e$1, r$1, n$1) {
				return !(e$1 === t.aA.horizontal || !r$1 && !gs$1(n$1) || r$1 && (xs$1(n$1) || (i$1 = n$1, /\p{sc=Arab}/u.test(String.fromCodePoint(i$1)))));
				var i$1;
			}
			function Zc(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o = s$1[t$1.fontStack], a$1 = function(t$2, e$2, r$2, n$2) {
					if (t$2 && t$2.rect) return t$2;
					const i$2 = e$2[r$2.fontStack], s$2 = i$2 && i$2[n$2];
					return s$2 ? {
						rect: null,
						metrics: s$2.metrics
					} : null;
				}(o && o[e$1], i$1, t$1, e$1);
				if (null === a$1) return null;
				let l$1;
				if (r$1) l$1 = n$1.verticalLineContentWidth - t$1.scale * hc$1;
				else {
					const e$2 = Xc(t$1.verticalAlign);
					l$1 = (n$1.horizontalLineContentHeight - t$1.scale * hc$1) * e$2;
				}
				return {
					rect: a$1.rect,
					metrics: a$1.metrics,
					baselineOffset: l$1
				};
			}
			function Hc(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = i$1[t$1.imageName];
				if (!s$1) return null;
				const o = s$1.paddedRect, a$1 = s$1.displaySize, l$1 = {
					width: a$1[0],
					height: a$1[1],
					left: 1,
					top: -3,
					advance: e$1 ? a$1[1] : a$1[0]
				};
				let u$1;
				if (e$1) u$1 = n$1.verticalLineContentWidth - a$1[1] * t$1.scale;
				else {
					const e$2 = Xc(t$1.verticalAlign);
					u$1 = (n$1.horizontalLineContentHeight - a$1[1] * t$1.scale) * e$2;
				}
				return {
					rect: o,
					metrics: l$1,
					baselineOffset: u$1,
					imageOffset: (e$1 ? a$1[0] : a$1[1]) * t$1.scale - hc$1 * r$1
				};
			}
			function Kc(t$1, e$1, r$1, n$1) {
				if (0 === n$1) return;
				const i$1 = t$1[r$1], s$1 = (t$1[r$1].x + i$1.metrics.advance * i$1.scale) * n$1;
				for (let n$2 = e$1; n$2 <= r$1; n$2++) t$1[n$2].x -= s$1;
			}
			function Wc(t$1, e$1, r$1) {
				const { horizontalAlign: n$1, verticalAlign: i$1 } = jc$1(r$1), s$1 = e$1[0] - t$1.displaySize[0] * n$1, o = e$1[1] - t$1.displaySize[1] * i$1;
				return {
					image: t$1,
					top: o,
					bottom: o + t$1.displaySize[1],
					left: s$1,
					right: s$1 + t$1.displaySize[0]
				};
			}
			function Jc$1(t$1) {
				var e$1, r$1;
				let n$1 = t$1.left, i$1 = t$1.top, s$1 = t$1.right - n$1, o = t$1.bottom - i$1;
				const a$1 = null !== (e$1 = t$1.image.textFitWidth) && void 0 !== e$1 ? e$1 : "stretchOrShrink", l$1 = null !== (r$1 = t$1.image.textFitHeight) && void 0 !== r$1 ? r$1 : "stretchOrShrink", u$1 = (t$1.image.content[2] - t$1.image.content[0]) / (t$1.image.content[3] - t$1.image.content[1]);
				if ("proportional" === l$1) {
					if ("stretchOnly" === a$1 && s$1 / o < u$1 || "proportional" === a$1) {
						const t$2 = Math.ceil(o * u$1);
						n$1 *= t$2 / s$1, s$1 = t$2;
					}
				} else if ("proportional" === a$1 && "stretchOnly" === l$1 && 0 !== u$1 && s$1 / o > u$1) {
					const t$2 = Math.ceil(s$1 / u$1);
					i$1 *= t$2 / o, o = t$2;
				}
				return {
					x1: n$1,
					y1: i$1,
					x2: n$1 + s$1,
					y2: i$1 + o
				};
			}
			function Qc$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o = t$1.image;
				let a$1;
				if (o.content) {
					const t$2 = o.content, e$2 = o.pixelRatio || 1;
					a$1 = [
						t$2[0] / e$2,
						t$2[1] / e$2,
						o.displaySize[0] - t$2[2] / e$2,
						o.displaySize[1] - t$2[3] / e$2
					];
				}
				const l$1 = e$1.left * s$1, u$1 = e$1.right * s$1;
				let c$1, h$1, p$1, f$1;
				"width" === r$1 || "both" === r$1 ? (f$1 = i$1[0] + l$1 - n$1[3], h$1 = i$1[0] + u$1 + n$1[1]) : (f$1 = i$1[0] + (l$1 + u$1 - o.displaySize[0]) / 2, h$1 = f$1 + o.displaySize[0]);
				const d$1 = e$1.top * s$1, y$1 = e$1.bottom * s$1;
				return "height" === r$1 || "both" === r$1 ? (c$1 = i$1[1] + d$1 - n$1[0], p$1 = i$1[1] + y$1 + n$1[2]) : (c$1 = i$1[1] + (d$1 + y$1 - o.displaySize[1]) / 2, p$1 = c$1 + o.displaySize[1]), {
					image: o,
					top: c$1,
					right: h$1,
					bottom: p$1,
					left: f$1,
					collisionPadding: a$1
				};
			}
			us$1("ImagePosition", Nc$1), us$1("ImageAtlas", $c$1), t.aA = void 0, (Uc$1 = t.aA || (t.aA = {}))[Uc$1.none = 0] = "none", Uc$1[Uc$1.horizontal = 1] = "horizontal", Uc$1[Uc$1.vertical = 2] = "vertical", Uc$1[Uc$1.horizontalOnly = 3] = "horizontalOnly";
			const th = 128, eh = 32640;
			function rh(t$1, e$1) {
				const { expression: r$1 } = e$1;
				if ("constant" === r$1.kind) return {
					kind: "constant",
					layoutSize: r$1.evaluate(new Fs$1(t$1 + 1))
				};
				if ("source" === r$1.kind) return { kind: "source" };
				{
					const { zoomStops: e$2, interpolationType: n$1 } = r$1;
					let i$1 = 0;
					for (; i$1 < e$2.length && e$2[i$1] <= t$1;) i$1++;
					i$1 = Math.max(0, i$1 - 1);
					let s$1 = i$1;
					for (; s$1 < e$2.length && e$2[s$1] < t$1 + 1;) s$1++;
					s$1 = Math.min(e$2.length - 1, s$1);
					const o = e$2[i$1], a$1 = e$2[s$1];
					return "composite" === r$1.kind ? {
						kind: "composite",
						minZoom: o,
						maxZoom: a$1,
						interpolationType: n$1
					} : {
						kind: "camera",
						minZoom: o,
						maxZoom: a$1,
						minSize: r$1.evaluate(new Fs$1(o)),
						maxSize: r$1.evaluate(new Fs$1(a$1)),
						interpolationType: n$1
					};
				}
			}
			function nh(t$1, e$1, r$1) {
				let n$1 = "never";
				const i$1 = t$1.get(e$1);
				return i$1 ? n$1 = i$1 : t$1.get(r$1) && (n$1 = "always"), n$1;
			}
			const ih = [{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint8",
				offset: 0
			}];
			function sh(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1) {
				const f$1 = a$1 ? Math.min(eh, Math.round(a$1[0])) : 0, d$1 = a$1 ? Math.min(eh, Math.round(a$1[1])) : 0;
				t$1.emplaceBack(e$1, r$1, Math.round(32 * n$1), Math.round(32 * i$1), s$1, o, (f$1 << 1) + (l$1 ? 1 : 0), d$1, 16 * u$1, 16 * c$1, 256 * h$1, 256 * p$1);
			}
			function oh(t$1, e$1, r$1) {
				t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1);
			}
			function ah(t$1) {
				for (const e$1 of t$1.sections) if (Is$1(e$1.text)) return !0;
				return !1;
			}
			class lh {
				constructor(t$1) {
					this.layoutVertexArray = new Yo$1(), this.indexArray = new Jo$1(), this.programConfigurations = t$1, this.segments = new ra$1(), this.dynamicLayoutVertexArray = new Zo$1(), this.opacityVertexArray = new Ho$1(), this.hasVisibleVertices = !1, this.placedSymbolArray = new Fo$1();
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
				}
				upload(t$1, e$1, r$1, n$1) {
					this.isEmpty() || (r$1 && (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, sc$1.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray, e$1), this.dynamicLayoutVertexBuffer = t$1.createVertexBuffer(this.dynamicLayoutVertexArray, oc$1.members, !0), this.opacityVertexBuffer = t$1.createVertexBuffer(this.opacityVertexArray, ih, !0), this.opacityVertexBuffer.itemSize = 1), (r$1 || n$1) && this.programConfigurations.upload(t$1));
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
				}
			}
			us$1("SymbolBuffers", lh);
			class uh {
				constructor(t$1, e$1, r$1) {
					this.layoutVertexArray = new t$1(), this.layoutAttributes = e$1, this.indexArray = new r$1(), this.segments = new ra$1(), this.collisionVertexArray = new Wo$1();
				}
				upload(t$1) {
					this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t$1.createVertexBuffer(this.collisionVertexArray, ac$1.members, !0);
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
				}
			}
			us$1("CollisionBuffers", uh);
			class ch {
				constructor(e$1) {
					this.collisionBoxArray = e$1.collisionBoxArray, this.zoom = e$1.zoom, this.overscaling = e$1.overscaling, this.layers = e$1.layers, this.layerIds = this.layers.map(((t$1) => t$1.id)), this.index = e$1.index, this.pixelRatio = e$1.pixelRatio, this.sourceLayerIndex = e$1.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
					const r$1 = this.layers[0]._unevaluatedLayout._values;
					this.textSizeData = rh(this.zoom, r$1["text-size"]), this.iconSizeData = rh(this.zoom, r$1["icon-size"]);
					const n$1 = this.layers[0].layout, i$1 = n$1.get("symbol-sort-key"), s$1 = n$1.get("symbol-z-order");
					this.canOverlap = "never" !== nh(n$1, "text-overlap", "text-allow-overlap") || "never" !== nh(n$1, "icon-overlap", "icon-allow-overlap") || n$1.get("text-ignore-placement") || n$1.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s$1 && !i$1.isConstant(), this.sortFeaturesByY = ("viewport-y" === s$1 || "auto" === s$1 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n$1.get("symbol-placement") && (this.writingModes = n$1.get("text-writing-mode").map(((e$2) => t.aA[e$2]))), this.stateDependentLayerIds = this.layers.filter(((t$1) => t$1.isStateDependent())).map(((t$1) => t$1.id)), this.sourceID = e$1.sourceID;
				}
				createArrays() {
					this.text = new lh(new Pa$1(this.layers, this.zoom, ((t$1) => /^text/.test(t$1)))), this.icon = new lh(new Pa$1(this.layers, this.zoom, ((t$1) => /^icon/.test(t$1)))), this.glyphOffsetArray = new zo$1(), this.lineVertexArray = new Bo$1(), this.symbolInstances = new Po$1(), this.textAnchorOffsets = new Co$1();
				}
				calculateGlyphDependencies(t$1, e$1, r$1, n$1, i$1) {
					for (const s$1 of t$1) if (e$1[s$1.codePointAt(0)] = !0, (r$1 || n$1) && i$1) {
						const t$2 = pc$1[s$1];
						t$2 && (e$1[t$2.codePointAt(0)] = !0);
					}
				}
				populate(e$1, r$1, n$1) {
					const i$1 = this.layers[0], s$1 = i$1.layout, o = s$1.get("text-font"), a$1 = s$1.get("text-field"), l$1 = s$1.get("icon-image"), u$1 = ("constant" !== a$1.value.kind || a$1.value.value instanceof De$1 && !a$1.value.value.isEmpty() || a$1.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0), c$1 = "constant" !== l$1.value.kind || !!l$1.value.value || Object.keys(l$1.parameters).length > 0, h$1 = s$1.get("symbol-sort-key");
					if (this.features = [], !u$1 && !c$1) return;
					const p$1 = r$1.iconDependencies, f$1 = r$1.glyphDependencies, d$1 = r$1.availableImages, y$1 = new Fs$1(this.zoom);
					for (const { feature: r$2, id: a$2, index: l$2, sourceLayerIndex: m$1 } of e$1) {
						const e$2 = i$1._featureFilter.needGeometry, g$2 = Oa$1(r$2, e$2);
						if (!i$1._featureFilter.filter(y$1, g$2, n$1)) continue;
						let x$1, v$1;
						if (e$2 || (g$2.geometry = La$1(r$2)), u$1) {
							const t$1 = i$1.getValueAndResolveTokens("text-field", g$2, n$1, d$1), e$3 = De$1.factory(t$1), r$3 = this.hasRTLText = this.hasRTLText || ah(e$3);
							(!r$3 || "unavailable" === Ms$1.getRTLTextPluginStatus() || r$3 && Ms$1.isParsed()) && (x$1 = cc$1(e$3, i$1, g$2));
						}
						if (c$1) {
							const t$1 = i$1.getValueAndResolveTokens("icon-image", g$2, n$1, d$1);
							v$1 = t$1 instanceof Oe$1 ? t$1 : Oe$1.fromString(t$1);
						}
						if (!x$1 && !v$1) continue;
						const b$1 = this.sortFeaturesByKey ? h$1.evaluate(g$2, {}, n$1) : void 0;
						if (this.features.push({
							id: a$2,
							text: x$1,
							icon: v$1,
							index: l$2,
							sourceLayerIndex: m$1,
							geometry: g$2.geometry,
							properties: r$2.properties,
							type: Eu$1.types[r$2.type],
							sortKey: b$1
						}), v$1 && (p$1[v$1.name] = !0), x$1) {
							const e$3 = o.evaluate(g$2, {}, n$1).join(","), r$3 = "viewport" !== s$1.get("text-rotation-alignment") && "point" !== s$1.get("symbol-placement");
							this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.aA.vertical) >= 0;
							for (const t$1 of x$1.sections) if (t$1.image) p$1[t$1.image.name] = !0;
							else {
								const n$2 = vs$1(x$1.toString()), i$2 = t$1.fontStack || e$3, s$2 = f$1[i$2] = f$1[i$2] || {};
								this.calculateGlyphDependencies(t$1.text, s$2, r$3, this.allowVerticalPlacement, n$2);
							}
						}
					}
					"line" === s$1.get("symbol-placement") && (this.features = function(t$1) {
						const e$2 = {}, r$2 = {}, n$2 = [];
						let i$2 = 0;
						function s$2(e$3) {
							n$2.push(t$1[e$3]), i$2++;
						}
						function o$1(t$2, e$3, i$3) {
							const s$3 = r$2[t$2];
							return delete r$2[t$2], r$2[e$3] = s$3, n$2[s$3].geometry[0].pop(), n$2[s$3].geometry[0] = n$2[s$3].geometry[0].concat(i$3[0]), s$3;
						}
						function a$2(t$2, r$3, i$3) {
							const s$3 = e$2[r$3];
							return delete e$2[r$3], e$2[t$2] = s$3, n$2[s$3].geometry[0].shift(), n$2[s$3].geometry[0] = i$3[0].concat(n$2[s$3].geometry[0]), s$3;
						}
						function l$2(t$2, e$3, r$3) {
							const n$3 = r$3 ? e$3[0][e$3[0].length - 1] : e$3[0][0];
							return `${t$2}:${n$3.x}:${n$3.y}`;
						}
						for (let u$2 = 0; u$2 < t$1.length; u$2++) {
							const c$2 = t$1[u$2], h$2 = c$2.geometry, p$2 = c$2.text ? c$2.text.toString() : null;
							if (!p$2) {
								s$2(u$2);
								continue;
							}
							const f$2 = l$2(p$2, h$2), d$2 = l$2(p$2, h$2, !0);
							if (f$2 in r$2 && d$2 in e$2 && r$2[f$2] !== e$2[d$2]) {
								const t$2 = a$2(f$2, d$2, h$2), i$3 = o$1(f$2, d$2, n$2[t$2].geometry);
								delete e$2[f$2], delete r$2[d$2], r$2[l$2(p$2, n$2[i$3].geometry, !0)] = i$3, n$2[t$2].geometry = null;
							} else f$2 in r$2 ? o$1(f$2, d$2, h$2) : d$2 in e$2 ? a$2(f$2, d$2, h$2) : (s$2(u$2), e$2[f$2] = i$2 - 1, r$2[d$2] = i$2 - 1);
						}
						return n$2.filter(((t$2) => t$2.geometry));
					}(this.features)), this.sortFeaturesByKey && this.features.sort(((t$1, e$2) => t$1.sortKey - e$2.sortKey));
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, { imagePositions: r$1 }), this.icon.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, { imagePositions: r$1 }));
				}
				isEmpty() {
					return 0 === this.symbolInstances.length && !this.hasRTLText;
				}
				uploadPending() {
					return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
				}
				upload(t$1) {
					!this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t$1), this.iconCollisionBox.upload(t$1)), this.text.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
				}
				destroyDebugData() {
					this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
				}
				destroy() {
					this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
				}
				addToLineVertexArray(t$1, e$1) {
					const r$1 = this.lineVertexArray.length;
					if (void 0 !== t$1.segment) {
						let r$2 = t$1.dist(e$1[t$1.segment + 1]), n$1 = t$1.dist(e$1[t$1.segment]);
						const i$1 = {};
						for (let n$2 = t$1.segment + 1; n$2 < e$1.length; n$2++) i$1[n$2] = {
							x: e$1[n$2].x,
							y: e$1[n$2].y,
							tileUnitDistanceFromAnchor: r$2
						}, n$2 < e$1.length - 1 && (r$2 += e$1[n$2 + 1].dist(e$1[n$2]));
						for (let r$3 = t$1.segment || 0; r$3 >= 0; r$3--) i$1[r$3] = {
							x: e$1[r$3].x,
							y: e$1[r$3].y,
							tileUnitDistanceFromAnchor: n$1
						}, r$3 > 0 && (n$1 += e$1[r$3 - 1].dist(e$1[r$3]));
						for (let t$2 = 0; t$2 < e$1.length; t$2++) {
							const e$2 = i$1[t$2];
							this.lineVertexArray.emplaceBack(e$2.x, e$2.y, e$2.tileUnitDistanceFromAnchor);
						}
					}
					return {
						lineStartIndex: r$1,
						lineLength: this.lineVertexArray.length - r$1
					};
				}
				addSymbols(e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = e$1.indexArray, d$1 = e$1.layoutVertexArray, y$1 = e$1.segments.prepareSegment(4 * r$1.length, d$1, f$1, this.canOverlap ? o.sortKey : void 0), m$1 = this.glyphOffsetArray.length, g$2 = y$1.vertexLength, x$1 = this.allowVerticalPlacement && a$1 === t.aA.vertical ? Math.PI / 2 : 0, v$1 = o.text && o.text.sections;
					for (let t$1 = 0; t$1 < r$1.length; t$1++) {
						const { tl: i$2, tr: s$2, bl: a$2, br: u$2, tex: c$2, pixelOffsetTL: h$2, pixelOffsetBR: m$2, minFontScaleX: g$3, minFontScaleY: b$1, glyphOffset: w$2, isSDF: _$2, sectionIndex: A$2 } = r$1[t$1], S$2 = y$1.vertexLength, k$2 = w$2[1];
						sh(d$1, l$1.x, l$1.y, i$2.x, k$2 + i$2.y, c$2.x, c$2.y, n$1, _$2, h$2.x, h$2.y, g$3, b$1), sh(d$1, l$1.x, l$1.y, s$2.x, k$2 + s$2.y, c$2.x + c$2.w, c$2.y, n$1, _$2, m$2.x, h$2.y, g$3, b$1), sh(d$1, l$1.x, l$1.y, a$2.x, k$2 + a$2.y, c$2.x, c$2.y + c$2.h, n$1, _$2, h$2.x, m$2.y, g$3, b$1), sh(d$1, l$1.x, l$1.y, u$2.x, k$2 + u$2.y, c$2.x + c$2.w, c$2.y + c$2.h, n$1, _$2, m$2.x, m$2.y, g$3, b$1), oh(e$1.dynamicLayoutVertexArray, l$1, x$1), f$1.emplaceBack(S$2, S$2 + 2, S$2 + 1), f$1.emplaceBack(S$2 + 1, S$2 + 2, S$2 + 3), y$1.vertexLength += 4, y$1.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w$2[0]), t$1 !== r$1.length - 1 && A$2 === r$1[t$1 + 1].sectionIndex || e$1.programConfigurations.populatePaintArrays(d$1.length, o, o.index, {
							imagePositions: {},
							canonical: p$1,
							formattedSection: v$1 && v$1[A$2]
						});
					}
					e$1.placedSymbolArray.emplaceBack(l$1.x, l$1.y, m$1, this.glyphOffsetArray.length - m$1, g$2, u$1, c$1, l$1.segment, n$1 ? n$1[0] : 0, n$1 ? n$1[1] : 0, i$1[0], i$1[1], a$1, 0, !1, 0, h$1);
				}
				_addCollisionDebugVertex(t$1, e$1, r$1, n$1, i$1, s$1) {
					return e$1.emplaceBack(0, 0), t$1.emplaceBack(r$1.x, r$1.y, n$1, i$1, Math.round(s$1.x), Math.round(s$1.y));
				}
				addCollisionDebugVertices(t$1, e$1, n$1, i$1, s$1, o, a$1) {
					const l$1 = s$1.segments.prepareSegment(4, s$1.layoutVertexArray, s$1.indexArray), u$1 = l$1.vertexLength, c$1 = s$1.layoutVertexArray, h$1 = s$1.collisionVertexArray, p$1 = a$1.anchorX, f$1 = a$1.anchorY;
					this._addCollisionDebugVertex(c$1, h$1, o, p$1, f$1, new r(t$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, o, p$1, f$1, new r(n$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, o, p$1, f$1, new r(n$1, i$1)), this._addCollisionDebugVertex(c$1, h$1, o, p$1, f$1, new r(t$1, i$1)), l$1.vertexLength += 4;
					const d$1 = s$1.indexArray;
					d$1.emplaceBack(u$1, u$1 + 1), d$1.emplaceBack(u$1 + 1, u$1 + 2), d$1.emplaceBack(u$1 + 2, u$1 + 3), d$1.emplaceBack(u$1 + 3, u$1), l$1.primitiveLength += 4;
				}
				addDebugCollisionBoxes(t$1, e$1, r$1, n$1) {
					for (let i$1 = t$1; i$1 < e$1; i$1++) {
						const t$2 = this.collisionBoxArray.get(i$1);
						this.addCollisionDebugVertices(t$2.x1, t$2.y1, t$2.x2, t$2.y2, n$1 ? this.textCollisionBox : this.iconCollisionBox, t$2.anchorPoint, r$1);
					}
				}
				generateCollisionDebugBuffers() {
					this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new uh(Ko$1, lc$1.members, Qo$1), this.iconCollisionBox = new uh(Ko$1, lc$1.members, Qo$1);
					for (let t$1 = 0; t$1 < this.symbolInstances.length; t$1++) {
						const e$1 = this.symbolInstances.get(t$1);
						this.addDebugCollisionBoxes(e$1.textBoxStartIndex, e$1.textBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.verticalTextBoxStartIndex, e$1.verticalTextBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.iconBoxStartIndex, e$1.iconBoxEndIndex, e$1, !1), this.addDebugCollisionBoxes(e$1.verticalIconBoxStartIndex, e$1.verticalIconBoxEndIndex, e$1, !1);
					}
				}
				_deserializeCollisionBoxesForSymbol(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1) {
					const u$1 = {};
					for (let n$2 = e$1; n$2 < r$1; n$2++) {
						const e$2 = t$1.get(n$2);
						u$1.textBox = {
							x1: e$2.x1,
							y1: e$2.y1,
							x2: e$2.x2,
							y2: e$2.y2,
							anchorPointX: e$2.anchorPointX,
							anchorPointY: e$2.anchorPointY
						}, u$1.textFeatureIndex = e$2.featureIndex;
						break;
					}
					for (let e$2 = n$1; e$2 < i$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalTextBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalTextFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = s$1; e$2 < o; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.iconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.iconFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = a$1; e$2 < l$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalIconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalIconFeatureIndex = r$2.featureIndex;
						break;
					}
					return u$1;
				}
				deserializeCollisionBoxes(t$1) {
					this.collisionArrays = [];
					for (let e$1 = 0; e$1 < this.symbolInstances.length; e$1++) {
						const r$1 = this.symbolInstances.get(e$1);
						this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t$1, r$1.textBoxStartIndex, r$1.textBoxEndIndex, r$1.verticalTextBoxStartIndex, r$1.verticalTextBoxEndIndex, r$1.iconBoxStartIndex, r$1.iconBoxEndIndex, r$1.verticalIconBoxStartIndex, r$1.verticalIconBoxEndIndex));
					}
				}
				hasTextData() {
					return this.text.segments.get().length > 0;
				}
				hasIconData() {
					return this.icon.segments.get().length > 0;
				}
				hasDebugData() {
					return this.textCollisionBox && this.iconCollisionBox;
				}
				hasTextCollisionBoxData() {
					return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
				}
				hasIconCollisionBoxData() {
					return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
				}
				addIndicesForPlacedSymbol(t$1, e$1) {
					const r$1 = t$1.placedSymbolArray.get(e$1), n$1 = r$1.vertexStartIndex + 4 * r$1.numGlyphs;
					for (let e$2 = r$1.vertexStartIndex; e$2 < n$1; e$2 += 4) t$1.indexArray.emplaceBack(e$2, e$2 + 2, e$2 + 1), t$1.indexArray.emplaceBack(e$2 + 1, e$2 + 2, e$2 + 3);
				}
				getSortedSymbolIndexes(t$1) {
					if (this.sortedAngle === t$1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
					const e$1 = Math.sin(t$1), r$1 = Math.cos(t$1), n$1 = [], i$1 = [], s$1 = [];
					for (let t$2 = 0; t$2 < this.symbolInstances.length; ++t$2) {
						s$1.push(t$2);
						const o = this.symbolInstances.get(t$2);
						n$1.push(0 | Math.round(e$1 * o.anchorX + r$1 * o.anchorY)), i$1.push(o.featureIndex);
					}
					return s$1.sort(((t$2, e$2) => n$1[t$2] - n$1[e$2] || i$1[e$2] - i$1[t$2])), s$1;
				}
				addToSortKeyRanges(t$1, e$1) {
					const r$1 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
					r$1 && r$1.sortKey === e$1 ? r$1.symbolInstanceEnd = t$1 + 1 : this.sortKeyRanges.push({
						sortKey: e$1,
						symbolInstanceStart: t$1,
						symbolInstanceEnd: t$1 + 1
					});
				}
				sortFeatures(t$1) {
					if (this.sortFeaturesByY && this.sortedAngle !== t$1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
						this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t$1), this.sortedAngle = t$1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
						for (const t$2 of this.symbolInstanceIndexes) {
							const e$1 = this.symbolInstances.get(t$2);
							this.featureSortOrder.push(e$1.featureIndex), [
								e$1.rightJustifiedTextSymbolIndex,
								e$1.centerJustifiedTextSymbolIndex,
								e$1.leftJustifiedTextSymbolIndex
							].forEach(((t$3, e$2, r$1) => {
								t$3 >= 0 && r$1.indexOf(t$3) === e$2 && this.addIndicesForPlacedSymbol(this.text, t$3);
							})), e$1.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e$1.verticalPlacedTextSymbolIndex), e$1.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.placedIconSymbolIndex), e$1.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.verticalPlacedIconSymbolIndex);
						}
						this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
					}
				}
			}
			let hh, ph;
			us$1("SymbolBucket", ch, { omit: [
				"layers",
				"collisionBoxArray",
				"features",
				"compareText"
			] }), ch.MAX_GLYPHS = 65535, ch.addDynamicAttributes = oh;
			var fh = {
				get paint() {
					return ph = ph || new Xs$1({
						"icon-opacity": new Us$1(vt$1.paint_symbol["icon-opacity"]),
						"icon-color": new Us$1(vt$1.paint_symbol["icon-color"]),
						"icon-halo-color": new Us$1(vt$1.paint_symbol["icon-halo-color"]),
						"icon-halo-width": new Us$1(vt$1.paint_symbol["icon-halo-width"]),
						"icon-halo-blur": new Us$1(vt$1.paint_symbol["icon-halo-blur"]),
						"icon-translate": new $s$1(vt$1.paint_symbol["icon-translate"]),
						"icon-translate-anchor": new $s$1(vt$1.paint_symbol["icon-translate-anchor"]),
						"text-opacity": new Us$1(vt$1.paint_symbol["text-opacity"]),
						"text-color": new Us$1(vt$1.paint_symbol["text-color"], {
							runtimeType: Rt$1,
							getOverride: (t$1) => t$1.textColor,
							hasOverride: (t$1) => !!t$1.textColor
						}),
						"text-halo-color": new Us$1(vt$1.paint_symbol["text-halo-color"]),
						"text-halo-width": new Us$1(vt$1.paint_symbol["text-halo-width"]),
						"text-halo-blur": new Us$1(vt$1.paint_symbol["text-halo-blur"]),
						"text-translate": new $s$1(vt$1.paint_symbol["text-translate"]),
						"text-translate-anchor": new $s$1(vt$1.paint_symbol["text-translate-anchor"])
					});
				},
				get layout() {
					return hh = hh || new Xs$1({
						"symbol-placement": new $s$1(vt$1.layout_symbol["symbol-placement"]),
						"symbol-spacing": new $s$1(vt$1.layout_symbol["symbol-spacing"]),
						"symbol-avoid-edges": new $s$1(vt$1.layout_symbol["symbol-avoid-edges"]),
						"symbol-sort-key": new Us$1(vt$1.layout_symbol["symbol-sort-key"]),
						"symbol-z-order": new $s$1(vt$1.layout_symbol["symbol-z-order"]),
						"icon-allow-overlap": new $s$1(vt$1.layout_symbol["icon-allow-overlap"]),
						"icon-overlap": new $s$1(vt$1.layout_symbol["icon-overlap"]),
						"icon-ignore-placement": new $s$1(vt$1.layout_symbol["icon-ignore-placement"]),
						"icon-optional": new $s$1(vt$1.layout_symbol["icon-optional"]),
						"icon-rotation-alignment": new $s$1(vt$1.layout_symbol["icon-rotation-alignment"]),
						"icon-size": new Us$1(vt$1.layout_symbol["icon-size"]),
						"icon-text-fit": new $s$1(vt$1.layout_symbol["icon-text-fit"]),
						"icon-text-fit-padding": new $s$1(vt$1.layout_symbol["icon-text-fit-padding"]),
						"icon-image": new Us$1(vt$1.layout_symbol["icon-image"]),
						"icon-rotate": new Us$1(vt$1.layout_symbol["icon-rotate"]),
						"icon-padding": new Us$1(vt$1.layout_symbol["icon-padding"]),
						"icon-keep-upright": new $s$1(vt$1.layout_symbol["icon-keep-upright"]),
						"icon-offset": new Us$1(vt$1.layout_symbol["icon-offset"]),
						"icon-anchor": new Us$1(vt$1.layout_symbol["icon-anchor"]),
						"icon-pitch-alignment": new $s$1(vt$1.layout_symbol["icon-pitch-alignment"]),
						"text-pitch-alignment": new $s$1(vt$1.layout_symbol["text-pitch-alignment"]),
						"text-rotation-alignment": new $s$1(vt$1.layout_symbol["text-rotation-alignment"]),
						"text-field": new Us$1(vt$1.layout_symbol["text-field"]),
						"text-font": new Us$1(vt$1.layout_symbol["text-font"]),
						"text-size": new Us$1(vt$1.layout_symbol["text-size"]),
						"text-max-width": new Us$1(vt$1.layout_symbol["text-max-width"]),
						"text-line-height": new $s$1(vt$1.layout_symbol["text-line-height"]),
						"text-letter-spacing": new Us$1(vt$1.layout_symbol["text-letter-spacing"]),
						"text-justify": new Us$1(vt$1.layout_symbol["text-justify"]),
						"text-radial-offset": new Us$1(vt$1.layout_symbol["text-radial-offset"]),
						"text-variable-anchor": new $s$1(vt$1.layout_symbol["text-variable-anchor"]),
						"text-variable-anchor-offset": new Us$1(vt$1.layout_symbol["text-variable-anchor-offset"]),
						"text-anchor": new Us$1(vt$1.layout_symbol["text-anchor"]),
						"text-max-angle": new $s$1(vt$1.layout_symbol["text-max-angle"]),
						"text-writing-mode": new $s$1(vt$1.layout_symbol["text-writing-mode"]),
						"text-rotate": new Us$1(vt$1.layout_symbol["text-rotate"]),
						"text-padding": new $s$1(vt$1.layout_symbol["text-padding"]),
						"text-keep-upright": new $s$1(vt$1.layout_symbol["text-keep-upright"]),
						"text-transform": new Us$1(vt$1.layout_symbol["text-transform"]),
						"text-offset": new Us$1(vt$1.layout_symbol["text-offset"]),
						"text-allow-overlap": new $s$1(vt$1.layout_symbol["text-allow-overlap"]),
						"text-overlap": new $s$1(vt$1.layout_symbol["text-overlap"]),
						"text-ignore-placement": new $s$1(vt$1.layout_symbol["text-ignore-placement"]),
						"text-optional": new $s$1(vt$1.layout_symbol["text-optional"])
					});
				}
			};
			class dh {
				constructor(t$1) {
					if (void 0 === t$1.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
					this.type = t$1.property.overrides ? t$1.property.overrides.runtimeType : Vt$1, this.defaultValue = t$1;
				}
				evaluate(t$1) {
					if (t$1.formattedSection) {
						const e$1 = this.defaultValue.property.overrides;
						if (e$1 && e$1.hasOverride(t$1.formattedSection)) return e$1.getOverride(t$1.formattedSection);
					}
					return t$1.feature && t$1.featureState ? this.defaultValue.evaluate(t$1.feature, t$1.featureState) : this.defaultValue.property.specification.default;
				}
				eachChild(t$1) {
					this.defaultValue.isConstant() || t$1(this.defaultValue.value._styleExpression.expression);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return null;
				}
			}
			us$1("FormatSectionOverride", dh, { omit: ["defaultValue"] });
			class yh extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, fh, e$1);
				}
				recalculate(t$1, e$1) {
					if (super.recalculate(t$1, e$1), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
						const t$2 = this.layout.get("text-writing-mode");
						if (t$2) {
							const e$2 = [];
							for (const r$1 of t$2) e$2.indexOf(r$1) < 0 && e$2.push(r$1);
							this.layout._values["text-writing-mode"] = e$2;
						} else this.layout._values["text-writing-mode"] = ["horizontal"];
					}
					this._setPaintOverrides();
				}
				getValueAndResolveTokens(t$1, e$1, r$1, n$1) {
					const i$1 = this.layout.get(t$1).evaluate(e$1, {}, r$1, n$1), s$1 = this._unevaluatedLayout._values[t$1];
					return s$1.isDataDriven() || ri$1(s$1.value) || !i$1 ? i$1 : function(t$2, e$2) {
						return e$2.replace(/{([^{}]+)}/g, ((e$3, r$2) => t$2 && r$2 in t$2 ? String(t$2[r$2]) : ""));
					}(e$1.properties, i$1);
				}
				createBucket(t$1) {
					return new ch(t$1);
				}
				queryRadius() {
					return 0;
				}
				queryIntersectsFeature() {
					throw new Error("Should take a different path in FeatureIndex");
				}
				_setPaintOverrides() {
					for (const t$1 of fh.paint.overridableProperties) {
						if (!yh.hasPaintOverride(this.layout, t$1)) continue;
						const e$1 = this.paint.get(t$1), n$1 = new ei$1(new dh(e$1), e$1.property.specification);
						let i$1 = null;
						i$1 = "constant" === e$1.value.kind || "source" === e$1.value.kind ? new ii$1("source", n$1) : new si$1("composite", n$1, e$1.value.zoomStops), this.paint._values[t$1] = new Rs$1(e$1.property, i$1, e$1.parameters);
					}
				}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !(!this.layout || e$1.isDataDriven() || r$1.isDataDriven()) && yh.hasPaintOverride(this.layout, t$1);
				}
				static hasPaintOverride(t$1, e$1) {
					const r$1 = t$1.get("text-field"), n$1 = fh.paint.properties[e$1];
					let i$1 = !1;
					const s$1 = (t$2) => {
						for (const e$2 of t$2) if (n$1.overrides && n$1.overrides.hasOverride(e$2)) return void (i$1 = !0);
					};
					if ("constant" === r$1.value.kind && r$1.value.value instanceof De$1) s$1(r$1.value.value.sections);
					else if ("source" === r$1.value.kind || "composite" === r$1.value.kind) {
						const t$2 = (e$3) => {
							i$1 || (e$3 instanceof je$1 && Ue$1(e$3.value) === jt$1 ? s$1(e$3.value.sections) : e$3 instanceof Ir$1 ? s$1(e$3.sections) : e$3.eachChild(t$2));
						}, e$2 = r$1.value;
						e$2._styleExpression && t$2(e$2._styleExpression.expression);
					}
					return i$1;
				}
			}
			let mh;
			var gh = { get paint() {
				return mh = mh || new Xs$1({
					"background-color": new $s$1(vt$1.paint_background["background-color"]),
					"background-pattern": new js$1(vt$1.paint_background["background-pattern"]),
					"background-opacity": new $s$1(vt$1.paint_background["background-opacity"])
				});
			} };
			class xh extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, gh, e$1);
				}
			}
			class vh extends Ys$1 {
				constructor(t$1, e$1) {
					super(t$1, {}, e$1), this.onAdd = (t$2) => {
						this.implementation.onAdd && this.implementation.onAdd(t$2, t$2.painter.context.gl);
					}, this.onRemove = (t$2) => {
						this.implementation.onRemove && this.implementation.onRemove(t$2, t$2.painter.context.gl);
					}, this.implementation = t$1;
				}
				is3D() {
					return "3d" === this.implementation.renderingMode;
				}
				hasOffscreenPass() {
					return void 0 !== this.implementation.prerender;
				}
				recalculate() {}
				updateTransitions() {}
				hasTransition() {
					return !1;
				}
				serialize() {
					throw new Error("Custom layers cannot be serialized");
				}
			}
			class bh {
				constructor(t$1) {
					this._methodToThrottle = t$1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
						this._triggered = !1, this._methodToThrottle();
					});
				}
				trigger() {
					this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
						this._triggered = !1, this._methodToThrottle();
					}), 0));
				}
				remove() {
					delete this._channel, this._methodToThrottle = () => {};
				}
			}
			const wh = { once: !0 }, _h = 6371008.8;
			class Ah {
				constructor(t$1, e$1) {
					if (isNaN(t$1) || isNaN(e$1)) throw new Error(`Invalid LngLat object: (${t$1}, ${e$1})`);
					if (this.lng = +t$1, this.lat = +e$1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
				}
				wrap() {
					return new Ah(L$1(this.lng, -180, 180), this.lat);
				}
				toArray() {
					return [this.lng, this.lat];
				}
				toString() {
					return `LngLat(${this.lng}, ${this.lat})`;
				}
				distanceTo(t$1) {
					const e$1 = Math.PI / 180, r$1 = this.lat * e$1, n$1 = t$1.lat * e$1, i$1 = Math.sin(r$1) * Math.sin(n$1) + Math.cos(r$1) * Math.cos(n$1) * Math.cos((t$1.lng - this.lng) * e$1);
					return _h * Math.acos(Math.min(i$1, 1));
				}
				static convert(t$1) {
					if (t$1 instanceof Ah) return t$1;
					if (Array.isArray(t$1) && (2 === t$1.length || 3 === t$1.length)) return new Ah(Number(t$1[0]), Number(t$1[1]));
					if (!Array.isArray(t$1) && "object" == typeof t$1 && null !== t$1) return new Ah(Number("lng" in t$1 ? t$1.lng : t$1.lon), Number(t$1.lat));
					throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
				}
			}
			const Sh = 2 * Math.PI * _h;
			function kh(t$1) {
				return Sh * Math.cos(t$1 * Math.PI / 180);
			}
			function Eh(t$1) {
				return (180 + t$1) / 360;
			}
			function Th(t$1) {
				return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1 * Math.PI / 360))) / 360;
			}
			function Ih(t$1, e$1) {
				return t$1 / kh(e$1);
			}
			function Mh(t$1) {
				return 360 * t$1 - 180;
			}
			function Fh(t$1) {
				return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t$1) * Math.PI / 180)) - 90;
			}
			function Dh(t$1, e$1) {
				return t$1 * kh(Fh(e$1));
			}
			class Ph {
				constructor(t$1, e$1, r$1 = 0) {
					this.x = +t$1, this.y = +e$1, this.z = +r$1;
				}
				static fromLngLat(t$1, e$1 = 0) {
					const r$1 = Ah.convert(t$1);
					return new Ph(Eh(r$1.lng), Th(r$1.lat), Ih(e$1, r$1.lat));
				}
				toLngLat() {
					return new Ah(Mh(this.x), Fh(this.y));
				}
				toAltitude() {
					return Dh(this.z, this.y);
				}
				meterInMercatorCoordinateUnits() {
					return 1 / Sh * (t$1 = Fh(this.y), 1 / Math.cos(t$1 * Math.PI / 180));
					var t$1;
				}
			}
			function zh(t$1, e$1, r$1) {
				var n$1 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r$1);
				return [t$1 * n$1 - 2 * Math.PI * 6378137 / 2, e$1 * n$1 - 2 * Math.PI * 6378137 / 2];
			}
			class Bh {
				constructor(t$1, e$1, r$1) {
					if (!function(t$2, e$2, r$2) {
						return !(t$2 < 0 || t$2 > 25 || r$2 < 0 || r$2 >= Math.pow(2, t$2) || e$2 < 0 || e$2 >= Math.pow(2, t$2));
					}(t$1, e$1, r$1)) throw new Error(`x=${e$1}, y=${r$1}, z=${t$1} outside of bounds. 0<=x<${Math.pow(2, t$1)}, 0<=y<${Math.pow(2, t$1)} 0<=z<=25 `);
					this.z = t$1, this.x = e$1, this.y = r$1, this.key = Lh(0, t$1, t$1, e$1, r$1);
				}
				equals(t$1) {
					return this.z === t$1.z && this.x === t$1.x && this.y === t$1.y;
				}
				url(t$1, e$1, r$1) {
					const n$1 = function(t$2, e$2, r$2) {
						var n$2 = zh(256 * t$2, 256 * (e$2 = Math.pow(2, r$2) - e$2 - 1), r$2), i$2 = zh(256 * (t$2 + 1), 256 * (e$2 + 1), r$2);
						return n$2[0] + "," + n$2[1] + "," + i$2[0] + "," + i$2[1];
					}(this.x, this.y, this.z), i$1 = function(t$2, e$2, r$2) {
						let n$2, i$2 = "";
						for (let s$1 = t$2; s$1 > 0; s$1--) n$2 = 1 << s$1 - 1, i$2 += (e$2 & n$2 ? 1 : 0) + (r$2 & n$2 ? 2 : 0);
						return i$2;
					}(this.z, this.x, this.y);
					return t$1[(this.x + this.y) % t$1.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r$1 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e$1 > 1 ? "@2x" : "").replace(/{quadkey}/g, i$1).replace(/{bbox-epsg-3857}/g, n$1);
				}
				isChildOf(t$1) {
					const e$1 = this.z - t$1.z;
					return e$1 > 0 && t$1.x === this.x >> e$1 && t$1.y === this.y >> e$1;
				}
				getTilePoint(t$1) {
					const e$1 = Math.pow(2, this.z);
					return new r((t$1.x * e$1 - this.x) * M$1, (t$1.y * e$1 - this.y) * M$1);
				}
				toString() {
					return `${this.z}/${this.x}/${this.y}`;
				}
			}
			class Vh {
				constructor(t$1, e$1) {
					this.wrap = t$1, this.canonical = e$1, this.key = Lh(t$1, e$1.z, e$1.z, e$1.x, e$1.y);
				}
			}
			class Ch {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					if (this.terrainRttPosMatrix32f = null, t$1 < r$1) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t$1}; z = ${r$1}`);
					this.overscaledZ = t$1, this.wrap = e$1, this.canonical = new Bh(r$1, +n$1, +i$1), this.key = Lh(e$1, t$1, r$1, n$1, i$1);
				}
				clone() {
					return new Ch(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				equals(t$1) {
					return this.overscaledZ === t$1.overscaledZ && this.wrap === t$1.wrap && this.canonical.equals(t$1.canonical);
				}
				scaledTo(t$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const e$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? new Ch(t$1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ch(t$1, this.wrap, t$1, this.canonical.x >> e$1, this.canonical.y >> e$1);
				}
				isOverscaled() {
					return this.overscaledZ > this.canonical.z;
				}
				calculateScaledKey(t$1, e$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const r$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? Lh(this.wrap * +e$1, t$1, this.canonical.z, this.canonical.x, this.canonical.y) : Lh(this.wrap * +e$1, t$1, t$1, this.canonical.x >> r$1, this.canonical.y >> r$1);
				}
				isChildOf(t$1) {
					if (t$1.wrap !== this.wrap) return !1;
					if (this.overscaledZ - t$1.overscaledZ <= 0) return !1;
					if (0 === t$1.overscaledZ) return this.overscaledZ > 0;
					const e$1 = this.canonical.z - t$1.canonical.z;
					return !(e$1 < 0) && t$1.canonical.x === this.canonical.x >> e$1 && t$1.canonical.y === this.canonical.y >> e$1;
				}
				children(t$1) {
					if (this.overscaledZ >= t$1) return [new Ch(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
					const e$1 = this.canonical.z + 1, r$1 = 2 * this.canonical.x, n$1 = 2 * this.canonical.y;
					return [
						new Ch(e$1, this.wrap, e$1, r$1, n$1),
						new Ch(e$1, this.wrap, e$1, r$1 + 1, n$1),
						new Ch(e$1, this.wrap, e$1, r$1, n$1 + 1),
						new Ch(e$1, this.wrap, e$1, r$1 + 1, n$1 + 1)
					];
				}
				isLessThan(t$1) {
					return this.wrap < t$1.wrap || !(this.wrap > t$1.wrap) && (this.overscaledZ < t$1.overscaledZ || !(this.overscaledZ > t$1.overscaledZ) && (this.canonical.x < t$1.canonical.x || !(this.canonical.x > t$1.canonical.x) && this.canonical.y < t$1.canonical.y));
				}
				wrapped() {
					return new Ch(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				unwrapTo(t$1) {
					return new Ch(this.overscaledZ, t$1, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				overscaleFactor() {
					return Math.pow(2, this.overscaledZ - this.canonical.z);
				}
				toUnwrapped() {
					return new Vh(this.wrap, this.canonical);
				}
				toString() {
					return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
				}
				getTilePoint(t$1) {
					return this.canonical.getTilePoint(new Ph(t$1.x - this.wrap, t$1.y));
				}
			}
			function Lh(t$1, e$1, r$1, n$1, i$1) {
				(t$1 *= 2) < 0 && (t$1 = -1 * t$1 - 1);
				const s$1 = 1 << r$1;
				return (s$1 * s$1 * t$1 + s$1 * i$1 + n$1).toString(36) + r$1.toString(36) + e$1.toString(36);
			}
			function Oh(t$1, e$1) {
				return e$1 ? t$1.properties[e$1] : t$1.id;
			}
			function Rh(t$1, e$1) {
				const r$1 = { id: t$1.id };
				if (e$1.removeAllProperties && (delete t$1.removeProperties, delete t$1.addOrUpdateProperties, delete e$1.removeProperties), e$1.removeProperties) for (const r$2 of e$1.removeProperties) {
					const e$2 = t$1.addOrUpdateProperties.findIndex(((t$2) => t$2.key === r$2));
					e$2 > -1 && t$1.addOrUpdateProperties.splice(e$2, 1);
				}
				return (t$1.removeAllProperties || e$1.removeAllProperties) && (r$1.removeAllProperties = !0), (t$1.removeProperties || e$1.removeProperties) && (r$1.removeProperties = [...t$1.removeProperties || [], ...e$1.removeProperties || []]), (t$1.addOrUpdateProperties || e$1.addOrUpdateProperties) && (r$1.addOrUpdateProperties = [...t$1.addOrUpdateProperties || [], ...e$1.addOrUpdateProperties || []]), (t$1.newGeometry || e$1.newGeometry) && (r$1.newGeometry = e$1.newGeometry || t$1.newGeometry), r$1;
			}
			function Nh(t$1) {
				var e$1, r$1;
				if (!t$1) return {};
				const n$1 = {};
				return n$1.removeAll = t$1.removeAll, n$1.remove = new Set(t$1.remove || []), n$1.add = new Map(null === (e$1 = t$1.add) || void 0 === e$1 ? void 0 : e$1.map(((t$2) => [t$2.id, t$2]))), n$1.update = new Map(null === (r$1 = t$1.update) || void 0 === r$1 ? void 0 : r$1.map(((t$2) => [t$2.id, t$2]))), n$1;
			}
			us$1("CanonicalTileID", Bh), us$1("OverscaledTileID", Ch, { omit: ["terrainRttPosMatrix32f"] });
			class $h {
				constructor(t$1) {
					this._stringToNumber = {}, this._numberToString = [];
					for (let e$1 = 0; e$1 < t$1.length; e$1++) {
						const r$1 = t$1[e$1];
						this._stringToNumber[r$1] = e$1, this._numberToString[e$1] = r$1;
					}
				}
				encode(t$1) {
					return this._stringToNumber[t$1];
				}
				decode(t$1) {
					if (t$1 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t$1} can't be >= this._numberToString.length ${this._numberToString.length}`);
					return this._numberToString[t$1];
				}
			}
			class Uh {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = "Feature", this._vectorTileFeature = t$1, this._x = r$1, this._y = n$1, this._z = e$1, this.properties = t$1.properties, this.id = i$1;
				}
				projectPoint(t$1, e$1, r$1, n$1) {
					return [360 * (t$1.x + e$1) / n$1 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t$1.y + r$1) / n$1) * Math.PI)) - 90];
				}
				projectLine(t$1, e$1, r$1, n$1) {
					return t$1.map(((t$2) => this.projectPoint(t$2, e$1, r$1, n$1)));
				}
				get geometry() {
					if (this._geometry) return this._geometry;
					const t$1 = this._vectorTileFeature, e$1 = t$1.extent * Math.pow(2, this._z), r$1 = t$1.extent * this._x, n$1 = t$1.extent * this._y, i$1 = t$1.loadGeometry();
					switch (t$1.type) {
						case 1: {
							const t$2 = [];
							for (const e$2 of i$1) t$2.push(e$2[0]);
							const s$1 = this.projectLine(t$2, r$1, n$1, e$1);
							this._geometry = 1 === t$2.length ? {
								type: "Point",
								coordinates: s$1[0]
							} : {
								type: "MultiPoint",
								coordinates: s$1
							};
							break;
						}
						case 2: {
							const t$2 = i$1.map(((t$3) => this.projectLine(t$3, r$1, n$1, e$1)));
							this._geometry = 1 === t$2.length ? {
								type: "LineString",
								coordinates: t$2[0]
							} : {
								type: "MultiLineString",
								coordinates: t$2
							};
							break;
						}
						case 3: {
							const t$2 = Iu$1(i$1), s$1 = [];
							for (const i$2 of t$2) s$1.push(i$2.map(((t$3) => this.projectLine(t$3, r$1, n$1, e$1))));
							this._geometry = 1 === s$1.length ? {
								type: "Polygon",
								coordinates: s$1[0]
							} : {
								type: "MultiPolygon",
								coordinates: s$1
							};
							break;
						}
						default: throw new Error(`unknown feature type: ${t$1.type}`);
					}
					return this._geometry;
				}
				set geometry(t$1) {
					this._geometry = t$1;
				}
				toJSON() {
					const t$1 = { geometry: this.geometry };
					for (const e$1 in this) "_geometry" !== e$1 && "_vectorTileFeature" !== e$1 && "_x" !== e$1 && "_y" !== e$1 && "_z" !== e$1 && (t$1[e$1] = this[e$1]);
					return t$1;
				}
			}
			class qh {
				_name;
				dataBuffer;
				nullabilityBuffer;
				_size;
				constructor(t$1, e$1, r$1) {
					this._name = t$1, this.dataBuffer = e$1, "number" == typeof r$1 ? this._size = r$1 : (this.nullabilityBuffer = r$1, this._size = r$1.size());
				}
				getValue(t$1) {
					return this.nullabilityBuffer && !this.nullabilityBuffer.get(t$1) ? null : this.getValueFromBuffer(t$1);
				}
				has(t$1) {
					return this.nullabilityBuffer && this.nullabilityBuffer.get(t$1) || !this.nullabilityBuffer;
				}
				get name() {
					return this._name;
				}
				get size() {
					return this._size;
				}
			}
			class jh extends qh {}
			class Gh extends jh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class Xh extends jh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class Yh extends qh {
				delta;
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1, n$1), this.delta = r$1;
				}
			}
			class Zh extends Yh {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, Int32Array.of(e$1), r$1, n$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0] + t$1 * this.delta;
				}
			}
			class Hh extends qh {
				constructor(t$1, e$1, r$1) {
					super(t$1, Int32Array.of(e$1), r$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0];
				}
			}
			class Kh {
				_name;
				_geometryVector;
				_idVector;
				_propertyVectors;
				_extent;
				propertyVectorsMap;
				constructor(t$1, e$1, r$1, n$1, i$1 = 4096) {
					this._name = t$1, this._geometryVector = e$1, this._idVector = r$1, this._propertyVectors = n$1, this._extent = i$1;
				}
				get name() {
					return this._name;
				}
				get idVector() {
					return this._idVector;
				}
				get geometryVector() {
					return this._geometryVector;
				}
				get propertyVectors() {
					return this._propertyVectors;
				}
				getPropertyVector(t$1) {
					return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(((t$2) => [t$2.name, t$2])))), this.propertyVectorsMap.get(t$1);
				}
				*[Symbol.iterator]() {
					const t$1 = this.geometryVector[Symbol.iterator]();
					let e$1 = 0;
					for (; e$1 < this.numFeatures;) {
						let r$1;
						this.idVector && (r$1 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(e$1)) : this.idVector.getValue(e$1));
						const n$1 = t$1?.next().value, i$1 = {};
						for (const t$2 of this.propertyVectors) {
							if (!t$2) continue;
							const r$2 = t$2.name, n$2 = t$2.getValue(e$1);
							null !== n$2 && (i$1[r$2] = n$2);
						}
						e$1++, yield {
							id: r$1,
							geometry: n$1,
							properties: i$1
						};
					}
				}
				get numFeatures() {
					return this.geometryVector.numGeometries;
				}
				get extent() {
					return this._extent;
				}
				getFeatures() {
					const t$1 = [], e$1 = this.geometryVector.getGeometries();
					for (let r$1 = 0; r$1 < this.numFeatures; r$1++) {
						let n$1;
						this.idVector && (n$1 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(r$1)) : this.idVector.getValue(r$1));
						const i$1 = {
							coordinates: e$1[r$1],
							type: this.geometryVector.geometryType(r$1)
						}, s$1 = {};
						for (const t$2 of this.propertyVectors) {
							if (!t$2) continue;
							const e$2 = t$2.name, n$2 = t$2.getValue(r$1);
							null !== n$2 && (s$1[e$2] = n$2);
						}
						t$1.push({
							id: n$1,
							geometry: i$1,
							properties: s$1
						});
					}
					return t$1;
				}
				containsMaxSaveIntegerValues(t$1) {
					return t$1 instanceof Gh || t$1 instanceof Hh && t$1 instanceof Zh || t$1 instanceof Xh;
				}
			}
			class Wh {
				value;
				constructor(t$1) {
					this.value = t$1;
				}
				get() {
					return this.value;
				}
				set(t$1) {
					this.value = t$1;
				}
				increment() {
					return this.value++;
				}
				add(t$1) {
					this.value += t$1;
				}
			}
			var Jh, Qh, tp$1, ep$1, rp$1, np$1, ip$1, sp$1, op$1, ap$1;
			function lp$1(t$1, e$1, r$1) {
				const n$1 = new Int32Array(r$1);
				let i$1 = 0, s$1 = e$1.get();
				for (let e$2 = 0; e$2 < n$1.length; e$2++) {
					let e$3 = t$1[s$1++], r$2 = 127 & e$3;
					e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (127 & e$3) << 7, e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (127 & e$3) << 14, e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (127 & e$3) << 21, e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (15 & e$3) << 28)))), n$1[i$1++] = r$2;
				}
				return e$1.set(s$1), n$1;
			}
			function up$1(t$1, e$1, r$1) {
				const n$1 = new BigInt64Array(r$1);
				for (let r$2 = 0; r$2 < n$1.length; r$2++) n$1[r$2] = dp$1(t$1, e$1);
				return n$1;
			}
			function cp$1(t$1, e$1) {
				let r$1, n$1;
				return n$1 = t$1[e$1.get()], e$1.increment(), r$1 = 127 & n$1, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], e$1.increment(), r$1 |= (127 & n$1) << 7, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], e$1.increment(), r$1 |= (127 & n$1) << 14, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], e$1.increment(), r$1 |= (127 & n$1) << 21, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], r$1 |= (15 & n$1) << 28, function(t$2, e$2, r$2) {
					let n$2, i$1;
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 = (112 & i$1) >> 4, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 3, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 10, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 17, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 24, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (1 & i$1) << 31, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					throw new Error("Expected varint not more than 10 bytes");
				}(r$1, t$1, e$1)))));
			}
			function hp$1(t$1, e$1, r$1, n$1) {
				throw new Error("FastPFor is not implemented yet.");
			}
			function pp$1(t$1) {
				return t$1 >>> 1 ^ -(1 & t$1);
			}
			function fp$1(t$1) {
				return t$1 >> 1n ^ -(1n & t$1);
			}
			function dp$1(t$1, e$1) {
				let r$1 = 0n, n$1 = 0, i$1 = e$1.get();
				for (; i$1 < t$1.length;) {
					const e$2 = t$1[i$1++];
					if (r$1 |= BigInt(127 & e$2) << BigInt(n$1), !(128 & e$2)) break;
					if (n$1 += 7, n$1 >= 64) throw new Error("Varint too long");
				}
				return e$1.set(i$1), r$1;
			}
			function yp$1(t$1, e$1, r$1) {
				const n$1 = new Int32Array(r$1);
				let i$1 = 0;
				for (let r$2 = 0; r$2 < e$1; r$2++) {
					const s$1 = t$1[r$2];
					n$1.fill(t$1[r$2 + e$1], i$1, i$1 + s$1), i$1 += s$1;
				}
				return n$1;
			}
			function mp$1(t$1, e$1, r$1) {
				const n$1 = new BigInt64Array(r$1);
				let i$1 = 0;
				for (let r$2 = 0; r$2 < e$1; r$2++) {
					const s$1 = Number(t$1[r$2]);
					n$1.fill(t$1[r$2 + e$1], i$1, i$1 + s$1), i$1 += s$1;
				}
				return n$1;
			}
			function gp$1(t$1, e$1, r$1) {
				const n$1 = new Float64Array(r$1);
				let i$1 = 0;
				for (let r$2 = 0; r$2 < e$1; r$2++) {
					const s$1 = t$1[r$2];
					n$1.fill(t$1[r$2 + e$1], i$1, i$1 + s$1), i$1 += s$1;
				}
				return n$1;
			}
			function xp$1(t$1) {
				const e$1 = t$1.length / 4 * 4;
				let r$1 = 1;
				if (e$1 >= 4) for (let n$1 = t$1[0]; r$1 < e$1 - 4; r$1 += 4) n$1 = t$1[r$1] += n$1, n$1 = t$1[r$1 + 1] += n$1, n$1 = t$1[r$1 + 2] += n$1, n$1 = t$1[r$1 + 3] += n$1;
				for (; r$1 != t$1.length;) t$1[r$1] += t$1[r$1 - 1], ++r$1;
			}
			function vp$1(t$1) {
				t$1[0] = t$1[0] >>> 1 ^ -(1 & t$1[0]), t$1[1] = t$1[1] >>> 1 ^ -(1 & t$1[1]);
				const e$1 = t$1.length / 4 * 4;
				let r$1 = 2;
				if (e$1 >= 4) for (; r$1 < e$1 - 4; r$1 += 4) {
					const e$2 = t$1[r$1], n$1 = t$1[r$1 + 1], i$1 = t$1[r$1 + 2], s$1 = t$1[r$1 + 3];
					t$1[r$1] = (e$2 >>> 1 ^ -(1 & e$2)) + t$1[r$1 - 2], t$1[r$1 + 1] = (n$1 >>> 1 ^ -(1 & n$1)) + t$1[r$1 - 1], t$1[r$1 + 2] = (i$1 >>> 1 ^ -(1 & i$1)) + t$1[r$1], t$1[r$1 + 3] = (s$1 >>> 1 ^ -(1 & s$1)) + t$1[r$1 + 1];
				}
				for (; r$1 != t$1.length; r$1 += 2) t$1[r$1] = (t$1[r$1] >>> 1 ^ -(1 & t$1[r$1])) + t$1[r$1 - 2], t$1[r$1 + 1] = (t$1[r$1 + 1] >>> 1 ^ -(1 & t$1[r$1 + 1])) + t$1[r$1 - 1];
			}
			(function(t$1) {
				t$1.NONE = "NONE", t$1.DELTA = "DELTA", t$1.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", t$1.RLE = "RLE", t$1.MORTON = "MORTON", t$1.PDE = "PDE";
			})(Jh || (Jh = {})), function(t$1) {
				t$1.NONE = "NONE", t$1.FAST_PFOR = "FAST_PFOR", t$1.VARINT = "VARINT", t$1.ALP = "ALP";
			}(Qh || (Qh = {})), function(t$1) {
				t$1.PRESENT = "PRESENT", t$1.DATA = "DATA", t$1.OFFSET = "OFFSET", t$1.LENGTH = "LENGTH";
			}(tp$1 || (tp$1 = {}));
			class bp$1 {
				_dictionaryType;
				_offsetType;
				_lengthType;
				constructor(t$1, e$1, r$1) {
					this._dictionaryType = t$1, this._offsetType = e$1, this._lengthType = r$1;
				}
				get dictionaryType() {
					return this._dictionaryType;
				}
				get offsetType() {
					return this._offsetType;
				}
				get lengthType() {
					return this._lengthType;
				}
			}
			function wp$1(t$1, e$1) {
				const r$1 = function(t$2, e$2) {
					const r$2 = t$2[e$2.get()], n$1 = Object.values(tp$1)[r$2 >> 4];
					let i$1 = null;
					switch (n$1) {
						case tp$1.DATA:
							i$1 = new bp$1(Object.values(ep$1)[15 & r$2]);
							break;
						case tp$1.OFFSET:
							i$1 = new bp$1(null, Object.values(rp$1)[15 & r$2]);
							break;
						case tp$1.LENGTH: i$1 = new bp$1(null, null, Object.values(np$1)[15 & r$2]);
					}
					e$2.increment();
					const s$1 = t$2[e$2.get()], o = Object.values(Jh)[s$1 >> 5], a$1 = Object.values(Jh)[s$1 >> 2 & 7], l$1 = Object.values(Qh)[3 & s$1];
					e$2.increment();
					const u$1 = lp$1(t$2, e$2, 2), c$1 = u$1[0];
					return {
						physicalStreamType: n$1,
						logicalStreamType: i$1,
						logicalLevelTechnique1: o,
						logicalLevelTechnique2: a$1,
						physicalLevelTechnique: l$1,
						numValues: c$1,
						byteLength: u$1[1],
						decompressedCount: c$1
					};
				}(t$1, e$1);
				return r$1.logicalLevelTechnique1 === Jh.MORTON ? function(t$2, e$2, r$2) {
					const n$1 = lp$1(e$2, r$2, 2);
					return {
						physicalStreamType: t$2.physicalStreamType,
						logicalStreamType: t$2.logicalStreamType,
						logicalLevelTechnique1: t$2.logicalLevelTechnique1,
						logicalLevelTechnique2: t$2.logicalLevelTechnique2,
						physicalLevelTechnique: t$2.physicalLevelTechnique,
						numValues: t$2.numValues,
						byteLength: t$2.byteLength,
						decompressedCount: t$2.decompressedCount,
						numBits: n$1[0],
						coordinateShift: n$1[1]
					};
				}(r$1, t$1, e$1) : Jh.RLE !== r$1.logicalLevelTechnique1 && Jh.RLE !== r$1.logicalLevelTechnique2 || Qh.NONE === r$1.physicalLevelTechnique ? r$1 : function(t$2, e$2, r$2) {
					const n$1 = lp$1(e$2, r$2, 2);
					return {
						physicalStreamType: t$2.physicalStreamType,
						logicalStreamType: t$2.logicalStreamType,
						logicalLevelTechnique1: t$2.logicalLevelTechnique1,
						logicalLevelTechnique2: t$2.logicalLevelTechnique2,
						physicalLevelTechnique: t$2.physicalLevelTechnique,
						numValues: t$2.numValues,
						byteLength: t$2.byteLength,
						decompressedCount: n$1[1],
						runs: n$1[0],
						numRleValues: n$1[1]
					};
				}(r$1, t$1, e$1);
			}
			(function(t$1) {
				t$1.NONE = "NONE", t$1.SINGLE = "SINGLE", t$1.SHARED = "SHARED", t$1.VERTEX = "VERTEX", t$1.MORTON = "MORTON", t$1.FSST = "FSST";
			})(ep$1 || (ep$1 = {})), function(t$1) {
				t$1.VERTEX = "VERTEX", t$1.INDEX = "INDEX", t$1.STRING = "STRING", t$1.KEY = "KEY";
			}(rp$1 || (rp$1 = {})), function(t$1) {
				t$1.VAR_BINARY = "VAR_BINARY", t$1.GEOMETRIES = "GEOMETRIES", t$1.PARTS = "PARTS", t$1.RINGS = "RINGS", t$1.TRIANGLES = "TRIANGLES", t$1.SYMBOL = "SYMBOL", t$1.DICTIONARY = "DICTIONARY";
			}(np$1 || (np$1 = {})), function(t$1) {
				t$1[t$1.FLAT = 0] = "FLAT", t$1[t$1.CONST = 1] = "CONST", t$1[t$1.SEQUENCE = 2] = "SEQUENCE", t$1[t$1.DICTIONARY = 3] = "DICTIONARY", t$1[t$1.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
			}(ip$1 || (ip$1 = {}));
			class _p$1 {
				values;
				_size;
				constructor(t$1, e$1) {
					this.values = t$1, this._size = e$1;
				}
				get(t$1) {
					const e$1 = Math.floor(t$1 / 8);
					return 1 == (this.values[e$1] >> t$1 % 8 & 1);
				}
				set(t$1, e$1) {
					const r$1 = Math.floor(t$1 / 8);
					this.values[r$1] = this.values[r$1] | (e$1 ? 1 : 0) << t$1 % 8;
				}
				getInt(t$1) {
					const e$1 = Math.floor(t$1 / 8);
					return this.values[e$1] >> t$1 % 8 & 1;
				}
				size() {
					return this._size;
				}
				getBuffer() {
					return this.values;
				}
			}
			function Ap$1(t$1, e$1, r$1, n$1, i$1) {
				return function(t$2, e$2, r$2) {
					switch (e$2.logicalLevelTechnique1) {
						case Jh.DELTA: return e$2.logicalLevelTechnique2 === Jh.RLE ? function(t$3, e$3, r$3) {
							const n$2 = new Int32Array(r$3);
							let i$2 = 0, s$1 = 0;
							for (let r$4 = 0; r$4 < e$3; r$4++) {
								const o = t$3[r$4], a$1 = pp$1(t$3[r$4 + e$3]);
								for (let t$4 = 0; t$4 < o; t$4++) s$1 += a$1, n$2[i$2++] = s$1;
							}
							return n$2;
						}(t$2, e$2.runs, e$2.numRleValues) : (function(t$3) {
							t$3[0] = t$3[0] >>> 1 ^ -(1 & t$3[0]);
							const e$3 = t$3.length / 4 * 4;
							let r$3 = 1;
							if (e$3 >= 4) for (; r$3 < e$3 - 4; r$3 += 4) {
								const e$4 = t$3[r$3], n$2 = t$3[r$3 + 1], i$2 = t$3[r$3 + 2], s$1 = t$3[r$3 + 3];
								t$3[r$3] = (e$4 >>> 1 ^ -(1 & e$4)) + t$3[r$3 - 1], t$3[r$3 + 1] = (n$2 >>> 1 ^ -(1 & n$2)) + t$3[r$3], t$3[r$3 + 2] = (i$2 >>> 1 ^ -(1 & i$2)) + t$3[r$3 + 1], t$3[r$3 + 3] = (s$1 >>> 1 ^ -(1 & s$1)) + t$3[r$3 + 2];
							}
							for (; r$3 != t$3.length; ++r$3) t$3[r$3] = (t$3[r$3] >>> 1 ^ -(1 & t$3[r$3])) + t$3[r$3 - 1];
						}(t$2), t$2);
						case Jh.RLE: return function(t$3, e$3, r$3) {
							return r$3 ? function(t$4, e$4, r$4) {
								const n$2 = new Int32Array(r$4);
								let i$2 = 0;
								for (let r$5 = 0; r$5 < e$4; r$5++) {
									const s$1 = t$4[r$5];
									let o = t$4[r$5 + e$4];
									o = o >>> 1 ^ -(1 & o), n$2.fill(o, i$2, i$2 + s$1), i$2 += s$1;
								}
								return n$2;
							}(t$3, e$3.runs, e$3.numRleValues) : yp$1(t$3, e$3.runs, e$3.numRleValues);
						}(t$2, e$2, r$2);
						case Jh.MORTON: return xp$1(t$2), t$2;
						case Jh.COMPONENTWISE_DELTA: return vp$1(t$2), t$2;
						case Jh.NONE: return r$2 && function(t$3) {
							for (let e$3 = 0; e$3 < t$3.length; e$3++) {
								const r$3 = t$3[e$3];
								t$3[e$3] = r$3 >>> 1 ^ -(1 & r$3);
							}
						}(t$2), t$2;
						default: throw new Error(`The specified Logical level technique is not supported: ${e$2.logicalLevelTechnique1}`);
					}
				}(kp$1(t$1, e$1, r$1), r$1, n$1);
			}
			function Sp$1(t$1, e$1, r$1) {
				return function(t$2, e$2) {
					if (e$2.logicalLevelTechnique1 === Jh.DELTA && e$2.logicalLevelTechnique2 === Jh.NONE) return function(t$3) {
						const e$3 = new Int32Array(t$3.length + 1);
						e$3[0] = 0, e$3[1] = pp$1(t$3[0]);
						let r$2 = e$3[1], n$1 = 2;
						for (; n$1 != e$3.length; ++n$1) {
							const i$1 = t$3[n$1 - 1];
							r$2 += i$1 >>> 1 ^ -(1 & i$1), e$3[n$1] = e$3[n$1 - 1] + r$2;
						}
						return e$3;
					}(t$2);
					if (e$2.logicalLevelTechnique1 === Jh.RLE && e$2.logicalLevelTechnique2 === Jh.NONE) return function(t$3, e$3, r$2) {
						const n$1 = new Int32Array(r$2 + 1);
						n$1[0] = 0;
						let i$1 = 1, s$1 = n$1[0];
						for (let r$3 = 0; r$3 < e$3; r$3++) {
							const o = t$3[r$3], a$1 = t$3[r$3 + e$3];
							for (let t$4 = i$1; t$4 < i$1 + o; t$4++) n$1[t$4] = a$1 + s$1, s$1 = n$1[t$4];
							i$1 += o;
						}
						return n$1;
					}(t$2, e$2.runs, e$2.numRleValues);
					if (e$2.logicalLevelTechnique1 === Jh.NONE && e$2.logicalLevelTechnique2 === Jh.NONE) {
						(function(t$3) {
							let e$3 = 0;
							for (let r$3 = 0; r$3 < t$3.length; r$3++) t$3[r$3] += e$3, e$3 = t$3[r$3];
						})(t$2);
						const r$2 = new Int32Array(e$2.numValues + 1);
						return r$2[0] = 0, r$2.set(t$2, 1), r$2;
					}
					if (e$2.logicalLevelTechnique1 === Jh.DELTA && e$2.logicalLevelTechnique2 === Jh.RLE) {
						const r$2 = function(t$3, e$3, r$3) {
							const n$1 = new Int32Array(r$3 + 1);
							n$1[0] = 0;
							let i$1 = 1, s$1 = n$1[0];
							for (let r$4 = 0; r$4 < e$3; r$4++) {
								const o = t$3[r$4];
								let a$1 = t$3[r$4 + e$3];
								a$1 = a$1 >>> 1 ^ -(1 & a$1);
								for (let t$4 = i$1; t$4 < i$1 + o; t$4++) n$1[t$4] = a$1 + s$1, s$1 = n$1[t$4];
								i$1 += o;
							}
							return n$1;
						}(t$2, e$2.runs, e$2.numRleValues);
						return xp$1(r$2), r$2;
					}
					throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
				}(kp$1(t$1, e$1, r$1), r$1);
			}
			function kp$1(t$1, e$1, r$1) {
				const n$1 = r$1.physicalLevelTechnique;
				if (n$1 === Qh.FAST_PFOR) return hp$1();
				if (n$1 === Qh.VARINT) return lp$1(t$1, e$1, r$1.numValues);
				if (n$1 === Qh.NONE) {
					const n$2 = e$1.get();
					e$1.add(r$1.byteLength);
					const i$1 = t$1.subarray(n$2, e$1.get());
					return new Int32Array(i$1);
				}
				throw new Error("Specified physicalLevelTechnique is not supported (yet).");
			}
			function Ep$1(t$1, e$1, r$1, n$1) {
				const i$1 = kp$1(t$1, e$1, r$1);
				if (1 === i$1.length) {
					const t$2 = i$1[0];
					return n$1 ? pp$1(t$2) : t$2;
				}
				return n$1 ? function(t$2) {
					return pp$1(t$2[1]);
				}(i$1) : function(t$2) {
					return t$2[1];
				}(i$1);
			}
			function Tp$1(t$1, e$1, r$1) {
				return function(t$2) {
					if (2 == t$2.length) {
						const e$2 = pp$1(t$2[1]);
						return [e$2, e$2];
					}
					return [pp$1(t$2[2]), pp$1(t$2[3])];
				}(kp$1(t$1, e$1, r$1));
			}
			function Ip$1(t$1, e$1, r$1) {
				return function(t$2) {
					if (2 == t$2.length) {
						const e$2 = fp$1(t$2[1]);
						return [e$2, e$2];
					}
					return [fp$1(t$2[2]), fp$1(t$2[3])];
				}(up$1(t$1, e$1, r$1.numValues));
			}
			function Mp$1(t$1, e$1, r$1, n$1) {
				return function(t$2, e$2, r$2) {
					switch (e$2.logicalLevelTechnique1) {
						case Jh.DELTA: return e$2.logicalLevelTechnique2 === Jh.RLE ? function(t$3, e$3, r$3) {
							const n$2 = new BigInt64Array(r$3);
							let i$1 = 0, s$1 = 0n;
							for (let r$4 = 0; r$4 < e$3; r$4++) {
								const o = Number(t$3[r$4]), a$1 = fp$1(t$3[r$4 + e$3]);
								for (let t$4 = 0; t$4 < o; t$4++) s$1 += a$1, n$2[i$1++] = s$1;
							}
							return n$2;
						}(t$2, e$2.runs, e$2.numRleValues) : (function(t$3) {
							t$3[0] = t$3[0] >> 1n ^ -(1n & t$3[0]);
							const e$3 = t$3.length / 4 * 4;
							let r$3 = 1;
							if (e$3 >= 4) for (; r$3 < e$3 - 4; r$3 += 4) {
								const e$4 = t$3[r$3], n$2 = t$3[r$3 + 1], i$1 = t$3[r$3 + 2], s$1 = t$3[r$3 + 3];
								t$3[r$3] = (e$4 >> 1n ^ -(1n & e$4)) + t$3[r$3 - 1], t$3[r$3 + 1] = (n$2 >> 1n ^ -(1n & n$2)) + t$3[r$3], t$3[r$3 + 2] = (i$1 >> 1n ^ -(1n & i$1)) + t$3[r$3 + 1], t$3[r$3 + 3] = (s$1 >> 1n ^ -(1n & s$1)) + t$3[r$3 + 2];
							}
							for (; r$3 != t$3.length; ++r$3) t$3[r$3] = (t$3[r$3] >> 1n ^ -(1n & t$3[r$3])) + t$3[r$3 - 1];
						}(t$2), t$2);
						case Jh.RLE: return function(t$3, e$3, r$3) {
							return r$3 ? function(t$4, e$4, r$4) {
								const n$2 = new BigInt64Array(r$4);
								let i$1 = 0;
								for (let r$5 = 0; r$5 < e$4; r$5++) {
									const s$1 = Number(t$4[r$5]);
									let o = t$4[r$5 + e$4];
									o = o >> 1n ^ -(1n & o), n$2.fill(o, i$1, i$1 + s$1), i$1 += s$1;
								}
								return n$2;
							}(t$3, e$3.runs, e$3.numRleValues) : mp$1(t$3, e$3.runs, e$3.numRleValues);
						}(t$2, e$2, r$2);
						case Jh.NONE: return r$2 && function(t$3) {
							for (let e$3 = 0; e$3 < t$3.length; e$3++) {
								const r$3 = t$3[e$3];
								t$3[e$3] = r$3 >> 1n ^ -(1n & r$3);
							}
						}(t$2), t$2;
						default: throw new Error(`The specified Logical level technique is not supported: ${e$2.logicalLevelTechnique1}`);
					}
				}(up$1(t$1, e$1, r$1.numValues), r$1, n$1);
			}
			function Fp$1(t$1, e$1, r$1, n$1) {
				const i$1 = up$1(t$1, e$1, r$1.numValues);
				if (1 === i$1.length) {
					const t$2 = i$1[0];
					return n$1 ? fp$1(t$2) : t$2;
				}
				return n$1 ? function(t$2) {
					return fp$1(t$2[1]);
				}(i$1) : function(t$2) {
					return t$2[1];
				}(i$1);
			}
			function Dp$1(t$1, e$1, r$1, n$1, i$1) {
				return function(t$2, e$2, r$2, n$2) {
					switch (e$2.logicalLevelTechnique1) {
						case Jh.DELTA: return e$2.logicalLevelTechnique2 === Jh.RLE && (t$2 = yp$1(t$2, e$2.runs, e$2.numRleValues)), function(t$3, e$3) {
							const r$3 = new Int32Array(t$3.size());
							let n$3 = 0;
							t$3.get(0) ? (r$3[0] = t$3.get(0) ? e$3[0] >>> 1 ^ -(1 & e$3[0]) : 0, n$3 = 1) : r$3[0] = 0;
							let i$2 = 1;
							for (; i$2 != r$3.length; ++i$2) r$3[i$2] = t$3.get(i$2) ? r$3[i$2 - 1] + (e$3[n$3] >>> 1 ^ -(1 & e$3[n$3++])) : r$3[i$2 - 1];
							return r$3;
						}(n$2, t$2);
						case Jh.RLE: return function(t$3, e$3, r$3, n$3) {
							const i$2 = e$3;
							return r$3 ? function(t$4, e$4, r$4) {
								const n$4 = new Int32Array(t$4.size());
								let i$3 = 0;
								for (let s$1 = 0; s$1 < r$4; s$1++) {
									const o = e$4[s$1];
									let a$1 = e$4[s$1 + r$4];
									a$1 = a$1 >>> 1 ^ -(1 & a$1);
									for (let e$5 = i$3; e$5 < i$3 + o; e$5++) t$4.get(e$5) ? n$4[e$5] = a$1 : (n$4[e$5] = 0, i$3++);
									i$3 += o;
								}
								return n$4;
							}(n$3, t$3, i$2.runs) : function(t$4, e$4, r$4) {
								const n$4 = new Int32Array(t$4.size());
								let i$3 = 0;
								for (let s$1 = 0; s$1 < r$4; s$1++) {
									const o = e$4[s$1], a$1 = e$4[s$1 + r$4];
									for (let e$5 = i$3; e$5 < i$3 + o; e$5++) t$4.get(e$5) ? n$4[e$5] = a$1 : (n$4[e$5] = 0, i$3++);
									i$3 += o;
								}
								return n$4;
							}(n$3, t$3, i$2.runs);
						}(t$2, e$2, r$2, n$2);
						case Jh.MORTON: return xp$1(t$2), t$2;
						case Jh.COMPONENTWISE_DELTA: return vp$1(t$2), t$2;
						case Jh.NONE: return t$2 = r$2 ? function(t$3, e$3) {
							const r$3 = new Int32Array(t$3.size());
							let n$3 = 0, i$2 = 0;
							for (; i$2 != r$3.length; ++i$2) if (t$3.get(i$2)) {
								const t$4 = e$3[n$3++];
								r$3[i$2] = t$4 >>> 1 ^ -(1 & t$4);
							} else r$3[i$2] = 0;
							return r$3;
						}(n$2, t$2) : function(t$3, e$3) {
							const r$3 = new Int32Array(t$3.size());
							let n$3 = 0, i$2 = 0;
							for (; i$2 != r$3.length; ++i$2) r$3[i$2] = t$3.get(i$2) ? e$3[n$3++] : 0;
							return r$3;
						}(n$2, t$2), t$2;
						default: throw new Error("The specified Logical level technique is not supported");
					}
				}(r$1.physicalLevelTechnique === Qh.FAST_PFOR ? hp$1() : lp$1(t$1, e$1, r$1.numValues), r$1, n$1, i$1);
			}
			function Pp$1(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.logicalLevelTechnique1;
				if (i$1 === Jh.RLE) return 1 === t$1.runs ? ip$1.CONST : ip$1.FLAT;
				const s$1 = e$1 instanceof _p$1 ? e$1.size() : e$1;
				if (i$1 === Jh.DELTA && t$1.logicalLevelTechnique2 === Jh.RLE) {
					const e$2 = t$1.runs, i$2 = 2;
					if (t$1.numRleValues !== s$1) return ip$1.FLAT;
					if (1 === e$2) return ip$1.SEQUENCE;
					if (2 === e$2) {
						const e$3 = n$1.get();
						let s$2;
						if (t$1.physicalLevelTechnique === Qh.VARINT) s$2 = lp$1(r$1, n$1, 4);
						else {
							const t$2 = n$1.get();
							s$2 = new Int32Array(r$1.buffer, r$1.byteOffset + t$2, 4);
						}
						if (n$1.set(e$3), s$2[2] === i$2 && s$2[3] === i$2) return ip$1.SEQUENCE;
					}
				}
				return 1 === t$1.numValues ? ip$1.CONST : ip$1.FLAT;
			}
			class zp$1 extends jh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class Bp$1 extends Yh {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, BigInt64Array.of(e$1), r$1, n$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0] + BigInt(t$1) * this.delta;
				}
			}
			class Vp$1 {
				_geometryOffsets;
				_partOffsets;
				_ringOffsets;
				constructor(t$1, e$1, r$1) {
					this._geometryOffsets = t$1, this._partOffsets = e$1, this._ringOffsets = r$1;
				}
				get geometryOffsets() {
					return this._geometryOffsets;
				}
				get partOffsets() {
					return this._partOffsets;
				}
				get ringOffsets() {
					return this._ringOffsets;
				}
			}
			function Cp$1(t$1, e$1, r$1) {
				return {
					x: Lp$1(t$1, e$1) - r$1,
					y: Lp$1(t$1 >> 1, e$1) - r$1
				};
			}
			function Lp$1(t$1, e$1) {
				let r$1 = 0;
				for (let n$1 = 0; n$1 < e$1; n$1++) r$1 |= (t$1 & 1 << 2 * n$1) >> n$1;
				return r$1;
			}
			(function(t$1) {
				t$1[t$1.POINT = 0] = "POINT", t$1[t$1.LINESTRING = 1] = "LINESTRING", t$1[t$1.POLYGON = 2] = "POLYGON", t$1[t$1.MULTIPOINT = 3] = "MULTIPOINT", t$1[t$1.MULTILINESTRING = 4] = "MULTILINESTRING", t$1[t$1.MULTIPOLYGON = 5] = "MULTIPOLYGON";
			})(sp$1 || (sp$1 = {})), function(t$1) {
				t$1[t$1.POINT = 0] = "POINT", t$1[t$1.LINESTRING = 1] = "LINESTRING", t$1[t$1.POLYGON = 2] = "POLYGON";
			}(op$1 || (op$1 = {})), function(t$1) {
				t$1[t$1.MORTON = 0] = "MORTON", t$1[t$1.VEC_2 = 1] = "VEC_2", t$1[t$1.VEC_3 = 2] = "VEC_3";
			}(ap$1 || (ap$1 = {}));
			class Op$1 {
				createPoint(t$1) {
					return [[t$1]];
				}
				createMultiPoint(t$1) {
					return t$1.map(((t$2) => [t$2]));
				}
				createLineString(t$1) {
					return [t$1];
				}
				createMultiLineString(t$1) {
					return t$1;
				}
				createPolygon(t$1, e$1) {
					return [t$1].concat(e$1);
				}
				createMultiPolygon(t$1) {
					return t$1.flat();
				}
			}
			function Rp$1(t$1) {
				const e$1 = new Array(t$1.numGeometries);
				let n$1 = 1, i$1 = 1, s$1 = 1, o = 0;
				const a$1 = new Op$1();
				let l$1 = 0, u$1 = 0;
				const c$1 = t$1.mortonSettings, h$1 = t$1.topologyVector, p$1 = h$1.geometryOffsets, f$1 = h$1.partOffsets, d$1 = h$1.ringOffsets, y$1 = t$1.vertexOffsets, m$1 = t$1.containsPolygonGeometry(), g$2 = t$1.vertexBuffer;
				for (let h$2 = 0; h$2 < t$1.numGeometries; h$2++) {
					const x$1 = t$1.geometryType(h$2);
					if (x$1 === sp$1.POINT) {
						if (y$1 && 0 !== y$1.length) if (t$1.vertexBufferType === ap$1.VEC_2) {
							const t$2 = 2 * y$1[u$1++], n$2 = new r(g$2[t$2], g$2[t$2 + 1]);
							e$1[o++] = a$1.createPoint(n$2);
						} else {
							const t$2 = Cp$1(g$2[y$1[u$1++]], c$1.numBits, c$1.coordinateShift), n$2 = new r(t$2.x, t$2.y);
							e$1[o++] = a$1.createPoint(n$2);
						}
						else {
							const t$2 = new r(g$2[l$1++], g$2[l$1++]);
							e$1[o++] = a$1.createPoint(t$2);
						}
						p$1 && s$1++, f$1 && n$1++, d$1 && i$1++;
					} else if (x$1 === sp$1.MULTIPOINT) {
						const t$2 = p$1[s$1] - p$1[s$1 - 1];
						s$1++;
						const n$2 = new Array(t$2);
						if (y$1 && 0 !== y$1.length) {
							for (let e$2 = 0; e$2 < t$2; e$2++) {
								const t$3 = 2 * y$1[u$1++];
								n$2[e$2] = new r(g$2[t$3], g$2[t$3 + 1]);
							}
							e$1[o++] = a$1.createMultiPoint(n$2);
						} else {
							for (let e$2 = 0; e$2 < t$2; e$2++) {
								const t$3 = g$2[l$1++], i$2 = g$2[l$1++];
								n$2[e$2] = new r(t$3, i$2);
							}
							e$1[o++] = a$1.createMultiPoint(n$2);
						}
					} else if (x$1 === sp$1.LINESTRING) {
						let r$1, h$3 = 0;
						m$1 ? (h$3 = d$1[i$1] - d$1[i$1 - 1], i$1++) : h$3 = f$1[n$1] - f$1[n$1 - 1], n$1++, y$1 && 0 !== y$1.length ? (r$1 = t$1.vertexBufferType === ap$1.VEC_2 ? jp$1(g$2, y$1, u$1, h$3, !1) : Gp$1(g$2, y$1, u$1, h$3, !1, c$1), u$1 += h$3) : (r$1 = qp$1(g$2, l$1, h$3, !1), l$1 += 2 * h$3), e$1[o++] = a$1.createLineString(r$1), p$1 && s$1++;
					} else if (x$1 === sp$1.POLYGON) {
						const r$1 = f$1[n$1] - f$1[n$1 - 1];
						n$1++;
						const h$3 = new Array(r$1 - 1);
						let m$2 = d$1[i$1] - d$1[i$1 - 1];
						if (i$1++, y$1 && 0 !== y$1.length) {
							const r$2 = t$1.vertexBufferType === ap$1.VEC_2 ? $p$1(g$2, y$1, u$1, m$2) : Up$1(g$2, y$1, u$1, m$2, 0, c$1);
							u$1 += m$2;
							for (let e$2 = 0; e$2 < h$3.length; e$2++) m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++, h$3[e$2] = t$1.vertexBufferType === ap$1.VEC_2 ? $p$1(g$2, y$1, u$1, m$2) : Up$1(g$2, y$1, u$1, m$2, 0, c$1), u$1 += m$2;
							e$1[o++] = a$1.createPolygon(r$2, h$3);
						} else {
							const t$2 = Np$1(g$2, l$1, m$2);
							l$1 += 2 * m$2;
							for (let t$3 = 0; t$3 < h$3.length; t$3++) m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++, h$3[t$3] = Np$1(g$2, l$1, m$2), l$1 += 2 * m$2;
							e$1[o++] = a$1.createPolygon(t$2, h$3);
						}
						p$1 && s$1++;
					} else if (x$1 === sp$1.MULTILINESTRING) {
						const r$1 = p$1[s$1] - p$1[s$1 - 1];
						s$1++;
						const h$3 = new Array(r$1);
						if (y$1 && 0 !== y$1.length) {
							for (let e$2 = 0; e$2 < r$1; e$2++) {
								let r$2 = 0;
								m$1 ? (r$2 = d$1[i$1] - d$1[i$1 - 1], i$1++) : r$2 = f$1[n$1] - f$1[n$1 - 1], n$1++;
								h$3[e$2] = t$1.vertexBufferType === ap$1.VEC_2 ? jp$1(g$2, y$1, u$1, r$2, !1) : Gp$1(g$2, y$1, u$1, r$2, !1, c$1), u$1 += r$2;
							}
							e$1[o++] = a$1.createMultiLineString(h$3);
						} else {
							for (let t$2 = 0; t$2 < r$1; t$2++) {
								let e$2 = 0;
								m$1 ? (e$2 = d$1[i$1] - d$1[i$1 - 1], i$1++) : e$2 = f$1[n$1] - f$1[n$1 - 1], n$1++, h$3[t$2] = qp$1(g$2, l$1, e$2, !1), l$1 += 2 * e$2;
							}
							e$1[o++] = a$1.createMultiLineString(h$3);
						}
					} else {
						if (x$1 !== sp$1.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
						{
							const r$1 = p$1[s$1] - p$1[s$1 - 1];
							s$1++;
							const h$3 = new Array(r$1);
							let m$2 = 0;
							if (y$1 && 0 !== y$1.length) {
								for (let e$2 = 0; e$2 < r$1; e$2++) {
									const r$2 = f$1[n$1] - f$1[n$1 - 1];
									n$1++;
									const s$2 = new Array(r$2 - 1);
									m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++;
									const o$1 = t$1.vertexBufferType === ap$1.VEC_2 ? $p$1(g$2, y$1, u$1, m$2) : Up$1(g$2, y$1, u$1, m$2, 0, c$1);
									u$1 += m$2;
									for (let e$3 = 0; e$3 < s$2.length; e$3++) m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++, s$2[e$3] = t$1.vertexBufferType === ap$1.VEC_2 ? $p$1(g$2, y$1, u$1, m$2) : Up$1(g$2, y$1, u$1, m$2, 0, c$1), u$1 += m$2;
									h$3[e$2] = a$1.createPolygon(o$1, s$2);
								}
								e$1[o++] = a$1.createMultiPolygon(h$3);
							} else {
								for (let t$2 = 0; t$2 < r$1; t$2++) {
									const e$2 = f$1[n$1] - f$1[n$1 - 1];
									n$1++;
									const r$2 = new Array(e$2 - 1);
									m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++;
									const s$2 = Np$1(g$2, l$1, m$2);
									l$1 += 2 * m$2;
									for (let t$3 = 0; t$3 < r$2.length; t$3++) {
										const e$3 = d$1[i$1] - d$1[i$1 - 1];
										i$1++, r$2[t$3] = Np$1(g$2, l$1, e$3), l$1 += 2 * e$3;
									}
									h$3[t$2] = a$1.createPolygon(s$2, r$2);
								}
								e$1[o++] = a$1.createMultiPolygon(h$3);
							}
						}
					}
				}
				return e$1;
			}
			function Np$1(t$1, e$1, r$1) {
				return qp$1(t$1, e$1, r$1, !0);
			}
			function $p$1(t$1, e$1, r$1, n$1) {
				return jp$1(t$1, e$1, r$1, n$1, !0);
			}
			function Up$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				return Gp$1(t$1, e$1, r$1, n$1, !0, s$1);
			}
			function qp$1(t$1, e$1, n$1, i$1) {
				const s$1 = new Array(i$1 ? n$1 + 1 : n$1);
				for (let i$2 = 0; i$2 < 2 * n$1; i$2 += 2) s$1[i$2 / 2] = new r(t$1[e$1 + i$2], t$1[e$1 + i$2 + 1]);
				return i$1 && (s$1[s$1.length - 1] = s$1[0]), s$1;
			}
			function jp$1(t$1, e$1, n$1, i$1, s$1) {
				const o = new Array(s$1 ? i$1 + 1 : i$1);
				for (let s$2 = 0; s$2 < 2 * i$1; s$2 += 2) {
					const i$2 = 2 * e$1[n$1 + s$2 / 2];
					o[s$2 / 2] = new r(t$1[i$2], t$1[i$2 + 1]);
				}
				return s$1 && (o[o.length - 1] = o[0]), o;
			}
			function Gp$1(t$1, e$1, n$1, i$1, s$1, o) {
				const a$1 = new Array(s$1 ? i$1 + 1 : i$1);
				for (let s$2 = 0; s$2 < i$1; s$2++) {
					const i$2 = Cp$1(t$1[e$1[n$1 + s$2]], o.numBits, o.coordinateShift);
					a$1[s$2] = new r(i$2.x, i$2.y);
				}
				return s$1 && (a$1[a$1.length - 1] = a$1[0]), a$1;
			}
			class Xp$1 {
				_vertexBufferType;
				_topologyVector;
				_vertexOffsets;
				_vertexBuffer;
				_mortonSettings;
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this._vertexBufferType = t$1, this._topologyVector = e$1, this._vertexOffsets = r$1, this._vertexBuffer = n$1, this._mortonSettings = i$1;
				}
				get vertexBufferType() {
					return this._vertexBufferType;
				}
				get topologyVector() {
					return this._topologyVector;
				}
				get vertexOffsets() {
					return this._vertexOffsets;
				}
				get vertexBuffer() {
					return this._vertexBuffer;
				}
				*[Symbol.iterator]() {
					const t$1 = Rp$1(this);
					let e$1 = 0;
					for (; e$1 < this.numGeometries;) yield {
						coordinates: t$1[e$1],
						type: this.geometryType(e$1)
					}, e$1++;
				}
				getSimpleEncodedVertex(t$1) {
					const e$1 = this.vertexOffsets ? 2 * this.vertexOffsets[t$1] : 2 * t$1;
					return [this.vertexBuffer[e$1], this.vertexBuffer[e$1 + 1]];
				}
				getVertex(t$1) {
					if (this.vertexOffsets && this.mortonSettings) {
						const e$2 = Cp$1(this.vertexBuffer[this.vertexOffsets[t$1]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
						return [e$2.x, e$2.y];
					}
					const e$1 = this.vertexOffsets ? 2 * this.vertexOffsets[t$1] : 2 * t$1;
					return [this.vertexBuffer[e$1], this.vertexBuffer[e$1 + 1]];
				}
				getGeometries() {
					return Rp$1(this);
				}
				get mortonSettings() {
					return this._mortonSettings;
				}
			}
			class Yp$1 extends Xp$1 {
				_numGeometries;
				_geometryType;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					super(r$1, n$1, i$1, s$1, o), this._numGeometries = t$1, this._geometryType = e$1;
				}
				geometryType(t$1) {
					return this._geometryType;
				}
				get numGeometries() {
					return this._numGeometries;
				}
				containsPolygonGeometry() {
					return this._geometryType === sp$1.POLYGON || this._geometryType === sp$1.MULTIPOLYGON;
				}
				containsSingleGeometryType() {
					return !0;
				}
			}
			class Zp$1 extends Xp$1 {
				_geometryTypes;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					super(t$1, r$1, n$1, i$1, s$1), this._geometryTypes = e$1;
				}
				geometryType(t$1) {
					return this._geometryTypes[t$1];
				}
				get numGeometries() {
					return this._geometryTypes.length;
				}
				containsPolygonGeometry() {
					for (let t$1 = 0; t$1 < this.numGeometries; t$1++) if (this.geometryType(t$1) === sp$1.POLYGON || this.geometryType(t$1) === sp$1.MULTIPOLYGON) return !0;
					return !1;
				}
				containsSingleGeometryType() {
					return !1;
				}
			}
			class Hp$1 {
				_triangleOffsets;
				_indexBuffer;
				_vertexBuffer;
				_topologyVector;
				constructor(t$1, e$1, r$1, n$1) {
					this._triangleOffsets = t$1, this._indexBuffer = e$1, this._vertexBuffer = r$1, this._topologyVector = n$1;
				}
				get triangleOffsets() {
					return this._triangleOffsets;
				}
				get indexBuffer() {
					return this._indexBuffer;
				}
				get vertexBuffer() {
					return this._vertexBuffer;
				}
				get topologyVector() {
					return this._topologyVector;
				}
				getGeometries() {
					if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
					const t$1 = new Array(this.numGeometries), e$1 = this._topologyVector, n$1 = e$1.partOffsets, i$1 = e$1.ringOffsets, s$1 = e$1.geometryOffsets;
					let o = 0, a$1 = 1, l$1 = 1, u$1 = 1;
					for (let e$2 = 0; e$2 < this.numGeometries; e$2++) switch (this.geometryType(e$2)) {
						case sp$1.POLYGON:
							{
								const c$1 = n$1[a$1] - n$1[a$1 - 1];
								a$1++;
								const h$1 = [];
								for (let t$2 = 0; t$2 < c$1; t$2++) {
									const t$3 = i$1[l$1] - i$1[l$1 - 1];
									l$1++;
									const e$3 = [];
									for (let n$2 = 0; n$2 < t$3; n$2++) {
										const t$4 = this._vertexBuffer[o++], n$3 = this._vertexBuffer[o++];
										e$3.push(new r(t$4, n$3));
									}
									e$3.length > 0 && e$3.push(e$3[0]), h$1.push(e$3);
								}
								t$1[e$2] = h$1, s$1 && u$1++;
							}
							break;
						case sp$1.MULTIPOLYGON: {
							const c$1 = s$1[u$1] - s$1[u$1 - 1];
							u$1++;
							const h$1 = [];
							for (let t$2 = 0; t$2 < c$1; t$2++) {
								const t$3 = n$1[a$1] - n$1[a$1 - 1];
								a$1++;
								for (let e$3 = 0; e$3 < t$3; e$3++) {
									const t$4 = i$1[l$1] - i$1[l$1 - 1];
									l$1++;
									const e$4 = [];
									for (let n$2 = 0; n$2 < t$4; n$2++) {
										const t$5 = this._vertexBuffer[o++], n$3 = this._vertexBuffer[o++];
										e$4.push(new r(t$5, n$3));
									}
									e$4.length > 0 && e$4.push(e$4[0]), h$1.push(e$4);
								}
							}
							t$1[e$2] = h$1;
						}
					}
					return t$1;
				}
				[Symbol.iterator]() {
					return null;
				}
			}
			function Kp$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				return new Wp$1(t$1, e$1, r$1, n$1, i$1, s$1);
			}
			class Wp$1 extends Hp$1 {
				_numGeometries;
				_geometryType;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					super(r$1, n$1, i$1, s$1), this._numGeometries = t$1, this._geometryType = e$1;
				}
				geometryType(t$1) {
					return this._geometryType;
				}
				get numGeometries() {
					return this._numGeometries;
				}
				containsSingleGeometryType() {
					return !0;
				}
			}
			function Jp$1(t$1, e$1, r$1, n$1, i$1) {
				return new Qp$1(t$1, e$1, r$1, n$1, i$1);
			}
			class Qp$1 extends Hp$1 {
				_geometryTypes;
				constructor(t$1, e$1, r$1, n$1, i$1) {
					super(e$1, r$1, n$1, i$1), this._geometryTypes = t$1;
				}
				geometryType(t$1) {
					return this._geometryTypes[t$1];
				}
				get numGeometries() {
					return this._geometryTypes.length;
				}
				containsSingleGeometryType() {
					return !1;
				}
			}
			function tf$1(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = wp$1(t$1, r$1);
				let o = null, a$1 = null, l$1 = null, u$1 = null, c$1 = null, h$1 = null, p$1 = null, f$1 = null;
				if (Pp$1(s$1, n$1, t$1, r$1) === ip$1.CONST) {
					const i$2 = Ep$1(t$1, r$1, s$1, !1);
					for (let n$2 = 0; n$2 < e$1 - 1; n$2++) {
						const e$2 = wp$1(t$1, r$1);
						switch (e$2.physicalStreamType) {
							case tp$1.LENGTH:
								switch (e$2.logicalStreamType.lengthType) {
									case np$1.GEOMETRIES:
										o = Sp$1(t$1, r$1, e$2);
										break;
									case np$1.PARTS:
										a$1 = Sp$1(t$1, r$1, e$2);
										break;
									case np$1.RINGS:
										l$1 = Sp$1(t$1, r$1, e$2);
										break;
									case np$1.TRIANGLES: p$1 = Sp$1(t$1, r$1, e$2);
								}
								break;
							case tp$1.OFFSET:
								switch (e$2.logicalStreamType.offsetType) {
									case rp$1.VERTEX:
										u$1 = Ap$1(t$1, r$1, e$2, !1);
										break;
									case rp$1.INDEX: f$1 = Ap$1(t$1, r$1, e$2, !1);
								}
								break;
							case tp$1.DATA: ep$1.VERTEX === e$2.logicalStreamType.dictionaryType ? c$1 = Ap$1(t$1, r$1, e$2, !0) : (h$1 = {
								numBits: e$2.numBits,
								coordinateShift: e$2.coordinateShift
							}, c$1 = Ap$1(t$1, r$1, e$2, !1));
						}
					}
					return null !== f$1 ? null != o || null != a$1 ? Kp$1(n$1, i$2, p$1, f$1, c$1, new Vp$1(o, a$1, l$1)) : Kp$1(n$1, i$2, p$1, f$1, c$1) : null === h$1 ? function(t$2, e$2, r$2, n$2, i$3) {
						return new Yp$1(t$2, e$2, ap$1.VEC_2, r$2, n$2, i$3);
					}(n$1, i$2, new Vp$1(o, a$1, l$1), u$1, c$1) : function(t$2, e$2, r$2, n$2, i$3, s$2) {
						return new Yp$1(t$2, e$2, ap$1.MORTON, r$2, n$2, i$3, s$2);
					}(n$1, i$2, new Vp$1(o, a$1, l$1), u$1, c$1, h$1);
				}
				const d$1 = Ap$1(t$1, r$1, s$1, !1);
				for (let n$2 = 0; n$2 < e$1 - 1; n$2++) {
					const e$2 = wp$1(t$1, r$1);
					switch (e$2.physicalStreamType) {
						case tp$1.LENGTH:
							switch (e$2.logicalStreamType.lengthType) {
								case np$1.GEOMETRIES:
									o = Ap$1(t$1, r$1, e$2, !1);
									break;
								case np$1.PARTS:
									a$1 = Ap$1(t$1, r$1, e$2, !1);
									break;
								case np$1.RINGS:
									l$1 = Ap$1(t$1, r$1, e$2, !1);
									break;
								case np$1.TRIANGLES: p$1 = Sp$1(t$1, r$1, e$2);
							}
							break;
						case tp$1.OFFSET:
							switch (e$2.logicalStreamType.offsetType) {
								case rp$1.VERTEX:
									u$1 = Ap$1(t$1, r$1, e$2, !1);
									break;
								case rp$1.INDEX: f$1 = Ap$1(t$1, r$1, e$2, !1);
							}
							break;
						case tp$1.DATA: ep$1.VERTEX === e$2.logicalStreamType.dictionaryType ? c$1 = Ap$1(t$1, r$1, e$2, !0) : (h$1 = {
							numBits: e$2.numBits,
							coordinateShift: e$2.coordinateShift
						}, c$1 = Ap$1(t$1, r$1, e$2, !1));
					}
				}
				return null !== f$1 && null === a$1 ? Jp$1(d$1, p$1, f$1, c$1) : (null !== o ? (o = ef$1(d$1, o, 2), null !== a$1 && null !== l$1 ? (a$1 = rf$1(d$1, o, a$1, !1), l$1 = function(t$2, e$2, r$2, n$2) {
					const i$2 = new Int32Array(r$2[r$2.length - 1] + 1);
					let s$2 = 0;
					i$2[0] = s$2;
					let o$1 = 1, a$2 = 1, l$2 = 0;
					for (let u$2 = 0; u$2 < t$2.length; u$2++) {
						const c$2 = t$2[u$2], h$2 = e$2[u$2 + 1] - e$2[u$2];
						if (0 !== c$2 && 3 !== c$2) for (let t$3 = 0; t$3 < h$2; t$3++) {
							const t$4 = r$2[o$1] - r$2[o$1 - 1];
							o$1++;
							for (let e$3 = 0; e$3 < t$4; e$3++) s$2 = i$2[a$2++] = s$2 + n$2[l$2++];
						}
						else for (let t$3 = 0; t$3 < h$2; t$3++) i$2[a$2++] = ++s$2, o$1++;
					}
					return i$2;
				}(d$1, o, a$1, l$1)) : null !== a$1 && (a$1 = function(t$2, e$2, r$2) {
					const n$2 = new Int32Array(e$2[e$2.length - 1] + 1);
					let i$2 = 0;
					n$2[0] = i$2;
					let s$2 = 1, o$1 = 0;
					for (let a$2 = 0; a$2 < t$2.length; a$2++) {
						const l$2 = t$2[a$2], u$2 = e$2[a$2 + 1] - e$2[a$2];
						if (4 === l$2 || 1 === l$2) for (let t$3 = 0; t$3 < u$2; t$3++) i$2 = n$2[s$2++] = i$2 + r$2[o$1++];
						else for (let t$3 = 0; t$3 < u$2; t$3++) n$2[s$2++] = ++i$2;
					}
					return n$2;
				}(d$1, o, a$1))) : null !== a$1 && null !== l$1 ? (a$1 = ef$1(d$1, a$1, 1), l$1 = rf$1(d$1, a$1, l$1, !0)) : null !== a$1 && (a$1 = ef$1(d$1, a$1, 0)), null !== f$1 ? Jp$1(d$1, p$1, f$1, c$1, new Vp$1(o, a$1, l$1)) : null === h$1 ? function(t$2, e$2, r$2, n$2) {
					return new Zp$1(ap$1.VEC_2, t$2, e$2, r$2, n$2);
				}(d$1, new Vp$1(o, a$1, l$1), u$1, c$1) : function(t$2, e$2, r$2, n$2, i$2) {
					return new Zp$1(ap$1.MORTON, t$2, e$2, r$2, n$2, i$2);
				}(d$1, new Vp$1(o, a$1, l$1), u$1, c$1, h$1));
			}
			function ef$1(t$1, e$1, r$1) {
				const n$1 = new Int32Array(t$1.length + 1);
				let i$1 = 0;
				n$1[0] = i$1;
				let s$1 = 0;
				for (let o = 0; o < t$1.length; o++) i$1 = n$1[o + 1] = i$1 + (t$1[o] > r$1 ? e$1[s$1++] : 1);
				return n$1;
			}
			function rf$1(t$1, e$1, r$1, n$1) {
				const i$1 = new Int32Array(e$1[e$1.length - 1] + 1);
				let s$1 = 0;
				i$1[0] = s$1;
				let o = 1, a$1 = 0;
				for (let l$1 = 0; l$1 < t$1.length; l$1++) {
					const u$1 = t$1[l$1], c$1 = e$1[l$1 + 1] - e$1[l$1];
					if (5 === u$1 || 2 === u$1 || n$1 && (4 === u$1 || 1 === u$1)) for (let t$2 = 0; t$2 < c$1; t$2++) s$1 = i$1[o++] = s$1 + r$1[a$1++];
					else for (let t$2 = 0; t$2 < c$1; t$2++) i$1[o++] = ++s$1;
				}
				return i$1;
			}
			class nf$1 extends qh {
				dataVector;
				constructor(t$1, e$1, r$1) {
					super(t$1, e$1.getBuffer(), r$1), this.dataVector = e$1;
				}
				getValueFromBuffer(t$1) {
					return this.dataVector.get(t$1);
				}
			}
			class sf$1 extends jh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class of$1 extends qh {
				constructor(t$1, e$1, r$1) {
					super(t$1, BigInt64Array.of(e$1), r$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0];
				}
			}
			function af$1(t$1, e$1, r$1) {
				return lf$1(t$1, Math.ceil(e$1 / 8), r$1);
			}
			function lf$1(t$1, e$1, r$1) {
				const n$1 = new Uint8Array(e$1);
				let i$1 = 0;
				for (; i$1 < e$1;) {
					const e$2 = t$1[r$1.increment()];
					if (e$2 <= 127) {
						const s$1 = e$2 + 3, o = t$1[r$1.increment()], a$1 = i$1 + s$1;
						n$1.fill(o, i$1, a$1), i$1 = a$1;
					} else {
						const s$1 = 256 - e$2;
						for (let e$3 = 0; e$3 < s$1; e$3++) n$1[i$1++] = t$1[r$1.increment()];
					}
				}
				return n$1;
			}
			const uf$1 = new TextDecoder();
			function cf$1(t$1, e$1, r$1) {
				return r$1 - e$1 >= 12 ? uf$1.decode(t$1.subarray(e$1, r$1)) : function(t$2, e$2, r$2) {
					let n$1 = "", i$1 = e$2;
					for (; i$1 < r$2;) {
						const e$3 = t$2[i$1];
						let s$1, o, a$1, l$1 = null, u$1 = e$3 > 239 ? 4 : e$3 > 223 ? 3 : e$3 > 191 ? 2 : 1;
						if (i$1 + u$1 > r$2) break;
						1 === u$1 ? e$3 < 128 && (l$1 = e$3) : 2 === u$1 ? (s$1 = t$2[i$1 + 1], 128 == (192 & s$1) && (l$1 = (31 & e$3) << 6 | 63 & s$1, l$1 <= 127 && (l$1 = null))) : 3 === u$1 ? (s$1 = t$2[i$1 + 1], o = t$2[i$1 + 2], 128 == (192 & s$1) && 128 == (192 & o) && (l$1 = (15 & e$3) << 12 | (63 & s$1) << 6 | 63 & o, (l$1 <= 2047 || l$1 >= 55296 && l$1 <= 57343) && (l$1 = null))) : 4 === u$1 && (s$1 = t$2[i$1 + 1], o = t$2[i$1 + 2], a$1 = t$2[i$1 + 3], 128 == (192 & s$1) && 128 == (192 & o) && 128 == (192 & a$1) && (l$1 = (15 & e$3) << 18 | (63 & s$1) << 12 | (63 & o) << 6 | 63 & a$1, (l$1 <= 65535 || l$1 >= 1114112) && (l$1 = null))), null === l$1 ? (l$1 = 65533, u$1 = 1) : l$1 > 65535 && (l$1 -= 65536, n$1 += String.fromCharCode(l$1 >>> 10 & 1023 | 55296), l$1 = 56320 | 1023 & l$1), n$1 += String.fromCharCode(l$1), i$1 += u$1;
					}
					return n$1;
				}(t$1, e$1, r$1);
			}
			class hf$1 extends qh {
				offsetBuffer;
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, r$1, n$1), this.offsetBuffer = e$1;
				}
			}
			class pf$1 extends hf$1 {
				textEncoder;
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1, r$1, n$1 ?? e$1.length - 1), this.textEncoder = new TextEncoder();
				}
				getValueFromBuffer(t$1) {
					return cf$1(this.dataBuffer, this.offsetBuffer[t$1], this.offsetBuffer[t$1 + 1]);
				}
			}
			class ff$1 extends hf$1 {
				indexBuffer;
				textEncoder;
				constructor(t$1, e$1, r$1, n$1, i$1) {
					super(t$1, r$1, n$1, i$1 ?? e$1.length), this.indexBuffer = e$1, this.indexBuffer = e$1, this.textEncoder = new TextEncoder();
				}
				getValueFromBuffer(t$1) {
					const e$1 = this.indexBuffer[t$1];
					return cf$1(this.dataBuffer, this.offsetBuffer[e$1], this.offsetBuffer[e$1 + 1]);
				}
			}
			class df$1 extends hf$1 {
				indexBuffer;
				symbolOffsetBuffer;
				symbolTableBuffer;
				textEncoder;
				symbolLengthBuffer;
				lengthBuffer;
				decodedDictionary;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1, o) {
					super(t$1, r$1, n$1, o), this.indexBuffer = e$1, this.symbolOffsetBuffer = i$1, this.symbolTableBuffer = s$1, this.textEncoder = new TextEncoder();
				}
				getValueFromBuffer(t$1) {
					this.decodedDictionary ?? (this.symbolLengthBuffer ?? (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = function(t$2, e$2, r$1) {
						const n$1 = [], i$1 = new Array(e$2.length).fill(0);
						for (let t$3 = 1; t$3 < e$2.length; t$3++) i$1[t$3] = i$1[t$3 - 1] + e$2[t$3 - 1];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) if (255 === r$1[s$1]) n$1.push(r$1[++s$1]);
						else {
							const o = e$2[r$1[s$1]], a$1 = i$1[r$1[s$1]];
							for (let e$3 = 0; e$3 < o; e$3++) n$1.push(t$2[a$1 + e$3]);
						}
						return new Uint8Array(n$1);
					}(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
					const e$1 = this.indexBuffer[t$1];
					return cf$1(this.decodedDictionary, this.offsetBuffer[e$1], this.offsetBuffer[e$1 + 1]);
				}
				offsetToLengthBuffer(t$1) {
					const e$1 = new Uint32Array(t$1.length - 1);
					let r$1 = t$1[0];
					for (let n$1 = 1; n$1 < t$1.length; n$1++) {
						const i$1 = t$1[n$1];
						e$1[n$1 - 1] = i$1 - r$1, r$1 = i$1;
					}
					return e$1;
				}
			}
			function yf$1(t$1, e$1, r$1, n$1, i$1, s$1) {
				return "scalarType" === r$1.type ? function(t$2, e$2, r$2, n$2, i$2, s$2) {
					let o = null, a$1 = 0;
					if (0 === t$2) return null;
					if (s$2.nullable) {
						const t$3 = wp$1(e$2, r$2);
						a$1 = t$3.numValues;
						const n$3 = r$2.get(), i$3 = af$1(e$2, a$1, r$2);
						r$2.set(n$3 + t$3.byteLength), o = new _p$1(i$3, t$3.numValues);
					}
					const l$1 = o ?? n$2;
					switch (i$2.physicalType) {
						case 4:
						case 3: return function(t$3, e$3, r$3, n$3, i$3) {
							const s$3 = wp$1(t$3, e$3), o$1 = Pp$1(s$3, i$3, t$3, e$3), a$2 = 3 === n$3.physicalType;
							if (o$1 === ip$1.FLAT) {
								const n$4 = mf$1(i$3) ? Dp$1(t$3, e$3, s$3, a$2, i$3) : Ap$1(t$3, e$3, s$3, a$2);
								return new Gh(r$3.name, n$4, i$3);
							}
							if (o$1 === ip$1.SEQUENCE) {
								const n$4 = Tp$1(t$3, e$3, s$3);
								return new Zh(r$3.name, n$4[0], n$4[1], s$3.numRleValues);
							}
							{
								const n$4 = Ep$1(t$3, e$3, s$3, a$2);
								return new Hh(r$3.name, n$4, i$3);
							}
						}(e$2, r$2, s$2, i$2, l$1);
						case 9: return function(t$3, e$3, r$3, n$3, i$3) {
							let s$3 = null, o$1 = null, a$2 = null, l$2 = null, u$1 = null, c$1 = null, h$1 = null, p$1 = null;
							for (let t$4 = 0; t$4 < n$3; t$4++) {
								const t$5 = wp$1(e$3, r$3);
								if (0 !== t$5.byteLength) switch (t$5.physicalStreamType) {
									case tp$1.PRESENT:
										c$1 = new _p$1(af$1(e$3, t$5.numValues, r$3), t$5.numValues);
										break;
									case tp$1.OFFSET:
										o$1 = null != i$3 || null != c$1 ? Dp$1(e$3, r$3, t$5, !1, i$3 ?? c$1) : Ap$1(e$3, r$3, t$5, !1);
										break;
									case tp$1.LENGTH: {
										const n$4 = Sp$1(e$3, r$3, t$5);
										np$1.DICTIONARY === t$5.logicalStreamType.lengthType ? s$3 = n$4 : np$1.SYMBOL === t$5.logicalStreamType.lengthType ? l$2 = n$4 : h$1 = n$4;
										break;
									}
									case tp$1.DATA: {
										const n$4 = e$3.subarray(r$3.get(), r$3.get() + t$5.byteLength);
										r$3.add(t$5.byteLength);
										const i$4 = t$5.logicalStreamType.dictionaryType;
										ep$1.FSST === i$4 ? u$1 = n$4 : ep$1.SINGLE === i$4 || ep$1.SHARED === i$4 ? a$2 = n$4 : ep$1.NONE === i$4 && (p$1 = n$4);
										break;
									}
								}
							}
							return function(t$4, e$4, r$4, n$4, i$4, s$4, o$2) {
								return e$4 ? new df$1(t$4, r$4, n$4, i$4, s$4, e$4, o$2) : null;
							}(t$3, u$1, o$1, s$3, a$2, l$2, i$3 ?? c$1) ?? function(t$4, e$4, r$4, n$4, i$4) {
								return e$4 ? i$4 ? new ff$1(t$4, r$4, n$4, e$4, i$4) : new ff$1(t$4, r$4, n$4, e$4) : null;
							}(t$3, a$2, o$1, s$3, i$3 ?? c$1) ?? function(t$4, e$4, r$4, n$4, i$4) {
								if (!e$4 || !r$4) return null;
								if (n$4) return i$4 ? new ff$1(t$4, n$4, e$4, r$4, i$4) : new ff$1(t$4, n$4, e$4, r$4);
								if (i$4 && i$4.size() !== e$4.length - 1) {
									const n$5 = new Int32Array(i$4.size());
									let s$4 = 0;
									for (let t$5 = 0; t$5 < i$4.size(); t$5++) n$5[t$5] = i$4.get(t$5) ? s$4++ : 0;
									return new ff$1(t$4, n$5, e$4, r$4, i$4);
								}
								return i$4 ? new pf$1(t$4, e$4, r$4, i$4) : new pf$1(t$4, e$4, r$4);
							}(t$3, h$1, p$1, o$1, i$3 ?? c$1);
						}(s$2.name, e$2, r$2, s$2.nullable ? t$2 - 1 : t$2, o);
						case 0: return function(t$3, e$3, r$3, n$3, i$3) {
							const s$3 = wp$1(t$3, e$3), o$1 = s$3.numValues, a$2 = e$3.get(), l$2 = mf$1(i$3) ? function(t$4, e$4, r$4, n$4) {
								const s$4 = new _p$1(lf$1(t$4, Math.ceil(e$4 / 8), r$4), e$4), o$2 = n$4.size(), a$3 = new _p$1(new Uint8Array(o$2), o$2);
								let l$3 = 0;
								for (let t$5 = 0; t$5 < n$4.size(); t$5++) {
									const e$5 = !!n$4.get(t$5) && s$4.get(l$3++);
									a$3.set(t$5, e$5);
								}
								return a$3.getBuffer();
							}(t$3, o$1, e$3, i$3) : af$1(t$3, o$1, e$3);
							e$3.set(a$2 + s$3.byteLength);
							const u$1 = new _p$1(l$2, o$1);
							return new nf$1(r$3.name, u$1, i$3);
						}(e$2, r$2, s$2, 0, l$1);
						case 6:
						case 5: return function(t$3, e$3, r$3, n$3, i$3) {
							const s$3 = wp$1(t$3, e$3), o$1 = Pp$1(s$3, n$3, t$3, e$3), a$2 = 5 === i$3.physicalType;
							if (o$1 === ip$1.FLAT) {
								const i$4 = mf$1(n$3) ? function(t$4, e$4, r$4, n$4, i$5) {
									return function(t$5, e$5, r$5, n$5) {
										switch (e$5.logicalLevelTechnique1) {
											case Jh.DELTA: return e$5.logicalLevelTechnique2 === Jh.RLE && (t$5 = mp$1(t$5, e$5.runs, e$5.numRleValues)), function(t$6, e$6) {
												const r$6 = new BigInt64Array(t$6.size());
												let n$6 = 0;
												t$6.get(0) ? (r$6[0] = t$6.get(0) ? e$6[0] >> 1n ^ -(1n & e$6[0]) : 0n, n$6 = 1) : r$6[0] = 0n;
												let i$6 = 1;
												for (; i$6 != r$6.length; ++i$6) r$6[i$6] = t$6.get(i$6) ? r$6[i$6 - 1] + (e$6[n$6] >> 1n ^ -(1n & e$6[n$6++])) : r$6[i$6 - 1];
												return r$6;
											}(n$5, t$5);
											case Jh.RLE: return function(t$6, e$6, r$6, n$6) {
												const i$6 = e$6;
												return r$6 ? function(t$7, e$7, r$7) {
													const n$7 = new BigInt64Array(t$7.size());
													let i$7 = 0;
													for (let s$4 = 0; s$4 < r$7; s$4++) {
														const o$2 = Number(e$7[s$4]);
														let a$3 = e$7[s$4 + r$7];
														a$3 = a$3 >> 1n ^ -(1n & a$3);
														for (let e$8 = i$7; e$8 < i$7 + o$2; e$8++) t$7.get(e$8) ? n$7[e$8] = a$3 : (n$7[e$8] = 0n, i$7++);
														i$7 += o$2;
													}
													return n$7;
												}(n$6, t$6, i$6.runs) : function(t$7, e$7, r$7) {
													const n$7 = new BigInt64Array(t$7.size());
													let i$7 = 0;
													for (let s$4 = 0; s$4 < r$7; s$4++) {
														const o$2 = Number(e$7[s$4]), a$3 = e$7[s$4 + r$7];
														for (let e$8 = i$7; e$8 < i$7 + o$2; e$8++) t$7.get(e$8) ? n$7[e$8] = a$3 : (n$7[e$8] = 0n, i$7++);
														i$7 += o$2;
													}
													return n$7;
												}(n$6, t$6, i$6.runs);
											}(t$5, e$5, r$5, n$5);
											case Jh.NONE: return t$5 = r$5 ? function(t$6, e$6) {
												const r$6 = new BigInt64Array(t$6.size());
												let n$6 = 0, i$6 = 0;
												for (; i$6 != r$6.length; ++i$6) if (t$6.get(i$6)) {
													const t$7 = e$6[n$6++];
													r$6[i$6] = t$7 >> 1n ^ -(1n & t$7);
												} else r$6[i$6] = 0n;
												return r$6;
											}(n$5, t$5) : function(t$6, e$6) {
												const r$6 = new BigInt64Array(t$6.size());
												let n$6 = 0, i$6 = 0;
												for (; i$6 != r$6.length; ++i$6) r$6[i$6] = t$6.get(i$6) ? e$6[n$6++] : 0n;
												return r$6;
											}(n$5, t$5), t$5;
											default: throw new Error("The specified Logical level technique is not supported");
										}
									}(up$1(t$4, e$4, r$4.numValues), r$4, n$4, i$5);
								}(t$3, e$3, s$3, a$2, n$3) : Mp$1(t$3, e$3, s$3, a$2);
								return new zp$1(r$3.name, i$4, n$3);
							}
							if (o$1 === ip$1.SEQUENCE) {
								const n$4 = Ip$1(t$3, e$3, s$3);
								return new Bp$1(r$3.name, n$4[0], n$4[1], s$3.numRleValues);
							}
							{
								const i$4 = Fp$1(t$3, e$3, s$3, a$2);
								return new of$1(r$3.name, i$4, n$3);
							}
						}(e$2, r$2, s$2, l$1, i$2);
						case 7: return function(t$3, e$3, r$3, n$3) {
							const i$3 = wp$1(t$3, e$3), s$3 = mf$1(n$3) ? function(t$4, e$4, r$4, n$4) {
								const i$4 = e$4.get(), s$4 = i$4 + n$4 * Float32Array.BYTES_PER_ELEMENT, o$1 = new Uint8Array(t$4.subarray(i$4, s$4)).buffer, a$2 = new Float32Array(o$1);
								e$4.set(s$4);
								const l$2 = r$4.size(), u$1 = new Float32Array(l$2);
								let c$1 = 0;
								for (let t$5 = 0; t$5 < l$2; t$5++) u$1[t$5] = r$4.get(t$5) ? a$2[c$1++] : 0;
								return u$1;
							}(t$3, e$3, n$3, i$3.numValues) : function(t$4, e$4, r$4) {
								const n$4 = e$4.get(), i$4 = n$4 + r$4 * Float32Array.BYTES_PER_ELEMENT, s$4 = new Uint8Array(t$4.subarray(n$4, i$4)).buffer, o$1 = new Float32Array(s$4);
								return e$4.set(i$4), o$1;
							}(t$3, e$3, i$3.numValues);
							return new sf$1(r$3.name, s$3, n$3);
						}(e$2, r$2, s$2, l$1);
						case 8: return function(t$3, e$3, r$3, n$3) {
							const i$3 = wp$1(t$3, e$3), s$3 = mf$1(n$3) ? function(t$4, e$4, r$4, n$4) {
								const i$4 = e$4.get(), s$4 = i$4 + n$4 * Float64Array.BYTES_PER_ELEMENT, o$1 = new Uint8Array(t$4.subarray(i$4, s$4)).buffer, a$2 = new Float64Array(o$1);
								e$4.set(s$4);
								const l$2 = r$4.size(), u$1 = new Float64Array(l$2);
								let c$1 = 0;
								for (let t$5 = 0; t$5 < l$2; t$5++) u$1[t$5] = r$4.get(t$5) ? a$2[c$1++] : 0;
								return u$1;
							}(t$3, e$3, n$3, i$3.numValues) : function(t$4, e$4, r$4) {
								const n$4 = e$4.get(), i$4 = n$4 + r$4 * Float64Array.BYTES_PER_ELEMENT, s$4 = new Uint8Array(t$4.subarray(n$4, i$4)).buffer, o$1 = new Float64Array(s$4);
								return e$4.set(i$4), o$1;
							}(t$3, e$3, i$3.numValues);
							return new Xh(r$3.name, s$3, n$3);
						}(e$2, r$2, s$2, l$1);
						default: throw new Error(`The specified data type for the field is currently not supported: ${i$2}`);
					}
				}(n$1, t$1, e$1, i$1, r$1.scalarType, r$1) : 1 != n$1 ? null : function(t$2, e$2, r$2, n$2) {
					let i$2 = null, s$2 = null, o = null, a$1 = null, l$1 = !1;
					for (; !l$1;) {
						const r$3 = wp$1(t$2, e$2);
						switch (r$3.physicalStreamType) {
							case tp$1.LENGTH:
								np$1.DICTIONARY === r$3.logicalStreamType.lengthType ? i$2 = Sp$1(t$2, e$2, r$3) : o = Sp$1(t$2, e$2, r$3);
								break;
							case tp$1.DATA: ep$1.SINGLE === r$3.logicalStreamType.dictionaryType || ep$1.SHARED === r$3.logicalStreamType.dictionaryType ? (s$2 = t$2.subarray(e$2.get(), e$2.get() + r$3.byteLength), l$1 = !0) : a$1 = t$2.subarray(e$2.get(), e$2.get() + r$3.byteLength), e$2.add(r$3.byteLength);
						}
					}
					const u$1 = r$2.complexType.children, c$1 = [];
					let h$1 = 0;
					for (const l$2 of u$1) {
						const u$2 = lp$1(t$2, e$2, 1)[0];
						if (0 == u$2) continue;
						const p$1 = `${r$2.name}${"default" === l$2.name ? "" : ":" + l$2.name}`;
						if (2 !== u$2 || "scalarField" !== l$2.type || 9 !== l$2.scalarField.physicalType) throw new Error("Currently only optional string fields are implemented for a struct.");
						const f$1 = wp$1(t$2, e$2), d$1 = af$1(t$2, f$1.numValues, e$2), y$1 = wp$1(t$2, e$2), m$1 = y$1.decompressedCount !== n$2 ? Dp$1(t$2, e$2, y$1, !1, new _p$1(d$1, f$1.numValues)) : Ap$1(t$2, e$2, y$1, !1);
						c$1[h$1++] = a$1 ? new df$1(p$1, m$1, i$2, s$2, o, a$1, new _p$1(d$1, f$1.numValues)) : new ff$1(p$1, m$1, i$2, s$2, new _p$1(d$1, f$1.numValues));
					}
					return c$1;
				}(t$1, e$1, r$1, i$1);
			}
			function mf$1(t$1) {
				return t$1 instanceof _p$1;
			}
			function gf$1(t$1) {
				if ("id" === t$1.name) return !1;
				if ("scalarType" === t$1.type) {
					const e$1 = t$1.scalarType;
					if ("physicalType" === e$1.type) switch (e$1.physicalType) {
						case 0:
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						default: return !1;
						case 9: return !0;
					}
					else if ("logicalType" === e$1.type) return !1;
				} else if ("complexType" === t$1.type) {
					const e$1 = t$1.complexType;
					if ("physicalType" === e$1.type) switch (e$1.physicalType) {
						case 0:
						case 1: return !0;
						default: return !1;
					}
				}
				return console.warn("Unexpected column type in hasStreamCount", t$1), !1;
			}
			const xf = new TextDecoder();
			function vf$1(t$1, e$1) {
				const r$1 = lp$1(t$1, e$1, 1)[0];
				if (0 === r$1) return "";
				const n$1 = e$1.get(), i$1 = t$1.subarray(n$1, n$1 + r$1);
				return e$1.add(r$1), xf.decode(i$1);
			}
			function bf(t$1, e$1) {
				const r$1 = lp$1(t$1, e$1, 1)[0] >>> 0, n$1 = !!(4 & r$1), i$1 = !!(2 & r$1), s$1 = lp$1(t$1, e$1, 1)[0] >>> 0, o = {};
				if (1 & r$1 && (o.nullable = !0), i$1) {
					const i$2 = {};
					if (n$1 ? (i$2.type = "logicalType", i$2.logicalType = s$1) : (i$2.type = "physicalType", i$2.physicalType = s$1), 8 & r$1) {
						const r$2 = lp$1(t$1, e$1, 1)[0] >>> 0;
						i$2.children = new Array(r$2);
						for (let n$2 = 0; n$2 < r$2; n$2++) i$2.children[n$2] = bf(t$1, e$1);
					}
					o.type = "complexField", o.complexField = i$2;
				} else {
					const t$2 = {};
					n$1 ? (t$2.type = "logicalType", t$2.logicalType = s$1) : (t$2.type = "physicalType", t$2.physicalType = s$1), o.type = "scalarField", o.scalarField = t$2;
				}
				return o;
			}
			function wf(t$1, e$1) {
				const r$1 = lp$1(t$1, e$1, 1)[0] >>> 0, n$1 = function(t$2) {
					switch (t$2) {
						case 0:
						case 1:
						case 2:
						case 3: {
							const e$2 = {};
							e$2.nullable = !!(1 & t$2), e$2.columnScope = 0;
							const r$2 = {};
							return r$2.physicalType = t$2 > 1 ? 6 : 4, r$2.type = "physicalType", e$2.scalarType = r$2, e$2.type = "scalarType", e$2;
						}
						case 4: {
							const t$3 = {
								nullable: !1,
								columnScope: 0
							};
							return t$3.type = "complexType", t$3.complexType = {
								type: "physicalType",
								physicalType: 0
							}, t$3;
						}
						case 30: {
							const t$3 = {
								nullable: !1,
								columnScope: 0
							};
							return t$3.type = "complexType", t$3.complexType = {
								type: "physicalType",
								physicalType: 1
							}, t$3;
						}
						default: return function(t$3) {
							let e$2 = null;
							switch (t$3) {
								case 10:
								case 11:
									e$2 = 0;
									break;
								case 12:
								case 13:
									e$2 = 1;
									break;
								case 14:
								case 15:
									e$2 = 2;
									break;
								case 16:
								case 17:
									e$2 = 3;
									break;
								case 18:
								case 19:
									e$2 = 4;
									break;
								case 20:
								case 21:
									e$2 = 5;
									break;
								case 22:
								case 23:
									e$2 = 6;
									break;
								case 24:
								case 25:
									e$2 = 7;
									break;
								case 26:
								case 27:
									e$2 = 8;
									break;
								case 28:
								case 29:
									e$2 = 9;
									break;
								default: return null;
							}
							const r$2 = {};
							r$2.nullable = !!(1 & t$3), r$2.columnScope = 0;
							const n$2 = { type: "physicalType" };
							return n$2.physicalType = e$2, r$2.type = "scalarType", r$2.scalarType = n$2, r$2;
						}(t$2);
					}
				}(r$1);
				if (!n$1) throw new Error(`Unsupported column type code: ${r$1}`);
				if (function(t$2) {
					return t$2 >= 10;
				}(r$1) ? n$1.name = vf$1(t$1, e$1) : r$1 >= 0 && r$1 <= 3 ? n$1.name = "id" : 4 === r$1 && (n$1.name = "geometry"), function(t$2) {
					return 30 === t$2;
				}(r$1)) {
					const r$2 = lp$1(t$1, e$1, 1)[0] >>> 0, i$1 = n$1.complexType;
					i$1.children = new Array(r$2);
					for (let n$2 = 0; n$2 < r$2; n$2++) i$1.children[n$2] = bf(t$1, e$1);
				}
				return n$1;
			}
			function _f(t$1, e$1) {
				const r$1 = { featureTables: [] }, n$1 = {};
				n$1.name = vf$1(t$1, e$1);
				const i$1 = lp$1(t$1, e$1, 1)[0] >>> 0, s$1 = lp$1(t$1, e$1, 1)[0] >>> 0;
				n$1.columns = new Array(s$1);
				for (let r$2 = 0; r$2 < s$1; r$2++) n$1.columns[r$2] = wf(t$1, e$1);
				return r$1.featureTables.push(n$1), [r$1, i$1];
			}
			function Af(t$1, e$1, r$1, n$1, i$1, s$1, o = !1) {
				const a$1 = e$1.scalarType.physicalType, l$1 = Pp$1(i$1, s$1, t$1, r$1);
				if (4 === a$1) switch (l$1) {
					case ip$1.FLAT: return new Gh(n$1, Ap$1(t$1, r$1, i$1, !1), s$1);
					case ip$1.SEQUENCE: {
						const e$2 = Tp$1(t$1, r$1, i$1);
						return new Zh(n$1, e$2[0], e$2[1], i$1.numRleValues);
					}
					case ip$1.CONST: return new Hh(n$1, Ep$1(t$1, r$1, i$1, !1), s$1);
				}
				else switch (l$1) {
					case ip$1.FLAT:
						if (o) return new Xh(n$1, function(t$2, e$2, r$2, n$2) {
							return function(t$3, e$3, r$3) {
								switch (e$3.logicalLevelTechnique1) {
									case Jh.DELTA: return e$3.logicalLevelTechnique2 === Jh.RLE && (t$3 = gp$1(t$3, e$3.runs, e$3.numRleValues)), function(t$4) {
										t$4[0] = t$4[0] % 2 == 1 ? (t$4[0] + 1) / -2 : t$4[0] / 2;
										const e$4 = t$4.length / 4 * 4;
										let r$4 = 1;
										if (e$4 >= 4) for (; r$4 < e$4 - 4; r$4 += 4) {
											const e$5 = t$4[r$4], n$3 = t$4[r$4 + 1], i$2 = t$4[r$4 + 2], s$2 = t$4[r$4 + 3];
											t$4[r$4] = (e$5 % 2 == 1 ? (e$5 + 1) / -2 : e$5 / 2) + t$4[r$4 - 1], t$4[r$4 + 1] = (n$3 % 2 == 1 ? (n$3 + 1) / -2 : n$3 / 2) + t$4[r$4], t$4[r$4 + 2] = (i$2 % 2 == 1 ? (i$2 + 1) / -2 : i$2 / 2) + t$4[r$4 + 1], t$4[r$4 + 3] = (s$2 % 2 == 1 ? (s$2 + 1) / -2 : s$2 / 2) + t$4[r$4 + 2];
										}
										for (; r$4 != t$4.length; ++r$4) t$4[r$4] = (t$4[r$4] % 2 == 1 ? (t$4[r$4] + 1) / -2 : t$4[r$4] / 2) + t$4[r$4 - 1];
									}(t$3), t$3;
									case Jh.RLE: return function(t$4, e$4, r$4) {
										return r$4 ? function(t$5, e$5, r$5) {
											const n$3 = new Float64Array(r$5);
											let i$2 = 0;
											for (let r$6 = 0; r$6 < e$5; r$6++) {
												const s$2 = t$5[r$6];
												let o$1 = t$5[r$6 + e$5];
												o$1 = o$1 % 2 == 1 ? (o$1 + 1) / -2 : o$1 / 2, n$3.fill(o$1, i$2, i$2 + s$2), i$2 += s$2;
											}
											return n$3;
										}(t$4, e$4.runs, e$4.numRleValues) : gp$1(t$4, e$4.runs, e$4.numRleValues);
									}(t$3, e$3, r$3);
									case Jh.NONE: return t$3;
									default: throw new Error(`The specified Logical level technique is not supported: ${e$3.logicalLevelTechnique1}`);
								}
							}(function(t$3, e$3, r$3) {
								const n$3 = new Float64Array(e$3);
								for (let i$2 = 0; i$2 < e$3; i$2++) n$3[i$2] = cp$1(t$3, r$3);
								return n$3;
							}(t$2, r$2.numValues, e$2), r$2, n$2);
						}(t$1, r$1, i$1, !1), s$1);
						return new zp$1(n$1, Mp$1(t$1, r$1, i$1, !1), s$1);
					case ip$1.SEQUENCE: {
						const e$2 = Ip$1(t$1, r$1, i$1);
						return new Bp$1(n$1, e$2[0], e$2[1], i$1.numRleValues);
					}
					case ip$1.CONST: return new of$1(n$1, Fp$1(t$1, r$1, i$1, !1), s$1);
				}
				throw new Error("Vector type not supported for id column.");
			}
			class Sf {
				constructor(t$1, e$1) {
					var r$1;
					switch (this._featureData = t$1, this.properties = this._featureData.properties || {}, null === (r$1 = this._featureData.geometry) || void 0 === r$1 ? void 0 : r$1.type) {
						case sp$1.POINT:
						case sp$1.MULTIPOINT:
							this.type = 1;
							break;
						case sp$1.LINESTRING:
						case sp$1.MULTILINESTRING:
							this.type = 2;
							break;
						case sp$1.POLYGON:
						case sp$1.MULTIPOLYGON:
							this.type = 3;
							break;
						default: this.type = 0;
					}
					this.extent = e$1, this.id = Number(this._featureData.id);
				}
				loadGeometry() {
					const t$1 = [];
					for (const e$1 of this._featureData.geometry.coordinates) {
						const n$1 = [];
						for (const t$2 of e$1) n$1.push(new r(t$2.x, t$2.y));
						t$1.push(n$1);
					}
					return t$1;
				}
			}
			class kf {
				constructor(t$1) {
					this.features = [], this.featureTable = t$1, this.name = t$1.name, this.extent = t$1.extent, this.version = 2, this.features = t$1.getFeatures(), this.length = this.features.length;
				}
				feature(t$1) {
					return new Sf(this.features[t$1], this.extent);
				}
			}
			class Ef {
				constructor(t$1) {
					this.layers = {};
					this.layers = function(t$2, e$1, r$1 = !0) {
						const n$1 = new Wh(0), i$1 = [];
						for (; n$1.get() < t$2.length;) {
							const e$2 = lp$1(t$2, n$1, 1)[0] >>> 0, s$1 = n$1.get() + e$2;
							if (s$1 > t$2.length) throw new Error(`Block overruns tile: ${s$1} > ${t$2.length}`);
							if (1 != lp$1(t$2, n$1, 1)[0] >>> 0) {
								n$1.set(s$1);
								continue;
							}
							const o = _f(t$2, n$1), a$1 = o[1], l$1 = o[0].featureTables[0];
							let u$1 = null, c$1 = null;
							const h$1 = [];
							let p$1 = 0;
							for (const e$3 of l$1.columns) {
								const i$2 = e$3.name;
								if ("id" === i$2) {
									let s$2 = null;
									if (e$3.nullable) {
										const e$4 = wp$1(t$2, n$1), r$2 = n$1.get(), i$3 = af$1(t$2, e$4.numValues, n$1);
										n$1.set(r$2 + e$4.byteLength), s$2 = new _p$1(i$3, e$4.numValues);
									}
									const o$1 = wp$1(t$2, n$1);
									p$1 = o$1.decompressedCount, u$1 = Af(t$2, e$3, n$1, i$2, o$1, s$2 ?? p$1, r$1);
								} else if ("geometry" === i$2) {
									const e$4 = lp$1(t$2, n$1, 1)[0];
									if (0 === p$1) {
										const e$5 = n$1.get();
										p$1 = wp$1(t$2, n$1).decompressedCount, n$1.set(e$5);
									}
									c$1 = tf$1(t$2, e$4, n$1, p$1);
								} else {
									const r$2 = gf$1(e$3) ? lp$1(t$2, n$1, 1)[0] : 1;
									if (0 === r$2 && "scalarType" === e$3.type) continue;
									const i$3 = yf$1(t$2, n$1, e$3, r$2, p$1);
									if (i$3) if (Array.isArray(i$3)) for (const t$3 of i$3) h$1.push(t$3);
									else h$1.push(i$3);
								}
							}
							const f$1 = new Kh(l$1.name, c$1, u$1, h$1, a$1);
							i$1.push(f$1), n$1.set(s$1);
						}
						return i$1;
					}(new Uint8Array(t$1)).reduce(((t$2, e$1) => Object.assign(Object.assign({}, t$2), { [e$1.name]: new kf(e$1) })), {});
				}
			}
			class Tf {
				constructor() {
					this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity;
				}
				extend(t$1) {
					return this.minX = Math.min(this.minX, t$1.x), this.minY = Math.min(this.minY, t$1.y), this.maxX = Math.max(this.maxX, t$1.x), this.maxY = Math.max(this.maxY, t$1.y), this;
				}
				expandBy(t$1) {
					return this.minX -= t$1, this.minY -= t$1, this.maxX += t$1, this.maxY += t$1, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity), this;
				}
				shrinkBy(t$1) {
					return this.expandBy(-t$1);
				}
				map(t$1) {
					const e$1 = new Tf();
					return e$1.extend(t$1(new r(this.minX, this.minY))), e$1.extend(t$1(new r(this.maxX, this.minY))), e$1.extend(t$1(new r(this.minX, this.maxY))), e$1.extend(t$1(new r(this.maxX, this.maxY))), e$1;
				}
				static fromPoints(t$1) {
					const e$1 = new Tf();
					for (const r$1 of t$1) e$1.extend(r$1);
					return e$1;
				}
				contains(t$1) {
					return t$1.x >= this.minX && t$1.x <= this.maxX && t$1.y >= this.minY && t$1.y <= this.maxY;
				}
				empty() {
					return this.minX > this.maxX;
				}
				width() {
					return this.maxX - this.minX;
				}
				height() {
					return this.maxY - this.minY;
				}
				covers(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX >= this.minX && t$1.maxX <= this.maxX && t$1.minY >= this.minY && t$1.maxY <= this.maxY;
				}
				intersects(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX <= this.maxX && t$1.maxX >= this.minX && t$1.minY <= this.maxY && t$1.maxY >= this.minY;
				}
			}
			class If {
				constructor(t$1, e$1) {
					this.feature = t$1, this.type = t$1.type, this.properties = t$1.tags ? t$1.tags : {}, this.extent = e$1, "id" in t$1 && ("string" == typeof t$1.id ? this.id = parseInt(t$1.id, 10) : "number" != typeof t$1.id || isNaN(t$1.id) || (this.id = t$1.id));
				}
				loadGeometry() {
					const t$1 = [], e$1 = 1 === this.feature.type ? [this.feature.geometry] : this.feature.geometry;
					for (const n$1 of e$1) {
						const e$2 = [];
						for (const t$2 of n$1) e$2.push(new r(t$2[0], t$2[1]));
						t$1.push(e$2);
					}
					return t$1;
				}
			}
			const Mf = "_geojsonTileLayer";
			function Ff(t$1, e$1) {
				e$1.writeVarintField(15, t$1.version || 1), e$1.writeStringField(1, t$1.name || ""), e$1.writeVarintField(5, t$1.extent || 4096);
				const r$1 = {
					keys: [],
					values: [],
					keycache: {},
					valuecache: {}
				};
				for (let n$2 = 0; n$2 < t$1.length; n$2++) r$1.feature = t$1.feature(n$2), e$1.writeMessage(2, Df, r$1);
				const n$1 = r$1.keys;
				for (const t$2 of n$1) e$1.writeStringField(3, t$2);
				const i$1 = r$1.values;
				for (const t$2 of i$1) e$1.writeMessage(4, Cf, t$2);
			}
			function Df(t$1, e$1) {
				if (!t$1.feature) return;
				const r$1 = t$1.feature;
				void 0 !== r$1.id && e$1.writeVarintField(1, r$1.id), e$1.writeMessage(2, Pf, t$1), e$1.writeVarintField(3, r$1.type), e$1.writeMessage(4, Vf, r$1);
			}
			function Pf(t$1, e$1) {
				for (const r$1 in t$1.feature?.properties) {
					let n$1 = t$1.feature.properties[r$1], i$1 = t$1.keycache[r$1];
					if (null === n$1) continue;
					void 0 === i$1 && (t$1.keys.push(r$1), i$1 = t$1.keys.length - 1, t$1.keycache[r$1] = i$1), e$1.writeVarint(i$1), "string" != typeof n$1 && "boolean" != typeof n$1 && "number" != typeof n$1 && (n$1 = JSON.stringify(n$1));
					const s$1 = typeof n$1 + ":" + n$1;
					let o = t$1.valuecache[s$1];
					void 0 === o && (t$1.values.push(n$1), o = t$1.values.length - 1, t$1.valuecache[s$1] = o), e$1.writeVarint(o);
				}
			}
			function zf(t$1, e$1) {
				return (e$1 << 3) + (7 & t$1);
			}
			function Bf(t$1) {
				return t$1 << 1 ^ t$1 >> 31;
			}
			function Vf(t$1, e$1) {
				const r$1 = t$1.loadGeometry(), n$1 = t$1.type;
				let i$1 = 0, s$1 = 0;
				for (const o of r$1) {
					let r$2 = 1;
					1 === n$1 && (r$2 = o.length), e$1.writeVarint(zf(1, r$2));
					const a$1 = 3 === n$1 ? o.length - 1 : o.length;
					for (let t$2 = 0; t$2 < a$1; t$2++) {
						1 === t$2 && 1 !== n$1 && e$1.writeVarint(zf(2, a$1 - 1));
						const r$3 = o[t$2].x - i$1, l$1 = o[t$2].y - s$1;
						e$1.writeVarint(Bf(r$3)), e$1.writeVarint(Bf(l$1)), i$1 += r$3, s$1 += l$1;
					}
					3 === t$1.type && e$1.writeVarint(zf(7, 1));
				}
			}
			function Cf(t$1, e$1) {
				const r$1 = typeof t$1;
				"string" === r$1 ? e$1.writeStringField(1, t$1) : "boolean" === r$1 ? e$1.writeBooleanField(7, t$1) : "number" === r$1 && (t$1 % 1 != 0 ? e$1.writeDoubleField(3, t$1) : t$1 < 0 ? e$1.writeSVarintField(6, t$1) : e$1.writeVarintField(5, t$1));
			}
			class Lf {
				constructor(t$1, e$1) {
					this.tileID = t$1, this.x = t$1.canonical.x, this.y = t$1.canonical.y, this.z = t$1.canonical.z, this.grid = new as$1(M$1, 16, 0), this.grid3D = new as$1(M$1, 16, 0), this.featureIndexArray = new Oo$1(), this.promoteId = e$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1, s$1) {
					const o = this.featureIndexArray.length;
					this.featureIndexArray.emplaceBack(r$1, n$1, i$1);
					const a$1 = s$1 ? this.grid3D : this.grid;
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const r$2 = e$1[t$2], n$2 = [
							Infinity,
							Infinity,
							-Infinity,
							-Infinity
						];
						for (let t$3 = 0; t$3 < r$2.length; t$3++) {
							const e$2 = r$2[t$3];
							n$2[0] = Math.min(n$2[0], e$2.x), n$2[1] = Math.min(n$2[1], e$2.y), n$2[2] = Math.max(n$2[2], e$2.x), n$2[3] = Math.max(n$2[3], e$2.y);
						}
						n$2[0] < M$1 && n$2[1] < M$1 && n$2[2] >= 0 && n$2[3] >= 0 && a$1.insert(o, n$2[0], n$2[1], n$2[2], n$2[3]);
					}
				}
				loadVTLayers() {
					return this.vtLayers || (this.vtLayers = "mlt" !== this.encoding ? new Pu$1(new Sc$1(this.rawTileData)).layers : new Ef(this.rawTileData).layers, this.sourceLayerCoder = new $h(this.vtLayers ? Object.keys(this.vtLayers).sort() : [Mf])), this.vtLayers;
				}
				query(t$1, e$1, n$1, i$1) {
					this.loadVTLayers();
					const s$1 = t$1.params, o = M$1 / t$1.tileSize / t$1.scale, a$1 = fi(s$1.filter, s$1.globalState), l$1 = t$1.queryGeometry, u$1 = t$1.queryPadding * o, c$1 = Tf.fromPoints(l$1), h$1 = this.grid.query(c$1.minX - u$1, c$1.minY - u$1, c$1.maxX + u$1, c$1.maxY + u$1), p$1 = Tf.fromPoints(t$1.cameraQueryGeometry).expandBy(u$1), f$1 = this.grid3D.query(p$1.minX, p$1.minY, p$1.maxX, p$1.maxY, ((e$2, n$2, i$2, s$2) => function(t$2, e$3, n$3, i$3, s$3) {
						for (const r$1 of t$2) if (e$3 <= r$1.x && n$3 <= r$1.y && i$3 >= r$1.x && s$3 >= r$1.y) return !0;
						const o$1 = [
							new r(e$3, n$3),
							new r(e$3, s$3),
							new r(i$3, s$3),
							new r(i$3, n$3)
						];
						if (t$2.length > 2) {
							for (const e$4 of o$1) if (Wa$1(t$2, e$4)) return !0;
						}
						for (let e$4 = 0; e$4 < t$2.length - 1; e$4++) if (Ja$1(t$2[e$4], t$2[e$4 + 1], o$1)) return !0;
						return !1;
					}(t$1.cameraQueryGeometry, e$2 - u$1, n$2 - u$1, i$2 + u$1, s$2 + u$1)));
					for (const t$2 of f$1) h$1.push(t$2);
					h$1.sort(Rf);
					const d$1 = {};
					let y$1;
					for (let r$1 = 0; r$1 < h$1.length; r$1++) {
						const u$2 = h$1[r$1];
						if (u$2 === y$1) continue;
						y$1 = u$2;
						const c$2 = this.featureIndexArray.get(u$2);
						let p$2 = null;
						this.loadMatchingFeature(d$1, c$2.bucketIndex, c$2.sourceLayerIndex, c$2.featureIndex, a$1, s$1.layers, s$1.availableImages, e$1, n$1, i$1, ((e$2, r$2, n$2) => (p$2 || (p$2 = La$1(e$2)), r$2.queryIntersectsFeature({
							queryGeometry: l$1,
							feature: e$2,
							featureState: n$2,
							geometry: p$2,
							zoom: this.z,
							transform: t$1.transform,
							pixelsToTileUnits: o,
							pixelPosMatrix: t$1.pixelPosMatrix,
							unwrappedTileID: this.tileID.toUnwrapped(),
							getElevation: t$1.getElevation
						}))));
					}
					return d$1;
				}
				loadMatchingFeature(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1) {
					const h$1 = this.bucketLayerIDs[e$1];
					if (s$1 && !h$1.some(((t$2) => s$1.has(t$2)))) return;
					const p$1 = this.sourceLayerCoder.decode(r$1), f$1 = this.vtLayers[p$1].feature(n$1);
					if (i$1.needGeometry) {
						const t$2 = Oa$1(f$1, !0);
						if (!i$1.filter(new Fs$1(this.tileID.overscaledZ), t$2, this.tileID.canonical)) return;
					} else if (!i$1.filter(new Fs$1(this.tileID.overscaledZ), f$1)) return;
					const d$1 = this.getId(f$1, p$1);
					for (let e$2 = 0; e$2 < h$1.length; e$2++) {
						const r$2 = h$1[e$2];
						if (s$1 && !s$1.has(r$2)) continue;
						const i$2 = a$1[r$2];
						if (!i$2) continue;
						let p$2 = {};
						d$1 && u$1 && (p$2 = u$1.getState(i$2.sourceLayer || Mf, d$1));
						const y$1 = O$1({}, l$1[r$2]);
						y$1.paint = Of(y$1.paint, i$2.paint, f$1, p$2, o), y$1.layout = Of(y$1.layout, i$2.layout, f$1, p$2, o);
						const m$1 = !c$1 || c$1(f$1, i$2, p$2);
						if (!m$1) continue;
						const g$2 = new Uh(f$1, this.z, this.x, this.y, d$1);
						g$2.layer = y$1;
						let x$1 = t$1[r$2];
						void 0 === x$1 && (x$1 = t$1[r$2] = []), x$1.push({
							featureIndex: n$1,
							feature: g$2,
							intersectionZ: m$1
						});
					}
				}
				lookupSymbolFeatures(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1) {
					const l$1 = {};
					this.loadVTLayers();
					const u$1 = fi(i$1.filterSpec, i$1.globalState);
					for (const i$2 of t$1) this.loadMatchingFeature(l$1, r$1, n$1, i$2, u$1, s$1, o, a$1, e$1);
					return l$1;
				}
				hasLayer(t$1) {
					for (const e$1 of this.bucketLayerIDs) for (const r$1 of e$1) if (t$1 === r$1) return !0;
					return !1;
				}
				getId(t$1, e$1) {
					var r$1;
					let n$1 = t$1.id;
					return this.promoteId && (n$1 = t$1.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e$1]], "boolean" == typeof n$1 && (n$1 = Number(n$1)), void 0 === n$1 && !(null === (r$1 = t$1.properties) || void 0 === r$1) && r$1.cluster && this.promoteId && (n$1 = Number(t$1.properties.cluster_id))), n$1;
				}
			}
			function Of(t$1, e$1, r$1, n$1, i$1) {
				return N(t$1, ((t$2, s$1) => {
					const o = e$1 instanceof Ns$1 ? e$1.get(s$1) : null;
					return o && o.evaluate ? o.evaluate(r$1, n$1, i$1) : o;
				}));
			}
			function Rf(t$1, e$1) {
				return e$1 - t$1;
			}
			function Nf(t$1, e$1, n$1, i$1, s$1) {
				const o = [];
				for (let a$1 = 0; a$1 < t$1.length; a$1++) {
					const l$1 = t$1[a$1];
					let u$1;
					for (let t$2 = 0; t$2 < l$1.length - 1; t$2++) {
						let a$2 = l$1[t$2], c$1 = l$1[t$2 + 1];
						a$2.x < e$1 && c$1.x < e$1 || (a$2.x < e$1 ? a$2 = new r(e$1, a$2.y + (e$1 - a$2.x) / (c$1.x - a$2.x) * (c$1.y - a$2.y))._round() : c$1.x < e$1 && (c$1 = new r(e$1, a$2.y + (e$1 - a$2.x) / (c$1.x - a$2.x) * (c$1.y - a$2.y))._round()), a$2.y < n$1 && c$1.y < n$1 || (a$2.y < n$1 ? a$2 = new r(a$2.x + (n$1 - a$2.y) / (c$1.y - a$2.y) * (c$1.x - a$2.x), n$1)._round() : c$1.y < n$1 && (c$1 = new r(a$2.x + (n$1 - a$2.y) / (c$1.y - a$2.y) * (c$1.x - a$2.x), n$1)._round()), a$2.x >= i$1 && c$1.x >= i$1 || (a$2.x >= i$1 ? a$2 = new r(i$1, a$2.y + (i$1 - a$2.x) / (c$1.x - a$2.x) * (c$1.y - a$2.y))._round() : c$1.x >= i$1 && (c$1 = new r(i$1, a$2.y + (i$1 - a$2.x) / (c$1.x - a$2.x) * (c$1.y - a$2.y))._round()), a$2.y >= s$1 && c$1.y >= s$1 || (a$2.y >= s$1 ? a$2 = new r(a$2.x + (s$1 - a$2.y) / (c$1.y - a$2.y) * (c$1.x - a$2.x), s$1)._round() : c$1.y >= s$1 && (c$1 = new r(a$2.x + (s$1 - a$2.y) / (c$1.y - a$2.y) * (c$1.x - a$2.x), s$1)._round()), u$1 && a$2.equals(u$1[u$1.length - 1]) || (u$1 = [a$2], o.push(u$1)), u$1.push(c$1)))));
					}
				}
				return o;
			}
			function $f(t$1, e$1, r$1, n$1, i$1) {
				switch (e$1) {
					case 1: return function(t$2, e$2, r$2, n$2) {
						const i$2 = [];
						for (const s$1 of t$2) for (const t$3 of s$1) {
							const s$2 = 0 === n$2 ? t$3.x : t$3.y;
							s$2 >= e$2 && s$2 <= r$2 && i$2.push([t$3]);
						}
						return i$2;
					}(t$1, r$1, n$1, i$1);
					case 2: return qf(t$1, r$1, n$1, i$1, !1);
					case 3: return qf(t$1, r$1, n$1, i$1, !0);
				}
				return [];
			}
			function Uf(t$1, e$1, n$1, i$1, s$1) {
				const o = 0 === i$1 ? jf : Gf;
				let a$1 = [];
				const l$1 = [];
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) {
					const u$2 = t$1[r$1], c$2 = t$1[r$1 + 1], h$1 = 0 === i$1 ? u$2.x : u$2.y, p$1 = 0 === i$1 ? c$2.x : c$2.y;
					let f$1 = !1;
					h$1 < e$1 ? p$1 > e$1 && a$1.push(o(u$2, c$2, e$1)) : h$1 > n$1 ? p$1 < n$1 && a$1.push(o(u$2, c$2, n$1)) : a$1.push(u$2), p$1 < e$1 && h$1 >= e$1 && (a$1.push(o(u$2, c$2, e$1)), f$1 = !0), p$1 > n$1 && h$1 <= n$1 && (a$1.push(o(u$2, c$2, n$1)), f$1 = !0), !s$1 && f$1 && (l$1.push(a$1), a$1 = []);
				}
				const u$1 = t$1.length - 1, c$1 = 0 === i$1 ? t$1[u$1].x : t$1[u$1].y;
				return c$1 >= e$1 && c$1 <= n$1 && a$1.push(t$1[u$1]), s$1 && a$1.length > 0 && !a$1[0].equals(a$1[a$1.length - 1]) && a$1.push(new r(a$1[0].x, a$1[0].y)), a$1.length > 0 && l$1.push(a$1), l$1;
			}
			function qf(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = [];
				for (const o of t$1) {
					const t$2 = Uf(o, e$1, r$1, n$1, i$1);
					t$2.length > 0 && s$1.push(...t$2);
				}
				return s$1;
			}
			function jf(t$1, e$1, n$1) {
				return new r(n$1, t$1.y + (n$1 - t$1.x) / (e$1.x - t$1.x) * (e$1.y - t$1.y));
			}
			function Gf(t$1, e$1, n$1) {
				return new r(t$1.x + (n$1 - t$1.y) / (e$1.y - t$1.y) * (e$1.x - t$1.x), n$1);
			}
			us$1("FeatureIndex", Lf, { omit: ["rawTileData", "sourceLayerCoder"] });
			class Xf extends r {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1), this.angle = r$1, void 0 !== n$1 && (this.segment = n$1);
				}
				clone() {
					return new Xf(this.x, this.y, this.angle, this.segment);
				}
			}
			function Yf(t$1, e$1, r$1, n$1, i$1) {
				if (void 0 === e$1.segment || 0 === r$1) return !0;
				let s$1 = e$1, o = e$1.segment + 1, a$1 = 0;
				for (; a$1 > -r$1 / 2;) {
					if (o--, o < 0) return !1;
					a$1 -= t$1[o].dist(s$1), s$1 = t$1[o];
				}
				a$1 += t$1[o].dist(t$1[o + 1]), o++;
				const l$1 = [];
				let u$1 = 0;
				for (; a$1 < r$1 / 2;) {
					const e$2 = t$1[o], r$2 = t$1[o + 1];
					if (!r$2) return !1;
					let s$2 = t$1[o - 1].angleTo(e$2) - e$2.angleTo(r$2);
					for (s$2 = Math.abs((s$2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l$1.push({
						distance: a$1,
						angleDelta: s$2
					}), u$1 += s$2; a$1 - l$1[0].distance > n$1;) u$1 -= l$1.shift().angleDelta;
					if (u$1 > i$1) return !1;
					o++, a$1 += e$2.dist(r$2);
				}
				return !0;
			}
			function Zf(t$1) {
				let e$1 = 0;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) e$1 += t$1[r$1].dist(t$1[r$1 + 1]);
				return e$1;
			}
			function Hf(t$1, e$1, r$1) {
				return t$1 ? .6 * e$1 * r$1 : 0;
			}
			function Kf(t$1, e$1) {
				return Math.max(t$1 ? t$1.right - t$1.left : 0, e$1 ? e$1.right - e$1.left : 0);
			}
			function Wf(t$1, e$1, r$1, n$1, i$1, s$1) {
				const o = Hf(r$1, i$1, s$1), a$1 = Kf(r$1, n$1) * s$1;
				let l$1 = 0;
				const u$1 = Zf(t$1) / 2;
				for (let r$2 = 0; r$2 < t$1.length - 1; r$2++) {
					const n$2 = t$1[r$2], i$2 = t$1[r$2 + 1], s$2 = n$2.dist(i$2);
					if (l$1 + s$2 > u$1) {
						const c$1 = (u$1 - l$1) / s$2, f$1 = new Xf(yr$1.number(n$2.x, i$2.x, c$1), yr$1.number(n$2.y, i$2.y, c$1), i$2.angleTo(n$2), r$2);
						return f$1._round(), !o || Yf(t$1, f$1, a$1, o, e$1) ? f$1 : void 0;
					}
					l$1 += s$2;
				}
			}
			function Jf(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1) {
				const u$1 = Hf(n$1, s$1, o), c$1 = Kf(n$1, i$1), h$1 = c$1 * o, p$1 = 0 === t$1[0].x || t$1[0].x === l$1 || 0 === t$1[0].y || t$1[0].y === l$1;
				return e$1 - h$1 < e$1 / 4 && (e$1 = h$1 + e$1 / 4), Qf(t$1, p$1 ? e$1 / 2 * a$1 % e$1 : (c$1 / 2 + 2 * s$1) * o * a$1 % e$1, e$1, u$1, r$1, h$1, p$1, !1, l$1);
			}
			function Qf(t$1, e$1, r$1, n$1, i$1, s$1, o, a$1, l$1) {
				const u$1 = s$1 / 2, c$1 = Zf(t$1);
				let h$1 = 0, p$1 = e$1 - r$1, f$1 = [];
				for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) {
					const o$1 = t$1[e$2], a$2 = t$1[e$2 + 1], d$1 = o$1.dist(a$2), y$1 = a$2.angleTo(o$1);
					for (; p$1 + r$1 < h$1 + d$1;) {
						p$1 += r$1;
						const m$1 = (p$1 - h$1) / d$1, g$2 = yr$1.number(o$1.x, a$2.x, m$1), x$1 = yr$1.number(o$1.y, a$2.y, m$1);
						if (g$2 >= 0 && g$2 < l$1 && x$1 >= 0 && x$1 < l$1 && p$1 - u$1 >= 0 && p$1 + u$1 <= c$1) {
							const r$2 = new Xf(g$2, x$1, y$1, e$2);
							r$2._round(), n$1 && !Yf(t$1, r$2, s$1, n$1, i$1) || f$1.push(r$2);
						}
					}
					h$1 += d$1;
				}
				return a$1 || f$1.length || o || (f$1 = Qf(t$1, h$1 / 2, r$1, n$1, i$1, s$1, o, !0, l$1)), f$1;
			}
			function td(t$1, e$1, n$1, i$1) {
				const s$1 = [], o = t$1.image, a$1 = o.pixelRatio, l$1 = o.paddedRect.w - 2, u$1 = o.paddedRect.h - 2;
				let c$1 = {
					x1: t$1.left,
					y1: t$1.top,
					x2: t$1.right,
					y2: t$1.bottom
				};
				const h$1 = o.stretchX || [[0, l$1]], p$1 = o.stretchY || [[0, u$1]], f$1 = (t$2, e$2) => t$2 + e$2[1] - e$2[0], d$1 = h$1.reduce(f$1, 0), y$1 = p$1.reduce(f$1, 0), m$1 = l$1 - d$1, g$2 = u$1 - y$1;
				let x$1 = 0, v$1 = d$1, b$1 = 0, w$2 = y$1, _$2 = 0, A$2 = m$1, S$2 = 0, k$2 = g$2;
				if (o.content && i$1) {
					const e$2 = o.content, r$1 = e$2[2] - e$2[0], n$2 = e$2[3] - e$2[1];
					(o.textFitWidth || o.textFitHeight) && (c$1 = Jc$1(t$1)), x$1 = ed(h$1, 0, e$2[0]), b$1 = ed(p$1, 0, e$2[1]), v$1 = ed(h$1, e$2[0], e$2[2]), w$2 = ed(p$1, e$2[1], e$2[3]), _$2 = e$2[0] - x$1, S$2 = e$2[1] - b$1, A$2 = r$1 - v$1, k$2 = n$2 - w$2;
				}
				const E$1 = c$1.x1, T$1 = c$1.y1, I$2 = c$1.x2 - E$1, M$2 = c$1.y2 - T$1, F$2 = (t$2, i$2, s$2, l$2) => {
					const u$2 = nd(t$2.stretch - x$1, v$1, I$2, E$1), c$2 = id(t$2.fixed - _$2, A$2, t$2.stretch, d$1), h$2 = nd(i$2.stretch - b$1, w$2, M$2, T$1), p$2 = id(i$2.fixed - S$2, k$2, i$2.stretch, y$1), f$2 = nd(s$2.stretch - x$1, v$1, I$2, E$1), m$2 = id(s$2.fixed - _$2, A$2, s$2.stretch, d$1), g$3 = nd(l$2.stretch - b$1, w$2, M$2, T$1), F$3 = id(l$2.fixed - S$2, k$2, l$2.stretch, y$1), D$2 = new r(u$2, h$2), P$2 = new r(f$2, h$2), z$2 = new r(f$2, g$3), B$2 = new r(u$2, g$3), V$2 = new r(c$2 / a$1, p$2 / a$1), C$1 = new r(m$2 / a$1, F$3 / a$1), L$2 = e$1 * Math.PI / 180;
					if (L$2) {
						const t$3 = Math.sin(L$2), e$2 = Math.cos(L$2), r$1 = [
							e$2,
							-t$3,
							t$3,
							e$2
						];
						D$2._matMult(r$1), P$2._matMult(r$1), B$2._matMult(r$1), z$2._matMult(r$1);
					}
					const O$2 = t$2.stretch + t$2.fixed, R$3 = i$2.stretch + i$2.fixed;
					return {
						tl: D$2,
						tr: P$2,
						bl: B$2,
						br: z$2,
						tex: {
							x: o.paddedRect.x + 1 + O$2,
							y: o.paddedRect.y + 1 + R$3,
							w: s$2.stretch + s$2.fixed - O$2,
							h: l$2.stretch + l$2.fixed - R$3
						},
						writingMode: void 0,
						glyphOffset: [0, 0],
						sectionIndex: 0,
						pixelOffsetTL: V$2,
						pixelOffsetBR: C$1,
						minFontScaleX: A$2 / a$1 / I$2,
						minFontScaleY: k$2 / a$1 / M$2,
						isSDF: n$1
					};
				};
				if (i$1 && (o.stretchX || o.stretchY)) {
					const t$2 = rd(h$1, m$1, d$1), e$2 = rd(p$1, g$2, y$1);
					for (let r$1 = 0; r$1 < t$2.length - 1; r$1++) {
						const n$2 = t$2[r$1], i$2 = t$2[r$1 + 1];
						for (let t$3 = 0; t$3 < e$2.length - 1; t$3++) s$1.push(F$2(n$2, e$2[t$3], i$2, e$2[t$3 + 1]));
					}
				} else s$1.push(F$2({
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: l$1 + 1
				}, {
					fixed: 0,
					stretch: u$1 + 1
				}));
				return s$1;
			}
			function ed(t$1, e$1, r$1) {
				let n$1 = 0;
				for (const i$1 of t$1) n$1 += Math.max(e$1, Math.min(r$1, i$1[1])) - Math.max(e$1, Math.min(r$1, i$1[0]));
				return n$1;
			}
			function rd(t$1, e$1, r$1) {
				const n$1 = [{
					fixed: -1,
					stretch: 0
				}];
				for (const [e$2, r$2] of t$1) {
					const t$2 = n$1[n$1.length - 1];
					n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch
					}), n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch + (r$2 - e$2)
					});
				}
				return n$1.push({
					fixed: e$1 + 1,
					stretch: r$1
				}), n$1;
			}
			function nd(t$1, e$1, r$1, n$1) {
				return t$1 / e$1 * r$1 + n$1;
			}
			function id(t$1, e$1, r$1, n$1) {
				return t$1 - e$1 * r$1 / n$1;
			}
			us$1("Anchor", Xf);
			class sd {
				constructor(t$1, e$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1) {
					var h$1;
					if (this.boxStartIndex = t$1.length, u$1) {
						let t$2 = o.top, e$2 = o.bottom;
						const r$1 = o.collisionPadding;
						r$1 && (t$2 -= r$1[1], e$2 += r$1[3]);
						let n$2 = e$2 - t$2;
						n$2 > 0 && (n$2 = Math.max(10, n$2), this.circleDiameter = n$2);
					} else {
						const u$2 = (null === (h$1 = o.image) || void 0 === h$1 ? void 0 : h$1.content) && (o.image.textFitWidth || o.image.textFitHeight) ? Jc$1(o) : {
							x1: o.left,
							y1: o.top,
							x2: o.right,
							y2: o.bottom
						};
						u$2.y1 = u$2.y1 * a$1 - l$1[0], u$2.y2 = u$2.y2 * a$1 + l$1[2], u$2.x1 = u$2.x1 * a$1 - l$1[3], u$2.x2 = u$2.x2 * a$1 + l$1[1];
						const p$1 = o.collisionPadding;
						if (p$1 && (u$2.x1 -= p$1[0] * a$1, u$2.y1 -= p$1[1] * a$1, u$2.x2 += p$1[2] * a$1, u$2.y2 += p$1[3] * a$1), c$1) {
							const t$2 = new r(u$2.x1, u$2.y1), e$2 = new r(u$2.x2, u$2.y1), n$2 = new r(u$2.x1, u$2.y2), i$2 = new r(u$2.x2, u$2.y2), s$2 = c$1 * Math.PI / 180;
							t$2._rotate(s$2), e$2._rotate(s$2), n$2._rotate(s$2), i$2._rotate(s$2), u$2.x1 = Math.min(t$2.x, e$2.x, n$2.x, i$2.x), u$2.x2 = Math.max(t$2.x, e$2.x, n$2.x, i$2.x), u$2.y1 = Math.min(t$2.y, e$2.y, n$2.y, i$2.y), u$2.y2 = Math.max(t$2.y, e$2.y, n$2.y, i$2.y);
						}
						t$1.emplaceBack(e$1.x, e$1.y, u$2.x1, u$2.y1, u$2.x2, u$2.y2, n$1, i$1, s$1);
					}
					this.boxEndIndex = t$1.length;
				}
			}
			class od {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			}
			function ad(t$1, e$1 = 1, n$1 = !1) {
				const i$1 = Tf.fromPoints(t$1[0]), s$1 = Math.min(i$1.width(), i$1.height());
				let o = s$1 / 2;
				const a$1 = new od([], ld), { minX: l$1, minY: u$1, maxX: c$1, maxY: h$1 } = i$1;
				if (0 === s$1) return new r(l$1, u$1);
				for (let e$2 = l$1; e$2 < c$1; e$2 += s$1) for (let r$1 = u$1; r$1 < h$1; r$1 += s$1) a$1.push(new ud(e$2 + o, r$1 + o, o, t$1));
				let p$1 = function(t$2) {
					let e$2 = 0, r$1 = 0, n$2 = 0;
					const i$2 = t$2[0];
					for (let t$3 = 0, s$2 = i$2.length, o$1 = s$2 - 1; t$3 < s$2; o$1 = t$3++) {
						const s$3 = i$2[t$3], a$2 = i$2[o$1], l$2 = s$3.x * a$2.y - a$2.x * s$3.y;
						r$1 += (s$3.x + a$2.x) * l$2, n$2 += (s$3.y + a$2.y) * l$2, e$2 += 3 * l$2;
					}
					return new ud(r$1 / e$2, n$2 / e$2, 0, t$2);
				}(t$1), f$1 = a$1.length;
				for (; a$1.length;) {
					const r$1 = a$1.pop();
					(r$1.d > p$1.d || !p$1.d) && (p$1 = r$1, n$1 && console.log("found best %d after %d probes", Math.round(1e4 * r$1.d) / 1e4, f$1)), r$1.max - p$1.d <= e$1 || (o = r$1.h / 2, a$1.push(new ud(r$1.p.x - o, r$1.p.y - o, o, t$1)), a$1.push(new ud(r$1.p.x + o, r$1.p.y - o, o, t$1)), a$1.push(new ud(r$1.p.x - o, r$1.p.y + o, o, t$1)), a$1.push(new ud(r$1.p.x + o, r$1.p.y + o, o, t$1)), f$1 += 4);
				}
				return n$1 && (console.log(`num probes: ${f$1}`), console.log(`best distance: ${p$1.d}`)), p$1.p;
			}
			function ld(t$1, e$1) {
				return e$1.max - t$1.max;
			}
			function ud(t$1, e$1, n$1, i$1) {
				this.p = new r(t$1, e$1), this.h = n$1, this.d = function(t$2, e$2) {
					let r$1 = !1, n$2 = Infinity;
					for (let i$2 = 0; i$2 < e$2.length; i$2++) {
						const s$1 = e$2[i$2];
						for (let e$3 = 0, i$3 = s$1.length, o = i$3 - 1; e$3 < i$3; o = e$3++) {
							const i$4 = s$1[e$3], a$1 = s$1[o];
							i$4.y > t$2.y != a$1.y > t$2.y && t$2.x < (a$1.x - i$4.x) * (t$2.y - i$4.y) / (a$1.y - i$4.y) + i$4.x && (r$1 = !r$1), n$2 = Math.min(n$2, Ha$1(t$2, i$4, a$1));
						}
					}
					return (r$1 ? 1 : -1) * Math.sqrt(n$2);
				}(this.p, i$1), this.max = this.d + this.h * Math.SQRT2;
			}
			var cd;
			t.aQ = void 0, (cd = t.aQ || (t.aQ = {}))[cd.center = 1] = "center", cd[cd.left = 2] = "left", cd[cd.right = 3] = "right", cd[cd.top = 4] = "top", cd[cd.bottom = 5] = "bottom", cd[cd["top-left"] = 6] = "top-left", cd[cd["top-right"] = 7] = "top-right", cd[cd["bottom-left"] = 8] = "bottom-left", cd[cd["bottom-right"] = 9] = "bottom-right";
			const hd = Number.POSITIVE_INFINITY;
			function pd(t$1, e$1) {
				return e$1[1] !== hd ? function(t$2, e$2, r$1) {
					let n$1 = 0, i$1 = 0;
					switch (e$2 = Math.abs(e$2), r$1 = Math.abs(r$1), t$2) {
						case "top-right":
						case "top-left":
						case "top":
							i$1 = r$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
						case "bottom": i$1 = 7 - r$1;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
						case "right":
							n$1 = -e$2;
							break;
						case "top-left":
						case "bottom-left":
						case "left": n$1 = e$2;
					}
					return [n$1, i$1];
				}(t$1, e$1[0], e$1[1]) : function(t$2, e$2) {
					let r$1 = 0, n$1 = 0;
					e$2 < 0 && (e$2 = 0);
					const i$1 = e$2 / Math.SQRT2;
					switch (t$2) {
						case "top-right":
						case "top-left":
							n$1 = i$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
							n$1 = 7 - i$1;
							break;
						case "bottom":
							n$1 = 7 - e$2;
							break;
						case "top": n$1 = e$2 - 7;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
							r$1 = -i$1;
							break;
						case "top-left":
						case "bottom-left":
							r$1 = i$1;
							break;
						case "left":
							r$1 = e$2;
							break;
						case "right": r$1 = -e$2;
					}
					return [r$1, n$1];
				}(t$1, e$1[0]);
			}
			function fd(t$1, e$1, r$1) {
				var n$1;
				const i$1 = t$1.layout, s$1 = null === (n$1 = i$1.get("text-variable-anchor-offset")) || void 0 === n$1 ? void 0 : n$1.evaluate(e$1, {}, r$1);
				if (s$1) {
					const t$2 = s$1.values, e$2 = [];
					for (let r$2 = 0; r$2 < t$2.length; r$2 += 2) {
						const n$2 = e$2[r$2] = t$2[r$2], i$2 = t$2[r$2 + 1].map(((t$3) => t$3 * hc$1));
						n$2.startsWith("top") ? i$2[1] -= 7 : n$2.startsWith("bottom") && (i$2[1] += 7), e$2[r$2 + 1] = i$2;
					}
					return new Le$1(e$2);
				}
				const o = i$1.get("text-variable-anchor");
				if (o) {
					let n$2;
					n$2 = void 0 !== t$1._unevaluatedLayout.getValue("text-radial-offset") ? [i$1.get("text-radial-offset").evaluate(e$1, {}, r$1) * hc$1, hd] : i$1.get("text-offset").evaluate(e$1, {}, r$1).map(((t$2) => t$2 * hc$1));
					const s$2 = [];
					for (const t$2 of o) s$2.push(t$2, pd(t$2, n$2));
					return new Le$1(s$2);
				}
				return null;
			}
			function dd(t$1) {
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right": return "right";
					case "left":
					case "top-left":
					case "bottom-left": return "left";
				}
				return "center";
			}
			function yd(e$1, r$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1) {
				let f$1 = o.textMaxSize.evaluate(r$1, {});
				void 0 === f$1 && (f$1 = a$1);
				const d$1 = e$1.layers[0].layout, y$1 = d$1.get("icon-offset").evaluate(r$1, {}, h$1), m$1 = gd(n$1.horizontal), g$2 = a$1 / 24, x$1 = e$1.tilePixelRatio * g$2, v$1 = e$1.tilePixelRatio * f$1 / 24, b$1 = e$1.tilePixelRatio * l$1, w$2 = e$1.tilePixelRatio * d$1.get("symbol-spacing"), _$2 = d$1.get("text-padding") * e$1.tilePixelRatio, A$2 = function(t$1, e$2, r$2, n$2 = 1) {
					const i$2 = t$1.get("icon-padding").evaluate(e$2, {}, r$2), s$2 = i$2 && i$2.values;
					return [
						s$2[0] * n$2,
						s$2[1] * n$2,
						s$2[2] * n$2,
						s$2[3] * n$2
					];
				}(d$1, r$1, h$1, e$1.tilePixelRatio), S$2 = d$1.get("text-max-angle") / 180 * Math.PI, k$2 = "viewport" !== d$1.get("text-rotation-alignment") && "point" !== d$1.get("symbol-placement"), E$1 = "map" === d$1.get("icon-rotation-alignment") && "point" !== d$1.get("symbol-placement"), T$1 = d$1.get("symbol-placement"), I$2 = w$2 / 2, F$2 = d$1.get("icon-text-fit");
				let D$2;
				i$1 && "none" !== F$2 && (e$1.allowVerticalPlacement && n$1.vertical && (D$2 = Qc$1(i$1, n$1.vertical, F$2, d$1.get("icon-text-fit-padding"), y$1, g$2)), m$1 && (i$1 = Qc$1(i$1, m$1, F$2, d$1.get("icon-text-fit-padding"), y$1, g$2)));
				const P$2 = h$1 ? p$1.line.getGranularityForZoomLevel(h$1.z) : 1, z$2 = (l$2, p$2) => {
					p$2.x < 0 || p$2.x >= M$1 || p$2.y < 0 || p$2.y >= M$1 || function(e$2, r$2, n$2, i$2, s$2, o$1, a$2, l$3, u$2, c$2, h$2, p$3, f$2, d$2, y$2, m$2, g$3, x$2, v$2, b$2, w$3, _$3, A$3, S$3, k$3) {
						const E$2 = e$2.addToLineVertexArray(r$2, n$2);
						let T$2, I$3, M$2, F$3, D$3 = 0, P$3 = 0, z$3 = 0, B$2 = 0, V$2 = -1, C$1 = -1;
						const L$2 = {};
						let O$2 = fa$1("");
						if (e$2.allowVerticalPlacement && i$2.vertical) {
							const t$1 = l$3.layout.get("text-rotate").evaluate(w$3, {}, S$3) + 90;
							M$2 = new sd(u$2, r$2, c$2, h$2, p$3, i$2.vertical, f$2, d$2, y$2, t$1), a$2 && (F$3 = new sd(u$2, r$2, c$2, h$2, p$3, a$2, g$3, x$2, y$2, t$1));
						}
						if (s$2) {
							const n$3 = l$3.layout.get("icon-rotate").evaluate(w$3, {}), i$3 = "none" !== l$3.layout.get("icon-text-fit"), o$2 = td(s$2, n$3, A$3, i$3), f$3 = a$2 ? td(a$2, n$3, A$3, i$3) : void 0;
							I$3 = new sd(u$2, r$2, c$2, h$2, p$3, s$2, g$3, x$2, !1, n$3), D$3 = 4 * o$2.length;
							const d$3 = e$2.iconSizeData;
							let y$3 = null;
							"source" === d$3.kind ? (y$3 = [th * l$3.layout.get("icon-size").evaluate(w$3, {})], y$3[0] > eh && j$1(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d$3.kind && (y$3 = [th * _$3.compositeIconSizes[0].evaluate(w$3, {}, S$3), th * _$3.compositeIconSizes[1].evaluate(w$3, {}, S$3)], (y$3[0] > eh || y$3[1] > eh) && j$1(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e$2.addSymbols(e$2.icon, o$2, y$3, b$2, v$2, w$3, t.aA.none, r$2, E$2.lineStartIndex, E$2.lineLength, -1, S$3), V$2 = e$2.icon.placedSymbolArray.length - 1, f$3 && (P$3 = 4 * f$3.length, e$2.addSymbols(e$2.icon, f$3, y$3, b$2, v$2, w$3, t.aA.vertical, r$2, E$2.lineStartIndex, E$2.lineLength, -1, S$3), C$1 = e$2.icon.placedSymbolArray.length - 1);
						}
						const R$3 = Object.keys(i$2.horizontal);
						for (const n$3 of R$3) {
							const s$3 = i$2.horizontal[n$3];
							if (!T$2) {
								O$2 = fa$1(s$3.text);
								T$2 = new sd(u$2, r$2, c$2, h$2, p$3, s$3, f$2, d$2, y$2, l$3.layout.get("text-rotate").evaluate(w$3, {}, S$3));
							}
							const a$3 = 1 === s$3.positionedLines.length;
							if (z$3 += md(e$2, r$2, s$3, o$1, l$3, y$2, w$3, m$2, E$2, i$2.vertical ? t.aA.horizontal : t.aA.horizontalOnly, a$3 ? R$3 : [n$3], L$2, V$2, _$3, S$3), a$3) break;
						}
						i$2.vertical && (B$2 += md(e$2, r$2, i$2.vertical, o$1, l$3, y$2, w$3, m$2, E$2, t.aA.vertical, ["vertical"], L$2, C$1, _$3, S$3));
						const N$1 = T$2 ? T$2.boxStartIndex : e$2.collisionBoxArray.length, $$2 = T$2 ? T$2.boxEndIndex : e$2.collisionBoxArray.length, U$2 = M$2 ? M$2.boxStartIndex : e$2.collisionBoxArray.length, q$2 = M$2 ? M$2.boxEndIndex : e$2.collisionBoxArray.length, G$2 = I$3 ? I$3.boxStartIndex : e$2.collisionBoxArray.length, X$1 = I$3 ? I$3.boxEndIndex : e$2.collisionBoxArray.length, Y$2 = F$3 ? F$3.boxStartIndex : e$2.collisionBoxArray.length, Z$2 = F$3 ? F$3.boxEndIndex : e$2.collisionBoxArray.length;
						let H$2 = -1;
						const K$2 = (t$1, e$3) => t$1 && t$1.circleDiameter ? Math.max(t$1.circleDiameter, e$3) : e$3;
						H$2 = K$2(T$2, H$2), H$2 = K$2(M$2, H$2), H$2 = K$2(I$3, H$2), H$2 = K$2(F$3, H$2);
						const W$2 = H$2 > -1 ? 1 : 0;
						W$2 && (H$2 *= k$3 / hc$1), e$2.glyphOffsetArray.length >= ch.MAX_GLYPHS && j$1("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w$3.sortKey && e$2.addToSortKeyRanges(e$2.symbolInstances.length, w$3.sortKey);
						const J$2 = fd(l$3, w$3, S$3), [Q$2, tt$2] = function(e$3, r$3) {
							const n$3 = e$3.length, i$3 = null == r$3 ? void 0 : r$3.values;
							if ((null == i$3 ? void 0 : i$3.length) > 0) for (let r$4 = 0; r$4 < i$3.length; r$4 += 2) {
								const n$4 = i$3[r$4 + 1];
								e$3.emplaceBack(t.aQ[i$3[r$4]], n$4[0], n$4[1]);
							}
							return [n$3, e$3.length];
						}(e$2.textAnchorOffsets, J$2);
						e$2.symbolInstances.emplaceBack(r$2.x, r$2.y, L$2.right >= 0 ? L$2.right : -1, L$2.center >= 0 ? L$2.center : -1, L$2.left >= 0 ? L$2.left : -1, L$2.vertical || -1, V$2, C$1, O$2, N$1, $$2, U$2, q$2, G$2, X$1, Y$2, Z$2, c$2, z$3, B$2, D$3, P$3, W$2, 0, f$2, H$2, Q$2, tt$2);
					}(e$1, p$2, l$2, n$1, i$1, s$1, D$2, e$1.layers[0], e$1.collisionBoxArray, r$1.index, r$1.sourceLayerIndex, e$1.index, x$1, [
						_$2,
						_$2,
						_$2,
						_$2
					], k$2, u$1, b$1, A$2, E$1, y$1, r$1, o, c$1, h$1, a$1);
				};
				if ("line" === T$1) for (const t$1 of Nf(r$1.geometry, 0, 0, M$1, M$1)) {
					const r$2 = du$1(t$1, P$2), s$2 = Jf(r$2, w$2, S$2, n$1.vertical || m$1, i$1, 24, v$1, e$1.overscaling, M$1);
					for (const t$2 of s$2) m$1 && xd(e$1, m$1.text, I$2, t$2) || z$2(r$2, t$2);
				}
				else if ("line-center" === T$1) {
					for (const t$1 of r$1.geometry) if (t$1.length > 1) {
						const e$2 = du$1(t$1, P$2), r$2 = Wf(e$2, S$2, n$1.vertical || m$1, i$1, 24, v$1);
						r$2 && z$2(e$2, r$2);
					}
				} else if ("Polygon" === r$1.type) for (const t$1 of tn$1(r$1.geometry, 0)) {
					const e$2 = ad(t$1, 16);
					z$2(du$1(t$1[0], P$2, !0), new Xf(e$2.x, e$2.y, 0));
				}
				else if ("LineString" === r$1.type) for (const t$1 of r$1.geometry) {
					const e$2 = du$1(t$1, P$2);
					z$2(e$2, new Xf(e$2[0].x, e$2[0].y, 0));
				}
				else if ("Point" === r$1.type) for (const t$1 of r$1.geometry) for (const e$2 of t$1) z$2([e$2], new Xf(e$2.x, e$2.y, 0));
			}
			function md(t$1, e$1, n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = function(t$2, e$2, n$2, i$2, s$2, o$1, a$2, l$2) {
					const u$2 = i$2.layout.get("text-rotate").evaluate(o$1, {}) * Math.PI / 180, c$2 = [];
					for (const t$3 of e$2.positionedLines) for (const i$3 of t$3.positionedGlyphs) {
						if (!i$3.rect) continue;
						const o$2 = i$3.rect || {};
						let h$2 = 4, p$2 = !0, f$2 = 1, d$2 = 0;
						const y$2 = (s$2 || l$2) && i$3.vertical, m$2 = i$3.metrics.advance * i$3.scale / 2;
						if (l$2 && e$2.verticalizable && (d$2 = t$3.lineOffset / 2 - (i$3.imageName ? -(hc$1 - i$3.metrics.width * i$3.scale) / 2 : (i$3.scale - 1) * hc$1)), i$3.imageName) {
							const t$4 = a$2[i$3.imageName];
							p$2 = t$4.sdf, f$2 = t$4.pixelRatio, h$2 = 1 / f$2;
						}
						const g$3 = s$2 ? [i$3.x + m$2, i$3.y] : [0, 0];
						let x$2 = s$2 ? [0, 0] : [i$3.x + m$2 + n$2[0], i$3.y + n$2[1] - d$2], v$1 = [0, 0];
						y$2 && (v$1 = x$2, x$2 = [0, 0]);
						const b$1 = i$3.metrics.isDoubleResolution ? 2 : 1, w$2 = (i$3.metrics.left - h$2) * i$3.scale - m$2 + x$2[0], _$2 = (-i$3.metrics.top - h$2) * i$3.scale + x$2[1], A$2 = w$2 + o$2.w / b$1 * i$3.scale / f$2, S$2 = _$2 + o$2.h / b$1 * i$3.scale / f$2, k$2 = new r(w$2, _$2), E$1 = new r(A$2, _$2), T$1 = new r(w$2, S$2), I$2 = new r(A$2, S$2);
						if (y$2) {
							const t$4 = new r(-m$2, m$2 - -17), e$3 = -Math.PI / 2, n$3 = 12 - m$2, s$3 = new r(22 - n$3, -(i$3.imageName ? n$3 : 0)), o$3 = new r(...v$1);
							k$2._rotateAround(e$3, t$4)._add(s$3)._add(o$3), E$1._rotateAround(e$3, t$4)._add(s$3)._add(o$3), T$1._rotateAround(e$3, t$4)._add(s$3)._add(o$3), I$2._rotateAround(e$3, t$4)._add(s$3)._add(o$3);
						}
						if (u$2) {
							const t$4 = Math.sin(u$2), e$3 = Math.cos(u$2), r$1 = [
								e$3,
								-t$4,
								t$4,
								e$3
							];
							k$2._matMult(r$1), E$1._matMult(r$1), T$1._matMult(r$1), I$2._matMult(r$1);
						}
						const M$2 = new r(0, 0), F$2 = new r(0, 0);
						c$2.push({
							tl: k$2,
							tr: E$1,
							bl: T$1,
							br: I$2,
							tex: o$2,
							writingMode: e$2.writingMode,
							glyphOffset: g$3,
							sectionIndex: i$3.sectionIndex,
							isSDF: p$2,
							pixelOffsetTL: M$2,
							pixelOffsetBR: F$2,
							minFontScaleX: 0,
							minFontScaleY: 0
						});
					}
					return c$2;
				}(0, n$1, l$1, s$1, o, a$1, i$1, t$1.allowVerticalPlacement), g$2 = t$1.textSizeData;
				let x$1 = null;
				"source" === g$2.kind ? (x$1 = [th * s$1.layout.get("text-size").evaluate(a$1, {})], x$1[0] > eh && j$1(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g$2.kind && (x$1 = [th * d$1.compositeTextSizes[0].evaluate(a$1, {}, y$1), th * d$1.compositeTextSizes[1].evaluate(a$1, {}, y$1)], (x$1[0] > eh || x$1[1] > eh) && j$1(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t$1.addSymbols(t$1.text, m$1, x$1, l$1, o, a$1, c$1, e$1, u$1.lineStartIndex, u$1.lineLength, f$1, y$1);
				for (const e$2 of h$1) p$1[e$2] = t$1.text.placedSymbolArray.length - 1;
				return 4 * m$1.length;
			}
			function gd(t$1) {
				for (const e$1 in t$1) return t$1[e$1];
				return null;
			}
			function xd(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.compareText;
				if (e$1 in i$1) {
					const t$2 = i$1[e$1];
					for (let e$2 = t$2.length - 1; e$2 >= 0; e$2--) if (n$1.dist(t$2[e$2]) < r$1) return !0;
				} else i$1[e$1] = [];
				return i$1[e$1].push(n$1), !1;
			}
			const vd = [
				Int8Array,
				Uint8Array,
				Uint8ClampedArray,
				Int16Array,
				Uint16Array,
				Int32Array,
				Uint32Array,
				Float32Array,
				Float64Array
			];
			class bd {
				static from(t$1) {
					if (!(t$1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
					const [e$1, r$1] = new Uint8Array(t$1, 0, 2);
					if (219 !== e$1) throw new Error("Data does not appear to be in a KDBush format.");
					const n$1 = r$1 >> 4;
					if (1 !== n$1) throw new Error(`Got v${n$1} data when expected v1.`);
					const i$1 = vd[15 & r$1];
					if (!i$1) throw new Error("Unrecognized array type.");
					const [s$1] = new Uint16Array(t$1, 2, 1), [o] = new Uint32Array(t$1, 4, 1);
					return new bd(o, s$1, i$1, t$1);
				}
				constructor(t$1, e$1 = 64, r$1 = Float64Array, n$1) {
					if (isNaN(t$1) || t$1 < 0) throw new Error(`Unpexpected numItems value: ${t$1}.`);
					this.numItems = +t$1, this.nodeSize = Math.min(Math.max(+e$1, 2), 65535), this.ArrayType = r$1, this.IndexArrayType = t$1 < 65536 ? Uint16Array : Uint32Array;
					const i$1 = vd.indexOf(this.ArrayType), s$1 = 2 * t$1 * this.ArrayType.BYTES_PER_ELEMENT, o = t$1 * this.IndexArrayType.BYTES_PER_ELEMENT, a$1 = (8 - o % 8) % 8;
					if (i$1 < 0) throw new Error(`Unexpected typed array class: ${r$1}.`);
					n$1 && n$1 instanceof ArrayBuffer ? (this.data = n$1, this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + o + a$1, 2 * t$1), this._pos = 2 * t$1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s$1 + o + a$1), this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + o + a$1, 2 * t$1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i$1]), new Uint16Array(this.data, 2, 1)[0] = e$1, new Uint32Array(this.data, 4, 1)[0] = t$1);
				}
				add(t$1, e$1) {
					const r$1 = this._pos >> 1;
					return this.ids[r$1] = r$1, this.coords[this._pos++] = t$1, this.coords[this._pos++] = e$1, r$1;
				}
				finish() {
					const t$1 = this._pos >> 1;
					if (t$1 !== this.numItems) throw new Error(`Added ${t$1} items when expected ${this.numItems}.`);
					return wd(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
				}
				range(t$1, e$1, r$1, n$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: i$1, coords: s$1, nodeSize: o } = this, a$1 = [
						0,
						i$1.length - 1,
						0
					], l$1 = [];
					for (; a$1.length;) {
						const u$1 = a$1.pop() || 0, c$1 = a$1.pop() || 0, h$1 = a$1.pop() || 0;
						if (c$1 - h$1 <= o) {
							for (let o$1 = h$1; o$1 <= c$1; o$1++) {
								const a$2 = s$1[2 * o$1], u$2 = s$1[2 * o$1 + 1];
								a$2 >= t$1 && a$2 <= r$1 && u$2 >= e$1 && u$2 <= n$1 && l$1.push(i$1[o$1]);
							}
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = s$1[2 * p$1], d$1 = s$1[2 * p$1 + 1];
						f$1 >= t$1 && f$1 <= r$1 && d$1 >= e$1 && d$1 <= n$1 && l$1.push(i$1[p$1]), (0 === u$1 ? t$1 <= f$1 : e$1 <= d$1) && (a$1.push(h$1), a$1.push(p$1 - 1), a$1.push(1 - u$1)), (0 === u$1 ? r$1 >= f$1 : n$1 >= d$1) && (a$1.push(p$1 + 1), a$1.push(c$1), a$1.push(1 - u$1));
					}
					return l$1;
				}
				within(t$1, e$1, r$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: n$1, coords: i$1, nodeSize: s$1 } = this, o = [
						0,
						n$1.length - 1,
						0
					], a$1 = [], l$1 = r$1 * r$1;
					for (; o.length;) {
						const u$1 = o.pop() || 0, c$1 = o.pop() || 0, h$1 = o.pop() || 0;
						if (c$1 - h$1 <= s$1) {
							for (let r$2 = h$1; r$2 <= c$1; r$2++) kd(i$1[2 * r$2], i$1[2 * r$2 + 1], t$1, e$1) <= l$1 && a$1.push(n$1[r$2]);
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = i$1[2 * p$1], d$1 = i$1[2 * p$1 + 1];
						kd(f$1, d$1, t$1, e$1) <= l$1 && a$1.push(n$1[p$1]), (0 === u$1 ? t$1 - r$1 <= f$1 : e$1 - r$1 <= d$1) && (o.push(h$1), o.push(p$1 - 1), o.push(1 - u$1)), (0 === u$1 ? t$1 + r$1 >= f$1 : e$1 + r$1 >= d$1) && (o.push(p$1 + 1), o.push(c$1), o.push(1 - u$1));
					}
					return a$1;
				}
			}
			function wd(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (i$1 - n$1 <= r$1) return;
				const o = n$1 + i$1 >> 1;
				_d(t$1, e$1, o, n$1, i$1, s$1), wd(t$1, e$1, r$1, n$1, o - 1, 1 - s$1), wd(t$1, e$1, r$1, o + 1, i$1, 1 - s$1);
			}
			function _d(t$1, e$1, r$1, n$1, i$1, s$1) {
				for (; i$1 > n$1;) {
					if (i$1 - n$1 > 600) {
						const o$1 = i$1 - n$1 + 1, a$2 = r$1 - n$1 + 1, l$2 = Math.log(o$1), u$1 = .5 * Math.exp(2 * l$2 / 3), c$1 = .5 * Math.sqrt(l$2 * u$1 * (o$1 - u$1) / o$1) * (a$2 - o$1 / 2 < 0 ? -1 : 1);
						_d(t$1, e$1, r$1, Math.max(n$1, Math.floor(r$1 - a$2 * u$1 / o$1 + c$1)), Math.min(i$1, Math.floor(r$1 + (o$1 - a$2) * u$1 / o$1 + c$1)), s$1);
					}
					const o = e$1[2 * r$1 + s$1];
					let a$1 = n$1, l$1 = i$1;
					for (Ad(t$1, e$1, n$1, r$1), e$1[2 * i$1 + s$1] > o && Ad(t$1, e$1, n$1, i$1); a$1 < l$1;) {
						for (Ad(t$1, e$1, a$1, l$1), a$1++, l$1--; e$1[2 * a$1 + s$1] < o;) a$1++;
						for (; e$1[2 * l$1 + s$1] > o;) l$1--;
					}
					e$1[2 * n$1 + s$1] === o ? Ad(t$1, e$1, n$1, l$1) : (l$1++, Ad(t$1, e$1, l$1, i$1)), l$1 <= r$1 && (n$1 = l$1 + 1), r$1 <= l$1 && (i$1 = l$1 - 1);
				}
			}
			function Ad(t$1, e$1, r$1, n$1) {
				Sd(t$1, r$1, n$1), Sd(e$1, 2 * r$1, 2 * n$1), Sd(e$1, 2 * r$1 + 1, 2 * n$1 + 1);
			}
			function Sd(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function kd(t$1, e$1, r$1, n$1) {
				const i$1 = t$1 - r$1, s$1 = e$1 - n$1;
				return i$1 * i$1 + s$1 * s$1;
			}
			var Ed;
			t.cI = void 0, (Ed = t.cI || (t.cI = {})).create = "create", Ed.load = "load", Ed.fullLoad = "fullLoad";
			let Td = null, Id = [];
			const Md = 1e3 / 60, Fd = "loadTime", Dd = "fullLoadTime";
			t.$ = c, t.A = f, t.B = os$1, t.C = es$1, t.D = $s$1, t.E = xt$1, t.F = function([t$1, e$1, r$1]) {
				return e$1 += 90, e$1 *= Math.PI / 180, r$1 *= Math.PI / 180, {
					x: t$1 * Math.cos(e$1) * Math.sin(r$1),
					y: t$1 * Math.sin(e$1) * Math.sin(r$1),
					z: t$1 * Math.cos(r$1)
				};
			}, t.G = yr$1, t.H = Fs$1, t.I = Nc$1, t.J = ns$1, t.K = function(t$1) {
				if (null == Y$1) {
					const e$1 = t$1.navigator ? t$1.navigator.userAgent : null;
					Y$1 = !!t$1.safari || !(!e$1 || !(/\b(iPad|iPhone|iPod)\b/.test(e$1) || e$1.match("Safari") && !e$1.match("Chrome")));
				}
				return Y$1;
			}, t.L = class {
				constructor(t$1, e$1) {
					this.target = t$1, this.mapId = e$1, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new bh((() => this.process())), this.subscription = Q$1(this.target, "message", ((t$2) => this.receive(t$2)), !1), this.globalScope = X(self) ? t$1 : window;
				}
				registerMessageHandler(t$1, e$1) {
					this.messageHandlers[t$1] = e$1;
				}
				unregisterMessageHandler(t$1) {
					delete this.messageHandlers[t$1];
				}
				sendAsync(t$1, e$1) {
					return new Promise(((r$1, n$1) => {
						const i$1 = Math.round(0xde0b6b3a7640000 * Math.random()).toString(36).substring(0, 10), s$1 = e$1 ? Q$1(e$1.signal, "abort", (() => {
							s$1?.unsubscribe(), delete this.resolveRejects[i$1];
							const e$2 = {
								id: i$1,
								type: "<cancel>",
								origin: location.origin,
								targetMapId: t$1.targetMapId,
								sourceMapId: this.mapId
							};
							this.target.postMessage(e$2);
						}), wh) : null;
						this.resolveRejects[i$1] = {
							resolve: (t$2) => {
								s$1?.unsubscribe(), r$1(t$2);
							},
							reject: (t$2) => {
								s$1?.unsubscribe(), n$1(t$2);
							}
						};
						const o = [], a$1 = Object.assign(Object.assign({}, t$1), {
							id: i$1,
							sourceMapId: this.mapId,
							origin: location.origin,
							data: fs$1(t$1.data, o)
						});
						this.target.postMessage(a$1, { transfer: o });
					}));
				}
				receive(t$1) {
					const e$1 = t$1.data, r$1 = e$1.id;
					if (!("file://" !== e$1.origin && "file://" !== location.origin && "resource://android" !== e$1.origin && "resource://android" !== location.origin && e$1.origin !== location.origin || e$1.targetMapId && this.mapId !== e$1.targetMapId)) {
						if ("<cancel>" === e$1.type) {
							delete this.tasks[r$1];
							const t$2 = this.abortControllers[r$1];
							delete this.abortControllers[r$1], t$2 && t$2.abort();
							return;
						}
						if (X(self) || e$1.mustQueue) return this.tasks[r$1] = e$1, this.taskQueue.push(r$1), void this.invoker.trigger();
						this.processTask(r$1, e$1);
					}
				}
				process() {
					if (0 === this.taskQueue.length) return;
					const t$1 = this.taskQueue.shift(), e$1 = this.tasks[t$1];
					delete this.tasks[t$1], this.taskQueue.length > 0 && this.invoker.trigger(), e$1 && this.processTask(t$1, e$1);
				}
				processTask(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if ("<response>" === r$1.type) {
							const e$2 = this.resolveRejects[t$1];
							if (delete this.resolveRejects[t$1], !e$2) return;
							r$1.error ? e$2.reject(ds$1(r$1.error)) : e$2.resolve(ds$1(r$1.data));
							return;
						}
						if (!this.messageHandlers[r$1.type]) return void this.completeTask(t$1, /* @__PURE__ */ new Error(`Could not find a registered handler for ${r$1.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
						const e$1 = ds$1(r$1.data), n$1 = new AbortController();
						this.abortControllers[t$1] = n$1;
						try {
							const i$1 = yield this.messageHandlers[r$1.type](r$1.sourceMapId, e$1, n$1);
							this.completeTask(t$1, null, i$1);
						} catch (e$2) {
							this.completeTask(t$1, e$2);
						}
					}));
				}
				completeTask(t$1, e$1, r$1) {
					const n$1 = [];
					delete this.abortControllers[t$1];
					const i$1 = {
						id: t$1,
						type: "<response>",
						sourceMapId: this.mapId,
						origin: location.origin,
						error: e$1 ? fs$1(e$1) : null,
						data: fs$1(r$1, n$1)
					};
					this.target.postMessage(i$1, { transfer: n$1 });
				}
				remove() {
					this.invoker.remove(), this.subscription.unsubscribe();
				}
			}, t.M = ut$1, t.N = function() {
				var t$1 = new f(16);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0), t$1[0] = 1, t$1[5] = 1, t$1[10] = 1, t$1[15] = 1, t$1;
			}, t.O = function(t$1, e$1, r$1) {
				var n$1, i$1, s$1, o, a$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1 = r$1[0], m$1 = r$1[1], g$2 = r$1[2];
				return e$1 === t$1 ? (t$1[12] = e$1[0] * y$1 + e$1[4] * m$1 + e$1[8] * g$2 + e$1[12], t$1[13] = e$1[1] * y$1 + e$1[5] * m$1 + e$1[9] * g$2 + e$1[13], t$1[14] = e$1[2] * y$1 + e$1[6] * m$1 + e$1[10] * g$2 + e$1[14], t$1[15] = e$1[3] * y$1 + e$1[7] * m$1 + e$1[11] * g$2 + e$1[15]) : (i$1 = e$1[1], s$1 = e$1[2], o = e$1[3], a$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], t$1[0] = n$1 = e$1[0], t$1[1] = i$1, t$1[2] = s$1, t$1[3] = o, t$1[4] = a$1, t$1[5] = l$1, t$1[6] = u$1, t$1[7] = c$1, t$1[8] = h$1, t$1[9] = p$1, t$1[10] = f$1, t$1[11] = d$1, t$1[12] = n$1 * y$1 + a$1 * m$1 + h$1 * g$2 + e$1[12], t$1[13] = i$1 * y$1 + l$1 * m$1 + p$1 * g$2 + e$1[13], t$1[14] = s$1 * y$1 + u$1 * m$1 + f$1 * g$2 + e$1[14], t$1[15] = o * y$1 + c$1 * m$1 + d$1 * g$2 + e$1[15]), t$1;
			}, t.P = r, t.Q = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2];
				return t$1[0] = e$1[0] * n$1, t$1[1] = e$1[1] * n$1, t$1[2] = e$1[2] * n$1, t$1[3] = e$1[3] * n$1, t$1[4] = e$1[4] * i$1, t$1[5] = e$1[5] * i$1, t$1[6] = e$1[6] * i$1, t$1[7] = e$1[7] * i$1, t$1[8] = e$1[8] * s$1, t$1[9] = e$1[9] * s$1, t$1[10] = e$1[10] * s$1, t$1[11] = e$1[11] * s$1, t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.R = bl$1, t.S = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o = e$1[3], a$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], y$1 = e$1[12], m$1 = e$1[13], g$2 = e$1[14], x$1 = e$1[15], v$1 = r$1[0], b$1 = r$1[1], w$2 = r$1[2], _$2 = r$1[3];
				return t$1[0] = v$1 * n$1 + b$1 * a$1 + w$2 * h$1 + _$2 * y$1, t$1[1] = v$1 * i$1 + b$1 * l$1 + w$2 * p$1 + _$2 * m$1, t$1[2] = v$1 * s$1 + b$1 * u$1 + w$2 * f$1 + _$2 * g$2, t$1[3] = v$1 * o + b$1 * c$1 + w$2 * d$1 + _$2 * x$1, t$1[4] = (v$1 = r$1[4]) * n$1 + (b$1 = r$1[5]) * a$1 + (w$2 = r$1[6]) * h$1 + (_$2 = r$1[7]) * y$1, t$1[5] = v$1 * i$1 + b$1 * l$1 + w$2 * p$1 + _$2 * m$1, t$1[6] = v$1 * s$1 + b$1 * u$1 + w$2 * f$1 + _$2 * g$2, t$1[7] = v$1 * o + b$1 * c$1 + w$2 * d$1 + _$2 * x$1, t$1[8] = (v$1 = r$1[8]) * n$1 + (b$1 = r$1[9]) * a$1 + (w$2 = r$1[10]) * h$1 + (_$2 = r$1[11]) * y$1, t$1[9] = v$1 * i$1 + b$1 * l$1 + w$2 * p$1 + _$2 * m$1, t$1[10] = v$1 * s$1 + b$1 * u$1 + w$2 * f$1 + _$2 * g$2, t$1[11] = v$1 * o + b$1 * c$1 + w$2 * d$1 + _$2 * x$1, t$1[12] = (v$1 = r$1[12]) * n$1 + (b$1 = r$1[13]) * a$1 + (w$2 = r$1[14]) * h$1 + (_$2 = r$1[15]) * y$1, t$1[13] = v$1 * i$1 + b$1 * l$1 + w$2 * p$1 + _$2 * m$1, t$1[14] = v$1 * s$1 + b$1 * u$1 + w$2 * f$1 + _$2 * g$2, t$1[15] = v$1 * o + b$1 * c$1 + w$2 * d$1 + _$2 * x$1, t$1;
			}, t.T = Ml$1, t.U = function(t$1, e$1) {
				const r$1 = {};
				for (let n$1 = 0; n$1 < e$1.length; n$1++) {
					const i$1 = e$1[n$1];
					i$1 in t$1 && (r$1[i$1] = t$1[i$1]);
				}
				return r$1;
			}, t.V = Ah, t.W = L$1, t.X = Th, t.Y = Eh, t.Z = ot$1, t._ = e, t.a = st$1, t.a$ = Dh, t.a0 = h, t.a1 = K$1, t.a2 = Ch, t.a3 = Mh, t.a4 = Fh, t.a5 = M$1, t.a6 = function(t$1, e$1, r$1) {
				if (!t$1) return e$1 || {};
				if (!e$1) return t$1 || {};
				const n$1 = Nh(t$1), i$1 = Nh(e$1);
				(function(t$2, e$2) {
					e$2.removeAll && (t$2.add.clear(), t$2.update.clear(), t$2.remove.clear(), e$2.remove.clear());
					for (const r$2 of e$2.remove) t$2.add.delete(r$2), t$2.update.delete(r$2);
					for (const [r$2, n$2] of e$2.update) {
						const i$2 = t$2.update.get(r$2);
						i$2 && (e$2.update.set(r$2, Rh(i$2, n$2)), t$2.update.delete(r$2));
					}
				})(n$1, i$1);
				const s$1 = {};
				if ((n$1.removeAll || i$1.removeAll) && (s$1.removeAll = !0), s$1.remove = new Set([...n$1.remove, ...i$1.remove]), s$1.add = new Map([...n$1.add, ...i$1.add]), s$1.update = new Map([...n$1.update, ...i$1.update]), s$1.remove.size && s$1.add.size) for (const t$2 of s$1.add.keys()) s$1.remove.delete(t$2);
				return function(t$2) {
					const e$2 = {};
					return t$2.removeAll && (e$2.removeAll = t$2.removeAll), t$2.remove && (e$2.remove = Array.from(t$2.remove)), t$2.add && (e$2.add = Array.from(t$2.add.values())), t$2.update && (e$2.update = Array.from(t$2.update.values())), e$2;
				}(s$1);
			}, t.a7 = function(t$1, e$1) {
				if (null == t$1) return !0;
				if (null == t$1.type) return !0;
				if ("Feature" === t$1.type) return null != Oh(t$1, e$1);
				if ("FeatureCollection" === t$1.type) {
					const r$1 = /* @__PURE__ */ new Set();
					for (const n$1 of t$1.features) {
						const t$2 = Oh(n$1, e$1);
						if (null == t$2) return !1;
						if (r$1.has(t$2)) return !1;
						r$1.add(t$2);
					}
					return !0;
				}
				return !1;
			}, t.a8 = function(t$1, e$1) {
				const r$1 = /* @__PURE__ */ new Map();
				if (null == t$1 || null == t$1.type);
				else if ("Feature" === t$1.type) r$1.set(Oh(t$1, e$1), t$1);
				else for (const n$1 of t$1.features) r$1.set(Oh(n$1, e$1), n$1);
				return r$1;
			}, t.a9 = function(t$1, e$1, r$1) {
				var n$1, i$1;
				if (e$1.removeAll) t$1.clear();
				else if (e$1.remove) for (const r$2 of e$1.remove) t$1.delete(r$2);
				if (e$1.add) for (const n$2 of e$1.add) {
					const e$2 = Oh(n$2, r$1);
					null != e$2 && t$1.set(e$2, n$2);
				}
				if (e$1.update) for (const r$2 of e$1.update) {
					let e$2 = t$1.get(r$2.id);
					if (!e$2) continue;
					const s$1 = !!r$2.newGeometry, o = r$2.removeAllProperties || (null === (n$1 = r$2.removeProperties) || void 0 === n$1 ? void 0 : n$1.length) > 0 || (null === (i$1 = r$2.addOrUpdateProperties) || void 0 === i$1 ? void 0 : i$1.length) > 0;
					if ((s$1 || o) && (e$2 = Object.assign({}, e$2), t$1.set(r$2.id, e$2), s$1 && (e$2.geometry = r$2.newGeometry), o)) {
						if (e$2.properties = r$2.removeAllProperties ? {} : Object.assign({}, e$2.properties || {}), r$2.removeProperties) for (const t$2 of r$2.removeProperties) delete e$2.properties[t$2];
						if (r$2.addOrUpdateProperties) for (const { key: t$2, value: n$2 } of r$2.addOrUpdateProperties) e$2.properties[t$2] = n$2;
					}
				}
			}, t.aB = function(t$1, { uSize: e$1, uSizeT: r$1 }, { lowerSize: n$1, upperSize: i$1 }) {
				return "source" === t$1.kind ? n$1 / th : "composite" === t$1.kind ? yr$1.number(n$1 / th, i$1 / th, r$1) : e$1;
			}, t.aC = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], o = e$1[4], a$1 = e$1[5], l$1 = e$1[6], u$1 = e$1[7], c$1 = e$1[8], h$1 = e$1[9], p$1 = e$1[10], f$1 = e$1[11], d$1 = e$1[12], y$1 = e$1[13], m$1 = e$1[14], g$2 = e$1[15], x$1 = r$1 * a$1 - n$1 * o, v$1 = r$1 * l$1 - i$1 * o, b$1 = r$1 * u$1 - s$1 * o, w$2 = n$1 * l$1 - i$1 * a$1, _$2 = n$1 * u$1 - s$1 * a$1, A$2 = i$1 * u$1 - s$1 * l$1, S$2 = c$1 * y$1 - h$1 * d$1, k$2 = c$1 * m$1 - p$1 * d$1, E$1 = c$1 * g$2 - f$1 * d$1, T$1 = h$1 * m$1 - p$1 * y$1, I$2 = h$1 * g$2 - f$1 * y$1, M$2 = p$1 * g$2 - f$1 * m$1, F$2 = x$1 * M$2 - v$1 * I$2 + b$1 * T$1 + w$2 * E$1 - _$2 * k$2 + A$2 * S$2;
				return F$2 ? (t$1[0] = (a$1 * M$2 - l$1 * I$2 + u$1 * T$1) * (F$2 = 1 / F$2), t$1[1] = (i$1 * I$2 - n$1 * M$2 - s$1 * T$1) * F$2, t$1[2] = (y$1 * A$2 - m$1 * _$2 + g$2 * w$2) * F$2, t$1[3] = (p$1 * _$2 - h$1 * A$2 - f$1 * w$2) * F$2, t$1[4] = (l$1 * E$1 - o * M$2 - u$1 * k$2) * F$2, t$1[5] = (r$1 * M$2 - i$1 * E$1 + s$1 * k$2) * F$2, t$1[6] = (m$1 * b$1 - d$1 * A$2 - g$2 * v$1) * F$2, t$1[7] = (c$1 * A$2 - p$1 * b$1 + f$1 * v$1) * F$2, t$1[8] = (o * I$2 - a$1 * E$1 + u$1 * S$2) * F$2, t$1[9] = (n$1 * E$1 - r$1 * I$2 - s$1 * S$2) * F$2, t$1[10] = (d$1 * _$2 - y$1 * b$1 + g$2 * x$1) * F$2, t$1[11] = (h$1 * b$1 - c$1 * _$2 - f$1 * x$1) * F$2, t$1[12] = (a$1 * k$2 - o * T$1 - l$1 * S$2) * F$2, t$1[13] = (r$1 * T$1 - n$1 * k$2 + i$1 * S$2) * F$2, t$1[14] = (y$1 * v$1 - d$1 * w$2 - m$1 * x$1) * F$2, t$1[15] = (c$1 * w$2 - h$1 * v$1 + p$1 * x$1) * F$2, t$1) : null;
			}, t.aD = T, t.aE = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1);
			}, t.aF = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1;
			}, t.aG = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1;
			}, t.aH = oh, t.aI = S$1, t.aJ = function(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.y - t$1.y, o = e$1.x - t$1.x, a$1 = i$1.y - n$1.y, l$1 = i$1.x - n$1.x, u$1 = a$1 * o - l$1 * s$1;
				if (0 === u$1) return null;
				const c$1 = (l$1 * (t$1.y - n$1.y) - a$1 * (t$1.x - n$1.x)) / u$1;
				return new r(t$1.x + c$1 * o, t$1.y + c$1 * s$1);
			}, t.aK = Nf, t.aL = Ua$1, t.aM = function(t$1) {
				let e$1 = Infinity, r$1 = Infinity, n$1 = -Infinity, i$1 = -Infinity;
				for (const s$1 of t$1) e$1 = Math.min(e$1, s$1.x), r$1 = Math.min(r$1, s$1.y), n$1 = Math.max(n$1, s$1.x), i$1 = Math.max(i$1, s$1.y);
				return [
					e$1,
					r$1,
					n$1,
					i$1
				];
			}, t.aN = hc$1, t.aO = F$1, t.aP = function(t$1, e$1, r$1, n$1, i$1 = !1) {
				if (!r$1[0] && !r$1[1]) return [0, 0];
				const s$1 = i$1 ? "map" === n$1 ? -t$1.bearingInRadians : 0 : "viewport" === n$1 ? t$1.bearingInRadians : 0;
				if (s$1) {
					const t$2 = Math.sin(s$1), e$2 = Math.cos(s$1);
					r$1 = [r$1[0] * e$2 - r$1[1] * t$2, r$1[0] * t$2 + r$1[1] * e$2];
				}
				return [i$1 ? r$1[0] : F$1(e$1, r$1[0], t$1.zoom), i$1 ? r$1[1] : F$1(e$1, r$1[1], t$1.zoom)];
			}, t.aR = nh, t.aS = dd, t.aT = jc$1, t.aU = bd, t.aV = to$1, t.aW = uu$1, t.aX = Ro, t.aY = ra$1, t.aZ = Jo$1, t.a_ = et$1, t.aa = Mf, t.ab = Ph, t.ac = Tf, t.ad = 25, t.ae = Bh, t.af = (t$1) => {
				const e$1 = window.document.createElement("video");
				return e$1.muted = !0, new Promise(((r$1) => {
					e$1.onloadstart = () => {
						r$1(e$1);
					};
					for (const r$2 of t$1) {
						const t$2 = window.document.createElement("source");
						ft(r$2) || (e$1.crossOrigin = "Anonymous"), t$2.src = r$2, e$1.appendChild(t$2);
					}
				}));
			}, t.ag = Dt$1, t.ah = function() {
				return R$2++;
			}, t.ai = Io$1, t.aj = ch, t.ak = fi, t.al = Oa$1, t.am = Uh, t.an = function(t$1) {
				const e$1 = {};
				if (t$1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t$2, r$1, n$1, i$1) => {
					const s$1 = n$1 || i$1;
					return e$1[r$1] = !s$1 || s$1.toLowerCase(), "";
				})), e$1["max-age"]) {
					const t$2 = parseInt(e$1["max-age"], 10);
					isNaN(t$2) ? delete e$1["max-age"] : e$1["max-age"] = t$2;
				}
				return e$1;
			}, t.ao = C, t.ap = 85.051129, t.aq = tt$1, t.ar = function(t$1) {
				return Math.pow(2, t$1);
			}, t.as = y, t.at = Ih, t.au = function(t$1) {
				return Math.log(t$1) / Math.LN2;
			}, t.av = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return e$1 * e$1 + r$1 * r$1;
			}, t.aw = function(t$1) {
				if (!t$1.length) return /* @__PURE__ */ new Set();
				const e$1 = Math.max(...t$1.map(((t$2) => t$2.canonical.z)));
				let r$1 = Infinity, n$1 = -Infinity, i$1 = Infinity, s$1 = -Infinity;
				const o = [];
				for (const a$2 of t$1) {
					const { x: t$2, y: l$1, z: u$1 } = a$2.canonical, c$1 = Math.pow(2, e$1 - u$1), h$1 = t$2 * c$1, p$1 = l$1 * c$1;
					o.push({
						id: a$2,
						x: h$1,
						y: p$1
					}), h$1 < r$1 && (r$1 = h$1), h$1 > n$1 && (n$1 = h$1), p$1 < i$1 && (i$1 = p$1), p$1 > s$1 && (s$1 = p$1);
				}
				const a$1 = /* @__PURE__ */ new Set();
				for (const t$2 of o) t$2.x !== r$1 && t$2.x !== n$1 && t$2.y !== i$1 && t$2.y !== s$1 || a$1.add(t$2.id);
				return a$1;
			}, t.ax = function(t$1, e$1) {
				const r$1 = Math.abs(2 * t$1.wrap) - +(t$1.wrap < 0), n$1 = Math.abs(2 * e$1.wrap) - +(e$1.wrap < 0);
				return t$1.overscaledZ - e$1.overscaledZ || n$1 - r$1 || e$1.canonical.y - t$1.canonical.y || e$1.canonical.x - t$1.canonical.x;
			}, t.ay = class {
				constructor(t$1, e$1) {
					this.max = t$1, this.onRemove = e$1, this.reset();
				}
				reset() {
					for (const t$1 in this.data) for (const e$1 of this.data[t$1]) e$1.timeout && clearTimeout(e$1.timeout), this.onRemove(e$1.value);
					return this.data = {}, this.order = [], this;
				}
				add(t$1, e$1, r$1) {
					const n$1 = t$1.wrapped().key;
					void 0 === this.data[n$1] && (this.data[n$1] = []);
					const i$1 = {
						value: e$1,
						timeout: void 0
					};
					if (void 0 !== r$1 && (i$1.timeout = setTimeout((() => {
						this.remove(t$1, i$1);
					}), r$1)), this.data[n$1].push(i$1), this.order.push(n$1), this.order.length > this.max) {
						const t$2 = this._getAndRemoveByKey(this.order[0]);
						t$2 && this.onRemove(t$2);
					}
					return this;
				}
				has(t$1) {
					return t$1.wrapped().key in this.data;
				}
				getAndRemove(t$1) {
					return this.has(t$1) ? this._getAndRemoveByKey(t$1.wrapped().key) : null;
				}
				_getAndRemoveByKey(t$1) {
					const e$1 = this.data[t$1].shift();
					return e$1.timeout && clearTimeout(e$1.timeout), 0 === this.data[t$1].length && delete this.data[t$1], this.order.splice(this.order.indexOf(t$1), 1), e$1.value;
				}
				getByKey(t$1) {
					const e$1 = this.data[t$1];
					return e$1 ? e$1[0].value : null;
				}
				get(t$1) {
					return this.has(t$1) ? this.data[t$1.wrapped().key][0].value : null;
				}
				remove(t$1, e$1) {
					if (!this.has(t$1)) return this;
					const r$1 = t$1.wrapped().key, n$1 = void 0 === e$1 ? 0 : this.data[r$1].indexOf(e$1), i$1 = this.data[r$1][n$1];
					return this.data[r$1].splice(n$1, 1), i$1.timeout && clearTimeout(i$1.timeout), 0 === this.data[r$1].length && delete this.data[r$1], this.onRemove(i$1.value), this.order.splice(this.order.indexOf(r$1), 1), this;
				}
				setMaxSize(t$1) {
					for (this.max = t$1; this.order.length > this.max;) {
						const t$2 = this._getAndRemoveByKey(this.order[0]);
						t$2 && this.onRemove(t$2);
					}
					return this;
				}
				filter(t$1) {
					const e$1 = [];
					for (const r$1 in this.data) for (const n$1 of this.data[r$1]) t$1(n$1.value) || e$1.push(n$1);
					for (const t$2 of e$1) this.remove(t$2.value.tileID, t$2);
				}
			}, t.az = function(t$1, e$1) {
				let r$1 = 0, n$1 = 0;
				if ("constant" === t$1.kind) n$1 = t$1.layoutSize;
				else if ("source" !== t$1.kind) {
					const { interpolationType: i$1, minZoom: s$1, maxZoom: o } = t$1, a$1 = i$1 ? C(fr$1.interpolationFactor(i$1, e$1, s$1, o), 0, 1) : 0;
					"camera" === t$1.kind ? n$1 = yr$1.number(t$1.minSize, t$1.maxSize, a$1) : r$1 = a$1;
				}
				return {
					uSizeT: r$1,
					uSize: n$1
				};
			}, t.b = Z$1, t.b$ = class extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1i(this.location, t$1));
				}
			}, t.b0 = b, t.b1 = v, t.b2 = function(t$1) {
				var e$1 = new f(3);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1;
			}, t.b3 = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] - r$1[0], t$1[1] = e$1[1] - r$1[1], t$1[2] = e$1[2] - r$1[2], t$1;
			}, t.b4 = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = r$1 * r$1 + n$1 * n$1 + i$1 * i$1;
				return s$1 > 0 && (s$1 = 1 / Math.sqrt(s$1)), t$1[0] = e$1[0] * s$1, t$1[1] = e$1[1] * s$1, t$1[2] = e$1[2] * s$1, t$1;
			}, t.b5 = w$1, t.b6 = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2];
			}, t.b7 = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1[0], t$1[1] = e$1[1] * r$1[1], t$1[2] = e$1[2] * r$1[2], t$1[3] = e$1[3] * r$1[3], t$1;
			}, t.b8 = g$1, t.b9 = function(t$1, e$1, r$1) {
				const n$1 = e$1[0] * r$1[0] + e$1[1] * r$1[1] + e$1[2] * r$1[2];
				return 0 === n$1 ? null : (-(t$1[0] * r$1[0] + t$1[1] * r$1[1] + t$1[2] * r$1[2]) - r$1[3]) / n$1;
			}, t.bA = function() {
				return new Float64Array(3);
			}, t.bB = function(t$1, e$1, r$1, n$1) {
				return t$1[0] = e$1[0] + r$1[0] * n$1, t$1[1] = e$1[1] + r$1[1] * n$1, t$1[2] = e$1[2] + r$1[2] * n$1, t$1;
			}, t.bC = E, t.bD = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2], o = r$1[3], a$1 = e$1[0], l$1 = e$1[1], u$1 = e$1[2], c$1 = i$1 * u$1 - s$1 * l$1, h$1 = s$1 * a$1 - n$1 * u$1, p$1 = n$1 * l$1 - i$1 * a$1;
				return t$1[0] = a$1 + o * (c$1 += c$1) + i$1 * (p$1 += p$1) - s$1 * (h$1 += h$1), t$1[1] = l$1 + o * h$1 + s$1 * c$1 - n$1 * p$1, t$1[2] = u$1 + o * p$1 + n$1 * h$1 - i$1 * c$1, t$1;
			}, t.bE = function(t$1, e$1, r$1) {
				const n$1 = function(t$2) {
					var e$2 = t$2[3], r$2 = t$2[4], n$2 = t$2[5], i$2 = t$2[6], s$2 = t$2[7], o$1 = t$2[8];
					return t$2[0] * (o$1 * r$2 - n$2 * s$2) + t$2[1] * (-o$1 * e$2 + n$2 * i$2) + t$2[2] * (s$2 * e$2 - r$2 * i$2);
				}([
					t$1[0],
					t$1[1],
					t$1[2],
					e$1[0],
					e$1[1],
					e$1[2],
					r$1[0],
					r$1[1],
					r$1[2]
				]);
				if (0 === n$1) return null;
				const i$1 = w$1([], [
					e$1[0],
					e$1[1],
					e$1[2]
				], [
					r$1[0],
					r$1[1],
					r$1[2]
				]), s$1 = w$1([], [
					r$1[0],
					r$1[1],
					r$1[2]
				], [
					t$1[0],
					t$1[1],
					t$1[2]
				]), o = w$1([], [
					t$1[0],
					t$1[1],
					t$1[2]
				], [
					e$1[0],
					e$1[1],
					e$1[2]
				]), a$1 = b([], i$1, -t$1[3]);
				return v(a$1, a$1, b([], s$1, -e$1[3])), v(a$1, a$1, b([], o, -r$1[3])), b(a$1, a$1, 1 / n$1), a$1;
			}, t.bF = _h, t.bG = function() {
				return new Float64Array(4);
			}, t.bH = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0] * Math.cos(n$1) - i$1[1] * Math.sin(n$1), s$1[1] = i$1[0] * Math.sin(n$1) + i$1[1] * Math.cos(n$1), s$1[2] = i$1[2], t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bI = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0], s$1[1] = i$1[1] * Math.cos(n$1) - i$1[2] * Math.sin(n$1), s$1[2] = i$1[1] * Math.sin(n$1) + i$1[2] * Math.cos(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bJ = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[2] * Math.sin(n$1) + i$1[0] * Math.cos(n$1), s$1[1] = i$1[1], s$1[2] = i$1[2] * Math.cos(n$1) - i$1[0] * Math.sin(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bK = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], o = e$1[1], a$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 - u$1 * n$1, t$1[1] = o * i$1 - c$1 * n$1, t$1[2] = a$1 * i$1 - h$1 * n$1, t$1[3] = l$1 * i$1 - p$1 * n$1, t$1[8] = s$1 * n$1 + u$1 * i$1, t$1[9] = o * n$1 + c$1 * i$1, t$1[10] = a$1 * n$1 + h$1 * i$1, t$1[11] = l$1 * n$1 + p$1 * i$1, t$1;
			}, t.bL = function(t$1, e$1) {
				const r$1 = D$1(t$1, 360), n$1 = D$1(e$1, 360), i$1 = n$1 - r$1, s$1 = n$1 > r$1 ? i$1 - 360 : i$1 + 360;
				return Math.abs(i$1) < Math.abs(s$1) ? i$1 : s$1;
			}, t.bM = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1;
			}, t.bN = function(t$1, e$1, r$1, n$1) {
				const i$1 = Math.sqrt(t$1 * t$1 + e$1 * e$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
				t$1 /= i$1, e$1 /= i$1, r$1 /= s$1, n$1 /= s$1;
				const o = Math.acos(t$1 * r$1 + e$1 * n$1);
				return -e$1 * r$1 + t$1 * n$1 > 0 ? o : -o;
			}, t.bO = function(t$1, e$1) {
				const r$1 = D$1(t$1, 2 * Math.PI), n$1 = D$1(e$1, 2 * Math.PI);
				return Math.min(Math.abs(r$1 - n$1), Math.abs(r$1 - n$1 + 2 * Math.PI), Math.abs(r$1 - n$1 - 2 * Math.PI));
			}, t.bP = function() {
				const t$1 = {}, e$1 = vt$1.$version;
				for (const r$1 in vt$1.$root) {
					const n$1 = vt$1.$root[r$1];
					if (n$1.required) {
						let i$1 = null;
						i$1 = "version" === r$1 ? e$1 : "array" === n$1.type ? [] : {}, null != i$1 && (t$1[r$1] = i$1);
					}
				}
				return t$1;
			}, t.bQ = ht$1, t.bR = ys$1, t.bS = function t$1(e$1, r$1) {
				if (Array.isArray(e$1)) {
					if (!Array.isArray(r$1) || e$1.length !== r$1.length) return !1;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				if ("object" == typeof e$1 && null !== e$1 && null !== r$1) {
					if ("object" != typeof r$1) return !1;
					if (Object.keys(e$1).length !== Object.keys(r$1).length) return !1;
					for (const n$1 in e$1) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				return e$1 === r$1;
			}, t.bT = function(t$1) {
				t$1 = t$1.slice();
				const e$1 = Object.create(null);
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[t$1[r$1].id] = t$1[r$1];
				for (let r$1 = 0; r$1 < t$1.length; r$1++) "ref" in t$1[r$1] && (t$1[r$1] = wt$1(t$1[r$1], e$1[t$1[r$1].ref]));
				return t$1;
			}, t.bU = function(t$1, e$1) {
				if ("custom" === t$1.type) return new vh(t$1, e$1);
				switch (t$1.type) {
					case "background": return new xh(t$1, e$1);
					case "circle": return new pl$1(t$1, e$1);
					case "color-relief": return new Pl$1(t$1, e$1);
					case "fill": return new _u$1(t$1, e$1);
					case "fill-extrusion": return new Uu$1(t$1, e$1);
					case "heatmap": return new Al$1(t$1, e$1);
					case "hillshade": return new El$1(t$1, e$1);
					case "line": return new nc$1(t$1, e$1);
					case "raster": return new Ks$1(t$1, e$1);
					case "symbol": return new yh(t$1, e$1);
				}
			}, t.bV = (t$1) => "raster" === t$1.type, t.bW = U$1, t.bX = function(t$1, e$1) {
				if (!t$1) return [{
					command: "setStyle",
					args: [e$1]
				}];
				let r$1 = [];
				try {
					if (!_t$1(t$1.version, e$1.version)) return [{
						command: "setStyle",
						args: [e$1]
					}];
					_t$1(t$1.center, e$1.center) || r$1.push({
						command: "setCenter",
						args: [e$1.center]
					}), _t$1(t$1.state, e$1.state) || r$1.push({
						command: "setGlobalState",
						args: [e$1.state]
					}), _t$1(t$1.centerAltitude, e$1.centerAltitude) || r$1.push({
						command: "setCenterAltitude",
						args: [e$1.centerAltitude]
					}), _t$1(t$1.zoom, e$1.zoom) || r$1.push({
						command: "setZoom",
						args: [e$1.zoom]
					}), _t$1(t$1.bearing, e$1.bearing) || r$1.push({
						command: "setBearing",
						args: [e$1.bearing]
					}), _t$1(t$1.pitch, e$1.pitch) || r$1.push({
						command: "setPitch",
						args: [e$1.pitch]
					}), _t$1(t$1.roll, e$1.roll) || r$1.push({
						command: "setRoll",
						args: [e$1.roll]
					}), _t$1(t$1.sprite, e$1.sprite) || r$1.push({
						command: "setSprite",
						args: [e$1.sprite]
					}), _t$1(t$1.glyphs, e$1.glyphs) || r$1.push({
						command: "setGlyphs",
						args: [e$1.glyphs]
					}), _t$1(t$1.transition, e$1.transition) || r$1.push({
						command: "setTransition",
						args: [e$1.transition]
					}), _t$1(t$1.light, e$1.light) || r$1.push({
						command: "setLight",
						args: [e$1.light]
					}), _t$1(t$1.terrain, e$1.terrain) || r$1.push({
						command: "setTerrain",
						args: [e$1.terrain]
					}), _t$1(t$1.sky, e$1.sky) || r$1.push({
						command: "setSky",
						args: [e$1.sky]
					}), _t$1(t$1.projection, e$1.projection) || r$1.push({
						command: "setProjection",
						args: [e$1.projection]
					});
					const n$1 = {}, i$1 = [];
					(function(t$2, e$2, r$2, n$2) {
						let i$2;
						for (i$2 in e$2 = e$2 || {}, t$2 = t$2 || {}) Object.prototype.hasOwnProperty.call(t$2, i$2) && (Object.prototype.hasOwnProperty.call(e$2, i$2) || kt$1(i$2, r$2, n$2));
						for (i$2 in e$2) Object.prototype.hasOwnProperty.call(e$2, i$2) && (Object.prototype.hasOwnProperty.call(t$2, i$2) ? _t$1(t$2[i$2], e$2[i$2]) || ("geojson" === t$2[i$2].type && "geojson" === e$2[i$2].type && Tt$1(t$2, e$2, i$2) ? At$1(r$2, {
							command: "setGeoJSONSourceData",
							args: [i$2, e$2[i$2].data]
						}) : Et$1(i$2, e$2, r$2, n$2)) : St$1(i$2, e$2, r$2));
					})(t$1.sources, e$1.sources, i$1, n$1);
					const s$1 = [];
					t$1.layers && t$1.layers.forEach(((t$2) => {
						"source" in t$2 && n$1[t$2.source] ? r$1.push({
							command: "removeLayer",
							args: [t$2.id]
						}) : s$1.push(t$2);
					})), r$1 = r$1.concat(i$1), function(t$2, e$2, r$2) {
						e$2 = e$2 || [];
						const n$2 = (t$2 = t$2 || []).map(Mt$1), i$2 = e$2.map(Mt$1), s$2 = t$2.reduce(Ft$1, {}), o = e$2.reduce(Ft$1, {}), a$1 = n$2.slice(), l$1 = Object.create(null);
						let u$1, c$1, h$1, p$1, f$1;
						for (let t$3 = 0, e$3 = 0; t$3 < n$2.length; t$3++) u$1 = n$2[t$3], Object.prototype.hasOwnProperty.call(o, u$1) ? e$3++ : (At$1(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), a$1.splice(a$1.indexOf(u$1, e$3), 1));
						for (let t$3 = 0, e$3 = 0; t$3 < i$2.length; t$3++) u$1 = i$2[i$2.length - 1 - t$3], a$1[a$1.length - 1 - t$3] !== u$1 && (Object.prototype.hasOwnProperty.call(s$2, u$1) ? (At$1(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), a$1.splice(a$1.lastIndexOf(u$1, a$1.length - e$3), 1)) : e$3++, p$1 = a$1[a$1.length - t$3], At$1(r$2, {
							command: "addLayer",
							args: [o[u$1], p$1]
						}), a$1.splice(a$1.length - t$3, 0, u$1), l$1[u$1] = !0);
						for (let t$3 = 0; t$3 < i$2.length; t$3++) if (u$1 = i$2[t$3], c$1 = s$2[u$1], h$1 = o[u$1], !l$1[u$1] && !_t$1(c$1, h$1)) if (_t$1(c$1.source, h$1.source) && _t$1(c$1["source-layer"], h$1["source-layer"]) && _t$1(c$1.type, h$1.type)) {
							for (f$1 in It$1(c$1.layout, h$1.layout, r$2, u$1, null, "setLayoutProperty"), It$1(c$1.paint, h$1.paint, r$2, u$1, null, "setPaintProperty"), _t$1(c$1.filter, h$1.filter) || At$1(r$2, {
								command: "setFilter",
								args: [u$1, h$1.filter]
							}), _t$1(c$1.minzoom, h$1.minzoom) && _t$1(c$1.maxzoom, h$1.maxzoom) || At$1(r$2, {
								command: "setLayerZoomRange",
								args: [
									u$1,
									h$1.minzoom,
									h$1.maxzoom
								]
							}), c$1) Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It$1(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : _t$1(c$1[f$1], h$1[f$1]) || At$1(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
							for (f$1 in h$1) Object.prototype.hasOwnProperty.call(h$1, f$1) && !Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It$1(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : _t$1(c$1[f$1], h$1[f$1]) || At$1(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
						} else At$1(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), p$1 = a$1[a$1.lastIndexOf(u$1) + 1], At$1(r$2, {
							command: "addLayer",
							args: [h$1, p$1]
						});
					}(s$1, e$1.layers, r$1);
				} catch (t$2) {
					console.warn("Unable to compute style diff:", t$2), r$1 = [{
						command: "setStyle",
						args: [e$1]
					}];
				}
				return r$1;
			}, t.bY = function(t$1) {
				const e$1 = [], r$1 = t$1.id;
				return void 0 === r$1 && e$1.push({ message: `layers.${r$1}: missing required property "id"` }), void 0 === t$1.render && e$1.push({ message: `layers.${r$1}: missing required method "render"` }), t$1.renderingMode && "2d" !== t$1.renderingMode && "3d" !== t$1.renderingMode && e$1.push({ message: `layers.${r$1}: property "renderingMode" must be either "2d" or "3d"` }), e$1;
			}, t.bZ = N, t.b_ = $$1, t.ba = A$1, t.bb = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1[3] = e$1[3] * r$1, t$1;
			}, t.bc = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3];
			}, t.bd = Vh, t.be = Lh, t.bf = function(t$1, e$1, r$1, n$1, i$1) {
				var s$1 = 1 / Math.tan(e$1 / 2);
				if (t$1[0] = s$1 / r$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = s$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = -1, t$1[12] = 0, t$1[13] = 0, t$1[15] = 0, null != i$1 && i$1 !== Infinity) {
					var o = 1 / (n$1 - i$1);
					t$1[10] = (i$1 + n$1) * o, t$1[14] = 2 * i$1 * n$1 * o;
				} else t$1[10] = -1, t$1[14] = -2 * n$1;
				return t$1;
			}, t.bg = function(t$1) {
				var e$1 = new f(16);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1[3] = t$1[3], e$1[4] = t$1[4], e$1[5] = t$1[5], e$1[6] = t$1[6], e$1[7] = t$1[7], e$1[8] = t$1[8], e$1[9] = t$1[9], e$1[10] = t$1[10], e$1[11] = t$1[11], e$1[12] = t$1[12], e$1[13] = t$1[13], e$1[14] = t$1[14], e$1[15] = t$1[15], e$1;
			}, t.bh = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], o = e$1[1], a$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[4], c$1 = e$1[5], h$1 = e$1[6], p$1 = e$1[7];
				return e$1 !== t$1 && (t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 + u$1 * n$1, t$1[1] = o * i$1 + c$1 * n$1, t$1[2] = a$1 * i$1 + h$1 * n$1, t$1[3] = l$1 * i$1 + p$1 * n$1, t$1[4] = u$1 * i$1 - s$1 * n$1, t$1[5] = c$1 * i$1 - o * n$1, t$1[6] = h$1 * i$1 - a$1 * n$1, t$1[7] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.bi = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[4], o = e$1[5], a$1 = e$1[6], l$1 = e$1[7], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[4] = s$1 * i$1 + u$1 * n$1, t$1[5] = o * i$1 + c$1 * n$1, t$1[6] = a$1 * i$1 + h$1 * n$1, t$1[7] = l$1 * i$1 + p$1 * n$1, t$1[8] = u$1 * i$1 - s$1 * n$1, t$1[9] = c$1 * i$1 - o * n$1, t$1[10] = h$1 * i$1 - a$1 * n$1, t$1[11] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.bj = function() {
				const t$1 = new Float32Array(16);
				return y(t$1), t$1;
			}, t.bk = function() {
				const t$1 = new Float64Array(16);
				return y(t$1), t$1;
			}, t.bl = function() {
				return new Float64Array(16);
			}, t.bm = function(t$1, e$1, r$1) {
				const n$1 = new Float64Array(4);
				return E(n$1, t$1, e$1 - 90, r$1), n$1;
			}, t.bn = function(t$1, e$1, r$1, n$1) {
				var i$1, s$1, o, a$1, l$1, u$1 = e$1[0], c$1 = e$1[1], h$1 = e$1[2], f$1 = e$1[3], d$1 = r$1[0], y$1 = r$1[1], m$1 = r$1[2], g$2 = r$1[3];
				return (s$1 = u$1 * d$1 + c$1 * y$1 + h$1 * m$1 + f$1 * g$2) < 0 && (s$1 = -s$1, d$1 = -d$1, y$1 = -y$1, m$1 = -m$1, g$2 = -g$2), 1 - s$1 > p ? (i$1 = Math.acos(s$1), o = Math.sin(i$1), a$1 = Math.sin((1 - n$1) * i$1) / o, l$1 = Math.sin(n$1 * i$1) / o) : (a$1 = 1 - n$1, l$1 = n$1), t$1[0] = a$1 * u$1 + l$1 * d$1, t$1[1] = a$1 * c$1 + l$1 * y$1, t$1[2] = a$1 * h$1 + l$1 * m$1, t$1[3] = a$1 * f$1 + l$1 * g$2, t$1;
			}, t.bo = function(t$1) {
				const e$1 = new Float64Array(9);
				(function(t$2, e$2) {
					var r$2 = e$2[0], n$2 = e$2[1], i$2 = e$2[2], s$1 = e$2[3], o = r$2 + r$2, a$1 = n$2 + n$2, l$1 = i$2 + i$2, u$1 = r$2 * o, c$1 = n$2 * o, h$1 = n$2 * a$1, p$1 = i$2 * o, f$1 = i$2 * a$1, d$1 = i$2 * l$1, y$1 = s$1 * o, m$1 = s$1 * a$1, g$2 = s$1 * l$1;
					t$2[0] = 1 - h$1 - d$1, t$2[3] = c$1 - g$2, t$2[6] = p$1 + m$1, t$2[1] = c$1 + g$2, t$2[4] = 1 - u$1 - d$1, t$2[7] = f$1 - y$1, t$2[2] = p$1 - m$1, t$2[5] = f$1 + y$1, t$2[8] = 1 - u$1 - h$1;
				})(e$1, t$1);
				const r$1 = et$1(-Math.asin(C(e$1[2], -1, 1)));
				let n$1, i$1;
				return Math.hypot(e$1[5], e$1[8]) < .001 ? (n$1 = 0, i$1 = -et$1(Math.atan2(e$1[3], e$1[4]))) : (n$1 = et$1(0 === e$1[5] && 0 === e$1[8] ? 0 : Math.atan2(e$1[5], e$1[8])), i$1 = et$1(0 === e$1[1] && 0 === e$1[0] ? 0 : Math.atan2(e$1[1], e$1[0]))), {
					roll: n$1,
					pitch: r$1 + 90,
					bearing: i$1
				};
			}, t.bp = function(t$1, e$1) {
				return t$1.roll == e$1.roll && t$1.pitch == e$1.pitch && t$1.bearing == e$1.bearing;
			}, t.bq = Te$1, t.br = va$1, t.bs = cu$1, t.bt = hu$1, t.bu = lu$1, t.bv = P$1, t.bw = z$1, t.bx = Re$1, t.by = function(t$1, e$1, r$1, n$1, i$1) {
				return P$1(n$1, i$1, C((t$1 - e$1) / (r$1 - e$1), 0, 1));
			}, t.bz = D$1, t.c = at$2, t.c$ = class {
				constructor(t$1) {
					this._marks = {
						start: [t$1.url, "start"].join("#"),
						end: [t$1.url, "end"].join("#"),
						measure: t$1.url.toString()
					}, performance.mark(this._marks.start);
				}
				finish() {
					performance.mark(this._marks.end);
					let t$1 = performance.getEntriesByName(this._marks.measure);
					return 0 === t$1.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t$1 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t$1;
				}
			}, t.c0 = wa$1, t.c1 = class extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = _a$1;
				}
				set(t$1) {
					if (t$1[12] !== this.current[12] || t$1[0] !== this.current[0]) return this.current = t$1, void this.gl.uniformMatrix4fv(this.location, !1, t$1);
					for (let e$1 = 1; e$1 < 16; e$1++) if (t$1[e$1] !== this.current[e$1]) {
						this.current = t$1, this.gl.uniformMatrix4fv(this.location, !1, t$1);
						break;
					}
				}
			}, t.c2 = ba$1, t.c3 = class extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] || (this.current = t$1, this.gl.uniform3f(this.location, t$1[0], t$1[1], t$1[2]));
				}
			}, t.c4 = class extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [0, 0];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] || (this.current = t$1, this.gl.uniform2f(this.location, t$1[0], t$1[1]));
				}
			}, t.c5 = d, t.c6 = function(t$1, e$1) {
				var r$1 = Math.sin(e$1), n$1 = Math.cos(e$1);
				return t$1[0] = n$1, t$1[1] = r$1, t$1[2] = 0, t$1[3] = -r$1, t$1[4] = n$1, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 1, t$1;
			}, t.c7 = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2];
				return t$1[0] = n$1 * r$1[0] + i$1 * r$1[3] + s$1 * r$1[6], t$1[1] = n$1 * r$1[1] + i$1 * r$1[4] + s$1 * r$1[7], t$1[2] = n$1 * r$1[2] + i$1 * r$1[5] + s$1 * r$1[8], t$1;
			}, t.c8 = function(t$1, e$1, r$1, n$1, i$1, s$1, o) {
				var a$1 = 1 / (e$1 - r$1), l$1 = 1 / (n$1 - i$1), u$1 = 1 / (s$1 - o);
				return t$1[0] = -2 * a$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = -2 * l$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 2 * u$1, t$1[11] = 0, t$1[12] = (e$1 + r$1) * a$1, t$1[13] = (i$1 + n$1) * l$1, t$1[14] = (o + s$1) * u$1, t$1[15] = 1, t$1;
			}, t.c9 = class extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(4 * t$1.length);
						for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[4 * r$1] = t$1[r$1].r, e$1[4 * r$1 + 1] = t$1[r$1].g, e$1[4 * r$1 + 2] = t$1[r$1].b, e$1[4 * r$1 + 3] = t$1[r$1].a;
						this.gl.uniform4fv(this.location, e$1);
					}
				}
			}, t.cA = function(t$1, e$1) {
				return nt$1[e$1] && (t$1 instanceof MouseEvent || t$1 instanceof WheelEvent);
			}, t.cB = function(t$1, e$1) {
				return rt$1[e$1] && "touches" in t$1;
			}, t.cC = function(t$1) {
				return rt$1[t$1] || nt$1[t$1];
			}, t.cD = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[12], t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[13], t$1;
			}, t.cE = function(t$1, e$1) {
				const { x: r$1, y: n$1 } = Ph.fromLngLat(e$1);
				return !(t$1 < 0 || t$1 > 25 || n$1 < 0 || n$1 >= 1 || r$1 < 0 || r$1 >= 1);
			}, t.cF = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = e$1[1], t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = e$1[2], t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}, t.cG = class extends no$1 {}, t.cH = {
				mark(t$1) {
					performance.mark(t$1);
				},
				frame(t$1) {
					const e$1 = t$1;
					null != Td && Id.push(e$1 - Td), Td = e$1;
				},
				clearMetrics() {
					Td = null, Id = [], performance.clearMeasures(Fd), performance.clearMeasures(Dd);
					for (const e$1 in t.cI) performance.clearMarks(t.cI[e$1]);
				},
				getPerformanceMetrics() {
					performance.measure(Fd, t.cI.create, t.cI.load), performance.measure(Dd, t.cI.create, t.cI.fullLoad);
					const e$1 = performance.getEntriesByName(Fd)[0].duration, r$1 = performance.getEntriesByName(Dd)[0].duration, n$1 = Id.length, i$1 = 1 / (Id.reduce(((t$1, e$2) => t$1 + e$2), 0) / n$1 / 1e3), s$1 = Id.filter(((t$1) => t$1 > Md)).reduce(((t$1, e$2) => t$1 + (e$2 - Md) / Md), 0);
					return {
						loadTime: e$1,
						fullLoadTime: r$1,
						fps: i$1,
						percentDroppedFrames: s$1 / (n$1 + s$1) * 100,
						totalFrames: n$1
					};
				}
			}, t.cJ = ct$1, t.cK = function(t$1, e$1) {
				at$2.REGISTERED_PROTOCOLS[t$1] = e$1;
			}, t.cL = function(t$1) {
				delete at$2.REGISTERED_PROTOCOLS[t$1];
			}, t.cM = function(t$1, e$1) {
				const r$1 = {};
				for (let n$2 = 0; n$2 < t$1.length; n$2++) {
					const i$1 = e$1 && e$1[t$1[n$2].id] || _i$1(t$1[n$2]);
					e$1 && (e$1[t$1[n$2].id] = i$1);
					let s$1 = r$1[i$1];
					s$1 || (s$1 = r$1[i$1] = []), s$1.push(t$1[n$2]);
				}
				const n$1 = [];
				for (const t$2 in r$1) n$1.push(r$1[t$2]);
				return n$1;
			}, t.cN = us$1, t.cO = $h, t.cP = Lf, t.cQ = $c$1, t.cR = function(e$1) {
				e$1.bucket.createArrays(), e$1.bucket.tilePixelRatio = M$1 / (512 * e$1.bucket.overscaling), e$1.bucket.compareText = {}, e$1.bucket.iconsNeedLinear = !1;
				const r$1 = e$1.bucket.layers[0], n$1 = r$1.layout, i$1 = r$1._unevaluatedLayout._values, s$1 = {
					layoutIconSize: i$1["icon-size"].possiblyEvaluate(new Fs$1(e$1.bucket.zoom + 1), e$1.canonical),
					layoutTextSize: i$1["text-size"].possiblyEvaluate(new Fs$1(e$1.bucket.zoom + 1), e$1.canonical),
					textMaxSize: i$1["text-size"].possiblyEvaluate(new Fs$1(18))
				};
				if ("composite" === e$1.bucket.textSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.textSizeData;
					s$1.compositeTextSizes = [i$1["text-size"].possiblyEvaluate(new Fs$1(t$1), e$1.canonical), i$1["text-size"].possiblyEvaluate(new Fs$1(r$2), e$1.canonical)];
				}
				if ("composite" === e$1.bucket.iconSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.iconSizeData;
					s$1.compositeIconSizes = [i$1["icon-size"].possiblyEvaluate(new Fs$1(t$1), e$1.canonical), i$1["icon-size"].possiblyEvaluate(new Fs$1(r$2), e$1.canonical)];
				}
				const o = n$1.get("text-line-height") * hc$1, a$1 = "viewport" !== n$1.get("text-rotation-alignment") && "point" !== n$1.get("symbol-placement"), l$1 = n$1.get("text-keep-upright"), u$1 = n$1.get("text-size");
				for (const i$2 of e$1.bucket.features) {
					const c$1 = n$1.get("text-font").evaluate(i$2, {}, e$1.canonical).join(","), h$1 = u$1.evaluate(i$2, {}, e$1.canonical), p$1 = s$1.layoutTextSize.evaluate(i$2, {}, e$1.canonical), f$1 = s$1.layoutIconSize.evaluate(i$2, {}, e$1.canonical), d$1 = {
						horizontal: {},
						vertical: void 0
					}, y$1 = i$2.text;
					let m$1, g$2 = [0, 0];
					if (y$1) {
						const s$2 = y$1.toString(), u$2 = n$1.get("text-letter-spacing").evaluate(i$2, {}, e$1.canonical) * hc$1, f$2 = bs$1(s$2) ? u$2 : 0, m$2 = n$1.get("text-anchor").evaluate(i$2, {}, e$1.canonical), x$2 = fd(r$1, i$2, e$1.canonical);
						if (!x$2) {
							const t$1 = n$1.get("text-radial-offset").evaluate(i$2, {}, e$1.canonical);
							g$2 = t$1 ? pd(m$2, [t$1 * hc$1, hd]) : n$1.get("text-offset").evaluate(i$2, {}, e$1.canonical).map(((t$2) => t$2 * hc$1));
						}
						let v$2 = a$1 ? "center" : n$1.get("text-justify").evaluate(i$2, {}, e$1.canonical);
						const b$1 = "point" === n$1.get("symbol-placement") ? n$1.get("text-max-width").evaluate(i$2, {}, e$1.canonical) * hc$1 : Infinity, w$2 = () => {
							e$1.bucket.allowVerticalPlacement && vs$1(s$2) && (d$1.vertical = qc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, o, m$2, "left", f$2, g$2, t.aA.vertical, !0, p$1, h$1));
						};
						if (!a$1 && x$2) {
							const r$2 = /* @__PURE__ */ new Set();
							if ("auto" === v$2) for (let t$1 = 0; t$1 < x$2.values.length; t$1 += 2) r$2.add(dd(x$2.values[t$1]));
							else r$2.add(v$2);
							let n$2 = !1;
							for (const i$3 of r$2) if (!d$1.horizontal[i$3]) if (n$2) d$1.horizontal[i$3] = d$1.horizontal[0];
							else {
								const r$3 = qc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, o, "center", i$3, f$2, g$2, t.aA.horizontal, !1, p$1, h$1);
								r$3 && (d$1.horizontal[i$3] = r$3, n$2 = 1 === r$3.positionedLines.length);
							}
							w$2();
						} else {
							"auto" === v$2 && (v$2 = dd(m$2));
							const r$2 = qc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, o, m$2, v$2, f$2, g$2, t.aA.horizontal, !1, p$1, h$1);
							r$2 && (d$1.horizontal[v$2] = r$2), w$2(), vs$1(s$2) && a$1 && l$1 && (d$1.vertical = qc$1(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, o, m$2, v$2, f$2, g$2, t.aA.vertical, !1, p$1, h$1));
						}
					}
					let x$1 = !1;
					if (i$2.icon && i$2.icon.name) {
						const t$1 = e$1.imageMap[i$2.icon.name];
						t$1 && (m$1 = Wc(e$1.imagePositions[i$2.icon.name], n$1.get("icon-offset").evaluate(i$2, {}, e$1.canonical), n$1.get("icon-anchor").evaluate(i$2, {}, e$1.canonical)), x$1 = !!t$1.sdf, void 0 === e$1.bucket.sdfIcons ? e$1.bucket.sdfIcons = x$1 : e$1.bucket.sdfIcons !== x$1 && j$1("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t$1.pixelRatio !== e$1.bucket.pixelRatio || 0 !== n$1.get("icon-rotate").constantOr(1)) && (e$1.bucket.iconsNeedLinear = !0));
					}
					const v$1 = gd(d$1.horizontal) || d$1.vertical;
					e$1.bucket.iconsInText = !!v$1 && v$1.iconsInText, (v$1 || m$1) && yd(e$1.bucket, i$2, d$1, m$1, e$1.imageMap, s$1, p$1, f$1, g$2, x$1, e$1.canonical, e$1.subdivisionGranularity);
				}
				e$1.showCollisionBoxes && e$1.bucket.generateCollisionDebugBuffers();
			}, t.cS = xu$1, t.cT = Cu$1, t.cU = Wu$1, t.cV = function(t$1) {
				const e$1 = new Sc$1();
				return function(t$2, e$2) {
					for (const r$1 in t$2.layers) e$2.writeMessage(3, Ff, t$2.layers[r$1]);
				}(t$1, e$1), e$1.finish();
			}, t.cW = function(t$1, e$1, r$1, n$1, i$1, s$1) {
				let o = $f(t$1, e$1, r$1, i$1, 0);
				return o = $f(o, e$1, n$1, s$1, 1), o;
			}, t.cX = class {
				constructor(t$1) {
					this.maxEntries = t$1, this.map = /* @__PURE__ */ new Map();
				}
				get(t$1) {
					const e$1 = this.map.get(t$1);
					return void 0 !== e$1 && (this.map.delete(t$1), this.map.set(t$1, e$1)), e$1;
				}
				set(t$1, e$1) {
					if (this.map.has(t$1)) this.map.delete(t$1);
					else if (this.map.size >= this.maxEntries) {
						const t$2 = this.map.keys().next().value;
						this.map.delete(t$2);
					}
					this.map.set(t$1, e$1);
				}
				clear() {
					this.map.clear();
				}
			}, t.cY = Pu$1, t.cZ = Sc$1, t.c_ = Ef, t.ca = class extends xa$1 {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(t$1);
						this.gl.uniform1fv(this.location, e$1);
					}
				}
			}, t.cb = class extends mo$1 {}, t.cc = uc$1, t.cd = class extends xo$1 {}, t.ce = _l$1, t.cf = function(t$1) {
				return t$1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t$1) / Math.LN2));
			}, t.cg = wl$1, t.ch = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], o = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15];
				return t$1[0] = (r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12]) / (o = o || 1), t$1[1] = (r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13]) / o, t$1[2] = (r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14]) / o, t$1;
			}, t.ci = class extends io$1 {}, t.cj = class extends ko$1 {}, t.ck = function(t$1, e$1) {
				return t$1[0] === e$1[0] && t$1[1] === e$1[1] && t$1[2] === e$1[2] && t$1[3] === e$1[3] && t$1[4] === e$1[4] && t$1[5] === e$1[5] && t$1[6] === e$1[6] && t$1[7] === e$1[7] && t$1[8] === e$1[8] && t$1[9] === e$1[9] && t$1[10] === e$1[10] && t$1[11] === e$1[11] && t$1[12] === e$1[12] && t$1[13] === e$1[13] && t$1[14] === e$1[14] && t$1[15] === e$1[15];
			}, t.cl = function(t$1, e$1) {
				var r$1 = t$1[0], n$1 = t$1[1], i$1 = t$1[2], s$1 = t$1[3], o = t$1[4], a$1 = t$1[5], l$1 = t$1[6], u$1 = t$1[7], c$1 = t$1[8], h$1 = t$1[9], f$1 = t$1[10], d$1 = t$1[11], y$1 = t$1[12], m$1 = t$1[13], g$2 = t$1[14], x$1 = t$1[15], v$1 = e$1[0], b$1 = e$1[1], w$2 = e$1[2], _$2 = e$1[3], A$2 = e$1[4], S$2 = e$1[5], k$2 = e$1[6], E$1 = e$1[7], T$1 = e$1[8], I$2 = e$1[9], M$2 = e$1[10], F$2 = e$1[11], D$2 = e$1[12], P$2 = e$1[13], z$2 = e$1[14], B$2 = e$1[15];
				return Math.abs(r$1 - v$1) <= p * Math.max(1, Math.abs(r$1), Math.abs(v$1)) && Math.abs(n$1 - b$1) <= p * Math.max(1, Math.abs(n$1), Math.abs(b$1)) && Math.abs(i$1 - w$2) <= p * Math.max(1, Math.abs(i$1), Math.abs(w$2)) && Math.abs(s$1 - _$2) <= p * Math.max(1, Math.abs(s$1), Math.abs(_$2)) && Math.abs(o - A$2) <= p * Math.max(1, Math.abs(o), Math.abs(A$2)) && Math.abs(a$1 - S$2) <= p * Math.max(1, Math.abs(a$1), Math.abs(S$2)) && Math.abs(l$1 - k$2) <= p * Math.max(1, Math.abs(l$1), Math.abs(k$2)) && Math.abs(u$1 - E$1) <= p * Math.max(1, Math.abs(u$1), Math.abs(E$1)) && Math.abs(c$1 - T$1) <= p * Math.max(1, Math.abs(c$1), Math.abs(T$1)) && Math.abs(h$1 - I$2) <= p * Math.max(1, Math.abs(h$1), Math.abs(I$2)) && Math.abs(f$1 - M$2) <= p * Math.max(1, Math.abs(f$1), Math.abs(M$2)) && Math.abs(d$1 - F$2) <= p * Math.max(1, Math.abs(d$1), Math.abs(F$2)) && Math.abs(y$1 - D$2) <= p * Math.max(1, Math.abs(y$1), Math.abs(D$2)) && Math.abs(m$1 - P$2) <= p * Math.max(1, Math.abs(m$1), Math.abs(P$2)) && Math.abs(g$2 - z$2) <= p * Math.max(1, Math.abs(g$2), Math.abs(z$2)) && Math.abs(x$1 - B$2) <= p * Math.max(1, Math.abs(x$1), Math.abs(B$2));
			}, t.cm = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.cn = (t$1) => "symbol" === t$1.type, t.co = (t$1) => "circle" === t$1.type, t.cp = (t$1) => "heatmap" === t$1.type, t.cq = (t$1) => "line" === t$1.type, t.cr = (t$1) => "fill" === t$1.type, t.cs = (t$1) => "fill-extrusion" === t$1.type, t.ct = (t$1) => "hillshade" === t$1.type, t.cu = (t$1) => "color-relief" === t$1.type, t.cv = (t$1) => "background" === t$1.type, t.cw = (t$1) => "custom" === t$1.type, t.cx = B$1, t.cy = function(t$1, e$1, r$1) {
				const n$1 = I$1(e$1.x - r$1.x, e$1.y - r$1.y), i$1 = I$1(t$1.x - r$1.x, t$1.y - r$1.y);
				return et$1(Math.atan2(n$1[0] * i$1[1] - n$1[1] * i$1[0], function(t$2, e$2) {
					return t$2[0] * e$2[0] + t$2[1] * e$2[1];
				}(n$1, i$1)));
			}, t.cz = V$1, t.d = ft, t.d0 = function(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if (h()) try {
						return yield K$1(t$1, r$1, n$1, i$1, s$1);
					} catch (t$2) {}
					return function(t$2, e$1, r$2, n$2, i$2) {
						const s$2 = t$2.width, o = t$2.height;
						W$1 && J$1 || (W$1 = new OffscreenCanvas(s$2, o), J$1 = W$1.getContext("2d", { willReadFrequently: !0 })), W$1.width = s$2, W$1.height = o, J$1.drawImage(t$2, 0, 0, s$2, o);
						const a$1 = J$1.getImageData(e$1, r$2, n$2, i$2);
						return J$1.clearRect(0, 0, s$2, o), a$1.data;
					}(t$1, r$1, n$1, i$1, s$1);
				}));
			}, t.d1 = Fl$1, t.d2 = n, t.d3 = class {
				constructor(t$1, e$1) {
					this.layers = { [Mf]: this }, this.name = Mf, this.version = e$1 ? e$1.version : 1, this.extent = e$1 ? e$1.extent : 4096, this.length = t$1.length, this.features = t$1;
				}
				feature(t$1) {
					return new If(this.features[t$1], this.extent);
				}
			}, t.d4 = ni$1, t.d5 = Ms$1, t.e = O$1, t.f = (t$1) => e(void 0, void 0, void 0, (function* () {
				if (0 === t$1.byteLength) return createImageBitmap(new ImageData(1, 1));
				const e$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				try {
					return createImageBitmap(e$1);
				} catch (t$2) {
					throw new Error(`Could not load image because of ${t$2.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
				}
			})), t.g = lt$1, t.h = (t$1) => new Promise(((e$1, r$1) => {
				const n$1 = new Image();
				n$1.onload = () => {
					e$1(n$1), URL.revokeObjectURL(n$1.src), n$1.onload = null, window.requestAnimationFrame((() => {
						n$1.src = H$1;
					}));
				}, n$1.onerror = () => r$1(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
				const i$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				n$1.src = t$1.byteLength ? URL.createObjectURL(i$1) : H$1;
			})), t.i = X, t.j = (t$1, e$1) => pt$1(O$1(t$1, { type: "json" }), e$1), t.k = gt$1, t.l = mt$1, t.m = pt$1, t.n = (t$1, e$1) => pt$1(O$1(t$1, { type: "arrayBuffer" }), e$1), t.o = function(t$1) {
				return new Sc$1(t$1).readFields(Cc$1, []);
			}, t.p = Rc$1, t.q = function(t$1) {
				return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t$1));
			}, t.r = vl$1, t.s = Q$1, t.t = Xs$1, t.u = vt$1, t.v = ts$1, t.w = j$1, t.x = Vs$1, t.y = rs$1, t.z = Ps$1;
		}));
		define$1("worker", ["./shared"], (function(e) {
			class t {
				constructor(e$1, t$1) {
					this.keyCache = {}, e$1 && this.replace(e$1, t$1);
				}
				replace(e$1, t$1) {
					this._layerConfigs = {}, this._layers = {}, this.update(e$1, [], t$1);
				}
				update(t$1, o$1, i$1) {
					for (const o$2 of t$1) {
						this._layerConfigs[o$2.id] = o$2;
						const t$2 = this._layers[o$2.id] = e.bU(o$2, i$1);
						t$2._featureFilter = e.ak(t$2.filter, i$1), this.keyCache[o$2.id] && delete this.keyCache[o$2.id];
					}
					for (const e$1 of o$1) delete this.keyCache[e$1], delete this._layerConfigs[e$1], delete this._layers[e$1];
					this.familiesBySource = {};
					const s$1 = e.cM(Object.values(this._layerConfigs), this.keyCache);
					for (const t$2 of s$1) {
						const o$2 = t$2.map(((e$1) => this._layers[e$1.id])), i$2 = o$2[0];
						if ("none" === i$2.visibility) continue;
						const s$2 = i$2.source || "";
						let n$1 = this.familiesBySource[s$2];
						n$1 || (n$1 = this.familiesBySource[s$2] = {});
						const r$1 = i$2.sourceLayer || e.aa;
						let a$1 = n$1[r$1];
						a$1 || (a$1 = n$1[r$1] = []), a$1.push(o$2);
					}
				}
			}
			class o {
				constructor(t$1) {
					const o$1 = {}, i$1 = [];
					for (const e$1 in t$1) {
						const s$2 = t$1[e$1], n$2 = o$1[e$1] = {};
						for (const e$2 in s$2) {
							const t$2 = s$2[+e$2];
							if (!t$2 || 0 === t$2.bitmap.width || 0 === t$2.bitmap.height) continue;
							const o$2 = {
								x: 0,
								y: 0,
								w: t$2.bitmap.width + 2,
								h: t$2.bitmap.height + 2
							};
							i$1.push(o$2), n$2[e$2] = {
								rect: o$2,
								metrics: t$2.metrics
							};
						}
					}
					const { w: s$1, h: n$1 } = e.p(i$1), r$1 = new e.r({
						width: s$1 || 1,
						height: n$1 || 1
					});
					for (const i$2 in t$1) {
						const s$2 = t$1[i$2];
						for (const t$2 in s$2) {
							const n$2 = s$2[+t$2];
							if (!n$2 || 0 === n$2.bitmap.width || 0 === n$2.bitmap.height) continue;
							const a$1 = o$1[i$2][t$2].rect;
							e.r.copy(n$2.bitmap, r$1, {
								x: 0,
								y: 0
							}, {
								x: a$1.x + 1,
								y: a$1.y + 1
							}, n$2.bitmap);
						}
					}
					this.image = r$1, this.positions = o$1;
				}
			}
			e.cN("GlyphAtlas", o);
			class i {
				constructor(t$1) {
					this.tileID = new e.a2(t$1.tileID.overscaledZ, t$1.tileID.wrap, t$1.tileID.canonical.z, t$1.tileID.canonical.x, t$1.tileID.canonical.y), this.uid = t$1.uid, this.zoom = t$1.zoom, this.pixelRatio = t$1.pixelRatio, this.tileSize = t$1.tileSize, this.source = t$1.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t$1.showCollisionBoxes, this.collectResourceTiming = !!t$1.collectResourceTiming, this.returnDependencies = !!t$1.returnDependencies, this.promoteId = t$1.promoteId, this.inFlightDependencies = [];
				}
				parse(t$1, i$1, n$1, r$1, a$1) {
					return e._(this, void 0, void 0, (function* () {
						this.status = "parsing", this.data = t$1, this.collisionBoxArray = new e.ai();
						const l$1 = new e.cO(Object.keys(t$1.layers).sort()), c$1 = new e.cP(this.tileID, this.promoteId);
						c$1.bucketLayerIDs = [];
						const h$1 = {}, u$1 = {
							featureIndex: c$1,
							iconDependencies: {},
							patternDependencies: {},
							glyphDependencies: {},
							dashDependencies: {},
							availableImages: n$1,
							subdivisionGranularity: a$1
						}, d$1 = i$1.familiesBySource[this.source];
						for (const o$1 in d$1) {
							const i$2 = t$1.layers[o$1];
							if (!i$2) continue;
							1 === i$2.version && e.w(`Vector tile source "${this.source}" layer "${o$1}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
							const r$2 = l$1.encode(o$1), a$2 = [];
							for (let e$1 = 0; e$1 < i$2.length; e$1++) {
								const t$2 = i$2.feature(e$1), s$1 = c$1.getId(t$2, o$1);
								a$2.push({
									feature: t$2,
									id: s$1,
									index: e$1,
									sourceLayerIndex: r$2
								});
							}
							for (const t$2 of d$1[o$1]) {
								const o$2 = t$2[0];
								o$2.source !== this.source && e.w(`layer.source = ${o$2.source} does not equal this.source = ${this.source}`), o$2.isHidden(this.zoom, !0) || (s(t$2, this.zoom, n$1), (h$1[o$2.id] = o$2.createBucket({
									index: c$1.bucketLayerIDs.length,
									layers: t$2,
									zoom: this.zoom,
									pixelRatio: this.pixelRatio,
									overscaling: this.overscaling,
									collisionBoxArray: this.collisionBoxArray,
									sourceLayerIndex: r$2,
									sourceID: this.source
								})).populate(a$2, u$1, this.tileID.canonical), c$1.bucketLayerIDs.push(t$2.map(((e$1) => e$1.id))));
							}
						}
						const g$2 = e.bZ(u$1.glyphDependencies, ((e$1) => Object.keys(e$1).map(Number)));
						this.inFlightDependencies.forEach(((e$1) => null == e$1 ? void 0 : e$1.abort())), this.inFlightDependencies = [];
						let f$1 = Promise.resolve({});
						if (Object.keys(g$2).length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), f$1 = r$1.sendAsync({
								type: "GG",
								data: {
									stacks: g$2,
									source: this.source,
									tileID: this.tileID,
									type: "glyphs"
								}
							}, e$1);
						}
						const p$1 = Object.keys(u$1.iconDependencies);
						let m$1 = Promise.resolve({});
						if (p$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), m$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: p$1,
									source: this.source,
									tileID: this.tileID,
									type: "icons"
								}
							}, e$1);
						}
						const y$1 = Object.keys(u$1.patternDependencies);
						let v$1 = Promise.resolve({});
						if (y$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), v$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: y$1,
									source: this.source,
									tileID: this.tileID,
									type: "patterns"
								}
							}, e$1);
						}
						const x$1 = u$1.dashDependencies;
						let _$2 = Promise.resolve({});
						if (Object.keys(x$1).length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), _$2 = r$1.sendAsync({
								type: "GDA",
								data: { dashes: x$1 }
							}, e$1);
						}
						const [w$2, S$2, b$1, M$2] = yield Promise.all([
							f$1,
							m$1,
							v$1,
							_$2
						]), I$2 = new o(w$2), P$2 = new e.cQ(S$2, b$1);
						for (const t$2 in h$1) {
							const o$1 = h$1[t$2];
							o$1 instanceof e.aj ? (s(o$1.layers, this.zoom, n$1), e.cR({
								bucket: o$1,
								glyphMap: w$2,
								glyphPositions: I$2.positions,
								imageMap: S$2,
								imagePositions: P$2.iconPositions,
								showCollisionBoxes: this.showCollisionBoxes,
								canonical: this.tileID.canonical,
								subdivisionGranularity: u$1.subdivisionGranularity
							})) : o$1.hasDependencies && (o$1 instanceof e.cS || o$1 instanceof e.cT || o$1 instanceof e.cU) && (s(o$1.layers, this.zoom, n$1), o$1.addFeatures(u$1, this.tileID.canonical, P$2.patternPositions, M$2));
						}
						return this.status = "done", {
							buckets: Object.values(h$1).filter(((e$1) => !e$1.isEmpty())),
							featureIndex: c$1,
							collisionBoxArray: this.collisionBoxArray,
							glyphAtlasImage: I$2.image,
							imageAtlas: P$2,
							dashPositions: M$2,
							glyphMap: this.returnDependencies ? w$2 : null,
							iconMap: this.returnDependencies ? S$2 : null,
							glyphPositions: this.returnDependencies ? I$2.positions : null
						};
					}));
				}
			}
			function s(t$1, o$1, i$1) {
				const s$1 = new e.H(o$1);
				for (const e$1 of t$1) e$1.recalculate(s$1, i$1);
			}
			class n {
				constructor(e$1, t$1, o$1, i$1, s$1) {
					this.type = e$1, this.properties = o$1 || {}, this.extent = s$1, this.pointsArray = t$1, this.id = i$1;
				}
				loadGeometry() {
					return this.pointsArray.map(((t$1) => t$1.map(((t$2) => new e.P(t$2.x, t$2.y)))));
				}
			}
			class r {
				constructor(e$1, t$1, o$1) {
					this.version = 2, this._myFeatures = e$1, this.name = t$1, this.length = e$1.length, this.extent = o$1;
				}
				feature(e$1) {
					return this._myFeatures[e$1];
				}
			}
			class a {
				constructor() {
					this.layers = {};
				}
				addLayer(e$1) {
					this.layers[e$1.name] = e$1;
				}
			}
			function l(t$1) {
				let o$1 = e.cV(t$1);
				return 0 === o$1.byteOffset && o$1.byteLength === o$1.buffer.byteLength || (o$1 = new Uint8Array(o$1)), {
					vectorTile: t$1,
					rawData: o$1.buffer
				};
			}
			function c(t$1, o$1, i$1) {
				const { extent: s$1 } = t$1, a$1 = Math.pow(2, i$1.z - o$1.z), l$1 = (i$1.x - o$1.x * a$1) * s$1, c$1 = (i$1.y - o$1.y * a$1) * s$1, h$1 = [];
				for (let o$2 = 0; o$2 < t$1.length; o$2++) {
					const i$2 = t$1.feature(o$2);
					let r$1 = i$2.loadGeometry();
					for (const e$1 of r$1) for (const t$2 of e$1) t$2.x = t$2.x * a$1 - l$1, t$2.y = t$2.y * a$1 - c$1;
					const u$1 = 128;
					r$1 = e.cW(r$1, i$2.type, -u$1, -u$1, s$1 + u$1, s$1 + u$1), 0 !== r$1.length && h$1.push(new n(i$2.type, r$1, i$2.properties, i$2.id, s$1));
				}
				return new r(h$1, t$1.name, s$1);
			}
			class h {
				constructor(t$1, o$1, i$1) {
					this.actor = t$1, this.layerIndex = o$1, this.availableImages = i$1, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new e.cX(1e3);
				}
				loadVectorTile(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$1 = yield e.n(t$1.request, o$1);
						try {
							return {
								vectorTile: "mlt" !== t$1.encoding ? new e.cY(new e.cZ(i$1.data)) : new e.c_(i$1.data),
								rawData: i$1.data,
								cacheControl: i$1.cacheControl,
								expires: i$1.expires
							};
						} catch (e$1) {
							const o$2 = new Uint8Array(i$1.data);
							let s$1 = `Unable to parse the tile at ${t$1.request.url}, `;
							throw s$1 += 31 === o$2[0] && 139 === o$2[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e$1.message}`, new Error(s$1);
						}
					}));
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const { uid: o$1, overzoomParameters: s$1 } = t$1;
						s$1 && (t$1.request = s$1.overzoomRequest);
						const n$1 = !!(t$1 && t$1.request && t$1.request.collectResourceTiming) && new e.c$(t$1.request), r$1 = new i(t$1);
						this.loading[o$1] = r$1;
						const a$1 = new AbortController();
						r$1.abort = a$1;
						try {
							const i$1 = yield this.loadVectorTile(t$1, a$1);
							if (delete this.loading[o$1], !i$1) return null;
							if (s$1) {
								const e$1 = this._getOverzoomTile(t$1, i$1.vectorTile);
								i$1.rawData = e$1.rawData, i$1.vectorTile = e$1.vectorTile;
							}
							const l$1 = i$1.rawData, c$1 = {};
							i$1.expires && (c$1.expires = i$1.expires), i$1.cacheControl && (c$1.cacheControl = i$1.cacheControl);
							const h$1 = {};
							if (n$1) {
								const e$1 = n$1.finish();
								e$1 && (h$1.resourceTiming = JSON.parse(JSON.stringify(e$1)));
							}
							r$1.vectorTile = i$1.vectorTile;
							const u$1 = r$1.parse(i$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							this.loaded[o$1] = r$1, this.fetching[o$1] = {
								rawTileData: l$1,
								cacheControl: c$1,
								resourceTiming: h$1
							};
							try {
								const o$2 = yield u$1;
								return e.e({
									rawTileData: l$1.slice(0),
									encoding: t$1.encoding
								}, o$2, c$1, h$1);
							} finally {
								delete this.fetching[o$1];
							}
						} catch (e$1) {
							throw delete this.loading[o$1], r$1.status = "done", this.loaded[o$1] = r$1, e$1;
						}
					}));
				}
				_getOverzoomTile(e$1, t$1) {
					const { tileID: o$1, source: i$1, overzoomParameters: s$1 } = e$1, { maxZoomTileID: n$1 } = s$1, r$1 = `${n$1.key}_${o$1.key}`, h$1 = this.overzoomedTileResultCache.get(r$1);
					if (h$1) return h$1;
					const u$1 = new a(), d$1 = this.layerIndex.familiesBySource[i$1];
					for (const e$2 in d$1) {
						const i$2 = t$1.layers[e$2];
						if (!i$2) continue;
						const s$2 = c(i$2, n$1, o$1.canonical);
						s$2.length > 0 && u$1.addLayer(s$2);
					}
					const g$2 = l(u$1);
					return this.overzoomedTileResultCache.set(r$1, g$2), g$2;
				}
				reloadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const o$1 = t$1.uid;
						if (!this.loaded || !this.loaded[o$1]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
						const i$1 = this.loaded[o$1];
						if (i$1.showCollisionBoxes = t$1.showCollisionBoxes, "parsing" === i$1.status) {
							const s$1 = yield i$1.parse(i$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							let n$1;
							if (this.fetching[o$1]) {
								const { rawTileData: i$2, cacheControl: r$1, resourceTiming: a$1 } = this.fetching[o$1];
								delete this.fetching[o$1], n$1 = e.e({
									rawTileData: i$2.slice(0),
									encoding: t$1.encoding
								}, s$1, r$1, a$1);
							} else n$1 = s$1;
							return n$1;
						}
						if ("done" === i$1.status && i$1.vectorTile) return i$1.parse(i$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
					}));
				}
				abortTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const e$1 = this.loading, o$1 = t$1.uid;
						e$1 && e$1[o$1] && e$1[o$1].abort && (e$1[o$1].abort.abort(), delete e$1[o$1]);
					}));
				}
				removeTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this.loaded && this.loaded[t$1.uid] && delete this.loaded[t$1.uid];
					}));
				}
			}
			class u {
				constructor() {
					this.loaded = {};
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const { uid: o$1, encoding: i$1, rawImageData: s$1, redFactor: n$1, greenFactor: r$1, blueFactor: a$1, baseShift: l$1 } = t$1, c$1 = s$1.width + 2, h$1 = s$1.height + 2, u$1 = e.b(s$1) ? new e.R({
							width: c$1,
							height: h$1
						}, yield e.d0(s$1, -1, -1, c$1, h$1)) : s$1, d$1 = new e.d1(o$1, u$1, i$1, n$1, r$1, a$1, l$1);
						return this.loaded = this.loaded || {}, this.loaded[o$1] = d$1, d$1;
					}));
				}
				removeTile(e$1) {
					const t$1 = this.loaded, o$1 = e$1.uid;
					t$1 && t$1[o$1] && delete t$1[o$1];
				}
			}
			var d, g$1, f = function() {
				if (g$1) return d;
				function e$1(e$2, o$1) {
					if (0 !== e$2.length) {
						t$1(e$2[0], o$1);
						for (var i$1 = 1; i$1 < e$2.length; i$1++) t$1(e$2[i$1], !o$1);
					}
				}
				function t$1(e$2, t$2) {
					for (var o$1 = 0, i$1 = 0, s$1 = 0, n$1 = e$2.length, r$1 = n$1 - 1; s$1 < n$1; r$1 = s$1++) {
						var a$1 = (e$2[s$1][0] - e$2[r$1][0]) * (e$2[r$1][1] + e$2[s$1][1]), l$1 = o$1 + a$1;
						i$1 += Math.abs(o$1) >= Math.abs(a$1) ? o$1 - l$1 + a$1 : a$1 - l$1 + o$1, o$1 = l$1;
					}
					o$1 + i$1 >= 0 != !!t$2 && e$2.reverse();
				}
				return g$1 = 1, d = function t$2(o$1, i$1) {
					var s$1, n$1 = o$1 && o$1.type;
					if ("FeatureCollection" === n$1) for (s$1 = 0; s$1 < o$1.features.length; s$1++) t$2(o$1.features[s$1], i$1);
					else if ("GeometryCollection" === n$1) for (s$1 = 0; s$1 < o$1.geometries.length; s$1++) t$2(o$1.geometries[s$1], i$1);
					else if ("Feature" === n$1) t$2(o$1.geometry, i$1);
					else if ("Polygon" === n$1) e$1(o$1.coordinates, i$1);
					else if ("MultiPolygon" === n$1) for (s$1 = 0; s$1 < o$1.coordinates.length; s$1++) e$1(o$1.coordinates[s$1], i$1);
					return o$1;
				};
			}(), p = e.d2(f);
			const m = {
				minZoom: 0,
				maxZoom: 16,
				minPoints: 2,
				radius: 40,
				extent: 512,
				nodeSize: 64,
				log: !1,
				generateId: !1,
				reduce: null,
				map: (e$1) => e$1
			}, y = Math.fround || (v = new Float32Array(1), (e$1) => (v[0] = +e$1, v[0]));
			var v;
			class x {
				constructor(e$1) {
					this.options = Object.assign(Object.create(m), e$1), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
				}
				load(e$1) {
					const { log: t$1, minZoom: o$1, maxZoom: i$1 } = this.options;
					t$1 && console.time("total time");
					const s$1 = `prepare ${e$1.length} points`;
					t$1 && console.time(s$1), this.points = e$1;
					const n$1 = [];
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const o$2 = e$1[t$2];
						if (!o$2.geometry) continue;
						const [i$2, s$2] = o$2.geometry.coordinates, r$2 = y(S$1(i$2)), a$1 = y(b(s$2));
						n$1.push(r$2, a$1, Infinity, t$2, -1, 1), this.options.reduce && n$1.push(0);
					}
					let r$1 = this.trees[i$1 + 1] = this._createTree(n$1);
					t$1 && console.timeEnd(s$1);
					for (let e$2 = i$1; e$2 >= o$1; e$2--) {
						const o$2 = +Date.now();
						r$1 = this.trees[e$2] = this._createTree(this._cluster(r$1, e$2)), t$1 && console.log("z%d: %d clusters in %dms", e$2, r$1.numItems, +Date.now() - o$2);
					}
					return t$1 && console.timeEnd("total time"), this;
				}
				getClusters(e$1, t$1) {
					let o$1 = ((e$1[0] + 180) % 360 + 360) % 360 - 180;
					const i$1 = Math.max(-90, Math.min(90, e$1[1]));
					let s$1 = 180 === e$1[2] ? 180 : ((e$1[2] + 180) % 360 + 360) % 360 - 180;
					const n$1 = Math.max(-90, Math.min(90, e$1[3]));
					if (e$1[2] - e$1[0] >= 360) o$1 = -180, s$1 = 180;
					else if (o$1 > s$1) {
						const e$2 = this.getClusters([
							o$1,
							i$1,
							180,
							n$1
						], t$1), r$2 = this.getClusters([
							-180,
							i$1,
							s$1,
							n$1
						], t$1);
						return e$2.concat(r$2);
					}
					const r$1 = this.trees[this._limitZoom(t$1)], a$1 = r$1.range(S$1(o$1), b(n$1), S$1(s$1), b(i$1)), l$1 = r$1.data, c$1 = [];
					for (const e$2 of a$1) {
						const t$2 = this.stride * e$2;
						c$1.push(l$1[t$2 + 5] > 1 ? _$1(l$1, t$2, this.clusterProps) : this.points[l$1[t$2 + 3]]);
					}
					return c$1;
				}
				getChildren(e$1) {
					const t$1 = this._getOriginId(e$1), o$1 = this._getOriginZoom(e$1), i$1 = "No cluster with the specified id.", s$1 = this.trees[o$1];
					if (!s$1) throw new Error(i$1);
					const n$1 = s$1.data;
					if (t$1 * this.stride >= n$1.length) throw new Error(i$1);
					const r$1 = this.options.radius / (this.options.extent * Math.pow(2, o$1 - 1)), a$1 = s$1.within(n$1[t$1 * this.stride], n$1[t$1 * this.stride + 1], r$1), l$1 = [];
					for (const t$2 of a$1) {
						const o$2 = t$2 * this.stride;
						n$1[o$2 + 4] === e$1 && l$1.push(n$1[o$2 + 5] > 1 ? _$1(n$1, o$2, this.clusterProps) : this.points[n$1[o$2 + 3]]);
					}
					if (0 === l$1.length) throw new Error(i$1);
					return l$1;
				}
				getLeaves(e$1, t$1, o$1) {
					const i$1 = [];
					return this._appendLeaves(i$1, e$1, t$1 = t$1 || 10, o$1 = o$1 || 0, 0), i$1;
				}
				getTile(e$1, t$1, o$1) {
					const i$1 = this.trees[this._limitZoom(e$1)], s$1 = Math.pow(2, e$1), { extent: n$1, radius: r$1 } = this.options, a$1 = r$1 / n$1, l$1 = (o$1 - a$1) / s$1, c$1 = (o$1 + 1 + a$1) / s$1, h$1 = { features: [] };
					return this._addTileFeatures(i$1.range((t$1 - a$1) / s$1, l$1, (t$1 + 1 + a$1) / s$1, c$1), i$1.data, t$1, o$1, s$1, h$1), 0 === t$1 && this._addTileFeatures(i$1.range(1 - a$1 / s$1, l$1, 1, c$1), i$1.data, s$1, o$1, s$1, h$1), t$1 === s$1 - 1 && this._addTileFeatures(i$1.range(0, l$1, a$1 / s$1, c$1), i$1.data, -1, o$1, s$1, h$1), h$1.features.length ? h$1 : null;
				}
				getClusterExpansionZoom(e$1) {
					let t$1 = this._getOriginZoom(e$1) - 1;
					for (; t$1 <= this.options.maxZoom;) {
						const o$1 = this.getChildren(e$1);
						if (t$1++, 1 !== o$1.length) break;
						e$1 = o$1[0].properties.cluster_id;
					}
					return t$1;
				}
				_appendLeaves(e$1, t$1, o$1, i$1, s$1) {
					const n$1 = this.getChildren(t$1);
					for (const t$2 of n$1) {
						const n$2 = t$2.properties;
						if (n$2 && n$2.cluster ? s$1 + n$2.point_count <= i$1 ? s$1 += n$2.point_count : s$1 = this._appendLeaves(e$1, n$2.cluster_id, o$1, i$1, s$1) : s$1 < i$1 ? s$1++ : e$1.push(t$2), e$1.length === o$1) break;
					}
					return s$1;
				}
				_createTree(t$1) {
					const o$1 = new e.aU(t$1.length / this.stride | 0, this.options.nodeSize, Float32Array);
					for (let e$1 = 0; e$1 < t$1.length; e$1 += this.stride) o$1.add(t$1[e$1], t$1[e$1 + 1]);
					return o$1.finish(), o$1.data = t$1, o$1;
				}
				_addTileFeatures(e$1, t$1, o$1, i$1, s$1, n$1) {
					for (const r$1 of e$1) {
						const e$2 = r$1 * this.stride, a$1 = t$1[e$2 + 5] > 1;
						let l$1, c$1, h$1;
						if (a$1) l$1 = w$1(t$1, e$2, this.clusterProps), c$1 = t$1[e$2], h$1 = t$1[e$2 + 1];
						else {
							const o$2 = this.points[t$1[e$2 + 3]];
							l$1 = o$2.properties;
							const [i$2, s$2] = o$2.geometry.coordinates;
							c$1 = S$1(i$2), h$1 = b(s$2);
						}
						const u$1 = {
							type: 1,
							geometry: [[Math.round(this.options.extent * (c$1 * s$1 - o$1)), Math.round(this.options.extent * (h$1 * s$1 - i$1))]],
							tags: l$1
						};
						let d$1;
						d$1 = a$1 || this.options.generateId ? t$1[e$2 + 3] : this.points[t$1[e$2 + 3]].id, void 0 !== d$1 && (u$1.id = d$1), n$1.features.push(u$1);
					}
				}
				_limitZoom(e$1) {
					return Math.max(this.options.minZoom, Math.min(Math.floor(+e$1), this.options.maxZoom + 1));
				}
				_cluster(e$1, t$1) {
					const { radius: o$1, extent: i$1, reduce: s$1, minPoints: n$1 } = this.options, r$1 = o$1 / (i$1 * Math.pow(2, t$1)), a$1 = e$1.data, l$1 = [], c$1 = this.stride;
					for (let o$2 = 0; o$2 < a$1.length; o$2 += c$1) {
						if (a$1[o$2 + 2] <= t$1) continue;
						a$1[o$2 + 2] = t$1;
						const i$2 = a$1[o$2], h$1 = a$1[o$2 + 1], u$1 = e$1.within(a$1[o$2], a$1[o$2 + 1], r$1), d$1 = a$1[o$2 + 5];
						let g$2 = d$1;
						for (const e$2 of u$1) {
							const o$3 = e$2 * c$1;
							a$1[o$3 + 2] > t$1 && (g$2 += a$1[o$3 + 5]);
						}
						if (g$2 > d$1 && g$2 >= n$1) {
							let e$2, n$2 = i$2 * d$1, r$2 = h$1 * d$1, f$1 = -1;
							const p$1 = (o$2 / c$1 << 5) + (t$1 + 1) + this.points.length;
							for (const i$3 of u$1) {
								const l$2 = i$3 * c$1;
								if (a$1[l$2 + 2] <= t$1) continue;
								a$1[l$2 + 2] = t$1;
								const h$2 = a$1[l$2 + 5];
								n$2 += a$1[l$2] * h$2, r$2 += a$1[l$2 + 1] * h$2, a$1[l$2 + 4] = p$1, s$1 && (e$2 || (e$2 = this._map(a$1, o$2, !0), f$1 = this.clusterProps.length, this.clusterProps.push(e$2)), s$1(e$2, this._map(a$1, l$2)));
							}
							a$1[o$2 + 4] = p$1, l$1.push(n$2 / g$2, r$2 / g$2, Infinity, p$1, -1, g$2), s$1 && l$1.push(f$1);
						} else {
							for (let e$2 = 0; e$2 < c$1; e$2++) l$1.push(a$1[o$2 + e$2]);
							if (g$2 > 1) for (const e$2 of u$1) {
								const o$3 = e$2 * c$1;
								if (!(a$1[o$3 + 2] <= t$1)) {
									a$1[o$3 + 2] = t$1;
									for (let e$3 = 0; e$3 < c$1; e$3++) l$1.push(a$1[o$3 + e$3]);
								}
							}
						}
					}
					return l$1;
				}
				_getOriginId(e$1) {
					return e$1 - this.points.length >> 5;
				}
				_getOriginZoom(e$1) {
					return (e$1 - this.points.length) % 32;
				}
				_map(e$1, t$1, o$1) {
					if (e$1[t$1 + 5] > 1) {
						const i$2 = this.clusterProps[e$1[t$1 + 6]];
						return o$1 ? Object.assign({}, i$2) : i$2;
					}
					const i$1 = this.points[e$1[t$1 + 3]].properties, s$1 = this.options.map(i$1);
					return o$1 && s$1 === i$1 ? Object.assign({}, s$1) : s$1;
				}
			}
			function _$1(e$1, t$1, o$1) {
				return {
					type: "Feature",
					id: e$1[t$1 + 3],
					properties: w$1(e$1, t$1, o$1),
					geometry: {
						type: "Point",
						coordinates: [(i$1 = e$1[t$1], 360 * (i$1 - .5)), M$1(e$1[t$1 + 1])]
					}
				};
				var i$1;
			}
			function w$1(e$1, t$1, o$1) {
				const i$1 = e$1[t$1 + 5], s$1 = i$1 >= 1e4 ? `${Math.round(i$1 / 1e3)}k` : i$1 >= 1e3 ? Math.round(i$1 / 100) / 10 + "k" : i$1, n$1 = e$1[t$1 + 6], r$1 = -1 === n$1 ? {} : Object.assign({}, o$1[n$1]);
				return Object.assign(r$1, {
					cluster: !0,
					cluster_id: e$1[t$1 + 3],
					point_count: i$1,
					point_count_abbreviated: s$1
				});
			}
			function S$1(e$1) {
				return e$1 / 360 + .5;
			}
			function b(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), o$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return o$1 < 0 ? 0 : o$1 > 1 ? 1 : o$1;
			}
			function M$1(e$1) {
				const t$1 = (180 - 360 * e$1) * Math.PI / 180;
				return 360 * Math.atan(Math.exp(t$1)) / Math.PI - 90;
			}
			function I$1(e$1, t$1, o$1, i$1) {
				let s$1 = i$1;
				const n$1 = t$1 + (o$1 - t$1 >> 1);
				let r$1, a$1 = o$1 - t$1;
				const l$1 = e$1[t$1], c$1 = e$1[t$1 + 1], h$1 = e$1[o$1], u$1 = e$1[o$1 + 1];
				for (let i$2 = t$1 + 3; i$2 < o$1; i$2 += 3) {
					const t$2 = P$1(e$1[i$2], e$1[i$2 + 1], l$1, c$1, h$1, u$1);
					if (t$2 > s$1) r$1 = i$2, s$1 = t$2;
					else if (t$2 === s$1) {
						const e$2 = Math.abs(i$2 - n$1);
						e$2 < a$1 && (r$1 = i$2, a$1 = e$2);
					}
				}
				s$1 > i$1 && (r$1 - t$1 > 3 && I$1(e$1, t$1, r$1, i$1), e$1[r$1 + 2] = s$1, o$1 - r$1 > 3 && I$1(e$1, r$1, o$1, i$1));
			}
			function P$1(e$1, t$1, o$1, i$1, s$1, n$1) {
				let r$1 = s$1 - o$1, a$1 = n$1 - i$1;
				if (0 !== r$1 || 0 !== a$1) {
					const l$1 = ((e$1 - o$1) * r$1 + (t$1 - i$1) * a$1) / (r$1 * r$1 + a$1 * a$1);
					l$1 > 1 ? (o$1 = s$1, i$1 = n$1) : l$1 > 0 && (o$1 += r$1 * l$1, i$1 += a$1 * l$1);
				}
				return r$1 = e$1 - o$1, a$1 = t$1 - i$1, r$1 * r$1 + a$1 * a$1;
			}
			function D$1(e$1, t$1, o$1, i$1) {
				const s$1 = {
					id: null == e$1 ? null : e$1,
					type: t$1,
					geometry: o$1,
					tags: i$1,
					minX: Infinity,
					minY: Infinity,
					maxX: -Infinity,
					maxY: -Infinity
				};
				if ("Point" === t$1 || "MultiPoint" === t$1 || "LineString" === t$1) k$1(s$1, o$1);
				else if ("Polygon" === t$1) k$1(s$1, o$1[0]);
				else if ("MultiLineString" === t$1) for (const e$2 of o$1) k$1(s$1, e$2);
				else if ("MultiPolygon" === t$1) for (const e$2 of o$1) k$1(s$1, e$2[0]);
				return s$1;
			}
			function k$1(e$1, t$1) {
				for (let o$1 = 0; o$1 < t$1.length; o$1 += 3) e$1.minX = Math.min(e$1.minX, t$1[o$1]), e$1.minY = Math.min(e$1.minY, t$1[o$1 + 1]), e$1.maxX = Math.max(e$1.maxX, t$1[o$1]), e$1.maxY = Math.max(e$1.maxY, t$1[o$1 + 1]);
			}
			function T(e$1, t$1, o$1, i$1) {
				if (!t$1.geometry) return;
				const s$1 = t$1.geometry.coordinates;
				if (s$1 && 0 === s$1.length) return;
				const n$1 = t$1.geometry.type, r$1 = Math.pow(o$1.tolerance / ((1 << o$1.maxZoom) * o$1.extent), 2);
				let a$1 = [], l$1 = t$1.id;
				if (o$1.promoteId ? l$1 = t$1.properties[o$1.promoteId] : o$1.generateId && (l$1 = i$1 || 0), "Point" === n$1) C(s$1, a$1);
				else if ("MultiPoint" === n$1) for (const e$2 of s$1) C(e$2, a$1);
				else if ("LineString" === n$1) O$1(s$1, a$1, r$1, !1);
				else if ("MultiLineString" === n$1) {
					if (o$1.lineMetrics) {
						for (const o$2 of s$1) a$1 = [], O$1(o$2, a$1, r$1, !1), e$1.push(D$1(l$1, "LineString", a$1, t$1.properties));
						return;
					}
					L$1(s$1, a$1, r$1, !1);
				} else if ("Polygon" === n$1) L$1(s$1, a$1, r$1, !0);
				else {
					if ("MultiPolygon" !== n$1) {
						if ("GeometryCollection" === n$1) {
							for (const s$2 of t$1.geometry.geometries) T(e$1, {
								id: l$1,
								geometry: s$2,
								properties: t$1.properties
							}, o$1, i$1);
							return;
						}
						throw new Error("Input data is not a valid GeoJSON object.");
					}
					for (const e$2 of s$1) {
						const t$2 = [];
						L$1(e$2, t$2, r$1, !0), a$1.push(t$2);
					}
				}
				e$1.push(D$1(l$1, n$1, a$1, t$1.properties));
			}
			function C(e$1, t$1) {
				t$1.push(z$1(e$1[0]), F$1(e$1[1]), 0);
			}
			function O$1(e$1, t$1, o$1, i$1) {
				let s$1, n$1, r$1 = 0;
				for (let o$2 = 0; o$2 < e$1.length; o$2++) {
					const a$2 = z$1(e$1[o$2][0]), l$1 = F$1(e$1[o$2][1]);
					t$1.push(a$2, l$1, 0), o$2 > 0 && (r$1 += i$1 ? (s$1 * l$1 - a$2 * n$1) / 2 : Math.sqrt(Math.pow(a$2 - s$1, 2) + Math.pow(l$1 - n$1, 2))), s$1 = a$2, n$1 = l$1;
				}
				const a$1 = t$1.length - 3;
				t$1[2] = 1, I$1(t$1, 0, a$1, o$1), t$1[a$1 + 2] = 1, t$1.size = Math.abs(r$1), t$1.start = 0, t$1.end = t$1.size;
			}
			function L$1(e$1, t$1, o$1, i$1) {
				for (let s$1 = 0; s$1 < e$1.length; s$1++) {
					const n$1 = [];
					O$1(e$1[s$1], n$1, o$1, i$1), t$1.push(n$1);
				}
			}
			function z$1(e$1) {
				return e$1 / 360 + .5;
			}
			function F$1(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), o$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return o$1 < 0 ? 0 : o$1 > 1 ? 1 : o$1;
			}
			function G$1(e$1, t$1, o$1, i$1, s$1, n$1, r$1, a$1) {
				if (i$1 /= t$1, n$1 >= (o$1 /= t$1) && r$1 < i$1) return e$1;
				if (r$1 < o$1 || n$1 >= i$1) return null;
				const l$1 = [];
				for (const t$2 of e$1) {
					const e$2 = t$2.geometry;
					let n$2 = t$2.type;
					const r$2 = 0 === s$1 ? t$2.minX : t$2.minY, c$1 = 0 === s$1 ? t$2.maxX : t$2.maxY;
					if (r$2 >= o$1 && c$1 < i$1) {
						l$1.push(t$2);
						continue;
					}
					if (c$1 < o$1 || r$2 >= i$1) continue;
					let h$1 = [];
					if ("Point" === n$2 || "MultiPoint" === n$2) A$1(e$2, h$1, o$1, i$1, s$1);
					else if ("LineString" === n$2) Z$1(e$2, h$1, o$1, i$1, s$1, !1, a$1.lineMetrics);
					else if ("MultiLineString" === n$2) E(e$2, h$1, o$1, i$1, s$1, !1);
					else if ("Polygon" === n$2) E(e$2, h$1, o$1, i$1, s$1, !0);
					else if ("MultiPolygon" === n$2) for (const t$3 of e$2) {
						const e$3 = [];
						E(t$3, e$3, o$1, i$1, s$1, !0), e$3.length && h$1.push(e$3);
					}
					if (h$1.length) {
						if (a$1.lineMetrics && "LineString" === n$2) {
							for (const e$3 of h$1) l$1.push(D$1(t$2.id, n$2, e$3, t$2.tags));
							continue;
						}
						"LineString" !== n$2 && "MultiLineString" !== n$2 || (1 === h$1.length ? (n$2 = "LineString", h$1 = h$1[0]) : n$2 = "MultiLineString"), "Point" !== n$2 && "MultiPoint" !== n$2 || (n$2 = 3 === h$1.length ? "Point" : "MultiPoint"), l$1.push(D$1(t$2.id, n$2, h$1, t$2.tags));
					}
				}
				return l$1.length ? l$1 : null;
			}
			function A$1(e$1, t$1, o$1, i$1, s$1) {
				for (let n$1 = 0; n$1 < e$1.length; n$1 += 3) {
					const r$1 = e$1[n$1 + s$1];
					r$1 >= o$1 && r$1 <= i$1 && j$1(t$1, e$1[n$1], e$1[n$1 + 1], e$1[n$1 + 2]);
				}
			}
			function Z$1(e$1, t$1, o$1, i$1, s$1, n$1, r$1) {
				let a$1 = R$2(e$1);
				const l$1 = 0 === s$1 ? N : W$1;
				let c$1, h$1, u$1 = e$1.start;
				for (let d$2 = 0; d$2 < e$1.length - 3; d$2 += 3) {
					const g$3 = e$1[d$2], f$2 = e$1[d$2 + 1], p$2 = e$1[d$2 + 2], m$1 = e$1[d$2 + 3], y$1 = e$1[d$2 + 4], v$1 = 0 === s$1 ? g$3 : f$2, x$1 = 0 === s$1 ? m$1 : y$1;
					let _$2 = !1;
					r$1 && (c$1 = Math.sqrt(Math.pow(g$3 - m$1, 2) + Math.pow(f$2 - y$1, 2))), v$1 < o$1 ? x$1 > o$1 && (h$1 = l$1(a$1, g$3, f$2, m$1, y$1, o$1), r$1 && (a$1.start = u$1 + c$1 * h$1)) : v$1 > i$1 ? x$1 < i$1 && (h$1 = l$1(a$1, g$3, f$2, m$1, y$1, i$1), r$1 && (a$1.start = u$1 + c$1 * h$1)) : j$1(a$1, g$3, f$2, p$2), x$1 < o$1 && v$1 >= o$1 && (h$1 = l$1(a$1, g$3, f$2, m$1, y$1, o$1), _$2 = !0), x$1 > i$1 && v$1 <= i$1 && (h$1 = l$1(a$1, g$3, f$2, m$1, y$1, i$1), _$2 = !0), !n$1 && _$2 && (r$1 && (a$1.end = u$1 + c$1 * h$1), t$1.push(a$1), a$1 = R$2(e$1)), r$1 && (u$1 += c$1);
				}
				let d$1 = e$1.length - 3;
				const g$2 = e$1[d$1], f$1 = e$1[d$1 + 1], p$1 = 0 === s$1 ? g$2 : f$1;
				p$1 >= o$1 && p$1 <= i$1 && j$1(a$1, g$2, f$1, e$1[d$1 + 2]), d$1 = a$1.length - 3, n$1 && d$1 >= 3 && (a$1[d$1] !== a$1[0] || a$1[d$1 + 1] !== a$1[1]) && j$1(a$1, a$1[0], a$1[1], a$1[2]), a$1.length && t$1.push(a$1);
			}
			function R$2(e$1) {
				const t$1 = [];
				return t$1.size = e$1.size, t$1.start = e$1.start, t$1.end = e$1.end, t$1;
			}
			function E(e$1, t$1, o$1, i$1, s$1, n$1) {
				for (const r$1 of e$1) Z$1(r$1, t$1, o$1, i$1, s$1, n$1, !1);
			}
			function j$1(e$1, t$1, o$1, i$1) {
				e$1.push(t$1, o$1, i$1);
			}
			function N(e$1, t$1, o$1, i$1, s$1, n$1) {
				const r$1 = (n$1 - t$1) / (i$1 - t$1);
				return j$1(e$1, n$1, o$1 + (s$1 - o$1) * r$1, 1), r$1;
			}
			function W$1(e$1, t$1, o$1, i$1, s$1, n$1) {
				const r$1 = (n$1 - o$1) / (s$1 - o$1);
				return j$1(e$1, t$1 + (i$1 - t$1) * r$1, n$1, 1), r$1;
			}
			function J$1(e$1, t$1) {
				const o$1 = [];
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					const s$1 = e$1[i$1], n$1 = s$1.type;
					let r$1;
					if ("Point" === n$1 || "MultiPoint" === n$1 || "LineString" === n$1) r$1 = Y$1(s$1.geometry, t$1);
					else if ("MultiLineString" === n$1 || "Polygon" === n$1) {
						r$1 = [];
						for (const e$2 of s$1.geometry) r$1.push(Y$1(e$2, t$1));
					} else if ("MultiPolygon" === n$1) {
						r$1 = [];
						for (const e$2 of s$1.geometry) {
							const o$2 = [];
							for (const i$2 of e$2) o$2.push(Y$1(i$2, t$1));
							r$1.push(o$2);
						}
					}
					o$1.push(D$1(s$1.id, n$1, r$1, s$1.tags));
				}
				return o$1;
			}
			function Y$1(e$1, t$1) {
				const o$1 = [];
				o$1.size = e$1.size, void 0 !== e$1.start && (o$1.start = e$1.start, o$1.end = e$1.end);
				for (let i$1 = 0; i$1 < e$1.length; i$1 += 3) o$1.push(e$1[i$1] + t$1, e$1[i$1 + 1], e$1[i$1 + 2]);
				return o$1;
			}
			function q$1(e$1, t$1) {
				if (e$1.transformed) return e$1;
				const o$1 = 1 << e$1.z, i$1 = e$1.x, s$1 = e$1.y;
				for (const n$1 of e$1.features) {
					const e$2 = n$1.geometry, r$1 = n$1.type;
					if (n$1.geometry = [], 1 === r$1) for (let r$2 = 0; r$2 < e$2.length; r$2 += 2) n$1.geometry.push(H$1(e$2[r$2], e$2[r$2 + 1], t$1, o$1, i$1, s$1));
					else for (let r$2 = 0; r$2 < e$2.length; r$2++) {
						const a$1 = [];
						for (let n$2 = 0; n$2 < e$2[r$2].length; n$2 += 2) a$1.push(H$1(e$2[r$2][n$2], e$2[r$2][n$2 + 1], t$1, o$1, i$1, s$1));
						n$1.geometry.push(a$1);
					}
				}
				return e$1.transformed = !0, e$1;
			}
			function H$1(e$1, t$1, o$1, i$1, s$1, n$1) {
				return [Math.round(o$1 * (e$1 * i$1 - s$1)), Math.round(o$1 * (t$1 * i$1 - n$1))];
			}
			function X(e$1, t$1, o$1, i$1, s$1) {
				const n$1 = t$1 === s$1.maxZoom ? 0 : s$1.tolerance / ((1 << t$1) * s$1.extent), r$1 = {
					features: [],
					numPoints: 0,
					numSimplified: 0,
					numFeatures: e$1.length,
					source: null,
					x: o$1,
					y: i$1,
					z: t$1,
					transformed: !1,
					minX: 2,
					minY: 1,
					maxX: -1,
					maxY: 0
				};
				for (const t$2 of e$1) $$1(r$1, t$2, n$1, s$1);
				return r$1;
			}
			function $$1(e$1, t$1, o$1, i$1) {
				const s$1 = t$1.geometry, n$1 = t$1.type, r$1 = [];
				if (e$1.minX = Math.min(e$1.minX, t$1.minX), e$1.minY = Math.min(e$1.minY, t$1.minY), e$1.maxX = Math.max(e$1.maxX, t$1.maxX), e$1.maxY = Math.max(e$1.maxY, t$1.maxY), "Point" === n$1 || "MultiPoint" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2 += 3) r$1.push(s$1[t$2], s$1[t$2 + 1]), e$1.numPoints++, e$1.numSimplified++;
				else if ("LineString" === n$1) B$1(r$1, s$1, e$1, o$1, !1, !1);
				else if ("MultiLineString" === n$1 || "Polygon" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2++) B$1(r$1, s$1[t$2], e$1, o$1, "Polygon" === n$1, 0 === t$2);
				else if ("MultiPolygon" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2++) {
					const i$2 = s$1[t$2];
					for (let t$3 = 0; t$3 < i$2.length; t$3++) B$1(r$1, i$2[t$3], e$1, o$1, !0, 0 === t$3);
				}
				if (r$1.length) {
					let o$2 = t$1.tags || null;
					if ("LineString" === n$1 && i$1.lineMetrics) {
						o$2 = {};
						for (const e$2 in t$1.tags) o$2[e$2] = t$1.tags[e$2];
						o$2.mapbox_clip_start = s$1.start / s$1.size, o$2.mapbox_clip_end = s$1.end / s$1.size;
					}
					const a$1 = {
						geometry: r$1,
						type: "Polygon" === n$1 || "MultiPolygon" === n$1 ? 3 : "LineString" === n$1 || "MultiLineString" === n$1 ? 2 : 1,
						tags: o$2
					};
					null !== t$1.id && (a$1.id = t$1.id), e$1.features.push(a$1);
				}
			}
			function B$1(e$1, t$1, o$1, i$1, s$1, n$1) {
				const r$1 = i$1 * i$1;
				if (i$1 > 0 && t$1.size < (s$1 ? r$1 : i$1)) return void (o$1.numPoints += t$1.length / 3);
				const a$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2 += 3) (0 === i$1 || t$1[e$2 + 2] > r$1) && (o$1.numSimplified++, a$1.push(t$1[e$2], t$1[e$2 + 1])), o$1.numPoints++;
				s$1 && function(e$2, t$2) {
					let o$2 = 0;
					for (let t$3 = 0, i$2 = e$2.length, s$2 = i$2 - 2; t$3 < i$2; s$2 = t$3, t$3 += 2) o$2 += (e$2[t$3] - e$2[s$2]) * (e$2[t$3 + 1] + e$2[s$2 + 1]);
					if (o$2 > 0 === t$2) for (let t$3 = 0, o$3 = e$2.length; t$3 < o$3 / 2; t$3 += 2) {
						const i$2 = e$2[t$3], s$2 = e$2[t$3 + 1];
						e$2[t$3] = e$2[o$3 - 2 - t$3], e$2[t$3 + 1] = e$2[o$3 - 1 - t$3], e$2[o$3 - 2 - t$3] = i$2, e$2[o$3 - 1 - t$3] = s$2;
					}
				}(a$1, n$1), e$1.push(a$1);
			}
			const U$1 = {
				maxZoom: 14,
				indexMaxZoom: 5,
				indexMaxPoints: 1e5,
				tolerance: 3,
				extent: 4096,
				buffer: 64,
				lineMetrics: !1,
				promoteId: null,
				generateId: !1,
				debug: 0
			};
			class V$1 {
				constructor(e$1, t$1) {
					const o$1 = (t$1 = this.options = function(e$2, t$2) {
						for (const o$2 in t$2) e$2[o$2] = t$2[o$2];
						return e$2;
					}(Object.create(U$1), t$1)).debug;
					if (o$1 && console.time("preprocess data"), t$1.maxZoom < 0 || t$1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
					if (t$1.promoteId && t$1.generateId) throw new Error("promoteId and generateId cannot be used together.");
					let i$1 = function(e$2, t$2) {
						const o$2 = [];
						if ("FeatureCollection" === e$2.type) for (let i$2 = 0; i$2 < e$2.features.length; i$2++) T(o$2, e$2.features[i$2], t$2, i$2);
						else T(o$2, "Feature" === e$2.type ? e$2 : { geometry: e$2 }, t$2);
						return o$2;
					}(e$1, t$1);
					this.tiles = {}, this.tileCoords = [], o$1 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t$1.indexMaxZoom, t$1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i$1 = function(e$2, t$2) {
						const o$2 = t$2.buffer / t$2.extent;
						let i$2 = e$2;
						const s$1 = G$1(e$2, 1, -1 - o$2, o$2, 0, -1, 2, t$2), n$1 = G$1(e$2, 1, 1 - o$2, 2 + o$2, 0, -1, 2, t$2);
						return (s$1 || n$1) && (i$2 = G$1(e$2, 1, -o$2, 1 + o$2, 0, -1, 2, t$2) || [], s$1 && (i$2 = J$1(s$1, 1).concat(i$2)), n$1 && (i$2 = i$2.concat(J$1(n$1, -1)))), i$2;
					}(i$1, t$1), i$1.length && this.splitTile(i$1, 0, 0, 0), o$1 && (i$1.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
				}
				splitTile(e$1, t$1, o$1, i$1, s$1, n$1, r$1) {
					const a$1 = [
						e$1,
						t$1,
						o$1,
						i$1
					], l$1 = this.options, c$1 = l$1.debug;
					for (; a$1.length;) {
						i$1 = a$1.pop(), o$1 = a$1.pop(), t$1 = a$1.pop(), e$1 = a$1.pop();
						const h$1 = 1 << t$1, u$1 = K$1(t$1, o$1, i$1);
						let d$1 = this.tiles[u$1];
						if (!d$1 && (c$1 > 1 && console.time("creation"), d$1 = this.tiles[u$1] = X(e$1, t$1, o$1, i$1, l$1), this.tileCoords.push({
							z: t$1,
							x: o$1,
							y: i$1
						}), c$1)) {
							c$1 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t$1, o$1, i$1, d$1.numFeatures, d$1.numPoints, d$1.numSimplified), console.timeEnd("creation"));
							const e$2 = `z${t$1}`;
							this.stats[e$2] = (this.stats[e$2] || 0) + 1, this.total++;
						}
						if (d$1.source = e$1, null == s$1) {
							if (t$1 === l$1.indexMaxZoom || d$1.numPoints <= l$1.indexMaxPoints) continue;
						} else {
							if (t$1 === l$1.maxZoom || t$1 === s$1) continue;
							if (null != s$1) {
								const e$2 = s$1 - t$1;
								if (o$1 !== n$1 >> e$2 || i$1 !== r$1 >> e$2) continue;
							}
						}
						if (d$1.source = null, 0 === e$1.length) continue;
						c$1 > 1 && console.time("clipping");
						const g$2 = .5 * l$1.buffer / l$1.extent, f$1 = .5 - g$2, p$1 = .5 + g$2, m$1 = 1 + g$2;
						let y$1 = null, v$1 = null, x$1 = null, _$2 = null, w$2 = G$1(e$1, h$1, o$1 - g$2, o$1 + p$1, 0, d$1.minX, d$1.maxX, l$1), S$2 = G$1(e$1, h$1, o$1 + f$1, o$1 + m$1, 0, d$1.minX, d$1.maxX, l$1);
						e$1 = null, w$2 && (y$1 = G$1(w$2, h$1, i$1 - g$2, i$1 + p$1, 1, d$1.minY, d$1.maxY, l$1), v$1 = G$1(w$2, h$1, i$1 + f$1, i$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), w$2 = null), S$2 && (x$1 = G$1(S$2, h$1, i$1 - g$2, i$1 + p$1, 1, d$1.minY, d$1.maxY, l$1), _$2 = G$1(S$2, h$1, i$1 + f$1, i$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), S$2 = null), c$1 > 1 && console.timeEnd("clipping"), a$1.push(y$1 || [], t$1 + 1, 2 * o$1, 2 * i$1), a$1.push(v$1 || [], t$1 + 1, 2 * o$1, 2 * i$1 + 1), a$1.push(x$1 || [], t$1 + 1, 2 * o$1 + 1, 2 * i$1), a$1.push(_$2 || [], t$1 + 1, 2 * o$1 + 1, 2 * i$1 + 1);
					}
				}
				getTile(e$1, t$1, o$1) {
					e$1 = +e$1, t$1 = +t$1, o$1 = +o$1;
					const { extent: s$1, debug: n$1 } = this.options;
					if (e$1 < 0 || e$1 > 24) return null;
					const r$1 = 1 << e$1, a$1 = K$1(e$1, t$1 = t$1 + r$1 & r$1 - 1, o$1);
					if (this.tiles[a$1]) return q$1(this.tiles[a$1], s$1);
					n$1 > 1 && console.log("drilling down to z%d-%d-%d", e$1, t$1, o$1);
					let l$1, c$1 = e$1, h$1 = t$1, u$1 = o$1;
					for (; !l$1 && c$1 > 0;) c$1--, h$1 >>= 1, u$1 >>= 1, l$1 = this.tiles[K$1(c$1, h$1, u$1)];
					return l$1 && l$1.source ? (n$1 > 1 && (console.log("found parent tile z%d-%d-%d", c$1, h$1, u$1), console.time("drilling down")), this.splitTile(l$1.source, c$1, h$1, u$1, e$1, t$1, o$1), n$1 > 1 && console.timeEnd("drilling down"), this.tiles[a$1] ? q$1(this.tiles[a$1], s$1) : null) : null;
				}
			}
			function K$1(e$1, t$1, o$1) {
				return 32 * ((1 << e$1) * o$1 + t$1) + e$1;
			}
			class Q$1 extends h {
				constructor(e$1, t$1, o$1, i$1 = ee$1) {
					super(e$1, t$1, o$1), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = i$1;
				}
				loadVectorTile(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						const o$2 = t$1.tileID.canonical;
						if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
						const i$1 = this._geoJSONIndex.getTile(o$2.z, o$2.x, o$2.y);
						return i$1 ? l(new e.d3(i$1.features, {
							version: 2,
							extent: e.a5
						})) : null;
					}));
				}
				loadData(t$1) {
					return e._(this, void 0, void 0, (function* () {
						var o$1;
						null === (o$1 = this._pendingRequest) || void 0 === o$1 || o$1.abort();
						const i$1 = this._startPerformance(t$1);
						this._pendingRequest = new AbortController();
						try {
							(!this._pendingData || t$1.request || t$1.data || t$1.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(t$1, this._pendingRequest));
							const e$1 = yield this._pendingData;
							this._geoJSONIndex = this._createGeoJSONIndex(e$1, t$1), this.loaded = {};
							const o$2 = {};
							return this._finishPerformance(i$1, t$1, o$2), o$2;
						} catch (t$2) {
							if (delete this._pendingRequest, e.Z(t$2)) return { abandoned: !0 };
							throw t$2;
						}
					}));
				}
				_startPerformance(t$1) {
					var o$1;
					if (null === (o$1 = null == t$1 ? void 0 : t$1.request) || void 0 === o$1 ? void 0 : o$1.collectResourceTiming) return new e.c$(t$1.request);
				}
				_finishPerformance(e$1, t$1, o$1) {
					if (!e$1) return;
					const i$1 = e$1.finish();
					i$1 && (o$1.resourceTiming = {}, o$1.resourceTiming[t$1.source] = JSON.parse(JSON.stringify(i$1)));
				}
				getData() {
					return e._(this, void 0, void 0, (function* () {
						return this._pendingData;
					}));
				}
				reloadTile(e$1) {
					const t$1 = this.loaded;
					return t$1 && t$1[e$1.uid] ? super.reloadTile(e$1) : this.loadTile(e$1);
				}
				loadAndProcessGeoJSON(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						let e$1;
						if (t$1.request ? e$1 = yield this.loadGeoJSONFromUrl(t$1.request, t$1.promoteId, o$1) : t$1.data ? e$1 = this._loadGeoJSONFromObject(t$1.data, t$1.promoteId) : t$1.dataDiff && (e$1 = this._loadGeoJSONFromDiff(t$1.dataDiff, t$1.promoteId, t$1.source)), delete this._pendingRequest, "object" != typeof e$1) throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						return p(e$1, !0), t$1.filter && (e$1 = this._filterGeoJSON(e$1, t$1.filter)), e$1;
					}));
				}
				loadGeoJSONFromUrl(t$1, o$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						const s$1 = yield e.j(t$1, i$1);
						return this._dataUpdateable = e.a7(s$1.data, o$1) ? e.a8(s$1.data, o$1) : void 0, s$1.data;
					}));
				}
				_loadGeoJSONFromObject(t$1, o$1) {
					return this._dataUpdateable = e.a7(t$1, o$1) ? e.a8(t$1, o$1) : void 0, t$1;
				}
				_loadGeoJSONFromDiff(t$1, o$1, i$1) {
					if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${i$1}`);
					e.a9(this._dataUpdateable, t$1, o$1);
					const s$1 = Array.from(this._dataUpdateable.values());
					return this._toFeatureCollection(s$1);
				}
				_filterGeoJSON(t$1, o$1) {
					const i$1 = e.d4(o$1, {
						type: "boolean",
						"property-type": "data-driven",
						overridable: !1,
						transition: !1
					});
					if ("error" === i$1.result) throw new Error(i$1.value.map(((e$1) => `${e$1.key}: ${e$1.message}`)).join(", "));
					const s$1 = t$1.features.filter(((e$1) => i$1.value.evaluate({ zoom: 0 }, e$1)));
					return this._toFeatureCollection(s$1);
				}
				_toFeatureCollection(e$1) {
					return {
						type: "FeatureCollection",
						features: e$1
					};
				}
				removeSource(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this._pendingRequest && this._pendingRequest.abort();
					}));
				}
				getClusterExpansionZoom(e$1) {
					return this._geoJSONIndex.getClusterExpansionZoom(e$1.clusterId);
				}
				getClusterChildren(e$1) {
					return this._geoJSONIndex.getChildren(e$1.clusterId);
				}
				getClusterLeaves(e$1) {
					return this._geoJSONIndex.getLeaves(e$1.clusterId, e$1.limit, e$1.offset);
				}
			}
			function ee$1(t$1, o$1) {
				return o$1.cluster ? new x(function({ superclusterOptions: t$2, clusterProperties: o$2 }) {
					if (!o$2 || !t$2) return t$2;
					const i$1 = {}, s$1 = {}, n$1 = {
						accumulated: null,
						zoom: 0
					}, r$1 = { properties: null }, a$1 = Object.keys(o$2);
					for (const t$3 of a$1) {
						const [n$2, r$2] = o$2[t$3], a$2 = e.d4(r$2), l$1 = e.d4("string" == typeof n$2 ? [
							n$2,
							["accumulated"],
							["get", t$3]
						] : n$2);
						i$1[t$3] = a$2.value, s$1[t$3] = l$1.value;
					}
					return t$2.map = (e$1) => {
						r$1.properties = e$1;
						const t$3 = {};
						for (const e$2 of a$1) t$3[e$2] = i$1[e$2].evaluate(n$1, r$1);
						return t$3;
					}, t$2.reduce = (e$1, t$3) => {
						r$1.properties = t$3;
						for (const t$4 of a$1) n$1.accumulated = e$1[t$4], e$1[t$4] = s$1[t$4].evaluate(n$1, r$1);
					}, t$2;
				}(o$1)).load(t$1.features) : function(e$1, t$2) {
					return new V$1(e$1, t$2);
				}(t$1, o$1.geojsonVtOptions);
			}
			class te$1 {
				constructor(t$1) {
					this.self = t$1, this.actor = new e.L(t$1), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (e$1, t$2) => {
						if (this.externalWorkerSourceTypes[e$1]) throw new Error(`Worker source with name "${e$1}" already registered.`);
						this.externalWorkerSourceTypes[e$1] = t$2;
					}, this.self.addProtocol = e.cK, this.self.removeProtocol = e.cL, this.self.registerRTLTextPlugin = (t$2) => {
						e.d5.setMethods(t$2);
					}, this.actor.registerMessageHandler("LDT", ((e$1, t$2) => this._getDEMWorkerSource(e$1, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RDT", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this._getDEMWorkerSource(t$2, o$1.source).removeTile(o$1);
					})))), this.actor.registerMessageHandler("GCEZ", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, o$1.type, o$1.source).getClusterExpansionZoom(o$1);
					})))), this.actor.registerMessageHandler("GCC", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, o$1.type, o$1.source).getClusterChildren(o$1);
					})))), this.actor.registerMessageHandler("GCL", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, o$1.type, o$1.source).getClusterLeaves(o$1);
					})))), this.actor.registerMessageHandler("LD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadData(t$2))), this.actor.registerMessageHandler("GD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).getData())), this.actor.registerMessageHandler("LT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).reloadTile(t$2))), this.actor.registerMessageHandler("AT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).abortTile(t$2))), this.actor.registerMessageHandler("RMT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).removeTile(t$2))), this.actor.registerMessageHandler("RS", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						if (!this.workerSources[t$2] || !this.workerSources[t$2][o$1.type] || !this.workerSources[t$2][o$1.type][o$1.source]) return;
						const e$1 = this.workerSources[t$2][o$1.type][o$1.source];
						delete this.workerSources[t$2][o$1.type][o$1.source], void 0 !== e$1.removeSource && e$1.removeSource(o$1);
					})))), this.actor.registerMessageHandler("RM", ((t$2) => e._(this, void 0, void 0, (function* () {
						delete this.layerIndexes[t$2], delete this.availableImages[t$2], delete this.workerSources[t$2], delete this.demWorkerSources[t$2], this.globalStates.delete(t$2);
					})))), this.actor.registerMessageHandler("SR", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this.referrer = o$1;
					})))), this.actor.registerMessageHandler("SRPS", ((e$1, t$2) => this._syncRTLPluginState(e$1, t$2))), this.actor.registerMessageHandler("IS", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this.self.importScripts(o$1);
					})))), this.actor.registerMessageHandler("SI", ((e$1, t$2) => this._setImages(e$1, t$2))), this.actor.registerMessageHandler("UL", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).update(o$1.layers, o$1.removedIds, this._getGlobalState(t$2));
					})))), this.actor.registerMessageHandler("UGS", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						const e$1 = this._getGlobalState(t$2);
						for (const t$3 in o$1) e$1[t$3] = o$1[t$3];
					})))), this.actor.registerMessageHandler("SL", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).replace(o$1, this._getGlobalState(t$2));
					}))));
				}
				_getGlobalState(e$1) {
					let t$1 = this.globalStates.get(e$1);
					return t$1 || (t$1 = {}, this.globalStates.set(e$1, t$1)), t$1;
				}
				_setImages(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						this.availableImages[t$1] = o$1;
						for (const e$1 in this.workerSources[t$1]) {
							const i$1 = this.workerSources[t$1][e$1];
							for (const e$2 in i$1) i$1[e$2].availableImages = o$1;
						}
					}));
				}
				_syncRTLPluginState(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						return yield e.d5.syncState(o$1, this.self.importScripts);
					}));
				}
				_getAvailableImages(e$1) {
					let t$1 = this.availableImages[e$1];
					return t$1 || (t$1 = []), t$1;
				}
				_getLayerIndex(e$1) {
					let o$1 = this.layerIndexes[e$1];
					return o$1 || (o$1 = this.layerIndexes[e$1] = new t()), o$1;
				}
				_getWorkerSource(e$1, t$1, o$1) {
					if (this.workerSources[e$1] || (this.workerSources[e$1] = {}), this.workerSources[e$1][t$1] || (this.workerSources[e$1][t$1] = {}), !this.workerSources[e$1][t$1][o$1]) {
						const i$1 = { sendAsync: (t$2, o$2) => (t$2.targetMapId = e$1, this.actor.sendAsync(t$2, o$2)) };
						switch (t$1) {
							case "vector":
								this.workerSources[e$1][t$1][o$1] = new h(i$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							case "geojson":
								this.workerSources[e$1][t$1][o$1] = new Q$1(i$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							default: this.workerSources[e$1][t$1][o$1] = new this.externalWorkerSourceTypes[t$1](i$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
						}
					}
					return this.workerSources[e$1][t$1][o$1];
				}
				_getDEMWorkerSource(e$1, t$1) {
					return this.demWorkerSources[e$1] || (this.demWorkerSources[e$1] = {}), this.demWorkerSources[e$1][t$1] || (this.demWorkerSources[e$1][t$1] = new u()), this.demWorkerSources[e$1][t$1];
				}
			}
			return e.i(self) && (self.worker = new te$1(self)), te$1;
		}));
		define$1("index", ["exports", "./shared"], (function(e, t) {
			var i = "5.14.0";
			function a() {
				var e$1 = new t.A(4);
				return t.A != Float32Array && (e$1[1] = 0, e$1[2] = 0), e$1[0] = 1, e$1[3] = 1, e$1;
			}
			let r, o, s;
			const n = {
				frame(e$1, i$1, a$1) {
					const r$1 = requestAnimationFrame(((e$2) => {
						o$1(), i$1(e$2);
					})), { unsubscribe: o$1 } = t.s(e$1.signal, "abort", (() => {
						o$1(), cancelAnimationFrame(r$1), a$1(new t.a(e$1.signal.reason));
					}), !1);
				},
				frameAsync(e$1) {
					return new Promise(((t$1, i$1) => {
						this.frame(e$1, t$1, i$1);
					}));
				},
				getImageData(e$1, t$1 = 0) {
					return this.getImageCanvasContext(e$1).getImageData(-t$1, -t$1, e$1.width + 2 * t$1, e$1.height + 2 * t$1);
				},
				getImageCanvasContext(e$1) {
					const t$1 = window.document.createElement("canvas"), i$1 = t$1.getContext("2d", { willReadFrequently: !0 });
					if (!i$1) throw new Error("failed to create canvas 2d context");
					return t$1.width = e$1.width, t$1.height = e$1.height, i$1.drawImage(e$1, 0, 0, e$1.width, e$1.height), i$1;
				},
				resolveURL: (e$1) => (r || (r = document.createElement("a")), r.href = e$1, r.href),
				hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4,
				get prefersReducedMotion() {
					return void 0 !== s ? s : !!matchMedia && (o ??= matchMedia("(prefers-reduced-motion: reduce)"), o.matches);
				},
				set prefersReducedMotion(e$1) {
					s = e$1;
				}
			}, l = new class {
				constructor() {
					this._realTime = "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
				}
				getCurrentTime() {
					return null !== this._frozenAt ? this._frozenAt : this._realTime();
				}
				setNow(e$1) {
					this._frozenAt = e$1;
				}
				restoreNow() {
					this._frozenAt = null;
				}
				isFrozen() {
					return null !== this._frozenAt;
				}
			}();
			function c() {
				return l.getCurrentTime();
			}
			class h {
				static testProp(e$1) {
					if (!h.docStyle) return e$1[0];
					for (let t$1 = 0; t$1 < e$1.length; t$1++) if (e$1[t$1] in h.docStyle) return e$1[t$1];
					return e$1[0];
				}
				static create(e$1, t$1, i$1) {
					const a$1 = window.document.createElement(e$1);
					return void 0 !== t$1 && (a$1.className = t$1), i$1 && i$1.appendChild(a$1), a$1;
				}
				static createNS(e$1, t$1) {
					return window.document.createElementNS(e$1, t$1);
				}
				static disableDrag() {
					h.docStyle && h.selectProp && (h.userSelect = h.docStyle[h.selectProp], h.docStyle[h.selectProp] = "none");
				}
				static enableDrag() {
					h.docStyle && h.selectProp && (h.docStyle[h.selectProp] = h.userSelect);
				}
				static setTransform(e$1, t$1) {
					e$1.style[h.transformProp] = t$1;
				}
				static addEventListener(e$1, t$1, i$1, a$1 = {}) {
					e$1.addEventListener(t$1, i$1, "passive" in a$1 ? a$1 : a$1.capture);
				}
				static removeEventListener(e$1, t$1, i$1, a$1 = {}) {
					e$1.removeEventListener(t$1, i$1, "passive" in a$1 ? a$1 : a$1.capture);
				}
				static suppressClickInternal(e$1) {
					e$1.preventDefault(), e$1.stopPropagation(), window.removeEventListener("click", h.suppressClickInternal, !0);
				}
				static suppressClick() {
					window.addEventListener("click", h.suppressClickInternal, !0), window.setTimeout((() => {
						window.removeEventListener("click", h.suppressClickInternal, !0);
					}), 0);
				}
				static getScale(e$1) {
					const t$1 = e$1.getBoundingClientRect();
					return {
						x: t$1.width / e$1.offsetWidth || 1,
						y: t$1.height / e$1.offsetHeight || 1,
						boundingClientRect: t$1
					};
				}
				static getPoint(e$1, i$1, a$1) {
					const r$1 = i$1.boundingClientRect;
					return new t.P((a$1.clientX - r$1.left) / i$1.x - e$1.clientLeft, (a$1.clientY - r$1.top) / i$1.y - e$1.clientTop);
				}
				static mousePos(e$1, t$1) {
					const i$1 = h.getScale(e$1);
					return h.getPoint(e$1, i$1, t$1);
				}
				static touchPos(e$1, t$1) {
					const i$1 = [], a$1 = h.getScale(e$1);
					for (let r$1 = 0; r$1 < t$1.length; r$1++) i$1.push(h.getPoint(e$1, a$1, t$1[r$1]));
					return i$1;
				}
				static mouseButton(e$1) {
					return e$1.button;
				}
				static remove(e$1) {
					e$1.parentNode && e$1.parentNode.removeChild(e$1);
				}
				static sanitize(e$1) {
					const t$1 = new DOMParser().parseFromString(e$1, "text/html").body || document.createElement("body"), i$1 = t$1.querySelectorAll("script");
					for (const e$2 of i$1) e$2.remove();
					return h.clean(t$1), t$1.innerHTML;
				}
				static isPossiblyDangerous(e$1, t$1) {
					const i$1 = t$1.replace(/\s+/g, "").toLowerCase();
					return !(![
						"src",
						"href",
						"xlink:href"
					].includes(e$1) || !i$1.includes("javascript:") && !i$1.includes("data:")) || !!e$1.startsWith("on") || void 0;
				}
				static clean(e$1) {
					const t$1 = e$1.children;
					for (const e$2 of t$1) h.removeAttributes(e$2), h.clean(e$2);
				}
				static removeAttributes(e$1) {
					for (const { name: t$1, value: i$1 } of e$1.attributes) h.isPossiblyDangerous(t$1, i$1) && e$1.removeAttribute(t$1);
				}
			}
			h.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, h.selectProp = h.testProp([
				"userSelect",
				"MozUserSelect",
				"WebkitUserSelect",
				"msUserSelect"
			]), h.transformProp = h.testProp(["transform", "WebkitTransform"]);
			const u = {
				supported: !1,
				testSupport: function(e$1) {
					!p && _$1 && (m ? f(e$1) : d = e$1);
				}
			};
			let d, _$1, p = !1, m = !1;
			function f(e$1) {
				const t$1 = e$1.createTexture();
				e$1.bindTexture(e$1.TEXTURE_2D, t$1);
				try {
					if (e$1.texImage2D(e$1.TEXTURE_2D, 0, e$1.RGBA, e$1.RGBA, e$1.UNSIGNED_BYTE, _$1), e$1.isContextLost()) return;
					u.supported = !0;
				} catch (e$2) {}
				e$1.deleteTexture(t$1), p = !0;
			}
			var g$1;
			"undefined" != typeof document && (_$1 = document.createElement("img"), _$1.onload = () => {
				d && f(d), d = null, m = !0;
			}, _$1.onerror = () => {
				p = !0, d = null;
			}, _$1.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e$1) {
				let i$1, a$1, r$1, o$1;
				e$1.resetRequestQueue = () => {
					i$1 = [], a$1 = 0, r$1 = 0, o$1 = {};
				}, e$1.addThrottleControl = (e$2) => {
					const t$1 = r$1++;
					return o$1[t$1] = e$2, t$1;
				}, e$1.removeThrottleControl = (e$2) => {
					delete o$1[e$2], n$1();
				}, e$1.getImage = (e$2, a$2, r$2 = !0) => new Promise(((o$2, s$2) => {
					u.supported && (e$2.headers || (e$2.headers = {}), e$2.headers.accept = "image/webp,*/*"), t.e(e$2, { type: "image" }), i$1.push({
						abortController: a$2,
						requestParameters: e$2,
						supportImageRefresh: r$2,
						state: "queued",
						onError: (e$3) => {
							s$2(e$3);
						},
						onSuccess: (e$3) => {
							o$2(e$3);
						}
					}), n$1();
				}));
				const s$1 = (e$2) => t._(this, void 0, void 0, (function* () {
					e$2.state = "running";
					const { requestParameters: i$2, supportImageRefresh: r$2, onError: o$2, onSuccess: s$2, abortController: c$1 } = e$2, h$1 = !1 === r$2 && !t.i(self) && !t.g(i$2.url) && (!i$2.headers || Object.keys(i$2.headers).reduce(((e$3, t$1) => e$3 && "accept" === t$1), !0));
					a$1++;
					const u$1 = h$1 ? l$1(i$2, c$1) : t.m(i$2, c$1);
					try {
						const i$3 = yield u$1;
						delete e$2.abortController, e$2.state = "completed", i$3.data instanceof HTMLImageElement || t.b(i$3.data) ? s$2(i$3) : i$3.data && s$2({
							data: yield (d$1 = i$3.data, "function" == typeof createImageBitmap ? t.f(d$1) : t.h(d$1)),
							cacheControl: i$3.cacheControl,
							expires: i$3.expires
						});
					} catch (t$1) {
						delete e$2.abortController, o$2(t$1);
					} finally {
						a$1--, n$1();
					}
					var d$1;
				})), n$1 = () => {
					const e$2 = (() => {
						for (const e$3 of Object.keys(o$1)) if (o$1[e$3]()) return !0;
						return !1;
					})() ? t.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.c.MAX_PARALLEL_IMAGE_REQUESTS;
					for (let t$1 = a$1; t$1 < e$2 && i$1.length > 0; t$1++) {
						const e$3 = i$1.shift();
						e$3.abortController.signal.aborted ? t$1-- : s$1(e$3);
					}
				}, l$1 = (e$2, i$2) => new Promise(((a$2, r$2) => {
					const o$2 = new Image(), s$2 = e$2.url, n$2 = e$2.credentials;
					n$2 && "include" === n$2 ? o$2.crossOrigin = "use-credentials" : (n$2 && "same-origin" === n$2 || !t.d(s$2)) && (o$2.crossOrigin = "anonymous"), i$2.signal.addEventListener("abort", (() => {
						o$2.src = "", r$2(new t.a(i$2.signal.reason));
					})), o$2.fetchPriority = "high", o$2.onload = () => {
						o$2.onerror = o$2.onload = null, a$2({ data: o$2 });
					}, o$2.onerror = () => {
						o$2.onerror = o$2.onload = null, i$2.signal.aborted || r$2(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
					}, o$2.src = s$2;
				}));
			}(g$1 || (g$1 = {})), g$1.resetRequestQueue();
			class v {
				constructor(e$1) {
					this._transformRequestFn = null != e$1 ? e$1 : null;
				}
				transformRequest(e$1, t$1) {
					return this._transformRequestFn && this._transformRequestFn(e$1, t$1) || { url: e$1 };
				}
				setTransformRequest(e$1) {
					this._transformRequestFn = e$1;
				}
			}
			function x(e$1) {
				const t$1 = [];
				if ("string" == typeof e$1) t$1.push({
					id: "default",
					url: e$1
				});
				else if (e$1 && e$1.length > 0) {
					const i$1 = [];
					for (const { id: a$1, url: r$1 } of e$1) {
						const e$2 = `${a$1}${r$1}`;
						-1 === i$1.indexOf(e$2) && (i$1.push(e$2), t$1.push({
							id: a$1,
							url: r$1
						}));
					}
				}
				return t$1;
			}
			function b(e$1, t$1, i$1) {
				try {
					const a$1 = new URL(e$1);
					return a$1.pathname += `${t$1}${i$1}`, a$1.toString();
				} catch (t$2) {
					throw new Error(`Invalid sprite URL "${e$1}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
				}
			}
			function y(e$1) {
				const { userImage: t$1 } = e$1;
				return !!(t$1 && t$1.render && t$1.render()) && (e$1.data.replace(new Uint8Array(t$1.data.buffer)), !0);
			}
			class w$1 extends t.E {
				constructor() {
					super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({
						width: 1,
						height: 1
					}), this.dirty = !0;
				}
				destroy() {
					this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
					for (const e$1 of Object.keys(this.images)) this.removeImage(e$1);
					this.patterns = {}, this.atlasImage = new t.R({
						width: 1,
						height: 1
					}), this.dirty = !0;
				}
				isLoaded() {
					return this.loaded;
				}
				setLoaded(e$1) {
					if (this.loaded !== e$1 && (this.loaded = e$1, e$1)) {
						for (const { ids: e$2, promiseResolve: t$1 } of this.requestors) t$1(this._getImagesForIds(e$2));
						this.requestors = [];
					}
				}
				getImage(e$1) {
					const i$1 = this.images[e$1];
					if (i$1 && !i$1.data && i$1.spriteData) {
						const e$2 = i$1.spriteData;
						i$1.data = new t.R({
							width: e$2.width,
							height: e$2.height
						}, e$2.context.getImageData(e$2.x, e$2.y, e$2.width, e$2.height).data), i$1.spriteData = null;
					}
					return i$1;
				}
				addImage(e$1, t$1) {
					if (this.images[e$1]) throw new Error(`Image id ${e$1} already exist, use updateImage instead`);
					this._validate(e$1, t$1) && (this.images[e$1] = t$1);
				}
				_validate(e$1, i$1) {
					let a$1 = !0;
					const r$1 = i$1.data || i$1.spriteData;
					return this._validateStretch(i$1.stretchX, r$1 && r$1.width) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchX" value`))), a$1 = !1), this._validateStretch(i$1.stretchY, r$1 && r$1.height) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchY" value`))), a$1 = !1), this._validateContent(i$1.content, i$1) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "content" value`))), a$1 = !1), a$1;
				}
				_validateStretch(e$1, t$1) {
					if (!e$1) return !0;
					let i$1 = 0;
					for (const a$1 of e$1) {
						if (a$1[0] < i$1 || a$1[1] < a$1[0] || t$1 < a$1[1]) return !1;
						i$1 = a$1[1];
					}
					return !0;
				}
				_validateContent(e$1, t$1) {
					if (!e$1) return !0;
					if (4 !== e$1.length) return !1;
					const i$1 = t$1.spriteData, a$1 = i$1 && i$1.width || t$1.data.width, r$1 = i$1 && i$1.height || t$1.data.height;
					return !(e$1[0] < 0 || a$1 < e$1[0] || e$1[1] < 0 || r$1 < e$1[1] || e$1[2] < 0 || a$1 < e$1[2] || e$1[3] < 0 || r$1 < e$1[3] || e$1[2] < e$1[0] || e$1[3] < e$1[1]);
				}
				updateImage(e$1, t$1, i$1 = !0) {
					const a$1 = this.getImage(e$1);
					if (i$1 && (a$1.data.width !== t$1.data.width || a$1.data.height !== t$1.data.height)) throw new Error(`size mismatch between old image (${a$1.data.width}x${a$1.data.height}) and new image (${t$1.data.width}x${t$1.data.height}).`);
					t$1.version = a$1.version + 1, this.images[e$1] = t$1, this.updatedImages[e$1] = !0;
				}
				removeImage(e$1) {
					const t$1 = this.images[e$1];
					delete this.images[e$1], delete this.patterns[e$1], t$1.userImage && t$1.userImage.onRemove && t$1.userImage.onRemove();
				}
				listImages() {
					return Object.keys(this.images);
				}
				getImages(e$1) {
					return new Promise(((t$1, i$1) => {
						let a$1 = !0;
						if (!this.isLoaded()) for (const t$2 of e$1) this.images[t$2] || (a$1 = !1);
						this.isLoaded() || a$1 ? t$1(this._getImagesForIds(e$1)) : this.requestors.push({
							ids: e$1,
							promiseResolve: t$1
						});
					}));
				}
				_getImagesForIds(e$1) {
					const i$1 = {};
					for (const a$1 of e$1) {
						let e$2 = this.getImage(a$1);
						e$2 || (this.fire(new t.l("styleimagemissing", { id: a$1 })), e$2 = this.getImage(a$1)), e$2 ? i$1[a$1] = {
							data: e$2.data.clone(),
							pixelRatio: e$2.pixelRatio,
							sdf: e$2.sdf,
							version: e$2.version,
							stretchX: e$2.stretchX,
							stretchY: e$2.stretchY,
							content: e$2.content,
							textFitWidth: e$2.textFitWidth,
							textFitHeight: e$2.textFitHeight,
							hasRenderCallback: Boolean(e$2.userImage && e$2.userImage.render)
						} : t.w(`Image "${a$1}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
					}
					return i$1;
				}
				getPixelSize() {
					const { width: e$1, height: t$1 } = this.atlasImage;
					return {
						width: e$1,
						height: t$1
					};
				}
				getPattern(e$1) {
					const i$1 = this.patterns[e$1], a$1 = this.getImage(e$1);
					if (!a$1) return null;
					if (i$1 && i$1.position.version === a$1.version) return i$1.position;
					if (i$1) i$1.position.version = a$1.version;
					else {
						const i$2 = {
							w: a$1.data.width + 2,
							h: a$1.data.height + 2,
							x: 0,
							y: 0
						}, r$1 = new t.I(i$2, a$1);
						this.patterns[e$1] = {
							bin: i$2,
							position: r$1
						};
					}
					return this._updatePatternAtlas(), this.patterns[e$1].position;
				}
				bind(e$1) {
					const i$1 = e$1.gl;
					this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.T(e$1, this.atlasImage, i$1.RGBA), this.atlasTexture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE);
				}
				_updatePatternAtlas() {
					const e$1 = [];
					for (const t$1 in this.patterns) e$1.push(this.patterns[t$1].bin);
					const { w: i$1, h: a$1 } = t.p(e$1), r$1 = this.atlasImage;
					r$1.resize({
						width: i$1 || 1,
						height: a$1 || 1
					});
					for (const e$2 in this.patterns) {
						const { bin: i$2 } = this.patterns[e$2], a$2 = i$2.x + 1, o$1 = i$2.y + 1, s$1 = this.getImage(e$2).data, n$1 = s$1.width, l$1 = s$1.height;
						t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: a$2,
							y: o$1
						}, {
							width: n$1,
							height: l$1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: l$1 - 1
						}, {
							x: a$2,
							y: o$1 - 1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: a$2,
							y: o$1 + l$1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, r$1, {
							x: n$1 - 1,
							y: 0
						}, {
							x: a$2 - 1,
							y: o$1
						}, {
							width: 1,
							height: l$1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: a$2 + n$1,
							y: o$1
						}, {
							width: 1,
							height: l$1
						});
					}
					this.dirty = !0;
				}
				beginFrame() {
					this.callbackDispatchedThisFrame = {};
				}
				dispatchRenderCallbacks(e$1) {
					for (const i$1 of e$1) {
						if (this.callbackDispatchedThisFrame[i$1]) continue;
						this.callbackDispatchedThisFrame[i$1] = !0;
						const e$2 = this.getImage(i$1);
						e$2 || t.w(`Image with ID: "${i$1}" was not found`), y(e$2) && this.updateImage(i$1, e$2);
					}
				}
				cloneImages() {
					const e$1 = {};
					for (const t$1 in this.images) {
						const i$1 = this.images[t$1];
						e$1[t$1] = Object.assign(Object.assign({}, i$1), { data: i$1.data ? i$1.data.clone() : null });
					}
					return e$1;
				}
			}
			const T = 0x56bc75e2d63100000;
			function P$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
				for (let c$1 = t$1; c$1 < t$1 + a$1; c$1++) I$1(e$1, i$1 * o$1 + c$1, o$1, r$1, s$1, n$1, l$1);
				for (let c$1 = i$1; c$1 < i$1 + r$1; c$1++) I$1(e$1, c$1 * o$1 + t$1, 1, a$1, s$1, n$1, l$1);
			}
			function I$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1) {
				o$1[0] = 0, s$1[0] = -T, s$1[1] = T, r$1[0] = e$1[t$1];
				for (let n$1 = 1, l$1 = 0, c$1 = 0; n$1 < a$1; n$1++) {
					r$1[n$1] = e$1[t$1 + n$1 * i$1];
					const a$2 = n$1 * n$1;
					do {
						const e$2 = o$1[l$1];
						c$1 = (r$1[n$1] - r$1[e$2] + a$2 - e$2 * e$2) / (n$1 - e$2) / 2;
					} while (c$1 <= s$1[l$1] && --l$1 > -1);
					l$1++, o$1[l$1] = n$1, s$1[l$1] = c$1, s$1[l$1 + 1] = T;
				}
				for (let n$1 = 0, l$1 = 0; n$1 < a$1; n$1++) {
					for (; s$1[l$1 + 1] < n$1;) l$1++;
					const a$2 = o$1[l$1], c$1 = n$1 - a$2;
					e$1[t$1 + n$1 * i$1] = r$1[a$2] + c$1 * c$1;
				}
			}
			const C = t.v.layout_symbol["text-font"].default.join(",");
			class M$1 {
				constructor(e$1, t$1, i$1) {
					this.requestManager = e$1, this.localIdeographFontFamily = t$1, this.entries = {}, this.lang = i$1;
				}
				setURL(e$1) {
					this.url = e$1;
				}
				getGlyphs(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = [];
						for (const i$2 in e$1) for (const a$2 of e$1[i$2]) t$1.push(this._getAndCacheGlyphsPromise(i$2, a$2));
						const i$1 = yield Promise.all(t$1), a$1 = {};
						for (const { stack: e$2, id: t$2, glyph: r$1 } of i$1) a$1[e$2] || (a$1[e$2] = {}), a$1[e$2][t$2] = r$1 && {
							id: r$1.id,
							bitmap: r$1.bitmap.clone(),
							metrics: r$1.metrics
						};
						return a$1;
					}));
				}
				_getAndCacheGlyphsPromise(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						let t$1 = this.entries[e$1];
						t$1 || (t$1 = this.entries[e$1] = {
							glyphs: {},
							requests: {},
							ranges: {}
						});
						let a$1 = t$1.glyphs[i$1];
						return void 0 !== a$1 ? {
							stack: e$1,
							id: i$1,
							glyph: a$1
						} : !this.url || this._charUsesLocalIdeographFontFamily(i$1) ? (a$1 = t$1.glyphs[i$1] = this._drawGlyph(t$1, e$1, i$1), {
							stack: e$1,
							id: i$1,
							glyph: a$1
						}) : yield this._downloadAndCacheRangePromise(e$1, i$1);
					}));
				}
				_downloadAndCacheRangePromise(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = this.entries[e$1], a$1 = Math.floor(i$1 / 256);
						if (t$1.ranges[a$1]) return {
							stack: e$1,
							id: i$1,
							glyph: null
						};
						if (!t$1.requests[a$1]) {
							const i$2 = M$1.loadGlyphRange(e$1, a$1, this.url, this.requestManager);
							t$1.requests[a$1] = i$2;
						}
						try {
							const r$1 = yield t$1.requests[a$1];
							for (const e$2 in r$1) t$1.glyphs[+e$2] = r$1[+e$2];
							return t$1.ranges[a$1] = !0, {
								stack: e$1,
								id: i$1,
								glyph: r$1[i$1] || null
							};
						} catch (r$1) {
							const o$1 = t$1.glyphs[i$1] = this._drawGlyph(t$1, e$1, i$1);
							return this._warnOnMissingGlyphRange(o$1, a$1, i$1, r$1), {
								stack: e$1,
								id: i$1,
								glyph: o$1
							};
						}
					}));
				}
				_warnOnMissingGlyphRange(e$1, i$1, a$1, r$1) {
					const o$1 = 256 * i$1, s$1 = o$1 + 255, n$1 = a$1.toString(16).padStart(4, "0").toUpperCase();
					t.w(`Unable to load glyph range ${i$1}, ${o$1}-${s$1}. Rendering codepoint U+${n$1} locally instead. ${r$1}`);
				}
				_charUsesLocalIdeographFontFamily(e$1) {
					return !!this.localIdeographFontFamily && t.q(e$1);
				}
				_drawGlyph(e$1, i$1, a$1) {
					const r$1 = i$1 === C && "" !== this.localIdeographFontFamily && this._charUsesLocalIdeographFontFamily(a$1), o$1 = r$1 ? "ideographTinySDF" : "tinySDF";
					e$1[o$1] || (e$1[o$1] = this._createTinySDF(r$1 ? this.localIdeographFontFamily : i$1));
					const s$1 = e$1[o$1].draw(String.fromCodePoint(a$1));
					return {
						id: a$1,
						bitmap: new t.r({
							width: s$1.width || 60,
							height: s$1.height || 60
						}, s$1.data),
						metrics: {
							width: s$1.glyphWidth / 2 || 24,
							height: s$1.glyphHeight / 2 || 24,
							left: s$1.glyphLeft / 2 + .5 || 0,
							top: s$1.glyphTop / 2 - 27.5 || -8,
							advance: s$1.glyphAdvance / 2 || 24,
							isDoubleResolution: !0
						}
					};
				}
				_createTinySDF(e$1) {
					const t$1 = e$1 ? e$1.split(",") : [];
					t$1.push("sans-serif");
					const i$1 = t$1.map(((e$2) => /[-\w]+/.test(e$2) ? e$2 : `'${CSS.escape(e$2)}'`)).join(",");
					return new M$1.TinySDF({
						fontSize: 48,
						buffer: 6,
						radius: 16,
						cutoff: .25,
						fontFamily: i$1,
						fontWeight: this._fontWeight(t$1[0]),
						fontStyle: this._fontStyle(t$1[0]),
						lang: this.lang
					});
				}
				_fontStyle(e$1) {
					return /italic/i.test(e$1) ? "italic" : /oblique/i.test(e$1) ? "oblique" : "normal";
				}
				_fontWeight(e$1) {
					const t$1 = {
						thin: 100,
						hairline: 100,
						"extra light": 200,
						"ultra light": 200,
						light: 300,
						normal: 400,
						regular: 400,
						medium: 500,
						semibold: 600,
						demibold: 600,
						bold: 700,
						"extra bold": 800,
						"ultra bold": 800,
						black: 900,
						heavy: 900,
						"extra black": 950,
						"ultra black": 950
					};
					let i$1;
					for (const [a$1, r$1] of Object.entries(t$1)) new RegExp(`\\b${a$1}\\b`, "i").test(e$1) && (i$1 = `${r$1}`);
					return i$1;
				}
				destroy() {
					for (const e$1 in this.entries) {
						const t$1 = this.entries[e$1];
						t$1.tinySDF && (t$1.tinySDF = null), t$1.ideographTinySDF && (t$1.ideographTinySDF = null), t$1.glyphs = {}, t$1.requests = {}, t$1.ranges = {};
					}
					this.entries = {};
				}
			}
			M$1.loadGlyphRange = function(e$1, i$1, a$1, r$1) {
				return t._(this, void 0, void 0, (function* () {
					const o$1 = 256 * i$1, s$1 = o$1 + 255, n$1 = r$1.transformRequest(a$1.replace("{fontstack}", e$1).replace("{range}", `${o$1}-${s$1}`), "Glyphs"), l$1 = yield t.n(n$1, new AbortController());
					if (!l$1 || !l$1.data) throw new Error(`Could not load glyph range. range: ${i$1}, ${o$1}-${s$1}`);
					const c$1 = {};
					for (const e$2 of t.o(l$1.data)) c$1[e$2.id] = e$2;
					return c$1;
				}));
			}, M$1.TinySDF = class {
				constructor({ fontSize: e$1 = 24, buffer: t$1 = 3, radius: i$1 = 8, cutoff: a$1 = .25, fontFamily: r$1 = "sans-serif", fontWeight: o$1 = "normal", fontStyle: s$1 = "normal", lang: n$1 = null } = {}) {
					this.buffer = t$1, this.cutoff = a$1, this.radius = i$1, this.lang = n$1;
					const l$1 = this.size = e$1 + 4 * t$1, h$1 = this.ctx = this._createCanvas(l$1).getContext("2d", { willReadFrequently: !0 });
					h$1.font = `${s$1} ${o$1} ${e$1}px ${r$1}`, h$1.textBaseline = "alphabetic", h$1.textAlign = "left", h$1.fillStyle = "black", this.gridOuter = new Float64Array(l$1 * l$1), this.gridInner = new Float64Array(l$1 * l$1), this.f = new Float64Array(l$1), this.z = new Float64Array(l$1 + 1), this.v = new Uint16Array(l$1);
				}
				_createCanvas(e$1) {
					const t$1 = document.createElement("canvas");
					return t$1.width = t$1.height = e$1, t$1;
				}
				draw(e$1) {
					const { width: t$1, actualBoundingBoxAscent: i$1, actualBoundingBoxDescent: a$1, actualBoundingBoxLeft: r$1, actualBoundingBoxRight: o$1 } = this.ctx.measureText(e$1), s$1 = Math.ceil(i$1), n$1 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o$1 - r$1))), l$1 = Math.min(this.size - this.buffer, s$1 + Math.ceil(a$1)), c$1 = n$1 + 2 * this.buffer, h$1 = l$1 + 2 * this.buffer, u$1 = Math.max(c$1 * h$1, 0), d$1 = new Uint8ClampedArray(u$1), _$2 = {
						data: d$1,
						width: c$1,
						height: h$1,
						glyphWidth: n$1,
						glyphHeight: l$1,
						glyphTop: s$1,
						glyphLeft: 0,
						glyphAdvance: t$1
					};
					if (0 === n$1 || 0 === l$1) return _$2;
					const { ctx: p$1, buffer: m$1, gridInner: f$1, gridOuter: g$2 } = this;
					this.lang && (p$1.lang = this.lang), p$1.clearRect(m$1, m$1, n$1, l$1), p$1.fillText(e$1, m$1, m$1 + s$1);
					const v$1 = p$1.getImageData(m$1, m$1, n$1, l$1);
					g$2.fill(T, 0, u$1), f$1.fill(0, 0, u$1);
					for (let e$2 = 0; e$2 < l$1; e$2++) for (let t$2 = 0; t$2 < n$1; t$2++) {
						const i$2 = v$1.data[4 * (e$2 * n$1 + t$2) + 3] / 255;
						if (0 === i$2) continue;
						const a$2 = (e$2 + m$1) * c$1 + t$2 + m$1;
						if (1 === i$2) g$2[a$2] = 0, f$1[a$2] = T;
						else {
							const e$3 = .5 - i$2;
							g$2[a$2] = e$3 > 0 ? e$3 * e$3 : 0, f$1[a$2] = e$3 < 0 ? e$3 * e$3 : 0;
						}
					}
					P$1(g$2, 0, 0, c$1, h$1, c$1, this.f, this.v, this.z), P$1(f$1, m$1, m$1, n$1, l$1, c$1, this.f, this.v, this.z);
					for (let e$2 = 0; e$2 < u$1; e$2++) {
						const t$2 = Math.sqrt(g$2[e$2]) - Math.sqrt(f$1[e$2]);
						d$1[e$2] = Math.round(255 - 255 * (t$2 / this.radius + this.cutoff));
					}
					return _$2;
				}
			};
			class E {
				constructor() {
					this.specification = t.u.light.position;
				}
				possiblyEvaluate(e$1, i$1) {
					return t.F(e$1.expression.evaluate(i$1));
				}
				interpolate(e$1, i$1, a$1) {
					return {
						x: t.G.number(e$1.x, i$1.x, a$1),
						y: t.G.number(e$1.y, i$1.y, a$1),
						z: t.G.number(e$1.z, i$1.z, a$1)
					};
				}
			}
			let S$1;
			class R$2 extends t.E {
				constructor(e$1) {
					super(), S$1 = S$1 || new t.t({
						anchor: new t.D(t.u.light.anchor),
						position: new E(),
						color: new t.D(t.u.light.color),
						intensity: new t.D(t.u.light.intensity)
					}), this._transitionable = new t.x(S$1, void 0), this.setLight(e$1), this._transitioning = this._transitionable.untransitioned();
				}
				getLight() {
					return this._transitionable.serialize();
				}
				setLight(e$1, i$1 = {}) {
					if (!this._validate(t.y, e$1, i$1)) for (const i$2 in e$1) {
						const a$1 = e$1[i$2];
						i$2.endsWith(t.z) ? this._transitionable.setTransition(i$2.slice(0, -t.z.length), a$1) : this._transitionable.setValue(i$2, a$1);
					}
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, a$1) {
					return (!a$1 || !1 !== a$1.validate) && t.B(this, e$1.call(t.C, {
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.u
					}));
				}
			}
			const z$1 = new t.t({
				"sky-color": new t.D(t.u.sky["sky-color"]),
				"horizon-color": new t.D(t.u.sky["horizon-color"]),
				"fog-color": new t.D(t.u.sky["fog-color"]),
				"fog-ground-blend": new t.D(t.u.sky["fog-ground-blend"]),
				"horizon-fog-blend": new t.D(t.u.sky["horizon-fog-blend"]),
				"sky-horizon-blend": new t.D(t.u.sky["sky-horizon-blend"]),
				"atmosphere-blend": new t.D(t.u.sky["atmosphere-blend"])
			});
			class D$1 extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.x(z$1, void 0), this.setSky(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0));
				}
				setSky(e$1, i$1 = {}) {
					if (!this._validate(t.J, e$1, i$1)) {
						e$1 || (e$1 = {
							"sky-color": "transparent",
							"horizon-color": "transparent",
							"fog-color": "transparent",
							"fog-ground-blend": 1,
							"atmosphere-blend": 0
						});
						for (const i$2 in e$1) {
							const a$1 = e$1[i$2];
							i$2.endsWith(t.z) ? this._transitionable.setTransition(i$2.slice(0, -t.z.length), a$1) : this._transitionable.setValue(i$2, a$1);
						}
					}
				}
				getSky() {
					return this._transitionable.serialize();
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, a$1 = {}) {
					return !1 !== (null == a$1 ? void 0 : a$1.validate) && t.B(this, e$1.call(t.C, t.e({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.u
					})));
				}
				calculateFogBlendOpacity(e$1) {
					return e$1 < 60 ? 0 : e$1 < 70 ? (e$1 - 60) / 10 : 1;
				}
			}
			class A$1 {
				constructor(e$1, t$1) {
					this.width = e$1, this.height = t$1, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
				}
				getDash(e$1, t$1) {
					const i$1 = e$1.join(",") + String(t$1);
					return this.dashEntry[i$1] || (this.dashEntry[i$1] = this.addDash(e$1, t$1)), this.dashEntry[i$1];
				}
				getDashRanges(e$1, t$1, i$1) {
					const a$1 = [];
					let r$1 = e$1.length % 2 == 1 ? -e$1[e$1.length - 1] * i$1 : 0, o$1 = e$1[0] * i$1, s$1 = !0;
					a$1.push({
						left: r$1,
						right: o$1,
						isDash: s$1,
						zeroLength: 0 === e$1[0]
					});
					let n$1 = e$1[0];
					for (let t$2 = 1; t$2 < e$1.length; t$2++) {
						s$1 = !s$1;
						const l$1 = e$1[t$2];
						r$1 = n$1 * i$1, n$1 += l$1, o$1 = n$1 * i$1, a$1.push({
							left: r$1,
							right: o$1,
							isDash: s$1,
							zeroLength: 0 === l$1
						});
					}
					return a$1;
				}
				addRoundDash(e$1, t$1, i$1) {
					const a$1 = t$1 / 2;
					for (let t$2 = -i$1; t$2 <= i$1; t$2++) {
						const r$1 = this.width * (this.nextRow + i$1 + t$2);
						let o$1 = 0, s$1 = e$1[o$1];
						for (let n$1 = 0; n$1 < this.width; n$1++) {
							n$1 / s$1.right > 1 && (s$1 = e$1[++o$1]);
							const l$1 = Math.abs(n$1 - s$1.left), c$1 = Math.abs(n$1 - s$1.right), h$1 = Math.min(l$1, c$1);
							let u$1;
							const d$1 = t$2 / i$1 * (a$1 + 1);
							if (s$1.isDash) {
								const e$2 = a$1 - Math.abs(d$1);
								u$1 = Math.sqrt(h$1 * h$1 + e$2 * e$2);
							} else u$1 = a$1 - Math.sqrt(h$1 * h$1 + d$1 * d$1);
							this.data[r$1 + n$1] = Math.max(0, Math.min(255, u$1 + 128));
						}
					}
				}
				addRegularDash(e$1) {
					for (let t$2 = e$1.length - 1; t$2 >= 0; --t$2) {
						const i$2 = e$1[t$2], a$2 = e$1[t$2 + 1];
						i$2.zeroLength ? e$1.splice(t$2, 1) : a$2 && a$2.isDash === i$2.isDash && (a$2.left = i$2.left, e$1.splice(t$2, 1));
					}
					const t$1 = e$1[0], i$1 = e$1[e$1.length - 1];
					t$1.isDash === i$1.isDash && (t$1.left = i$1.left - this.width, i$1.right = t$1.right + this.width);
					const a$1 = this.width * this.nextRow;
					let r$1 = 0, o$1 = e$1[r$1];
					for (let t$2 = 0; t$2 < this.width; t$2++) {
						t$2 / o$1.right > 1 && (o$1 = e$1[++r$1]);
						const i$2 = Math.abs(t$2 - o$1.left), s$1 = Math.abs(t$2 - o$1.right), n$1 = Math.min(i$2, s$1);
						this.data[a$1 + t$2] = Math.max(0, Math.min(255, (o$1.isDash ? n$1 : -n$1) + 128));
					}
				}
				addDash(e$1, i$1) {
					const a$1 = i$1 ? 7 : 0, r$1 = 2 * a$1 + 1;
					if (this.nextRow + r$1 > this.height) return t.w("LineAtlas out of space"), null;
					let o$1 = 0;
					for (let t$1 = 0; t$1 < e$1.length; t$1++) o$1 += e$1[t$1];
					if (0 !== o$1) {
						const t$1 = this.width / o$1, r$2 = this.getDashRanges(e$1, this.width, t$1);
						i$1 ? this.addRoundDash(r$2, t$1, a$1) : this.addRegularDash(r$2);
					}
					const s$1 = {
						y: this.nextRow + a$1,
						height: 2 * a$1,
						width: o$1
					};
					return this.nextRow += r$1, this.dirty = !0, s$1;
				}
				bind(e$1) {
					const t$1 = e$1.gl;
					this.texture ? (t$1.bindTexture(t$1.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t$1.texSubImage2D(t$1.TEXTURE_2D, 0, 0, 0, this.width, this.height, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data))) : (this.texture = t$1.createTexture(), t$1.bindTexture(t$1.TEXTURE_2D, this.texture), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_S, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_T, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MIN_FILTER, t$1.LINEAR), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MAG_FILTER, t$1.LINEAR), t$1.texImage2D(t$1.TEXTURE_2D, 0, t$1.ALPHA, this.width, this.height, 0, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data));
				}
			}
			const L$1 = "maplibre_preloaded_worker_pool";
			class k$1 {
				constructor() {
					this.active = {};
				}
				acquire(e$1) {
					if (!this.workers) for (this.workers = []; this.workers.length < k$1.workerCount;) this.workers.push(new Worker(t.c.WORKER_URL));
					return this.active[e$1] = !0, this.workers.slice();
				}
				release(e$1) {
					delete this.active[e$1], 0 === this.numActive() && (this.workers.forEach(((e$2) => {
						e$2.terminate();
					})), this.workers = null);
				}
				isPreloaded() {
					return !!this.active[L$1];
				}
				numActive() {
					return Object.keys(this.active).length;
				}
			}
			const F$1 = Math.floor(n.hardwareConcurrency / 2);
			let B$1, O$1;
			function j$1() {
				return B$1 || (B$1 = new k$1()), B$1;
			}
			k$1.workerCount = t.K(globalThis) ? Math.max(Math.min(F$1, 3), 1) : 1;
			class N {
				constructor(e$1, i$1) {
					this.workerPool = e$1, this.actors = [], this.currentActor = 0, this.id = i$1;
					const a$1 = this.workerPool.acquire(i$1);
					for (let e$2 = 0; e$2 < a$1.length; e$2++) {
						const r$1 = new t.L(a$1[e$2], i$1);
						r$1.name = `Worker ${e$2}`, this.actors.push(r$1);
					}
					if (!this.actors.length) throw new Error("No actors found");
				}
				broadcast(e$1, t$1) {
					const i$1 = [];
					for (const a$1 of this.actors) i$1.push(a$1.sendAsync({
						type: e$1,
						data: t$1
					}));
					return Promise.all(i$1);
				}
				getActor() {
					return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
				}
				remove(e$1 = !0) {
					this.actors.forEach(((e$2) => {
						e$2.remove();
					})), this.actors = [], e$1 && this.workerPool.release(this.id);
				}
				registerMessageHandler(e$1, t$1) {
					for (const i$1 of this.actors) i$1.registerMessageHandler(e$1, t$1);
				}
				unregisterMessageHandler(e$1) {
					for (const t$1 of this.actors) t$1.unregisterMessageHandler(e$1);
				}
			}
			function Z$1() {
				return O$1 || (O$1 = new N(j$1(), t.M), O$1.registerMessageHandler("GR", ((e$1, i$1, a$1) => t.m(i$1, a$1)))), O$1;
			}
			function G$1(e$1, i$1) {
				const a$1 = t.N();
				return t.O(a$1, a$1, [
					1,
					1,
					0
				]), t.Q(a$1, a$1, [
					.5 * e$1.width,
					.5 * e$1.height,
					1
				]), e$1.calculatePosMatrix ? t.S(a$1, a$1, e$1.calculatePosMatrix(i$1.toUnwrapped())) : a$1;
			}
			function U$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1) {
				var n$1;
				const l$1 = function(e$2, t$2, i$2) {
					if (e$2) for (const a$2 of e$2) {
						const e$3 = t$2[a$2];
						if (e$3 && e$3.source === i$2 && "fill-extrusion" === e$3.type) return !0;
					}
					else for (const e$3 in t$2) {
						const a$2 = t$2[e$3];
						if (a$2.source === i$2 && "fill-extrusion" === a$2.type) return !0;
					}
					return !1;
				}(null !== (n$1 = null == r$1 ? void 0 : r$1.layers) && void 0 !== n$1 ? n$1 : null, t$1, e$1.id), c$1 = o$1.maxPitchScaleFactor(), h$1 = e$1.tilesIn(a$1, c$1, l$1);
				h$1.sort(V$1);
				const u$1 = [];
				for (const a$2 of h$1) u$1.push({
					wrappedTileID: a$2.tileID.wrapped().key,
					queryResults: a$2.tile.queryRenderedFeatures(t$1, i$1, e$1.getState(), a$2.queryGeometry, a$2.cameraQueryGeometry, a$2.scale, r$1, o$1, c$1, G$1(o$1, a$2.tileID), s$1 ? (e$2, t$2) => s$1(a$2.tileID, e$2, t$2) : void 0)
				});
				return function(e$2, t$2) {
					for (const i$2 in e$2) for (const a$2 of e$2[i$2]) q$1(a$2, t$2);
					return e$2;
				}(function(e$2) {
					const t$2 = {}, i$2 = {};
					for (const a$2 of e$2) {
						const e$3 = a$2.queryResults, r$2 = a$2.wrappedTileID, o$2 = i$2[r$2] = i$2[r$2] || {};
						for (const i$3 in e$3) {
							const a$3 = e$3[i$3], r$3 = o$2[i$3] = o$2[i$3] || {}, s$2 = t$2[i$3] = t$2[i$3] || [];
							for (const e$4 of a$3) r$3[e$4.featureIndex] || (r$3[e$4.featureIndex] = !0, s$2.push(e$4));
						}
					}
					return t$2;
				}(u$1), e$1);
			}
			function V$1(e$1, t$1) {
				const i$1 = e$1.tileID, a$1 = t$1.tileID;
				return i$1.overscaledZ - a$1.overscaledZ || i$1.canonical.y - a$1.canonical.y || i$1.wrap - a$1.wrap || i$1.canonical.x - a$1.canonical.x;
			}
			function q$1(e$1, t$1) {
				const i$1 = e$1.feature, a$1 = t$1.getFeatureState(i$1.layer["source-layer"], i$1.id);
				i$1.source = i$1.layer.source, i$1.layer["source-layer"] && (i$1.sourceLayer = i$1.layer["source-layer"]), i$1.state = a$1;
			}
			function W$1(e$1, i$1, a$1) {
				return t._(this, void 0, void 0, (function* () {
					let r$1 = e$1;
					if (e$1.url ? r$1 = (yield t.j(i$1.transformRequest(e$1.url, "Source"), a$1)).data : yield n.frameAsync(a$1), !r$1) return null;
					const o$1 = t.U(t.e(r$1, e$1), [
						"tiles",
						"minzoom",
						"maxzoom",
						"attribution",
						"bounds",
						"scheme",
						"tileSize",
						"encoding"
					]);
					return "vector_layers" in r$1 && r$1.vector_layers && (o$1.vectorLayerIds = r$1.vector_layers.map(((e$2) => e$2.id))), o$1;
				}));
			}
			class $$1 {
				constructor(e$1, t$1) {
					e$1 && (t$1 ? this.setSouthWest(e$1).setNorthEast(t$1) : Array.isArray(e$1) && (4 === e$1.length ? this.setSouthWest([e$1[0], e$1[1]]).setNorthEast([e$1[2], e$1[3]]) : this.setSouthWest(e$1[0]).setNorthEast(e$1[1])));
				}
				setNorthEast(e$1) {
					return this._ne = e$1 instanceof t.V ? new t.V(e$1.lng, e$1.lat) : t.V.convert(e$1), this;
				}
				setSouthWest(e$1) {
					return this._sw = e$1 instanceof t.V ? new t.V(e$1.lng, e$1.lat) : t.V.convert(e$1), this;
				}
				extend(e$1) {
					const i$1 = this._sw, a$1 = this._ne;
					let r$1, o$1;
					if (e$1 instanceof t.V) r$1 = e$1, o$1 = e$1;
					else {
						if (!(e$1 instanceof $$1)) return Array.isArray(e$1) ? 4 === e$1.length || e$1.every(Array.isArray) ? this.extend($$1.convert(e$1)) : this.extend(t.V.convert(e$1)) : e$1 && ("lng" in e$1 || "lon" in e$1) && "lat" in e$1 ? this.extend(t.V.convert(e$1)) : this;
						if (r$1 = e$1._sw, o$1 = e$1._ne, !r$1 || !o$1) return this;
					}
					return i$1 || a$1 ? (i$1.lng = Math.min(r$1.lng, i$1.lng), i$1.lat = Math.min(r$1.lat, i$1.lat), a$1.lng = Math.max(o$1.lng, a$1.lng), a$1.lat = Math.max(o$1.lat, a$1.lat)) : (this._sw = new t.V(r$1.lng, r$1.lat), this._ne = new t.V(o$1.lng, o$1.lat)), this;
				}
				getCenter() {
					return new t.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
				}
				getSouthWest() {
					return this._sw;
				}
				getNorthEast() {
					return this._ne;
				}
				getNorthWest() {
					return new t.V(this.getWest(), this.getNorth());
				}
				getSouthEast() {
					return new t.V(this.getEast(), this.getSouth());
				}
				getWest() {
					return this._sw.lng;
				}
				getSouth() {
					return this._sw.lat;
				}
				getEast() {
					return this._ne.lng;
				}
				getNorth() {
					return this._ne.lat;
				}
				toArray() {
					return [this._sw.toArray(), this._ne.toArray()];
				}
				toString() {
					return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
				}
				isEmpty() {
					return !(this._sw && this._ne);
				}
				contains(e$1) {
					const { lng: i$1, lat: a$1 } = t.V.convert(e$1);
					let r$1 = this._sw.lng <= i$1 && i$1 <= this._ne.lng;
					return this._sw.lng > this._ne.lng && (r$1 = this._sw.lng >= i$1 && i$1 >= this._ne.lng), this._sw.lat <= a$1 && a$1 <= this._ne.lat && r$1;
				}
				intersects(e$1) {
					if (!((e$1 = $$1.convert(e$1)).getNorth() >= this.getSouth() && e$1.getSouth() <= this.getNorth())) return !1;
					const i$1 = t.W(this.getWest(), -180, 180), a$1 = t.W(this.getEast(), -180, 180), r$1 = t.W(e$1.getWest(), -180, 180), o$1 = t.W(e$1.getEast(), -180, 180), s$1 = i$1 >= a$1, n$1 = r$1 >= o$1;
					return !(!s$1 || !n$1) || (s$1 ? o$1 >= i$1 || r$1 <= a$1 : n$1 ? a$1 >= r$1 || i$1 <= o$1 : r$1 <= a$1 && o$1 >= i$1);
				}
				static convert(e$1) {
					return e$1 instanceof $$1 ? e$1 : e$1 ? new $$1(e$1) : e$1;
				}
				static fromLngLat(e$1, i$1 = 0) {
					const a$1 = 360 * i$1 / 40075017, r$1 = a$1 / Math.cos(Math.PI / 180 * e$1.lat);
					return new $$1(new t.V(e$1.lng - r$1, e$1.lat - a$1), new t.V(e$1.lng + r$1, e$1.lat + a$1));
				}
				adjustAntiMeridian() {
					const e$1 = new t.V(this._sw.lng, this._sw.lat), i$1 = new t.V(this._ne.lng, this._ne.lat);
					return new $$1(e$1, e$1.lng > i$1.lng ? new t.V(i$1.lng + 360, i$1.lat) : i$1);
				}
			}
			class H$1 {
				constructor(e$1, t$1, i$1) {
					this.bounds = $$1.convert(this.validateBounds(e$1)), this.minzoom = t$1 || 0, this.maxzoom = i$1 || 24;
				}
				validateBounds(e$1) {
					return Array.isArray(e$1) && 4 === e$1.length ? [
						Math.max(-180, e$1[0]),
						Math.max(-90, e$1[1]),
						Math.min(180, e$1[2]),
						Math.min(90, e$1[3])
					] : [
						-180,
						-90,
						180,
						90
					];
				}
				contains(e$1) {
					const i$1 = Math.pow(2, e$1.z), a$1 = Math.floor(t.Y(this.bounds.getWest()) * i$1), r$1 = Math.floor(t.X(this.bounds.getNorth()) * i$1), o$1 = Math.ceil(t.Y(this.bounds.getEast()) * i$1), s$1 = Math.ceil(t.X(this.bounds.getSouth()) * i$1);
					return e$1.x >= a$1 && e$1.x < o$1 && e$1.y >= r$1 && e$1.y < s$1;
				}
			}
			class X extends t.E {
				constructor(e$1, i$1, a$1, r$1) {
					if (super(), this.id = e$1, this.dispatcher = a$1, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.e(this, t.U(i$1, [
						"url",
						"scheme",
						"tileSize",
						"promoteId",
						"encoding"
					])), this._options = t.e({ type: "vector" }, i$1), this._collectResourceTiming = i$1.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
					this.setEventedParent(r$1);
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const e$1 = yield W$1(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e$1 && (t.e(this, e$1), e$1.bounds && (this.tileBounds = new H$1(e$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content"
							})));
						} catch (e$1) {
							this._tileJSONRequest = null, this._loaded = !0, t.Z(e$1) || this.fire(new t.k(e$1));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && this._tileJSONRequest.abort(), e$1(), this.load();
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				serialize() {
					return t.e({}, this._options);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i$1 = {
							request: this.map._requestManager.transformRequest(t$1, "Tile"),
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							tileSize: this.tileSize * e$1.tileID.overscaleFactor(),
							type: this.type,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
							encoding: this.encoding,
							overzoomParameters: this._getOverzoomParameters(e$1)
						};
						i$1.request.collectResourceTiming = this._collectResourceTiming;
						let a$1 = "RT";
						if (e$1.actor && "expired" !== e$1.state) {
							if ("loading" === e$1.state) return new Promise(((t$2, i$2) => {
								e$1.reloadPromise = {
									resolve: t$2,
									reject: i$2
								};
							}));
						} else e$1.actor = this.dispatcher.getActor(), a$1 = "LT";
						e$1.abortController = new AbortController();
						try {
							const t$2 = yield e$1.actor.sendAsync({
								type: a$1,
								data: i$1
							}, e$1.abortController);
							if (delete e$1.abortController, e$1.aborted) return;
							this._afterTileLoadWorkerResponse(e$1, t$2);
						} catch (t$2) {
							if (delete e$1.abortController, e$1.aborted) return;
							if (t$2 && 404 !== t$2.status) throw t$2;
							this._afterTileLoadWorkerResponse(e$1, null);
						}
					}));
				}
				_getOverzoomParameters(e$1) {
					if (e$1.tileID.canonical.z <= this.maxzoom) return;
					if (void 0 === this.map._zoomLevelsToOverscale) return;
					const t$1 = e$1.tileID.scaledTo(this.maxzoom).canonical, i$1 = t$1.url(this.tiles, this.map.getPixelRatio(), this.scheme);
					return {
						maxZoomTileID: t$1,
						overzoomRequest: this.map._requestManager.transformRequest(i$1, "Tile")
					};
				}
				_afterTileLoadWorkerResponse(e$1, t$1) {
					if (t$1 && t$1.resourceTiming && (e$1.resourceTiming = t$1.resourceTiming), t$1 && this.map._refreshExpiredTiles && e$1.setExpiryData(t$1), e$1.loadVectorData(t$1, this.map.painter), e$1.reloadPromise) {
						const t$2 = e$1.reloadPromise;
						e$1.reloadPromise = null, this.loadTile(e$1).then(t$2.resolve).catch(t$2.reject);
					}
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.actor && (yield e$1.actor.sendAsync({
							type: "AT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), e$1.actor && (yield e$1.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class K$1 extends t.E {
				constructor(e$1, i$1, a$1, r$1) {
					super(), this.id = e$1, this.dispatcher = a$1, this.setEventedParent(r$1), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.e({ type: "raster" }, i$1), t.e(this, t.U(i$1, [
						"url",
						"scheme",
						"tileSize"
					]));
				}
				load() {
					return t._(this, arguments, void 0, (function* (e$1 = !1) {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const i$1 = yield W$1(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, i$1 && (t.e(this, i$1), i$1.bounds && (this.tileBounds = new H$1(i$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content",
								sourceDataChanged: e$1
							})));
						} catch (e$2) {
							this._tileJSONRequest = null, this._loaded = !0, t.Z(e$2) || this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e$1(), this.load(!0);
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				serialize() {
					return t.e({}, this._options);
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
						e$1.abortController = new AbortController();
						try {
							const a$1 = yield g$1.getImage(this.map._requestManager.transformRequest(i$1, "Tile"), e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (a$1 && a$1.data) {
								this.map._refreshExpiredTiles && (a$1.cacheControl || a$1.expires) && e$1.setExpiryData({
									cacheControl: a$1.cacheControl,
									expires: a$1.expires
								});
								const i$2 = this.map.painter.context, r$1 = i$2.gl, o$1 = a$1.data;
								e$1.texture = this.map.painter.getTileTexture(o$1.width), e$1.texture ? e$1.texture.update(o$1, { useMipmap: !0 }) : (e$1.texture = new t.T(i$2, o$1, r$1.RGBA, { useMipmap: !0 }), e$1.texture.bind(r$1.LINEAR, r$1.CLAMP_TO_EDGE, r$1.LINEAR_MIPMAP_NEAREST)), e$1.state = "loaded";
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController);
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.texture && this.map.painter.saveTileTexture(e$1.texture);
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class Y$1 extends K$1 {
				constructor(e$1, i$1, a$1, r$1) {
					super(e$1, i$1, a$1, r$1), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i$1), this.encoding = i$1.encoding || "mapbox", this.redFactor = i$1.redFactor, this.greenFactor = i$1.greenFactor, this.blueFactor = i$1.blueFactor, this.baseShift = i$1.baseShift;
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a$1 = this.map._requestManager.transformRequest(i$1, "Tile");
						e$1.neighboringTiles = this._getNeighboringTiles(e$1.tileID), e$1.abortController = new AbortController();
						try {
							const i$2 = yield g$1.getImage(a$1, e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (i$2 && i$2.data) {
								const a$2 = i$2.data;
								this.map._refreshExpiredTiles && (i$2.cacheControl || i$2.expires) && e$1.setExpiryData({
									cacheControl: i$2.cacheControl,
									expires: i$2.expires
								});
								const r$1 = t.b(a$2) && t.$() ? a$2 : yield this.readImageNow(a$2), o$1 = {
									type: this.type,
									uid: e$1.uid,
									source: this.id,
									rawImageData: r$1,
									encoding: this.encoding,
									redFactor: this.redFactor,
									greenFactor: this.greenFactor,
									blueFactor: this.blueFactor,
									baseShift: this.baseShift
								};
								if (!e$1.actor || "expired" === e$1.state) {
									e$1.actor = this.dispatcher.getActor();
									e$1.dem = yield e$1.actor.sendAsync({
										type: "LDT",
										data: o$1
									}), e$1.needsHillshadePrepare = !0, e$1.needsTerrainPrepare = !0, e$1.state = "loaded";
								}
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				readImageNow(e$1) {
					return t._(this, void 0, void 0, (function* () {
						if ("undefined" != typeof VideoFrame && t.a0()) {
							const i$1 = e$1.width + 2, a$1 = e$1.height + 2;
							try {
								return new t.R({
									width: i$1,
									height: a$1
								}, yield t.a1(e$1, -1, -1, i$1, a$1));
							} catch (e$2) {}
						}
						return n.getImageData(e$1, 1);
					}));
				}
				_getNeighboringTiles(e$1) {
					const i$1 = e$1.canonical, a$1 = Math.pow(2, i$1.z), r$1 = (i$1.x - 1 + a$1) % a$1, o$1 = 0 === i$1.x ? e$1.wrap - 1 : e$1.wrap, s$1 = (i$1.x + 1 + a$1) % a$1, n$1 = i$1.x + 1 === a$1 ? e$1.wrap + 1 : e$1.wrap, l$1 = {};
					return l$1[new t.a2(e$1.overscaledZ, o$1, i$1.z, r$1, i$1.y).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y).key] = { backfilled: !1 }, i$1.y > 0 && (l$1[new t.a2(e$1.overscaledZ, o$1, i$1.z, r$1, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y - 1).key] = { backfilled: !1 }), i$1.y + 1 < a$1 && (l$1[new t.a2(e$1.overscaledZ, o$1, i$1.z, r$1, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y + 1).key] = { backfilled: !1 }), l$1;
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.demTexture && this.map.painter.saveTileTexture(e$1.demTexture), e$1.fbo && (e$1.fbo.destroy(), delete e$1.fbo), e$1.dem && delete e$1.dem, delete e$1.neighboringTiles, e$1.state = "unloaded", e$1.actor && (yield e$1.actor.sendAsync({
							type: "RDT",
							data: {
								type: this.type,
								uid: e$1.uid,
								source: this.id
							}
						}));
					}));
				}
			}
			function Q$1(e$1) {
				return "GeometryCollection" === e$1.type ? e$1.geometries.map(((e$2) => e$2.coordinates)).flat(Infinity) : e$1.coordinates.flat(Infinity);
			}
			function J$1(e$1) {
				const t$1 = new $$1();
				let i$1;
				switch (e$1.type) {
					case "FeatureCollection":
						i$1 = e$1.features.map(((e$2) => Q$1(e$2.geometry))).flat(Infinity);
						break;
					case "Feature":
						i$1 = Q$1(e$1.geometry);
						break;
					default: i$1 = Q$1(e$1);
				}
				if (0 == i$1.length) return t$1;
				for (let e$2 = 0; e$2 < i$1.length - 1; e$2 += 2) t$1.extend([i$1[e$2], i$1[e$2 + 1]]);
				return t$1;
			}
			class ee$1 extends t.E {
				constructor(e$1, i$1, a$1, r$1) {
					super(), this.id = e$1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: i$1.data }, this.actor = a$1.getActor(), this.setEventedParent(r$1), this._data = "string" == typeof i$1.data ? { url: i$1.data } : { geojson: i$1.data }, this._options = t.e({}, i$1), this._collectResourceTiming = i$1.collectResourceTiming, void 0 !== i$1.maxzoom && (this.maxzoom = i$1.maxzoom), i$1.type && (this.type = i$1.type), i$1.attribution && (this.attribution = i$1.attribution), this.promoteId = i$1.promoteId, void 0 !== i$1.clusterMaxZoom && this.maxzoom <= i$1.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i$1.clusterMaxZoom}".`), this.workerOptions = t.e({
						source: this.id,
						cluster: i$1.cluster || !1,
						geojsonVtOptions: {
							buffer: this._pixelsToTileUnits(void 0 !== i$1.buffer ? i$1.buffer : 128),
							tolerance: this._pixelsToTileUnits(void 0 !== i$1.tolerance ? i$1.tolerance : .375),
							extent: t.a5,
							maxZoom: this.maxzoom,
							lineMetrics: i$1.lineMetrics || !1,
							generateId: i$1.generateId || !1
						},
						superclusterOptions: {
							maxZoom: this._getClusterMaxZoom(i$1.clusterMaxZoom),
							minPoints: Math.max(2, i$1.clusterMinPoints || 2),
							extent: t.a5,
							radius: this._pixelsToTileUnits(i$1.clusterRadius || 50),
							log: !1,
							generateId: i$1.generateId || !1
						},
						clusterProperties: i$1.clusterProperties,
						filter: i$1.filter
					}, i$1.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
				}
				_hasPendingWorkerUpdate() {
					return void 0 !== this._pendingWorkerUpdate.data || void 0 !== this._pendingWorkerUpdate.diff || this._pendingWorkerUpdate.optionsChanged;
				}
				_pixelsToTileUnits(e$1) {
					return e$1 * (t.a5 / this.tileSize);
				}
				_getClusterMaxZoom(e$1) {
					const i$1 = e$1 ? Math.round(e$1) : this.maxzoom - 1;
					return Number.isInteger(e$1) || void 0 === e$1 || t.w(`Integer expected for option 'clusterMaxZoom': provided value "${e$1}" rounded to "${i$1}"`), i$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						yield this._updateWorkerData();
					}));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setData(e$1, t$1) {
					this._data = "string" == typeof e$1 ? { url: e$1 } : { geojson: e$1 }, this._pendingWorkerUpdate = { data: e$1 };
					const i$1 = this._updateWorkerData();
					return t$1 ? i$1 : this;
				}
				updateData(e$1, i$1) {
					this._pendingWorkerUpdate.diff = t.a6(this._pendingWorkerUpdate.diff, e$1);
					const a$1 = this._updateWorkerData();
					return i$1 ? a$1 : this;
				}
				getData() {
					return t._(this, void 0, void 0, (function* () {
						const e$1 = t.e({ type: this.type }, this.workerOptions);
						return this.actor.sendAsync({
							type: "GD",
							data: e$1
						});
					}));
				}
				getBounds() {
					return t._(this, void 0, void 0, (function* () {
						return J$1(yield this.getData());
					}));
				}
				setClusterOptions(e$1) {
					return this.workerOptions.cluster = e$1.cluster, void 0 !== e$1.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e$1.clusterRadius)), void 0 !== e$1.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e$1.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this;
				}
				getClusterExpansionZoom(e$1) {
					return this.actor.sendAsync({
						type: "GCEZ",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterChildren(e$1) {
					return this.actor.sendAsync({
						type: "GCC",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterLeaves(e$1, t$1, i$1) {
					return this.actor.sendAsync({
						type: "GCL",
						data: {
							type: this.type,
							source: this.id,
							clusterId: e$1,
							limit: t$1,
							offset: i$1
						}
					});
				}
				_updateWorkerData() {
					return t._(this, void 0, void 0, (function* () {
						if (this._isUpdatingWorker) return;
						if (!this._hasPendingWorkerUpdate()) return void t.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
						const { data: e$1, diff: i$1 } = this._pendingWorkerUpdate, a$1 = t.e({ type: this.type }, this.workerOptions);
						void 0 !== e$1 ? ("string" == typeof e$1 ? (a$1.request = this.map._requestManager.transformRequest(n.resolveURL(e$1), "Source"), a$1.request.collectResourceTiming = this._collectResourceTiming) : a$1.data = e$1, this._pendingWorkerUpdate.data = void 0) : i$1 && (a$1.dataDiff = i$1, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new t.l("dataloading", { dataType: "source" }));
						try {
							const e$2 = yield this.actor.sendAsync({
								type: "LD",
								data: a$1
							});
							if (this._isUpdatingWorker = !1, this._removed || e$2.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							i$1 && this._applyDiff(i$1);
							let r$1 = null;
							e$2.resourceTiming && e$2.resourceTiming[this.id] && (r$1 = e$2.resourceTiming[this.id].slice(0));
							const o$1 = { dataType: "source" };
							this._collectResourceTiming && r$1 && r$1.length > 0 && t.e(o$1, { resourceTiming: r$1 }), this.fire(new t.l("data", Object.assign(Object.assign({}, o$1), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, o$1), {
								sourceDataType: "content",
								shouldReloadTileOptions: this._getShouldReloadTileOptions(i$1)
							})));
						} catch (e$2) {
							if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this.fire(new t.k(e$2));
						} finally {
							this._hasPendingWorkerUpdate() && this._updateWorkerData();
						}
					}));
				}
				_applyDiff(e$1) {
					const i$1 = "string" == typeof this.promoteId ? this.promoteId : void 0;
					if (!this._data.url && !this._data.updateable) {
						if (!t.a7(this._data.geojson, i$1)) throw new Error(`GeoJSONSource "${this.id}": GeoJSON data is not compatible with updateData`);
						this._data = { updateable: t.a8(this._data.geojson, i$1) };
					}
					this._data.updateable && t.a9(this._data.updateable, e$1, i$1);
				}
				_getShouldReloadTileOptions(e$1) {
					if (this._options.cluster || !e$1 || e$1.removeAll) return;
					const { add: i$1 = [], update: a$1 = [], remove: r$1 = [] } = e$1 || {}, o$1 = new Set([...a$1.map(((e$2) => e$2.id)), ...r$1]);
					for (const e$2 of o$1.values()) if ("number" != typeof e$2 && null == this.promoteId) return void t.w(`GeoJSONSource "${this.id}": updateData is slower when using string GeoJSON feature IDs. Consider using promoteId or numeric IDs for better performance.`);
					return {
						nextBounds: [...a$1.map(((e$2) => e$2.newGeometry)), ...i$1.map(((e$2) => e$2.geometry))].filter(Boolean).map(((e$2) => J$1(e$2))),
						prevIds: o$1
					};
				}
				shouldReloadTile(e$1, { nextBounds: i$1, prevIds: a$1 }) {
					if (!e$1.latestFeatureIndex) return "unloaded" !== e$1.state;
					const r$1 = e$1.latestFeatureIndex.loadVTLayers();
					for (let i$2 = 0; i$2 < e$1.latestFeatureIndex.featureIndexArray.length; i$2++) {
						const o$2 = e$1.latestFeatureIndex.featureIndexArray.get(i$2), s$2 = r$1[t.aa].feature(o$2.featureIndex), n$2 = e$1.latestFeatureIndex.getId(s$2, t.aa);
						if (a$1.has(n$2)) return !0;
					}
					const { buffer: o$1, extent: s$1 } = this.workerOptions.geojsonVtOptions, n$1 = function({ x: e$2, y: i$2, z: a$2 }, r$2 = 0) {
						const o$2 = t.a3((e$2 - r$2) / Math.pow(2, a$2)), s$2 = t.a4((i$2 + 1 + r$2) / Math.pow(2, a$2)), n$2 = t.a3((e$2 + 1 + r$2) / Math.pow(2, a$2)), l$1 = t.a4((i$2 - r$2) / Math.pow(2, a$2));
						return new $$1([o$2, s$2], [n$2, l$1]);
					}(e$1.tileID.canonical, o$1 / s$1);
					for (const e$2 of i$1) if (n$1.intersects(e$2)) return !0;
					return !1;
				}
				loaded() {
					return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.actor ? "RT" : "LT";
						e$1.actor = this.actor;
						const i$1 = {
							type: this.type,
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							maxZoom: this.maxzoom,
							tileSize: this.tileSize,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity
						};
						e$1.abortController = new AbortController();
						const a$1 = yield this.actor.sendAsync({
							type: t$1,
							data: i$1
						}, e$1.abortController);
						delete e$1.abortController, e$1.unloadVectorData(), e$1.aborted || e$1.loadVectorData(a$1, this.map.painter, "RT" === t$1);
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.aborted = !0;
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), yield this.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						});
					}));
				}
				onRemove() {
					this._removed = !0, this.actor.sendAsync({
						type: "RS",
						data: {
							type: this.type,
							source: this.id
						}
					});
				}
				serialize() {
					return t.e({}, this._options, {
						type: this.type,
						data: this._data.updateable ? {
							type: "FeatureCollection",
							features: Array.from(this._data.updateable.values())
						} : this._data.url || this._data.geojson
					});
				}
				hasTransition() {
					return !1;
				}
			}
			class te$1 extends t.E {
				constructor(e$1, t$1, i$1, a$1) {
					super(), this.flippedWindingOrder = !1, this.id = e$1, this.dispatcher = i$1, this.coordinates = t$1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(a$1), this.options = t$1;
				}
				load(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
						try {
							const t$1 = yield g$1.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
							this._request = null, this._loaded = !0, t$1 && t$1.data && (this.image = t$1.data, e$1 && (this.coordinates = e$1), this._finishLoading());
						} catch (e$2) {
							this._request = null, this._loaded = !0, t.Z(e$2) || this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				updateImage(e$1) {
					return e$1.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e$1.url, this.load(e$1.coordinates).finally((() => {
						this.texture = null;
					})), this) : this;
				}
				_finishLoading() {
					this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "metadata"
					})));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._request && (this._request.abort(), this._request = null);
				}
				setCoordinates(e$1) {
					this.coordinates = e$1;
					const i$1 = e$1.map(t.ab.fromLngLat);
					var a$1;
					return this.tileID = function(e$2) {
						const i$2 = t.ac.fromPoints(e$2), a$2 = i$2.width(), r$1 = i$2.height(), o$1 = Math.max(a$2, r$1), s$1 = Math.max(0, Math.floor(-Math.log(o$1) / Math.LN2)), n$1 = Math.pow(2, s$1);
						return new t.ae(s$1, Math.floor((i$2.minX + i$2.maxX) / 2 * n$1), Math.floor((i$2.minY + i$2.maxY) / 2 * n$1));
					}(i$1), this.terrainTileRanges = this._getOverlappingTileRanges(i$1), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i$1.map(((e$2) => this.tileID.getTilePoint(e$2)._round())), this.flippedWindingOrder = ((a$1 = this.tileCoords)[1].x - a$1[0].x) * (a$1[2].y - a$1[0].y) - (a$1[1].y - a$1[0].y) * (a$1[2].x - a$1[0].x) < 0, this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "content"
					})), this;
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || !this.image) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture || (this.texture = new t.T(e$1, this.image, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let a$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, a$1 = !0);
					}
					a$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this.tileID && this.tileID.equals(e$1.tileID.canonical) ? (this.tiles[String(e$1.tileID.wrap)] = e$1, e$1.buckets = {}) : e$1.state = "errored";
					}));
				}
				serialize() {
					return {
						type: "image",
						url: this.options.url,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return !1;
				}
				_getOverlappingTileRanges(e$1) {
					const { minX: i$1, minY: a$1, maxX: r$1, maxY: o$1 } = t.ac.fromPoints(e$1), s$1 = {};
					for (let e$2 = 0; e$2 <= t.ad; e$2++) {
						const t$1 = Math.pow(2, e$2);
						s$1[e$2] = {
							minTileX: Math.floor(i$1 * t$1),
							minTileY: Math.floor(a$1 * t$1),
							maxTileX: Math.floor(r$1 * t$1),
							maxTileY: Math.floor(o$1 * t$1)
						};
					}
					return s$1;
				}
			}
			class ie$1 extends te$1 {
				constructor(e$1, t$1, i$1, a$1) {
					super(e$1, t$1, i$1, a$1), this.roundZoom = !0, this.type = "video", this.options = t$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1;
						const e$1 = this.options;
						this.urls = [];
						for (const t$1 of e$1.urls) this.urls.push(this.map._requestManager.transformRequest(t$1, "Source").url);
						try {
							const e$2 = yield t.af(this.urls);
							if (this._loaded = !0, !e$2) return;
							this.video = e$2, this.video.loop = !0, this.video.addEventListener("playing", (() => {
								this.map.triggerRepaint();
							})), this.map && this.video.play(), this._finishLoading();
						} catch (e$2) {
							this.fire(new t.k(e$2));
						}
					}));
				}
				pause() {
					this.video && this.video.pause();
				}
				play() {
					this.video && this.video.play();
				}
				seek(e$1) {
					if (this.video) {
						const i$1 = this.video.seekable;
						e$1 < i$1.start(0) || e$1 > i$1.end(0) ? this.fire(new t.k(new t.ag(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i$1.start(0)} and ${i$1.end(0)}-second mark.`))) : this.video.currentTime = e$1;
					}
				}
				getVideo() {
					return this.video;
				}
				onAdd(e$1) {
					this.map || (this.map = e$1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture ? this.video.paused || (this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE), i$1.texSubImage2D(i$1.TEXTURE_2D, 0, 0, 0, i$1.RGBA, i$1.UNSIGNED_BYTE, this.video)) : (this.texture = new t.T(e$1, this.video, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let a$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, a$1 = !0);
					}
					a$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "video",
						urls: this.urls,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this.video && !this.video.paused;
				}
			}
			class ae$1 extends te$1 {
				constructor(e$1, i$1, a$1, r$1) {
					super(e$1, i$1, a$1, r$1), i$1.coordinates ? Array.isArray(i$1.coordinates) && 4 === i$1.coordinates.length && !i$1.coordinates.some(((e$2) => !Array.isArray(e$2) || 2 !== e$2.length || e$2.some(((e$3) => "number" != typeof e$3)))) || this.fire(new t.k(new t.ag(`sources.${e$1}`, null, "\"coordinates\" property must be an array of 4 longitude/latitude array pairs"))) : this.fire(new t.k(new t.ag(`sources.${e$1}`, null, "missing required property \"coordinates\""))), i$1.animate && "boolean" != typeof i$1.animate && this.fire(new t.k(new t.ag(`sources.${e$1}`, null, "optional \"animate\" property must be a boolean value"))), i$1.canvas ? "string" == typeof i$1.canvas || i$1.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.ag(`sources.${e$1}`, null, "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance"))) : this.fire(new t.k(new t.ag(`sources.${e$1}`, null, "missing required property \"canvas\""))), this.options = i$1, this.animate = void 0 === i$1.animate || i$1.animate;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(/* @__PURE__ */ new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
							this._playing = !0, this.map.triggerRepaint();
						}, this.pause = function() {
							this._playing && (this.prepare(), this._playing = !1);
						}, this._finishLoading());
					}));
				}
				getCanvas() {
					return this.canvas;
				}
				onAdd(e$1) {
					this.map = e$1, this.load(), this.canvas && this.animate && this.play();
				}
				onRemove() {
					this.pause();
				}
				prepare() {
					let e$1 = !1;
					if (this.canvas.width !== this.width && (this.width = this.canvas.width, e$1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e$1 = !0), this._hasInvalidDimensions()) return;
					if (0 === Object.keys(this.tiles).length) return;
					const i$1 = this.map.painter.context, a$1 = i$1.gl;
					this.texture ? (e$1 || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : (this.texture = new t.T(i$1, this.canvas, a$1.RGBA, { premultiply: !0 }), this.texture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE));
					let r$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, r$1 = !0);
					}
					r$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "canvas",
						animate: this.animate,
						canvas: this.options.canvas,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this._playing;
				}
				_hasInvalidDimensions() {
					for (const e$1 of [this.canvas.width, this.canvas.height]) if (isNaN(e$1) || e$1 <= 0) return !0;
					return !1;
				}
			}
			const re$1 = {}, oe$1 = (e$1) => {
				switch (e$1) {
					case "geojson": return ee$1;
					case "image": return te$1;
					case "raster": return K$1;
					case "raster-dem": return Y$1;
					case "vector": return X;
					case "video": return ie$1;
					case "canvas": return ae$1;
				}
				return re$1[e$1];
			}, se$1 = "RTLPluginLoaded";
			class ne$1 extends t.E {
				constructor() {
					super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Z$1();
				}
				_syncState(e$1) {
					return this.status = e$1, this.dispatcher.broadcast("SRPS", {
						pluginStatus: e$1,
						pluginURL: this.url
					}).catch(((e$2) => {
						throw this.status = "error", e$2;
					}));
				}
				getRTLTextPluginStatus() {
					return this.status;
				}
				clearRTLTextPlugin() {
					this.status = "unavailable", this.url = null;
				}
				setRTLTextPlugin(e$1) {
					return t._(this, arguments, void 0, (function* (e$2, t$1 = !1) {
						if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
						if (this.url = n.resolveURL(e$2), !this.url) throw new Error(`requested url ${e$2} is invalid`);
						if ("unavailable" === this.status) {
							if (!t$1) return this._requestImport();
							this.status = "deferred", this._syncState(this.status);
						} else if ("requested" === this.status) return this._requestImport();
					}));
				}
				_requestImport() {
					return t._(this, void 0, void 0, (function* () {
						yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(se$1));
					}));
				}
				lazyLoad() {
					"unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
				}
			}
			let le$1 = null;
			function ce$1() {
				return le$1 || (le$1 = new ne$1()), le$1;
			}
			var he$1, ue$1;
			(function(e$1) {
				e$1[e$1.Base = 0] = "Base", e$1[e$1.Parent = 1] = "Parent";
			})(he$1 || (he$1 = {})), function(e$1) {
				e$1[e$1.Departing = 0] = "Departing", e$1[e$1.Incoming = 1] = "Incoming";
			}(ue$1 || (ue$1 = {}));
			class de$1 {
				constructor(e$1, i$1) {
					this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e$1, this.uid = t.ah(), this.uses = 0, this.tileSize = i$1, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
				}
				isRenderable(e$1) {
					return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e$1 || !this.holdingForSymbolFade());
				}
				setCrossFadeLogic({ fadingRole: e$1, fadingDirection: t$1, fadingParentID: i$1, fadeEndTime: a$1 }) {
					this.resetFadeLogic(), this.fadingRole = e$1, this.fadingDirection = t$1, this.fadingParentID = i$1, this.fadeEndTime = a$1;
				}
				setSelfFadeLogic(e$1) {
					this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e$1;
				}
				resetFadeLogic() {
					this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = c(), this.fadeEndTime = 0, this.fadeOpacity = 1;
				}
				wasRequested() {
					return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
				}
				clearTextures(e$1) {
					this.demTexture && e$1.saveTileTexture(this.demTexture), this.demTexture = null;
				}
				loadVectorData(e$1, i$1, a$1) {
					if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e$1) {
						e$1.featureIndex && (this.latestFeatureIndex = e$1.featureIndex, e$1.rawTileData ? (this.latestRawTileData = e$1.rawTileData, this.latestFeatureIndex.rawTileData = e$1.rawTileData, this.latestFeatureIndex.encoding = e$1.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = e$1.collisionBoxArray, this.buckets = function(e$2, t$1) {
							const i$2 = {};
							if (!t$1) return i$2;
							for (const a$2 of e$2) {
								const e$3 = a$2.layerIds.map(((e$4) => t$1.getLayer(e$4))).filter(Boolean);
								if (0 !== e$3.length) {
									a$2.layers = e$3, a$2.stateDependentLayerIds && (a$2.stateDependentLayers = a$2.stateDependentLayerIds.map(((t$2) => e$3.filter(((e$4) => e$4.id === t$2))[0])));
									for (const t$2 of e$3) i$2[t$2.id] = a$2;
								}
							}
							return i$2;
						}(e$1.buckets, null == i$1 ? void 0 : i$1.style), this.hasSymbolBuckets = !1;
						for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.aj) {
								if (this.hasSymbolBuckets = !0, !a$1) break;
								i$2.justReloaded = !0;
							}
						}
						if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.aj && i$2.hasRTLText) {
								this.hasRTLText = !0, ce$1().lazyLoad();
								break;
							}
						}
						this.queryPadding = 0;
						for (const e$2 in this.buckets) {
							const t$1 = this.buckets[e$2];
							this.queryPadding = Math.max(this.queryPadding, i$1.style.getLayer(e$2).queryRadius(t$1));
						}
						e$1.imageAtlas && (this.imageAtlas = e$1.imageAtlas), e$1.glyphAtlasImage && (this.glyphAtlasImage = e$1.glyphAtlasImage), this.dashPositions = e$1.dashPositions;
					} else this.collisionBoxArray = new t.ai();
				}
				unloadVectorData() {
					for (const e$1 in this.buckets) this.buckets[e$1].destroy();
					this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
				}
				getBucket(e$1) {
					return this.buckets[e$1.id];
				}
				upload(e$1) {
					for (const t$1 in this.buckets) {
						const i$2 = this.buckets[t$1];
						i$2.uploadPending() && i$2.upload(e$1);
					}
					const i$1 = e$1.gl;
					this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t.T(e$1, this.imageAtlas.image, i$1.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new t.T(e$1, this.glyphAtlasImage, i$1.ALPHA), this.glyphAtlasImage = null);
				}
				prepare(e$1) {
					this.imageAtlas && this.imageAtlas.patchUpdatedImages(e$1, this.imageAtlasTexture);
				}
				queryRenderedFeatures(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1) {
					return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
						queryGeometry: a$1,
						cameraQueryGeometry: r$1,
						scale: o$1,
						tileSize: this.tileSize,
						pixelPosMatrix: c$1,
						transform: n$1,
						params: s$1,
						queryPadding: this.queryPadding * l$1,
						getElevation: h$1
					}, e$1, t$1, i$1) : {};
				}
				querySourceFeatures(e$1, i$1) {
					const a$1 = this.latestFeatureIndex;
					if (!a$1 || !a$1.rawTileData) return;
					const r$1 = a$1.loadVTLayers(), o$1 = i$1 && i$1.sourceLayer ? i$1.sourceLayer : "", s$1 = r$1[t.aa] || r$1[o$1];
					if (!s$1) return;
					const n$1 = t.ak(null == i$1 ? void 0 : i$1.filter, null == i$1 ? void 0 : i$1.globalState), { z: l$1, x: c$1, y: h$1 } = this.tileID.canonical, u$1 = {
						z: l$1,
						x: c$1,
						y: h$1
					};
					for (let i$2 = 0; i$2 < s$1.length; i$2++) {
						const r$2 = s$1.feature(i$2);
						if (n$1.needGeometry) {
							const e$2 = t.al(r$2, !0);
							if (!n$1.filter(new t.H(this.tileID.overscaledZ), e$2, this.tileID.canonical)) continue;
						} else if (!n$1.filter(new t.H(this.tileID.overscaledZ), r$2)) continue;
						const d$1 = a$1.getId(r$2, o$1), _$2 = new t.am(r$2, l$1, c$1, h$1, d$1);
						_$2.tile = u$1, e$1.push(_$2);
					}
				}
				hasData() {
					return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
				}
				patternsLoaded() {
					return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
				}
				setExpiryData(e$1) {
					const i$1 = this.expirationTime;
					if (e$1.cacheControl) {
						const i$2 = t.an(e$1.cacheControl);
						i$2["max-age"] && (this.expirationTime = Date.now() + 1e3 * i$2["max-age"]);
					} else e$1.expires && (this.expirationTime = new Date(e$1.expires).getTime());
					if (this.expirationTime) {
						const e$2 = Date.now();
						let t$1 = !1;
						if (this.expirationTime > e$2) t$1 = !1;
						else if (i$1) if (this.expirationTime < i$1) t$1 = !0;
						else {
							const a$1 = this.expirationTime - i$1;
							a$1 ? this.expirationTime = e$2 + Math.max(a$1, 3e4) : t$1 = !0;
						}
						else t$1 = !0;
						t$1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
					}
				}
				getExpiryTimeout() {
					if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
				}
				setFeatureState(e$1, i$1) {
					if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e$1).length) return;
					const a$1 = this.latestFeatureIndex.loadVTLayers();
					for (const r$1 in this.buckets) {
						if (!i$1.style.hasLayer(r$1)) continue;
						const o$1 = this.buckets[r$1], s$1 = o$1.layers[0].sourceLayer || t.aa, n$1 = a$1[s$1], l$1 = e$1[s$1];
						if (!n$1 || !l$1 || 0 === Object.keys(l$1).length) continue;
						o$1.update(l$1, n$1, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
						const c$1 = i$1 && i$1.style && i$1.style.getLayer(r$1);
						c$1 && (this.queryPadding = Math.max(this.queryPadding, c$1.queryRadius(o$1)));
					}
				}
				holdingForSymbolFade() {
					return void 0 !== this.symbolFadeHoldUntil;
				}
				symbolFadeFinished() {
					return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < c();
				}
				clearSymbolFadeHold() {
					this.symbolFadeHoldUntil = void 0;
				}
				setSymbolHoldDuration(e$1) {
					this.symbolFadeHoldUntil = c() + e$1;
				}
				setDependencies(e$1, t$1) {
					const i$1 = {};
					for (const e$2 of t$1) i$1[e$2] = !0;
					this.dependencies[e$1] = i$1;
				}
				hasDependency(e$1, t$1) {
					for (const i$1 of e$1) {
						const e$2 = this.dependencies[i$1];
						if (e$2) {
							for (const i$2 of t$1) if (e$2[i$2]) return !0;
						}
					}
					return !1;
				}
			}
			class _e$1 {
				constructor() {
					this.state = {}, this.stateChanges = {}, this.deletedStates = {};
				}
				updateState(e$1, i$1, a$1) {
					const r$1 = String(i$1);
					if (this.stateChanges[e$1] = this.stateChanges[e$1] || {}, this.stateChanges[e$1][r$1] = this.stateChanges[e$1][r$1] || {}, t.e(this.stateChanges[e$1][r$1], a$1), null === this.deletedStates[e$1]) {
						this.deletedStates[e$1] = {};
						for (const t$1 in this.state[e$1]) t$1 !== r$1 && (this.deletedStates[e$1][t$1] = null);
					} else if (this.deletedStates[e$1] && null === this.deletedStates[e$1][r$1]) {
						this.deletedStates[e$1][r$1] = {};
						for (const t$1 in this.state[e$1][r$1]) a$1[t$1] || (this.deletedStates[e$1][r$1][t$1] = null);
					} else for (const t$1 in a$1) this.deletedStates[e$1] && this.deletedStates[e$1][r$1] && null === this.deletedStates[e$1][r$1][t$1] && delete this.deletedStates[e$1][r$1][t$1];
				}
				removeFeatureState(e$1, t$1, i$1) {
					if (null === this.deletedStates[e$1]) return;
					const a$1 = String(t$1);
					if (this.deletedStates[e$1] = this.deletedStates[e$1] || {}, i$1 && void 0 !== t$1) null !== this.deletedStates[e$1][a$1] && (this.deletedStates[e$1][a$1] = this.deletedStates[e$1][a$1] || {}, this.deletedStates[e$1][a$1][i$1] = null);
					else if (void 0 !== t$1) if (this.stateChanges[e$1] && this.stateChanges[e$1][a$1]) for (i$1 in this.deletedStates[e$1][a$1] = {}, this.stateChanges[e$1][a$1]) this.deletedStates[e$1][a$1][i$1] = null;
					else this.deletedStates[e$1][a$1] = null;
					else this.deletedStates[e$1] = null;
				}
				getState(e$1, i$1) {
					const a$1 = String(i$1), r$1 = t.e({}, (this.state[e$1] || {})[a$1], (this.stateChanges[e$1] || {})[a$1]);
					if (null === this.deletedStates[e$1]) return {};
					if (this.deletedStates[e$1]) {
						const t$1 = this.deletedStates[e$1][i$1];
						if (null === t$1) return {};
						for (const e$2 in t$1) delete r$1[e$2];
					}
					return r$1;
				}
				initializeTileState(e$1, t$1) {
					e$1.setFeatureState(this.state, t$1);
				}
				coalesceChanges(e$1, i$1) {
					const a$1 = {};
					for (const e$2 in this.stateChanges) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						for (const a$2 in this.stateChanges[e$2]) this.state[e$2][a$2] || (this.state[e$2][a$2] = {}), t.e(this.state[e$2][a$2], this.stateChanges[e$2][a$2]), i$2[a$2] = this.state[e$2][a$2];
						a$1[e$2] = i$2;
					}
					for (const e$2 in this.deletedStates) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						if (null === this.deletedStates[e$2]) for (const t$1 in this.state[e$2]) i$2[t$1] = {}, this.state[e$2][t$1] = {};
						else for (const t$1 in this.deletedStates[e$2]) {
							if (null === this.deletedStates[e$2][t$1]) this.state[e$2][t$1] = {};
							else for (const i$3 of Object.keys(this.deletedStates[e$2][t$1])) delete this.state[e$2][t$1][i$3];
							i$2[t$1] = this.state[e$2][t$1];
						}
						a$1[e$2] = a$1[e$2] || {}, t.e(a$1[e$2], i$2);
					}
					this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(a$1).length && e$1.setFeatureState(a$1, i$1);
				}
			}
			const pe$1 = 89.25;
			function me$1(e$1, i$1) {
				const a$1 = t.ao(i$1.lat, -t.ap, t.ap);
				return new t.P(t.Y(i$1.lng) * e$1, t.X(a$1) * e$1);
			}
			function fe$1(e$1, i$1) {
				return new t.ab(i$1.x / e$1, i$1.y / e$1).toLngLat();
			}
			function ge(e$1) {
				return e$1.cameraToCenterDistance * Math.min(.85 * Math.tan(t.aq(90 - e$1.pitch)), Math.tan(t.aq(pe$1 - e$1.pitch)));
			}
			function ve$1(e$1, i$1) {
				const a$1 = e$1.canonical, r$1 = i$1 / t.ar(a$1.z), o$1 = a$1.x + Math.pow(2, a$1.z) * e$1.wrap, s$1 = t.as(new Float64Array(16));
				return t.O(s$1, s$1, [
					o$1 * r$1,
					a$1.y * r$1,
					0
				]), t.Q(s$1, s$1, [
					r$1 / t.a5,
					r$1 / t.a5,
					1
				]), s$1;
			}
			function xe$1(e$1, i$1, a$1, r$1, o$1) {
				const s$1 = t.ab.fromLngLat(e$1, i$1), n$1 = o$1 * t.at(1, e$1.lat), { x: l$1, y: c$1, z: h$1 } = be$1(a$1, r$1);
				return new t.ab(s$1.x + n$1 * -l$1, s$1.y + n$1 * -c$1, s$1.z + n$1 * -h$1);
			}
			function be$1(e$1, i$1) {
				const a$1 = t.aq(e$1), r$1 = t.aq(i$1), o$1 = Math.cos(-a$1), s$1 = Math.sin(a$1);
				return {
					x: s$1 * Math.sin(r$1),
					y: -s$1 * Math.cos(r$1),
					z: o$1
				};
			}
			function ye$1(e$1, t$1, i$1) {
				const a$1 = t$1.intersectsFrustum(e$1);
				if (!i$1 || 0 === a$1) return a$1;
				const r$1 = t$1.intersectsPlane(i$1);
				return 0 === r$1 ? 0 : 2 === a$1 && 2 === r$1 ? 2 : 1;
			}
			function we$1(e$1, t$1, i$1) {
				let a$1 = 0;
				const r$1 = (i$1 - t$1) / 10;
				for (let o$1 = 0; o$1 < 10; o$1++) a$1 += r$1 * Math.pow(Math.cos(t$1 + (o$1 + .5) / 10 * (i$1 - t$1)), e$1);
				return a$1;
			}
			function Te$1(e$1, i$1) {
				return function(a$1, r$1, o$1, s$1, n$1) {
					const l$1 = 2 * ((e$1 - 1) / t.au(Math.cos(t.aq(pe$1 - n$1)) / Math.cos(t.aq(pe$1))) - 1), c$1 = Math.acos(o$1 / s$1), h$1 = 2 * we$1(l$1 - 1, 0, t.aq(n$1 / 2)), u$1 = Math.min(t.aq(pe$1), c$1 + t.aq(n$1 / 2)), d$1 = we$1(l$1 - 1, Math.min(u$1, c$1 - t.aq(n$1 / 2)), u$1), _$2 = Math.atan(r$1 / o$1), p$1 = Math.hypot(r$1, o$1);
					let m$1 = a$1;
					return m$1 += t.au(s$1 / p$1 / Math.max(.5, Math.cos(t.aq(n$1 / 2)))), m$1 += l$1 * t.au(Math.cos(_$2)) / 2, m$1 -= t.au(Math.max(1, d$1 / h$1 / i$1)) / 2, m$1;
				};
			}
			const Pe$1 = Te$1(9.314, 3);
			function Ie$1(e$1, i$1) {
				const a$1 = (i$1.roundZoom ? Math.round : Math.floor)(e$1.zoom + t.au(e$1.tileSize / i$1.tileSize));
				return Math.max(0, a$1);
			}
			function Ce$1(e$1, i$1) {
				const a$1 = e$1.getCameraFrustum(), r$1 = e$1.getClippingPlane(), o$1 = e$1.screenPointToMercatorCoordinate(e$1.getCameraPoint()), s$1 = t.ab.fromLngLat(e$1.center, e$1.elevation);
				o$1.z = s$1.z + Math.cos(e$1.pitchInRadians) * e$1.cameraToCenterDistance / e$1.worldSize;
				const n$1 = e$1.getCoveringTilesDetailsProvider(), l$1 = n$1.allowVariableZoom(e$1, i$1), c$1 = Ie$1(e$1, i$1), h$1 = i$1.minzoom || 0, u$1 = void 0 !== i$1.maxzoom ? i$1.maxzoom : e$1.maxZoom, d$1 = Math.min(Math.max(0, c$1), u$1), _$2 = Math.pow(2, d$1), p$1 = [
					_$2 * o$1.x,
					_$2 * o$1.y,
					0
				], m$1 = [
					_$2 * s$1.x,
					_$2 * s$1.y,
					0
				], f$1 = Math.hypot(s$1.x - o$1.x, s$1.y - o$1.y), g$2 = Math.abs(s$1.z - o$1.z), v$1 = Math.hypot(f$1, g$2), x$1 = (e$2) => ({
					zoom: 0,
					x: 0,
					y: 0,
					wrap: e$2,
					fullyVisible: !1
				}), b$1 = [], y$1 = [];
				if (e$1.renderWorldCopies && n$1.allowWorldCopies()) for (let e$2 = 1; e$2 <= 3; e$2++) b$1.push(x$1(-e$2)), b$1.push(x$1(e$2));
				for (b$1.push(x$1(0)); b$1.length > 0;) {
					const _$3 = b$1.pop(), f$2 = _$3.x, x$2 = _$3.y;
					let w$2 = _$3.fullyVisible;
					const T$1 = {
						x: f$2,
						y: x$2,
						z: _$3.zoom
					}, P$2 = n$1.getTileBoundingVolume(T$1, _$3.wrap, e$1.elevation, i$1);
					if (!w$2) {
						const e$2 = ye$1(a$1, P$2, r$1);
						if (0 === e$2) continue;
						w$2 = 2 === e$2;
					}
					const I$2 = n$1.distanceToTile2d(o$1.x, o$1.y, T$1, P$2);
					let C$1 = c$1;
					l$1 && (C$1 = (i$1.calculateTileZoom || Pe$1)(e$1.zoom + t.au(e$1.tileSize / i$1.tileSize), I$2, g$2, v$1, e$1.fov)), C$1 = (i$1.roundZoom ? Math.round : Math.floor)(C$1), C$1 = Math.max(0, C$1);
					const M$2 = Math.min(C$1, u$1);
					if (_$3.wrap = n$1.getWrap(s$1, T$1, _$3.wrap), _$3.zoom >= M$2) {
						if (_$3.zoom < h$1) continue;
						const e$2 = d$1 - _$3.zoom, a$2 = p$1[0] - .5 - (f$2 << e$2), r$2 = p$1[1] - .5 - (x$2 << e$2), o$2 = i$1.reparseOverscaled ? Math.max(_$3.zoom, C$1) : _$3.zoom;
						y$1.push({
							tileID: new t.a2(_$3.zoom === u$1 ? o$2 : _$3.zoom, _$3.wrap, _$3.zoom, f$2, x$2),
							distanceSq: t.av([m$1[0] - .5 - f$2, m$1[1] - .5 - x$2]),
							tileDistanceToCamera: Math.sqrt(a$2 * a$2 + r$2 * r$2)
						});
					} else for (let e$2 = 0; e$2 < 4; e$2++) b$1.push({
						zoom: _$3.zoom + 1,
						x: (f$2 << 1) + e$2 % 2,
						y: (x$2 << 1) + (e$2 >> 1),
						wrap: _$3.wrap,
						fullyVisible: w$2
					});
				}
				return y$1.sort(((e$2, t$1) => e$2.distanceSq - t$1.distanceSq)).map(((e$2) => e$2.tileID));
			}
			const Me$1 = t.ac.fromPoints([new t.P(0, 0), new t.P(t.a5, t.a5)]);
			function Ee$1(e$1) {
				return "raster" === e$1 || "image" === e$1 || "video" === e$1;
			}
			function Se$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1) {
				if (!t$1.hasData()) return !1;
				const { tileID: n$1, fadingRole: l$1, fadingDirection: c$1, fadingParentID: h$1 } = t$1;
				if (l$1 === he$1.Base && c$1 === ue$1.Incoming && h$1) return i$1[h$1.key] = h$1, !0;
				const u$1 = Math.max(n$1.overscaledZ - r$1, o$1);
				for (let r$2 = n$1.overscaledZ - 1; r$2 >= u$1; r$2--) {
					const o$2 = n$1.scaledTo(r$2), l$2 = e$1.getLoadedTile(o$2);
					if (l$2) return t$1.setCrossFadeLogic({
						fadingRole: he$1.Base,
						fadingDirection: ue$1.Incoming,
						fadingParentID: l$2.tileID,
						fadeEndTime: a$1 + s$1
					}), l$2.setCrossFadeLogic({
						fadingRole: he$1.Parent,
						fadingDirection: ue$1.Departing,
						fadeEndTime: a$1 + s$1
					}), i$1[o$2.key] = o$2, !0;
				}
				return !1;
			}
			function Re$1(e$1, t$1, i$1, a$1, r$1, o$1) {
				if (!t$1.hasData()) return !1;
				const s$1 = t$1.tileID.children(r$1);
				let n$1 = ze$1(e$1, t$1, s$1, i$1, a$1, r$1, o$1);
				if (n$1) return !0;
				for (const l$1 of s$1) ze$1(e$1, t$1, l$1.children(r$1), i$1, a$1, r$1, o$1) && (n$1 = !0);
				return n$1;
			}
			function ze$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1) {
				if (i$1[0].overscaledZ >= o$1) return !1;
				let n$1 = !1;
				for (const o$2 of i$1) {
					const i$2 = e$1.getLoadedTile(o$2);
					if (!i$2) continue;
					const { fadingRole: l$1, fadingDirection: c$1, fadingParentID: h$1 } = i$2;
					l$1 === he$1.Base && c$1 === ue$1.Departing && h$1 || (i$2.setCrossFadeLogic({
						fadingRole: he$1.Base,
						fadingDirection: ue$1.Departing,
						fadingParentID: t$1.tileID,
						fadeEndTime: r$1 + s$1
					}), t$1.setCrossFadeLogic({
						fadingRole: he$1.Parent,
						fadingDirection: ue$1.Incoming,
						fadeEndTime: r$1 + s$1
					})), a$1[o$2.key] = o$2, n$1 = !0;
				}
				return n$1;
			}
			function De$1(e$1, t$1, i$1, a$1) {
				const r$1 = e$1.tileID;
				return !!e$1.selfFading || !e$1.hasData() && !!t$1.has(r$1) && (e$1.setSelfFadeLogic(i$1 + a$1), !0);
			}
			function Ae$1(e$1, t$1) {
				var i$1;
				e$1.needsHillshadePrepare = !0, e$1.needsTerrainPrepare = !0;
				let a$1 = t$1.tileID.canonical.x - e$1.tileID.canonical.x;
				const r$1 = t$1.tileID.canonical.y - e$1.tileID.canonical.y, o$1 = Math.pow(2, e$1.tileID.canonical.z), s$1 = t$1.tileID.key;
				0 === a$1 && 0 === r$1 || Math.abs(r$1) > 1 || (Math.abs(a$1) > 1 && (1 === Math.abs(a$1 + o$1) ? a$1 += o$1 : 1 === Math.abs(a$1 - o$1) && (a$1 -= o$1)), t$1.dem && e$1.dem && (e$1.dem.backfillBorder(t$1.dem, a$1, r$1), !(null === (i$1 = e$1.neighboringTiles) || void 0 === i$1) && i$1[s$1] && (e$1.neighboringTiles[s$1].backfilled = !0)));
			}
			class Le$1 {
				constructor() {
					this._tiles = {};
				}
				handleWrapJump(e$1) {
					const t$1 = {};
					for (const i$1 in this._tiles) {
						const a$1 = this._tiles[i$1];
						a$1.tileID = a$1.tileID.unwrapTo(a$1.tileID.wrap + e$1), t$1[a$1.tileID.key] = a$1;
					}
					this._tiles = t$1;
				}
				setFeatureState(e$1, t$1) {
					for (const i$1 in this._tiles) this._tiles[i$1].setFeatureState(e$1, t$1);
				}
				getAllTiles() {
					return Object.values(this._tiles);
				}
				getAllIds(e$1 = !1) {
					return e$1 ? Object.values(this._tiles).map(((e$2) => e$2.tileID)).sort(t.ax).map(((e$2) => e$2.key)) : Object.keys(this._tiles);
				}
				getTileById(e$1) {
					return this._tiles[e$1];
				}
				setTile(e$1, t$1) {
					this._tiles[e$1] = t$1;
				}
				deleteTileById(e$1) {
					delete this._tiles[e$1];
				}
				getLoadedTile(e$1) {
					const t$1 = this.getTileById(e$1.key);
					return (null == t$1 ? void 0 : t$1.hasData()) ? t$1 : null;
				}
				isIdRenderable(e$1, t$1 = !1) {
					var i$1;
					return null === (i$1 = this.getTileById(e$1)) || void 0 === i$1 ? void 0 : i$1.isRenderable(t$1);
				}
				getRenderableIds(e$1 = 0, i$1) {
					const a$1 = [];
					for (const e$2 of this.getAllIds()) this.isIdRenderable(e$2, i$1) && a$1.push(this.getTileById(e$2));
					return i$1 ? a$1.sort(((i$2, a$2) => {
						const r$1 = i$2.tileID, o$1 = a$2.tileID, s$1 = new t.P(r$1.canonical.x, r$1.canonical.y)._rotate(-e$1), n$1 = new t.P(o$1.canonical.x, o$1.canonical.y)._rotate(-e$1);
						return r$1.overscaledZ - o$1.overscaledZ || n$1.y - s$1.y || n$1.x - s$1.x;
					})).map(((e$2) => e$2.tileID.key)) : a$1.map(((e$2) => e$2.tileID)).sort(t.ax).map(((e$2) => e$2.key));
				}
			}
			class ke$1 extends t.E {
				constructor(e$1, i$1, a$1) {
					super(), this.id = e$1, this.dispatcher = a$1, this.on("data", ((e$2) => this._dataHandler(e$2))), this.on("dataloading", (() => {
						this._sourceErrored = !1;
					})), this.on("error", (() => {
						this._sourceErrored = this._source.loaded();
					})), this._source = ((e$2, t$1, i$2, a$2) => {
						const r$1 = new (oe$1(t$1.type))(e$2, t$1, i$2, a$2);
						if (r$1.id !== e$2) throw new Error(`Expected Source id to be ${e$2} instead of ${r$1.id}`);
						return r$1;
					})(e$1, i$1, a$1, this), this._inViewTiles = new Le$1(), this._outOfViewCache = new t.ay(0, ((e$2) => this._unloadTile(e$2))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new _e$1(), this._didEmitContent = !1, this._updated = !1;
				}
				onAdd(e$1) {
					this.map = e$1, this._maxTileCacheSize = e$1 ? e$1._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e$1 ? e$1._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e$1);
				}
				onRemove(e$1) {
					for (const e$2 of this._inViewTiles.getAllTiles()) e$2.unloadVectorData();
					this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e$1), this._inViewTiles = new Le$1();
				}
				loaded() {
					if (this._sourceErrored) return !0;
					if (!this._sourceLoaded) return !1;
					if (!this._source.loaded()) return !1;
					if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return !0;
					if (!this._updated) return !1;
					for (const e$1 of this._inViewTiles.getAllTiles()) if ("loaded" !== e$1.state && "errored" !== e$1.state) return !1;
					return !0;
				}
				getSource() {
					return this._source;
				}
				getState() {
					return this._state;
				}
				pause() {
					this._paused = !0;
				}
				resume() {
					if (!this._paused) return;
					const e$1 = this._shouldReloadOnResume;
					this._paused = !1, this._shouldReloadOnResume = !1, e$1 && this.reload(), this.transform && this.update(this.transform, this.terrain);
				}
				_loadTile(e$1, i$1, a$1) {
					return t._(this, void 0, void 0, (function* () {
						try {
							yield this._source.loadTile(e$1), this._tileLoaded(e$1, i$1, a$1);
						} catch (i$2) {
							e$1.state = "errored", 404 !== i$2.status ? this._source.fire(new t.k(i$2, { tile: e$1 })) : this.update(this.transform, this.terrain);
						}
					}));
				}
				_unloadTile(e$1) {
					this._source.unloadTile && this._source.unloadTile(e$1);
				}
				_abortTile(e$1) {
					this._source.abortTile && this._source.abortTile(e$1), this._source.fire(new t.l("dataabort", {
						tile: e$1,
						coord: e$1.tileID,
						dataType: "source"
					}));
				}
				serialize() {
					return this._source.serialize();
				}
				prepare(e$1) {
					this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._inViewTiles, this.map ? this.map.painter : null);
					for (const t$1 of this._inViewTiles.getAllTiles()) t$1.upload(e$1), t$1.prepare(this.map.style.imageManager);
				}
				getIds() {
					return this._inViewTiles.getAllIds(!0);
				}
				getRenderableIds(e$1) {
					var t$1;
					return this._inViewTiles.getRenderableIds(null === (t$1 = this.transform) || void 0 === t$1 ? void 0 : t$1.bearingInRadians, e$1);
				}
				hasRenderableParent(e$1) {
					const t$1 = e$1.overscaledZ - 1;
					if (t$1 >= this._source.minzoom) {
						const i$1 = this.getLoadedTile(e$1.scaledTo(t$1));
						if (i$1) return this._inViewTiles.isIdRenderable(i$1.tileID.key);
					}
					return !1;
				}
				reload(e$1, t$1 = void 0) {
					if (this._paused) this._shouldReloadOnResume = !0;
					else {
						this._outOfViewCache.reset();
						for (const i$1 of this._inViewTiles.getAllIds()) {
							const a$1 = this._inViewTiles.getTileById(i$1);
							t$1 && !this._source.shouldReloadTile(a$1, t$1) || (e$1 ? this._reloadTile(i$1, "expired") : "errored" !== a$1.state && this._reloadTile(i$1, "reloading"));
						}
					}
				}
				_reloadTile(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = this._inViewTiles.getTileById(e$1);
						t$1 && ("loading" !== t$1.state && (t$1.state = i$1), yield this._loadTile(t$1, e$1, i$1));
					}));
				}
				_tileLoaded(e$1, i$1, a$1) {
					e$1.timeAdded = c(), e$1.selfFading && (e$1.fadeEndTime = e$1.timeAdded + this._rasterFadeDuration), "expired" === a$1 && (e$1.refreshedUponExpiration = !0), this._setTileReloadTimer(i$1, e$1), "raster-dem" === this.getSource().type && e$1.dem && function(e$2, t$1) {
						var i$2, a$2;
						const r$1 = t$1.getRenderableIds();
						for (const o$1 of r$1) {
							if (!e$2.neighboringTiles || !e$2.neighboringTiles[o$1]) continue;
							const r$2 = t$1.getTileById(o$1);
							e$2.neighboringTiles[o$1].backfilled || Ae$1(e$2, r$2), !(null === (a$2 = null === (i$2 = r$2.neighboringTiles) || void 0 === i$2 ? void 0 : i$2[e$2.tileID.key]) || void 0 === a$2) && a$2.backfilled || Ae$1(r$2, e$2);
						}
					}(e$1, this._inViewTiles), this._state.initializeTileState(e$1, this.map ? this.map.painter : null), e$1.aborted || this._source.fire(new t.l("data", {
						dataType: "source",
						tile: e$1,
						coord: e$1.tileID
					}));
				}
				getTile(e$1) {
					return this.getTileByID(e$1.key);
				}
				getTileByID(e$1) {
					return this._inViewTiles.getTileById(e$1);
				}
				_retainLoadedChildren(e$1, t$1) {
					const i$1 = this._getLoadedDescendents(t$1), a$1 = /* @__PURE__ */ new Set();
					for (const r$1 of t$1) {
						const t$2 = i$1[r$1.key];
						if (!(null == t$2 ? void 0 : t$2.length)) {
							a$1.add(r$1);
							continue;
						}
						const o$1 = r$1.overscaledZ + ke$1.maxOverzooming, s$1 = t$2.filter(((e$2) => e$2.tileID.overscaledZ <= o$1));
						if (!s$1.length) {
							a$1.add(r$1);
							continue;
						}
						const n$1 = Math.min(...s$1.map(((e$2) => e$2.tileID.overscaledZ))), l$1 = s$1.filter(((e$2) => e$2.tileID.overscaledZ === n$1)).map(((e$2) => e$2.tileID));
						for (const t$3 of l$1) e$1[t$3.key] = t$3;
						this._areDescendentsComplete(l$1, n$1, r$1.overscaledZ) || a$1.add(r$1);
					}
					return a$1;
				}
				_getLoadedDescendents(e$1) {
					var t$1;
					const i$1 = {};
					for (const a$1 of this._inViewTiles.getAllTiles().filter(((e$2) => e$2.hasData()))) for (const r$1 of e$1) a$1.tileID.isChildOf(r$1) && (i$1[t$1 = r$1.key] || (i$1[t$1] = [])).push(a$1);
					return i$1;
				}
				_areDescendentsComplete(e$1, t$1, i$1) {
					return 1 === e$1.length && e$1[0].isOverscaled() ? e$1[0].overscaledZ === t$1 : Math.pow(4, t$1 - i$1) === e$1.length;
				}
				getLoadedTile(e$1) {
					return this._inViewTiles.getLoadedTile(e$1);
				}
				updateCacheSize(e$1) {
					const i$1 = Math.ceil(e$1.width / this._source.tileSize) + 1, a$1 = Math.ceil(e$1.height / this._source.tileSize) + 1, r$1 = Math.floor(i$1 * a$1 * (null === this._maxTileCacheZoomLevels ? t.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o$1 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r$1) : r$1;
					this._outOfViewCache.setMaxSize(o$1);
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - (void 0 === this._prevLng ? e$1 : this._prevLng)) / 360);
					this._prevLng = e$1, t$1 && (this._inViewTiles.handleWrapJump(t$1), this._resetTileReloadTimers());
				}
				update(e$1, i$1) {
					if (!this._sourceLoaded || this._paused) return;
					let a$1;
					this.transform = e$1, this.terrain = i$1, this.updateCacheSize(e$1), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? a$1 = e$1.getVisibleUnwrappedCoordinates(this._source.tileID).map(((e$2) => new t.a2(e$2.canonical.z, e$2.wrap, e$2.canonical.z, e$2.canonical.x, e$2.canonical.y))) : (a$1 = Ce$1(e$1, {
						tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
						minzoom: this._source.minzoom,
						maxzoom: "vector" === this._source.type && void 0 !== this.map._zoomLevelsToOverscale ? e$1.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom,
						roundZoom: !this.usedForTerrain && this._source.roundZoom,
						reparseOverscaled: this._source.reparseOverscaled,
						terrain: i$1,
						calculateTileZoom: this._source.calculateTileZoom
					}), this._source.hasTile && (a$1 = a$1.filter(((e$2) => this._source.hasTile(e$2))))) : a$1 = [], this.usedForTerrain && (a$1 = this._addTerrainIdealTiles(a$1));
					const r$1 = 0 === a$1.length && !this._updated && this._didEmitContent;
					this._updated = !0, r$1 && this.fire(new t.l("data", {
						sourceDataType: "idle",
						dataType: "source",
						sourceId: this.id
					}));
					const o$1 = Ie$1(e$1, this._source), s$1 = this._updateRetainedTiles(a$1, o$1), n$1 = Ee$1(this._source.type);
					n$1 && this._rasterFadeDuration > 0 && !i$1 && function(e$2, i$2, a$2, r$2, o$2, s$2, n$2) {
						const l$1 = c(), h$1 = t.aw(i$2);
						for (const t$1 of i$2) {
							const i$3 = e$2.getTileById(t$1.key);
							i$3.fadingDirection !== ue$1.Departing && 0 !== i$3.fadeOpacity || i$3.resetFadeLogic(), Se$1(e$2, i$3, a$2, l$1, r$2, o$2, n$2) || Re$1(e$2, i$3, a$2, l$1, s$2, n$2) || De$1(i$3, h$1, l$1, n$2) || i$3.resetFadeLogic();
						}
					}(this._inViewTiles, a$1, s$1, this._maxFadingAncestorLevels, this._source.minzoom, this._source.maxzoom, this._rasterFadeDuration), n$1 ? this._cleanUpRasterTiles(s$1) : this._cleanUpVectorTiles(s$1);
				}
				_cleanUpRasterTiles(e$1) {
					for (const t$1 of this._inViewTiles.getAllIds()) e$1[t$1] || this._removeTile(t$1);
				}
				_cleanUpVectorTiles(e$1) {
					for (const t$1 of this._inViewTiles.getAllIds()) {
						const i$1 = this._inViewTiles.getTileById(t$1);
						e$1[t$1] ? i$1.clearSymbolFadeHold() : i$1.hasSymbolBuckets ? i$1.holdingForSymbolFade() ? i$1.symbolFadeFinished() && this._removeTile(t$1) : i$1.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(t$1);
					}
				}
				_addTerrainIdealTiles(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) if (i$1.canonical.z > this._source.minzoom) {
						const e$2 = i$1.scaledTo(i$1.canonical.z - 1);
						t$1.push(e$2);
						const a$1 = i$1.scaledTo(Math.max(this._source.minzoom, Math.min(i$1.canonical.z, 5)));
						t$1.push(a$1);
					}
					return e$1.concat(t$1);
				}
				releaseSymbolFadeTiles() {
					for (const e$1 of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(e$1).holdingForSymbolFade() && this._removeTile(e$1);
				}
				_updateRetainedTiles(e$1, t$1) {
					var i$1;
					const a$1 = /* @__PURE__ */ new Set();
					for (const t$2 of e$1) this._addTile(t$2).hasData() || a$1.add(t$2);
					const r$1 = e$1.reduce(((e$2, t$2) => (e$2[t$2.key] = t$2, e$2)), {}), o$1 = this._retainLoadedChildren(r$1, a$1), s$1 = {}, n$1 = Math.max(t$1 - ke$1.maxUnderzooming, this._source.minzoom);
					for (const e$2 of o$1) {
						let t$2 = this._inViewTiles.getTileById(e$2.key), a$2 = null == t$2 ? void 0 : t$2.wasRequested();
						for (let o$2 = e$2.overscaledZ - 1; o$2 >= n$1; --o$2) {
							const n$2 = e$2.scaledTo(o$2);
							if (s$1[n$2.key]) break;
							if (s$1[n$2.key] = !0, t$2 = this.getTile(n$2), !t$2 && a$2 && (t$2 = this._addTile(n$2)), t$2) {
								const e$3 = t$2.hasData();
								if ((e$3 || !(null === (i$1 = this.map) || void 0 === i$1 ? void 0 : i$1.cancelPendingTileRequestsWhileZooming) || a$2) && (r$1[n$2.key] = n$2), a$2 = t$2.wasRequested(), e$3) break;
							}
						}
					}
					return r$1;
				}
				_addTile(e$1) {
					let i$1 = this._inViewTiles.getTileById(e$1.key);
					if (i$1) return i$1;
					i$1 = this._outOfViewCache.getAndRemove(e$1), i$1 && (i$1.resetFadeLogic(), this._setTileReloadTimer(e$1.key, i$1), i$1.tileID = e$1, this._state.initializeTileState(i$1, this.map ? this.map.painter : null));
					const a$1 = i$1;
					return i$1 || (i$1 = new de$1(e$1, this._source.tileSize * e$1.overscaleFactor()), this._loadTile(i$1, e$1.key, i$1.state)), i$1.uses++, this._inViewTiles.setTile(e$1.key, i$1), a$1 || this._source.fire(new t.l("dataloading", {
						tile: i$1,
						coord: i$1.tileID,
						dataType: "source"
					})), i$1;
				}
				_setTileReloadTimer(e$1, t$1) {
					this._clearTileReloadTimer(e$1);
					const i$1 = t$1.getExpiryTimeout();
					i$1 && (this._timers[e$1] = setTimeout((() => {
						this._reloadTile(e$1, "expired"), delete this._timers[e$1];
					}), i$1));
				}
				_clearTileReloadTimer(e$1) {
					const t$1 = this._timers[e$1];
					t$1 && (clearTimeout(t$1), delete this._timers[e$1]);
				}
				_resetTileReloadTimers() {
					for (const e$1 in this._timers) clearTimeout(this._timers[e$1]), delete this._timers[e$1];
					for (const e$1 of this._inViewTiles.getAllIds()) {
						const t$1 = this._inViewTiles.getTileById(e$1);
						this._setTileReloadTimer(e$1, t$1);
					}
				}
				refreshTiles(e$1) {
					for (const t$1 of this._inViewTiles.getAllIds()) {
						const i$1 = this._inViewTiles.getTileById(t$1);
						(this._inViewTiles.isIdRenderable(t$1) || "errored" == i$1.state) && e$1.some(((e$2) => e$2.equals(i$1.tileID.canonical))) && this._reloadTile(t$1, "expired");
					}
				}
				_removeTile(e$1) {
					const t$1 = this._inViewTiles.getTileById(e$1);
					t$1 && (t$1.uses--, this._inViewTiles.deleteTileById(e$1), this._clearTileReloadTimer(e$1), t$1.uses > 0 || (t$1.hasData() && "reloading" !== t$1.state ? this._outOfViewCache.add(t$1.tileID, t$1, t$1.getExpiryTimeout()) : (t$1.aborted = !0, this._abortTile(t$1), this._unloadTile(t$1))));
				}
				_dataHandler(e$1) {
					"source" === e$1.dataType && ("metadata" !== e$1.sourceDataType ? "content" === e$1.sourceDataType && this._sourceLoaded && !this._paused && (this.reload(e$1.sourceDataChanged, e$1.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0);
				}
				clearTiles() {
					this._shouldReloadOnResume = !1, this._paused = !1;
					for (const e$1 of this._inViewTiles.getAllIds()) this._removeTile(e$1);
					this._outOfViewCache.reset();
				}
				tilesIn(e$1, i$1, a$1) {
					const r$1 = [], o$1 = this.transform;
					if (!o$1) return r$1;
					const s$1 = o$1.getCoveringTilesDetailsProvider().allowWorldCopies(), n$1 = a$1 ? o$1.getCameraQueryGeometry(e$1) : e$1, l$1 = (e$2) => o$1.screenPointToMercatorCoordinate(e$2, this.terrain), c$1 = this.transformBbox(e$1, l$1, !s$1), h$1 = this.transformBbox(n$1, l$1, !s$1), u$1 = this.getIds(), d$1 = t.ac.fromPoints(h$1);
					for (let e$2 = 0; e$2 < u$1.length; e$2++) {
						const a$2 = this._inViewTiles.getTileById(u$1[e$2]);
						if (a$2.holdingForSymbolFade()) continue;
						const n$2 = s$1 ? [a$2.tileID] : [a$2.tileID.unwrapTo(-1), a$2.tileID.unwrapTo(0)], l$2 = Math.pow(2, o$1.zoom - a$2.tileID.overscaledZ), _$2 = i$1 * a$2.queryPadding * t.a5 / a$2.tileSize / l$2;
						for (const e$3 of n$2) {
							const i$2 = d$1.map(((i$3) => e$3.getTilePoint(new t.ab(i$3.x, i$3.y))));
							if (i$2.expandBy(_$2), i$2.intersects(Me$1)) {
								const t$1 = c$1.map(((t$2) => e$3.getTilePoint(t$2))), i$3 = h$1.map(((t$2) => e$3.getTilePoint(t$2)));
								r$1.push({
									tile: a$2,
									tileID: s$1 ? e$3 : e$3.unwrapTo(0),
									queryGeometry: t$1,
									cameraQueryGeometry: i$3,
									scale: l$2
								});
							}
						}
					}
					return r$1;
				}
				transformBbox(e$1, i$1, a$1) {
					let r$1 = e$1.map(i$1);
					if (a$1) {
						const a$2 = t.ac.fromPoints(e$1);
						a$2.shrinkBy(.001 * Math.min(a$2.width(), a$2.height()));
						const o$1 = a$2.map(i$1);
						t.ac.fromPoints(r$1).covers(o$1) || (r$1 = r$1.map(((e$2) => e$2.x > .5 ? new t.ab(e$2.x - 1, e$2.y, e$2.z) : e$2)));
					}
					return r$1;
				}
				getVisibleCoordinates(e$1) {
					const t$1 = this.getRenderableIds(e$1).map(((e$2) => this._inViewTiles.getTileById(e$2).tileID));
					return this.transform && this.transform.populateCache(t$1), t$1;
				}
				hasTransition() {
					return !!this._source.hasTransition() || !(!Ee$1(this._source.type) || !function(e$1, t$1) {
						if (t$1 <= 0) return !1;
						const i$1 = c();
						for (const t$2 of e$1.getAllTiles()) if (t$2.fadeEndTime >= i$1) return !0;
						return !1;
					}(this._inViewTiles, this._rasterFadeDuration));
				}
				setRasterFadeDuration(e$1) {
					this._rasterFadeDuration = e$1;
				}
				setFeatureState(e$1, i$1, a$1) {
					this._state.updateState(e$1 = e$1 || t.aa, i$1, a$1);
				}
				removeFeatureState(e$1, i$1, a$1) {
					this._state.removeFeatureState(e$1 = e$1 || t.aa, i$1, a$1);
				}
				getFeatureState(e$1, i$1) {
					return this._state.getState(e$1 = e$1 || t.aa, i$1);
				}
				setDependencies(e$1, t$1, i$1) {
					const a$1 = this._inViewTiles.getTileById(e$1);
					a$1 && a$1.setDependencies(t$1, i$1);
				}
				reloadTilesForDependencies(e$1, t$1) {
					for (const i$1 of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(i$1).hasDependency(e$1, t$1) && this._reloadTile(i$1, "reloading");
					this._outOfViewCache.filter(((i$1) => !i$1.hasDependency(e$1, t$1)));
				}
				areTilesLoaded() {
					for (const e$1 of this._inViewTiles.getAllTiles()) if ("loaded" !== e$1.state && "errored" !== e$1.state) return !1;
					return !0;
				}
			}
			ke$1.maxUnderzooming = 10, ke$1.maxOverzooming = 3;
			class Fe$1 {
				constructor(e$1, t$1) {
					this.reset(e$1, t$1);
				}
				reset(e$1, t$1) {
					this.points = e$1 || [], this._distances = [0];
					for (let e$2 = 1; e$2 < this.points.length; e$2++) this._distances[e$2] = this._distances[e$2 - 1] + this.points[e$2].dist(this.points[e$2 - 1]);
					this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t$1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
				}
				lerp(e$1) {
					if (1 === this.points.length) return this.points[0];
					e$1 = t.ao(e$1, 0, 1);
					let i$1 = 1, a$1 = this._distances[i$1];
					const r$1 = e$1 * this.paddedLength + this.padding;
					for (; a$1 < r$1 && i$1 < this._distances.length;) a$1 = this._distances[++i$1];
					const o$1 = i$1 - 1, s$1 = this._distances[o$1], n$1 = a$1 - s$1, l$1 = n$1 > 0 ? (r$1 - s$1) / n$1 : 0;
					return this.points[o$1].mult(1 - l$1).add(this.points[i$1].mult(l$1));
				}
			}
			function Be$1(e$1, t$1) {
				let i$1 = !0;
				return "always" === e$1 || "never" !== e$1 && "never" !== t$1 || (i$1 = !1), i$1;
			}
			class Oe$1 {
				constructor(e$1, t$1, i$1) {
					const a$1 = this.boxCells = [], r$1 = this.circleCells = [];
					this.xCellCount = Math.ceil(e$1 / i$1), this.yCellCount = Math.ceil(t$1 / i$1);
					for (let e$2 = 0; e$2 < this.xCellCount * this.yCellCount; e$2++) a$1.push([]), r$1.push([]);
					this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e$1, this.height = t$1, this.xScale = this.xCellCount / e$1, this.yScale = this.yCellCount / t$1, this.boxUid = 0, this.circleUid = 0;
				}
				keysLength() {
					return this.boxKeys.length + this.circleKeys.length;
				}
				insert(e$1, t$1, i$1, a$1, r$1) {
					this._forEachCell(t$1, i$1, a$1, r$1, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e$1), this.bboxes.push(t$1), this.bboxes.push(i$1), this.bboxes.push(a$1), this.bboxes.push(r$1);
				}
				insertCircle(e$1, t$1, i$1, a$1) {
					this._forEachCell(t$1 - a$1, i$1 - a$1, t$1 + a$1, i$1 + a$1, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e$1), this.circles.push(t$1), this.circles.push(i$1), this.circles.push(a$1);
				}
				_insertBoxCell(e$1, t$1, i$1, a$1, r$1, o$1) {
					this.boxCells[r$1].push(o$1);
				}
				_insertCircleCell(e$1, t$1, i$1, a$1, r$1, o$1) {
					this.circleCells[r$1].push(o$1);
				}
				_query(e$1, t$1, i$1, a$1, r$1, o$1, s$1) {
					if (i$1 < 0 || e$1 > this.width || a$1 < 0 || t$1 > this.height) return [];
					const n$1 = [];
					if (e$1 <= 0 && t$1 <= 0 && this.width <= i$1 && this.height <= a$1) {
						if (r$1) return [{
							key: null,
							x1: e$1,
							y1: t$1,
							x2: i$1,
							y2: a$1
						}];
						for (let e$2 = 0; e$2 < this.boxKeys.length; e$2++) n$1.push({
							key: this.boxKeys[e$2],
							x1: this.bboxes[4 * e$2],
							y1: this.bboxes[4 * e$2 + 1],
							x2: this.bboxes[4 * e$2 + 2],
							y2: this.bboxes[4 * e$2 + 3]
						});
						for (let e$2 = 0; e$2 < this.circleKeys.length; e$2++) {
							const t$2 = this.circles[3 * e$2], i$2 = this.circles[3 * e$2 + 1], a$2 = this.circles[3 * e$2 + 2];
							n$1.push({
								key: this.circleKeys[e$2],
								x1: t$2 - a$2,
								y1: i$2 - a$2,
								x2: t$2 + a$2,
								y2: i$2 + a$2
							});
						}
					} else this._forEachCell(e$1, t$1, i$1, a$1, this._queryCell, n$1, {
						hitTest: r$1,
						overlapMode: o$1,
						seenUids: {
							box: {},
							circle: {}
						}
					}, s$1);
					return n$1;
				}
				query(e$1, t$1, i$1, a$1) {
					return this._query(e$1, t$1, i$1, a$1, !1, null);
				}
				hitTest(e$1, t$1, i$1, a$1, r$1, o$1) {
					return this._query(e$1, t$1, i$1, a$1, !0, r$1, o$1).length > 0;
				}
				hitTestCircle(e$1, t$1, i$1, a$1, r$1) {
					const o$1 = e$1 - i$1, s$1 = e$1 + i$1, n$1 = t$1 - i$1, l$1 = t$1 + i$1;
					if (s$1 < 0 || o$1 > this.width || l$1 < 0 || n$1 > this.height) return !1;
					const c$1 = [];
					return this._forEachCell(o$1, n$1, s$1, l$1, this._queryCellCircle, c$1, {
						hitTest: !0,
						overlapMode: a$1,
						circle: {
							x: e$1,
							y: t$1,
							radius: i$1
						},
						seenUids: {
							box: {},
							circle: {}
						}
					}, r$1), c$1.length > 0;
				}
				_queryCell(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1) {
					const { seenUids: l$1, hitTest: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[r$1];
					if (null !== u$1) {
						const r$2 = this.bboxes;
						for (const s$2 of u$1) if (!l$1.box[s$2]) {
							l$1.box[s$2] = !0;
							const u$2 = 4 * s$2, d$2 = this.boxKeys[s$2];
							if (e$1 <= r$2[u$2 + 2] && t$1 <= r$2[u$2 + 3] && i$1 >= r$2[u$2 + 0] && a$1 >= r$2[u$2 + 1] && (!n$1 || n$1(d$2)) && (!c$1 || !Be$1(h$1, d$2.overlapMode)) && (o$1.push({
								key: d$2,
								x1: r$2[u$2],
								y1: r$2[u$2 + 1],
								x2: r$2[u$2 + 2],
								y2: r$2[u$2 + 3]
							}), c$1)) return !0;
						}
					}
					const d$1 = this.circleCells[r$1];
					if (null !== d$1) {
						const r$2 = this.circles;
						for (const s$2 of d$1) if (!l$1.circle[s$2]) {
							l$1.circle[s$2] = !0;
							const u$2 = 3 * s$2, d$2 = this.circleKeys[s$2];
							if (this._circleAndRectCollide(r$2[u$2], r$2[u$2 + 1], r$2[u$2 + 2], e$1, t$1, i$1, a$1) && (!n$1 || n$1(d$2)) && (!c$1 || !Be$1(h$1, d$2.overlapMode))) {
								const e$2 = r$2[u$2], t$2 = r$2[u$2 + 1], i$2 = r$2[u$2 + 2];
								if (o$1.push({
									key: d$2,
									x1: e$2 - i$2,
									y1: t$2 - i$2,
									x2: e$2 + i$2,
									y2: t$2 + i$2
								}), c$1) return !0;
							}
						}
					}
					return !1;
				}
				_queryCellCircle(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1) {
					const { circle: l$1, seenUids: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[r$1];
					if (null !== u$1) {
						const e$2 = this.bboxes;
						for (const t$2 of u$1) if (!c$1.box[t$2]) {
							c$1.box[t$2] = !0;
							const i$2 = 4 * t$2, a$2 = this.boxKeys[t$2];
							if (this._circleAndRectCollide(l$1.x, l$1.y, l$1.radius, e$2[i$2 + 0], e$2[i$2 + 1], e$2[i$2 + 2], e$2[i$2 + 3]) && (!n$1 || n$1(a$2)) && !Be$1(h$1, a$2.overlapMode)) return o$1.push(!0), !0;
						}
					}
					const d$1 = this.circleCells[r$1];
					if (null !== d$1) {
						const e$2 = this.circles;
						for (const t$2 of d$1) if (!c$1.circle[t$2]) {
							c$1.circle[t$2] = !0;
							const i$2 = 3 * t$2, a$2 = this.circleKeys[t$2];
							if (this._circlesCollide(e$2[i$2], e$2[i$2 + 1], e$2[i$2 + 2], l$1.x, l$1.y, l$1.radius) && (!n$1 || n$1(a$2)) && !Be$1(h$1, a$2.overlapMode)) return o$1.push(!0), !0;
						}
					}
				}
				_forEachCell(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1) {
					const l$1 = this._convertToXCellCoord(e$1), c$1 = this._convertToYCellCoord(t$1), h$1 = this._convertToXCellCoord(i$1), u$1 = this._convertToYCellCoord(a$1);
					for (let d$1 = l$1; d$1 <= h$1; d$1++) for (let l$2 = c$1; l$2 <= u$1; l$2++) if (r$1.call(this, e$1, t$1, i$1, a$1, this.xCellCount * l$2 + d$1, o$1, s$1, n$1)) return;
				}
				_convertToXCellCoord(e$1) {
					return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e$1 * this.xScale)));
				}
				_convertToYCellCoord(e$1) {
					return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e$1 * this.yScale)));
				}
				_circlesCollide(e$1, t$1, i$1, a$1, r$1, o$1) {
					const s$1 = a$1 - e$1, n$1 = r$1 - t$1, l$1 = i$1 + o$1;
					return l$1 * l$1 > s$1 * s$1 + n$1 * n$1;
				}
				_circleAndRectCollide(e$1, t$1, i$1, a$1, r$1, o$1, s$1) {
					const n$1 = (o$1 - a$1) / 2, l$1 = Math.abs(e$1 - (a$1 + n$1));
					if (l$1 > n$1 + i$1) return !1;
					const c$1 = (s$1 - r$1) / 2, h$1 = Math.abs(t$1 - (r$1 + c$1));
					if (h$1 > c$1 + i$1) return !1;
					if (l$1 <= n$1 || h$1 <= c$1) return !0;
					const u$1 = l$1 - n$1, d$1 = h$1 - c$1;
					return u$1 * u$1 + d$1 * d$1 <= i$1 * i$1;
				}
			}
			function je$1(e$1, i$1, r$1) {
				const o$1 = t.N();
				if (!e$1) {
					const { vecSouth: e$2, vecEast: t$1 } = Ze$1(i$1), r$2 = a();
					r$2[0] = t$1[0], r$2[1] = t$1[1], r$2[2] = e$2[0], r$2[3] = e$2[1], s$1 = r$2, (d$1 = (l$1 = (n$1 = r$2)[0]) * (u$1 = n$1[3]) - (h$1 = n$1[2]) * (c$1 = n$1[1])) && (s$1[0] = u$1 * (d$1 = 1 / d$1), s$1[1] = -c$1 * d$1, s$1[2] = -h$1 * d$1, s$1[3] = l$1 * d$1), o$1[0] = r$2[0], o$1[1] = r$2[1], o$1[4] = r$2[2], o$1[5] = r$2[3];
				}
				var s$1, n$1, l$1, c$1, h$1, u$1, d$1;
				return t.Q(o$1, o$1, [
					1 / r$1,
					1 / r$1,
					1
				]), o$1;
			}
			function Ne$1(e$1, i$1, a$1, r$1) {
				if (e$1) {
					const e$2 = t.N();
					if (!i$1) {
						const { vecSouth: t$1, vecEast: i$2 } = Ze$1(a$1);
						e$2[0] = i$2[0], e$2[1] = i$2[1], e$2[4] = t$1[0], e$2[5] = t$1[1];
					}
					return t.Q(e$2, e$2, [
						r$1,
						r$1,
						1
					]), e$2;
				}
				return a$1.pixelsToClipSpaceMatrix;
			}
			function Ze$1(e$1) {
				const i$1 = Math.cos(e$1.rollInRadians), a$1 = Math.sin(e$1.rollInRadians), r$1 = Math.cos(e$1.pitchInRadians), o$1 = Math.cos(e$1.bearingInRadians), s$1 = Math.sin(e$1.bearingInRadians), n$1 = t.aD();
				n$1[0] = -o$1 * r$1 * a$1 - s$1 * i$1, n$1[1] = -s$1 * r$1 * a$1 + o$1 * i$1;
				const l$1 = t.aE(n$1);
				l$1 < 1e-9 ? t.aF(n$1) : t.aG(n$1, n$1, 1 / l$1);
				const c$1 = t.aD();
				c$1[0] = o$1 * r$1 * i$1 - s$1 * a$1, c$1[1] = s$1 * r$1 * i$1 + o$1 * a$1;
				const h$1 = t.aE(c$1);
				return h$1 < 1e-9 ? t.aF(c$1) : t.aG(c$1, c$1, 1 / h$1), {
					vecEast: c$1,
					vecSouth: n$1
				};
			}
			function Ge$1(e$1, i$1, a$1, r$1) {
				let o$1;
				r$1 ? (o$1 = [
					e$1,
					i$1,
					r$1(e$1, i$1),
					1
				], t.aI(o$1, o$1, a$1)) : (o$1 = [
					e$1,
					i$1,
					0,
					1
				], ot$1(o$1, o$1, a$1));
				const s$1 = o$1[3];
				return {
					point: new t.P(o$1[0] / s$1, o$1[1] / s$1),
					signedDistanceFromCamera: s$1,
					isOccluded: !1
				};
			}
			function Ue$1(e$1, t$1) {
				return .5 + e$1 / t$1 * .5;
			}
			function Ve$1(e$1, t$1) {
				return e$1.x >= -t$1[0] && e$1.x <= t$1[0] && e$1.y >= -t$1[1] && e$1.y <= t$1[1];
			}
			function qe$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2) {
				const p$1 = a$1 ? e$1.textSizeData : e$1.iconSizeData, m$1 = t.az(p$1, i$1.transform.zoom), f$1 = [256 / i$1.width * 2 + 1, 256 / i$1.height * 2 + 1], g$2 = a$1 ? e$1.text.dynamicLayoutVertexArray : e$1.icon.dynamicLayoutVertexArray;
				g$2.clear();
				const v$1 = e$1.lineVertexArray, x$1 = a$1 ? e$1.text.placedSymbolArray : e$1.icon.placedSymbolArray, b$1 = i$1.transform.width / i$1.transform.height;
				let y$1 = !1;
				for (let a$2 = 0; a$2 < x$1.length; a$2++) {
					const w$2 = x$1.get(a$2);
					if (w$2.hidden || w$2.writingMode === t.aA.vertical && !y$1) {
						rt$1(w$2.numGlyphs, g$2);
						continue;
					}
					y$1 = !1;
					const T$1 = new t.P(w$2.anchorX, w$2.anchorY), P$2 = {
						getElevation: _$2,
						pitchedLabelPlaneMatrix: r$1,
						lineVertexArray: v$1,
						pitchWithMap: s$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: i$1.transform,
						tileAnchorPoint: T$1,
						unwrappedTileID: c$1,
						width: h$1,
						height: u$1,
						translation: d$1
					}, I$2 = Je$1(w$2.anchorX, w$2.anchorY, P$2);
					if (!Ve$1(I$2.point, f$1)) {
						rt$1(w$2.numGlyphs, g$2);
						continue;
					}
					const C$1 = Ue$1(i$1.transform.cameraToCenterDistance, I$2.signedDistanceFromCamera), M$2 = t.aB(p$1, m$1, w$2), E$1 = s$1 ? M$2 * i$1.transform.getPitchedTextCorrection(w$2.anchorX, w$2.anchorY, c$1) / C$1 : M$2 * C$1, S$2 = He$1({
						projectionContext: P$2,
						pitchedLabelPlaneMatrixInverse: o$1,
						symbol: w$2,
						fontSize: E$1,
						flip: !1,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$2,
						aspectRatio: b$1,
						rotateToLine: l$1
					});
					y$1 = S$2.useVertical, (S$2.notEnoughRoom || y$1 || S$2.needsFlipping && He$1({
						projectionContext: P$2,
						pitchedLabelPlaneMatrixInverse: o$1,
						symbol: w$2,
						fontSize: E$1,
						flip: !0,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$2,
						aspectRatio: b$1,
						rotateToLine: l$1
					}).notEnoughRoom) && rt$1(w$2.numGlyphs, g$2);
				}
				a$1 ? e$1.text.dynamicLayoutVertexBuffer.updateData(g$2) : e$1.icon.dynamicLayoutVertexBuffer.updateData(g$2);
			}
			function We(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1) {
				const l$1 = o$1.glyphStartIndex + o$1.numGlyphs, c$1 = o$1.lineStartIndex, h$1 = o$1.lineStartIndex + o$1.lineLength, u$1 = t$1.getoffsetX(o$1.glyphStartIndex), d$1 = t$1.getoffsetX(l$1 - 1), _$2 = it$1(e$1 * u$1, i$1, a$1, r$1, o$1.segment, c$1, h$1, n$1, s$1);
				if (!_$2) return null;
				const p$1 = it$1(e$1 * d$1, i$1, a$1, r$1, o$1.segment, c$1, h$1, n$1, s$1);
				return p$1 ? n$1.projectionCache.anyProjectionOccluded ? null : {
					first: _$2,
					last: p$1
				} : null;
			}
			function $e$1(e$1, i$1, a$1, r$1) {
				return e$1 === t.aA.horizontal && Math.abs(a$1.y - i$1.y) > Math.abs(a$1.x - i$1.x) * r$1 ? { useVertical: !0 } : (e$1 === t.aA.vertical ? i$1.y < a$1.y : i$1.x > a$1.x) ? { needsFlipping: !0 } : null;
			}
			function He$1(e$1) {
				const { projectionContext: i$1, pitchedLabelPlaneMatrixInverse: a$1, symbol: r$1, fontSize: o$1, flip: s$1, keepUpright: n$1, glyphOffsetArray: l$1, dynamicLayoutVertexArray: c$1, aspectRatio: h$1, rotateToLine: u$1 } = e$1, d$1 = o$1 / 24, _$2 = r$1.lineOffsetX * d$1, p$1 = r$1.lineOffsetY * d$1;
				let m$1;
				if (r$1.numGlyphs > 1) {
					const e$2 = r$1.glyphStartIndex + r$1.numGlyphs, t$1 = r$1.lineStartIndex, o$2 = r$1.lineStartIndex + r$1.lineLength, c$2 = We(d$1, l$1, _$2, p$1, s$1, r$1, u$1, i$1);
					if (!c$2) return { notEnoughRoom: !0 };
					const f$1 = Qe$1(c$2.first.point.x, c$2.first.point.y, i$1, a$1), g$2 = Qe$1(c$2.last.point.x, c$2.last.point.y, i$1, a$1);
					if (n$1 && !s$1) {
						const e$3 = $e$1(r$1.writingMode, f$1, g$2, h$1);
						if (e$3) return e$3;
					}
					m$1 = [c$2.first];
					for (let a$2 = r$1.glyphStartIndex + 1; a$2 < e$2 - 1; a$2++) {
						const e$3 = it$1(d$1 * l$1.getoffsetX(a$2), _$2, p$1, s$1, r$1.segment, t$1, o$2, i$1, u$1);
						if (!e$3) return { notEnoughRoom: !0 };
						m$1.push(e$3);
					}
					m$1.push(c$2.last);
				} else {
					if (n$1 && !s$1) {
						const e$3 = Ye(i$1.tileAnchorPoint.x, i$1.tileAnchorPoint.y, i$1).point, o$2 = r$1.lineStartIndex + r$1.segment + 1, s$2 = new t.P(i$1.lineVertexArray.getx(o$2), i$1.lineVertexArray.gety(o$2)), n$2 = Ye(s$2.x, s$2.y, i$1), l$2 = n$2.signedDistanceFromCamera > 0 ? n$2.point : Xe(i$1.tileAnchorPoint, s$2, e$3, 1, i$1), c$2 = Qe$1(e$3.x, e$3.y, i$1, a$1), u$2 = Qe$1(l$2.x, l$2.y, i$1, a$1), d$2 = $e$1(r$1.writingMode, c$2, u$2, h$1);
						if (d$2) return d$2;
					}
					const e$2 = it$1(d$1 * l$1.getoffsetX(r$1.glyphStartIndex), _$2, p$1, s$1, r$1.segment, r$1.lineStartIndex, r$1.lineStartIndex + r$1.lineLength, i$1, u$1);
					if (!e$2 || i$1.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
					m$1 = [e$2];
				}
				for (const e$2 of m$1) t.aH(c$1, e$2.point, e$2.angle);
				return {};
			}
			function Xe(e$1, t$1, i$1, a$1, r$1) {
				const o$1 = e$1.add(e$1.sub(t$1)._unit()), s$1 = Ye(o$1.x, o$1.y, r$1).point, n$1 = i$1.sub(s$1);
				return i$1.add(n$1._mult(a$1 / n$1.mag()));
			}
			function Ke$1(e$1, i$1, a$1) {
				const r$1 = i$1.projectionCache;
				if (r$1.projections[e$1]) return r$1.projections[e$1];
				const o$1 = new t.P(i$1.lineVertexArray.getx(e$1), i$1.lineVertexArray.gety(e$1)), s$1 = Ye(o$1.x, o$1.y, i$1);
				if (s$1.signedDistanceFromCamera > 0) return r$1.projections[e$1] = s$1.point, r$1.anyProjectionOccluded = r$1.anyProjectionOccluded || s$1.isOccluded, s$1.point;
				const n$1 = e$1 - a$1.direction;
				return Xe(0 === a$1.distanceFromAnchor ? i$1.tileAnchorPoint : new t.P(i$1.lineVertexArray.getx(n$1), i$1.lineVertexArray.gety(n$1)), o$1, a$1.previousVertex, a$1.absOffsetX - a$1.distanceFromAnchor + 1, i$1);
			}
			function Ye(e$1, t$1, i$1) {
				const a$1 = e$1 + i$1.translation[0], r$1 = t$1 + i$1.translation[1];
				let o$1;
				return i$1.pitchWithMap ? (o$1 = Ge$1(a$1, r$1, i$1.pitchedLabelPlaneMatrix, i$1.getElevation), o$1.isOccluded = !1) : (o$1 = i$1.transform.projectTileCoordinates(a$1, r$1, i$1.unwrappedTileID, i$1.getElevation), o$1.point.x = (.5 * o$1.point.x + .5) * i$1.width, o$1.point.y = (.5 * -o$1.point.y + .5) * i$1.height), o$1;
			}
			function Qe$1(e$1, i$1, a$1, r$1) {
				if (a$1.pitchWithMap) {
					const o$1 = [
						e$1,
						i$1,
						0,
						1
					];
					return t.aI(o$1, o$1, r$1), a$1.transform.projectTileCoordinates(o$1[0] / o$1[3], o$1[1] / o$1[3], a$1.unwrappedTileID, a$1.getElevation).point;
				}
				return {
					x: e$1 / a$1.width * 2 - 1,
					y: 1 - i$1 / a$1.height * 2
				};
			}
			function Je$1(e$1, t$1, i$1) {
				return i$1.transform.projectTileCoordinates(e$1, t$1, i$1.unwrappedTileID, i$1.getElevation);
			}
			function et$1(e$1, t$1, i$1) {
				return e$1._unit()._perp()._mult(t$1 * i$1);
			}
			function tt$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1) {
				if (l$1.projectionCache.offsets[e$1]) return l$1.projectionCache.offsets[e$1];
				const h$1 = a$1.add(i$1);
				if (e$1 + c$1.direction < r$1 || e$1 + c$1.direction >= o$1) return l$1.projectionCache.offsets[e$1] = h$1, h$1;
				const u$1 = Ke$1(e$1 + c$1.direction, l$1, c$1), d$1 = et$1(u$1.sub(a$1), n$1, c$1.direction), _$2 = a$1.add(d$1), p$1 = u$1.add(d$1);
				return l$1.projectionCache.offsets[e$1] = t.aJ(s$1, h$1, _$2, p$1) || h$1, l$1.projectionCache.offsets[e$1];
			}
			function it$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
				const c$1 = a$1 ? e$1 - t$1 : e$1 + t$1;
				let h$1 = c$1 > 0 ? 1 : -1, u$1 = 0;
				a$1 && (h$1 *= -1, u$1 = Math.PI), h$1 < 0 && (u$1 += Math.PI);
				let d$1, _$2 = h$1 > 0 ? o$1 + r$1 : o$1 + r$1 + 1;
				n$1.projectionCache.cachedAnchorPoint ? d$1 = n$1.projectionCache.cachedAnchorPoint : (d$1 = Ye(n$1.tileAnchorPoint.x, n$1.tileAnchorPoint.y, n$1).point, n$1.projectionCache.cachedAnchorPoint = d$1);
				let p$1, m$1, f$1 = d$1, g$2 = d$1, v$1 = 0, x$1 = 0;
				const b$1 = Math.abs(c$1), y$1 = [];
				let w$2;
				for (; v$1 + x$1 <= b$1;) {
					if (_$2 += h$1, _$2 < o$1 || _$2 >= s$1) return null;
					v$1 += x$1, g$2 = f$1, m$1 = p$1;
					const e$2 = {
						absOffsetX: b$1,
						direction: h$1,
						distanceFromAnchor: v$1,
						previousVertex: g$2
					};
					if (f$1 = Ke$1(_$2, n$1, e$2), 0 === i$1) y$1.push(g$2), w$2 = f$1.sub(g$2);
					else {
						let t$2;
						const a$2 = f$1.sub(g$2);
						t$2 = 0 === a$2.mag() ? et$1(Ke$1(_$2 + h$1, n$1, e$2).sub(f$1), i$1, h$1) : et$1(a$2, i$1, h$1), m$1 || (m$1 = g$2.add(t$2)), p$1 = tt$1(_$2, t$2, f$1, o$1, s$1, m$1, i$1, n$1, e$2), y$1.push(m$1), w$2 = p$1.sub(m$1);
					}
					x$1 = w$2.mag();
				}
				const T$1 = w$2._mult((b$1 - v$1) / x$1)._add(m$1 || g$2), P$2 = u$1 + Math.atan2(f$1.y - g$2.y, f$1.x - g$2.x);
				return y$1.push(T$1), {
					point: T$1,
					angle: l$1 ? P$2 : 0,
					path: y$1
				};
			}
			const at$2 = new Float32Array([
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0
			]);
			function rt$1(e$1, t$1) {
				for (let i$1 = 0; i$1 < e$1; i$1++) {
					const e$2 = t$1.length;
					t$1.resize(e$2 + 4), t$1.float32.set(at$2, 3 * e$2);
				}
			}
			function ot$1(e$1, t$1, i$1) {
				const a$1 = t$1[0], r$1 = t$1[1];
				return e$1[0] = i$1[0] * a$1 + i$1[4] * r$1 + i$1[12], e$1[1] = i$1[1] * a$1 + i$1[5] * r$1 + i$1[13], e$1[3] = i$1[3] * a$1 + i$1[7] * r$1 + i$1[15], e$1;
			}
			const st$1 = 100;
			class nt$1 {
				constructor(e$1, t$1 = new Oe$1(e$1.width + 200, e$1.height + 200, 25), i$1 = new Oe$1(e$1.width + 200, e$1.height + 200, 25)) {
					this.transform = e$1, this.grid = t$1, this.ignoredGrid = i$1, this.pitchFactor = Math.cos(e$1.pitch * Math.PI / 180) * e$1.cameraToCenterDistance, this.screenRightBoundary = e$1.width + st$1, this.screenBottomBoundary = e$1.height + st$1, this.gridRightBoundary = e$1.width + 200, this.gridBottomBoundary = e$1.height + 200, this.perspectiveRatioCutoff = .6;
				}
				placeCollisionBox(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					const d$1 = this.projectAndGetPerspectiveRatio(e$1.anchorPointX + n$1[0], e$1.anchorPointY + n$1[1], r$1, c$1, u$1), _$2 = i$1 * d$1.perspectiveRatio;
					let p$1;
					if (o$1 || s$1) p$1 = this._projectCollisionBox(e$1, _$2, a$1, r$1, o$1, s$1, n$1, d$1, c$1, h$1, u$1);
					else {
						const t$2 = d$1.x + (h$1 ? h$1.x * _$2 : 0), i$2 = d$1.y + (h$1 ? h$1.y * _$2 : 0);
						p$1 = {
							allPointsOccluded: !1,
							box: [
								t$2 + e$1.x1 * _$2,
								i$2 + e$1.y1 * _$2,
								t$2 + e$1.x2 * _$2,
								i$2 + e$1.y2 * _$2
							]
						};
					}
					const [m$1, f$1, g$2, v$1] = p$1.box, x$1 = o$1 ? p$1.allPointsOccluded : d$1.isOccluded;
					let b$1 = x$1;
					return b$1 || (b$1 = d$1.perspectiveRatio < this.perspectiveRatioCutoff), b$1 || (b$1 = !this.isInsideGrid(m$1, f$1, g$2, v$1)), b$1 || "always" !== t$1 && this.grid.hitTest(m$1, f$1, g$2, v$1, t$1, l$1) ? {
						box: [
							m$1,
							f$1,
							g$2,
							v$1
						],
						placeable: !1,
						offscreen: !1,
						occluded: x$1
					} : {
						box: [
							m$1,
							f$1,
							g$2,
							v$1
						],
						placeable: !0,
						offscreen: this.isOffscreen(m$1, f$1, g$2, v$1),
						occluded: x$1
					};
				}
				placeCollisionCircles(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1) {
					const m$1 = [], f$1 = new t.P(i$1.anchorX, i$1.anchorY), g$2 = this.getPerspectiveRatio(f$1.x, f$1.y, s$1, p$1), v$1 = (c$1 ? o$1 * this.transform.getPitchedTextCorrection(i$1.anchorX, i$1.anchorY, s$1) / g$2 : o$1 * g$2) / t.aN, x$1 = {
						getElevation: p$1,
						pitchedLabelPlaneMatrix: n$1,
						lineVertexArray: a$1,
						pitchWithMap: c$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: this.transform,
						tileAnchorPoint: f$1,
						unwrappedTileID: s$1,
						width: this.transform.width,
						height: this.transform.height,
						translation: _$2
					}, b$1 = We(v$1, r$1, i$1.lineOffsetX * v$1, i$1.lineOffsetY * v$1, !1, i$1, !1, x$1);
					let y$1 = !1, w$2 = !1, T$1 = !0;
					if (b$1) {
						const i$2 = .5 * u$1 * g$2 + d$1, a$2 = new t.P(-100, -100), r$2 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), o$2 = new Fe$1(), s$2 = b$1.first, n$2 = b$1.last;
						let _$3 = [];
						for (let e$2 = s$2.path.length - 1; e$2 >= 1; e$2--) _$3.push(s$2.path[e$2]);
						for (let e$2 = 1; e$2 < n$2.path.length; e$2++) _$3.push(n$2.path[e$2]);
						const p$2 = 2.5 * i$2;
						if (c$1) {
							const e$2 = this.projectPathToScreenSpace(_$3, x$1);
							_$3 = e$2.some(((e$3) => e$3.signedDistanceFromCamera <= 0)) ? [] : e$2.map(((e$3) => e$3.point));
						}
						let f$2 = [];
						if (_$3.length > 0) {
							const e$2 = _$3[0].clone(), i$3 = _$3[0].clone();
							for (let t$1 = 1; t$1 < _$3.length; t$1++) e$2.x = Math.min(e$2.x, _$3[t$1].x), e$2.y = Math.min(e$2.y, _$3[t$1].y), i$3.x = Math.max(i$3.x, _$3[t$1].x), i$3.y = Math.max(i$3.y, _$3[t$1].y);
							f$2 = e$2.x >= a$2.x && i$3.x <= r$2.x && e$2.y >= a$2.y && i$3.y <= r$2.y ? [_$3] : i$3.x < a$2.x || e$2.x > r$2.x || i$3.y < a$2.y || e$2.y > r$2.y ? [] : t.aK([_$3], a$2.x, a$2.y, r$2.x, r$2.y);
						}
						for (const t$1 of f$2) {
							o$2.reset(t$1, .25 * i$2);
							let a$3 = 0;
							a$3 = o$2.length <= .5 * i$2 ? 1 : Math.ceil(o$2.paddedLength / p$2) + 1;
							for (let t$2 = 0; t$2 < a$3; t$2++) {
								const r$3 = t$2 / Math.max(a$3 - 1, 1), s$3 = o$2.lerp(r$3), n$3 = s$3.x + st$1, c$2 = s$3.y + st$1;
								m$1.push(n$3, c$2, i$2, 0);
								const u$2 = n$3 - i$2, d$2 = c$2 - i$2, _$4 = n$3 + i$2, p$3 = c$2 + i$2;
								if (T$1 = T$1 && this.isOffscreen(u$2, d$2, _$4, p$3), w$2 = w$2 || this.isInsideGrid(u$2, d$2, _$4, p$3), "always" !== e$1 && this.grid.hitTestCircle(n$3, c$2, i$2, e$1, h$1) && (y$1 = !0, !l$1)) return {
									circles: [],
									offscreen: !1,
									collisionDetected: y$1
								};
							}
						}
					}
					return {
						circles: !l$1 && y$1 || !w$2 || g$2 < this.perspectiveRatioCutoff ? [] : m$1,
						offscreen: T$1,
						collisionDetected: y$1
					};
				}
				projectPathToScreenSpace(e$1, i$1) {
					return function(e$2) {
						let t$1 = 0, i$2 = 0, a$1 = 0, r$1 = 0;
						for (let o$1 = 0; o$1 < e$2.length; o$1++) e$2[o$1].isOccluded ? (a$1 = o$1 + 1, r$1 = 0) : (r$1++, r$1 > i$2 && (i$2 = r$1, t$1 = a$1));
						return e$2.slice(t$1, t$1 + i$2);
					}(function(e$2, i$2) {
						const a$1 = t.N();
						return t.aC(a$1, i$2.pitchedLabelPlaneMatrix), e$2.map(((e$3) => {
							const t$1 = Ge$1(e$3.x, e$3.y, a$1, i$2.getElevation), r$1 = i$2.transform.projectTileCoordinates(t$1.point.x, t$1.point.y, i$2.unwrappedTileID, i$2.getElevation);
							return r$1.point.x = (.5 * r$1.point.x + .5) * i$2.width, r$1.point.y = (.5 * -r$1.point.y + .5) * i$2.height, r$1;
						}));
					}(e$1, i$1));
				}
				queryRenderedSymbols(e$1) {
					if (0 === e$1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
					const i$1 = [], a$1 = new t.ac();
					for (const r$2 of e$1) {
						const e$2 = new t.P(r$2.x + st$1, r$2.y + st$1);
						a$1.extend(e$2), i$1.push(e$2);
					}
					const { minX: r$1, minY: o$1, maxX: s$1, maxY: n$1 } = a$1, l$1 = this.grid.query(r$1, o$1, s$1, n$1).concat(this.ignoredGrid.query(r$1, o$1, s$1, n$1)), c$1 = {}, h$1 = {};
					for (const e$2 of l$1) {
						const a$2 = e$2.key;
						if (void 0 === c$1[a$2.bucketInstanceId] && (c$1[a$2.bucketInstanceId] = {}), c$1[a$2.bucketInstanceId][a$2.featureIndex]) continue;
						const r$2 = [
							new t.P(e$2.x1, e$2.y1),
							new t.P(e$2.x2, e$2.y1),
							new t.P(e$2.x2, e$2.y2),
							new t.P(e$2.x1, e$2.y2)
						];
						t.aL(i$1, r$2) && (c$1[a$2.bucketInstanceId][a$2.featureIndex] = !0, void 0 === h$1[a$2.bucketInstanceId] && (h$1[a$2.bucketInstanceId] = []), h$1[a$2.bucketInstanceId].push(a$2.featureIndex));
					}
					return h$1;
				}
				insertCollisionBox(e$1, t$1, i$1, a$1, r$1, o$1) {
					(i$1 ? this.ignoredGrid : this.grid).insert({
						bucketInstanceId: a$1,
						featureIndex: r$1,
						collisionGroupID: o$1,
						overlapMode: t$1
					}, e$1[0], e$1[1], e$1[2], e$1[3]);
				}
				insertCollisionCircles(e$1, t$1, i$1, a$1, r$1, o$1) {
					const s$1 = i$1 ? this.ignoredGrid : this.grid, n$1 = {
						bucketInstanceId: a$1,
						featureIndex: r$1,
						collisionGroupID: o$1,
						overlapMode: t$1
					};
					for (let t$2 = 0; t$2 < e$1.length; t$2 += 4) s$1.insertCircle(n$1, e$1[t$2], e$1[t$2 + 1], e$1[t$2 + 2]);
				}
				projectAndGetPerspectiveRatio(e$1, i$1, a$1, r$1, o$1) {
					if (o$1) {
						let a$2;
						r$1 ? (a$2 = [
							e$1,
							i$1,
							r$1(e$1, i$1),
							1
						], t.aI(a$2, a$2, o$1)) : (a$2 = [
							e$1,
							i$1,
							0,
							1
						], ot$1(a$2, a$2, o$1));
						const s$1 = a$2[3];
						return {
							x: (a$2[0] / s$1 + 1) / 2 * this.transform.width + st$1,
							y: (-a$2[1] / s$1 + 1) / 2 * this.transform.height + st$1,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / s$1 * .5,
							isOccluded: !1,
							signedDistanceFromCamera: s$1
						};
					}
					{
						const t$1 = this.transform.projectTileCoordinates(e$1, i$1, a$1, r$1);
						return {
							x: (t$1.point.x + 1) / 2 * this.transform.width + st$1,
							y: (1 - t$1.point.y) / 2 * this.transform.height + st$1,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / t$1.signedDistanceFromCamera * .5,
							isOccluded: t$1.isOccluded,
							signedDistanceFromCamera: t$1.signedDistanceFromCamera
						};
					}
				}
				getPerspectiveRatio(e$1, t$1, i$1, a$1) {
					const r$1 = this.transform.projectTileCoordinates(e$1, t$1, i$1, a$1);
					return .5 + this.transform.cameraToCenterDistance / r$1.signedDistanceFromCamera * .5;
				}
				isOffscreen(e$1, t$1, i$1, a$1) {
					return i$1 < st$1 || e$1 >= this.screenRightBoundary || a$1 < st$1 || t$1 > this.screenBottomBoundary;
				}
				isInsideGrid(e$1, t$1, i$1, a$1) {
					return i$1 >= 0 && e$1 < this.gridRightBoundary && a$1 >= 0 && t$1 < this.gridBottomBoundary;
				}
				getViewportMatrix() {
					const e$1 = t.as([]);
					return t.O(e$1, e$1, [
						-100,
						-100,
						0
					]), e$1;
				}
				_projectCollisionBox(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					let d$1 = 1, _$2 = 0, p$1 = 0, m$1 = 1;
					const f$1 = e$1.anchorPointX + n$1[0], g$2 = e$1.anchorPointY + n$1[1];
					if (s$1 && !o$1) {
						const e$2 = this.projectAndGetPerspectiveRatio(f$1 + 1, g$2, r$1, c$1, u$1), t$1 = e$2.x - l$1.x, i$2 = Math.atan((e$2.y - l$1.y) / t$1) + (t$1 < 0 ? Math.PI : 0), a$2 = Math.sin(i$2), o$2 = Math.cos(i$2);
						d$1 = o$2, _$2 = a$2, p$1 = -a$2, m$1 = o$2;
					} else if (!s$1 && o$1) {
						const e$2 = Ze$1(this.transform);
						d$1 = e$2.vecEast[0], _$2 = e$2.vecEast[1], p$1 = e$2.vecSouth[0], m$1 = e$2.vecSouth[1];
					}
					let v$1 = l$1.x, x$1 = l$1.y, b$1 = i$1;
					o$1 && (v$1 = f$1, x$1 = g$2, b$1 = Math.pow(2, -(this.transform.zoom - a$1.overscaledZ)), b$1 *= this.transform.getPitchedTextCorrection(f$1, g$2, r$1), h$1 || (b$1 *= t.ao(.5 + l$1.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), h$1 && (v$1 += d$1 * h$1.x * b$1 + p$1 * h$1.y * b$1, x$1 += _$2 * h$1.x * b$1 + m$1 * h$1.y * b$1);
					const y$1 = e$1.x1 * b$1, w$2 = e$1.x2 * b$1, T$1 = (y$1 + w$2) / 2, P$2 = e$1.y1 * b$1, I$2 = e$1.y2 * b$1, C$1 = (P$2 + I$2) / 2, M$2 = [
						{
							offsetX: y$1,
							offsetY: P$2
						},
						{
							offsetX: T$1,
							offsetY: P$2
						},
						{
							offsetX: w$2,
							offsetY: P$2
						},
						{
							offsetX: w$2,
							offsetY: C$1
						},
						{
							offsetX: w$2,
							offsetY: I$2
						},
						{
							offsetX: T$1,
							offsetY: I$2
						},
						{
							offsetX: y$1,
							offsetY: I$2
						},
						{
							offsetX: y$1,
							offsetY: C$1
						}
					];
					let E$1 = [];
					for (const { offsetX: e$2, offsetY: i$2 } of M$2) E$1.push(new t.P(v$1 + d$1 * e$2 + p$1 * i$2, x$1 + _$2 * e$2 + m$1 * i$2));
					let S$2 = !1;
					if (o$1) {
						const e$2 = E$1.map(((e$3) => this.projectAndGetPerspectiveRatio(e$3.x, e$3.y, r$1, c$1, u$1)));
						S$2 = e$2.some(((e$3) => !e$3.isOccluded)), E$1 = e$2.map(((e$3) => new t.P(e$3.x, e$3.y)));
					} else S$2 = !0;
					return {
						box: t.aM(E$1),
						allPointsOccluded: !S$2
					};
				}
			}
			class lt$1 {
				constructor(e$1, t$1, i$1, a$1) {
					this.opacity = e$1 ? Math.max(0, Math.min(1, e$1.opacity + (e$1.placed ? t$1 : -t$1))) : a$1 && i$1 ? 1 : 0, this.placed = i$1;
				}
				isHidden() {
					return 0 === this.opacity && !this.placed;
				}
			}
			class ct$1 {
				constructor(e$1, t$1, i$1, a$1, r$1) {
					this.text = new lt$1(e$1 ? e$1.text : null, t$1, i$1, r$1), this.icon = new lt$1(e$1 ? e$1.icon : null, t$1, a$1, r$1);
				}
				isHidden() {
					return this.text.isHidden() && this.icon.isHidden();
				}
			}
			class ht$1 {
				constructor(e$1, t$1, i$1) {
					this.text = e$1, this.icon = t$1, this.skipFade = i$1;
				}
			}
			class ut$1 {
				constructor(e$1, t$1, i$1, a$1, r$1) {
					this.bucketInstanceId = e$1, this.featureIndex = t$1, this.sourceLayerIndex = i$1, this.bucketIndex = a$1, this.tileID = r$1;
				}
			}
			class dt$1 {
				constructor(e$1) {
					this.crossSourceCollisions = e$1, this.maxGroupID = 0, this.collisionGroups = {};
				}
				get(e$1) {
					if (this.crossSourceCollisions) return {
						ID: 0,
						predicate: null
					};
					if (!this.collisionGroups[e$1]) {
						const t$1 = ++this.maxGroupID;
						this.collisionGroups[e$1] = {
							ID: t$1,
							predicate: (e$2) => e$2.collisionGroupID === t$1
						};
					}
					return this.collisionGroups[e$1];
				}
			}
			function _t$1(e$1, i$1, a$1, r$1, o$1) {
				const { horizontalAlign: s$1, verticalAlign: n$1 } = t.aT(e$1);
				return new t.P(-(s$1 - .5) * i$1 + r$1[0] * o$1, -(n$1 - .5) * a$1 + r$1[1] * o$1);
			}
			class pt$1 {
				constructor(e$1, t$1, i$1, a$1, r$1) {
					this.transform = e$1.clone(), this.terrain = t$1, this.collisionIndex = new nt$1(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = i$1, this.retainedQueryData = {}, this.collisionGroups = new dt$1(a$1), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = r$1, r$1 && (r$1.prevPlacement = void 0), this.placedOrientations = {};
				}
				_getTerrainElevationFunc(e$1) {
					const t$1 = this.terrain;
					return t$1 ? (i$1, a$1) => t$1.getElevation(e$1, i$1, a$1) : null;
				}
				getBucketParts(e$1, i$1, a$1, r$1) {
					const o$1 = a$1.getBucket(i$1), s$1 = a$1.latestFeatureIndex;
					if (!o$1 || !s$1 || i$1.id !== o$1.layerIds[0]) return;
					const n$1 = a$1.collisionBoxArray, l$1 = o$1.layers[0].layout, c$1 = o$1.layers[0].paint, h$1 = Math.pow(2, this.transform.zoom - a$1.tileID.overscaledZ), u$1 = a$1.tileSize / t.a5, d$1 = a$1.tileID.toUnwrapped(), _$2 = "map" === l$1.get("text-rotation-alignment"), p$1 = t.aO(a$1, 1, this.transform.zoom), m$1 = t.aP(this.collisionIndex.transform, a$1, c$1.get("text-translate"), c$1.get("text-translate-anchor")), f$1 = t.aP(this.collisionIndex.transform, a$1, c$1.get("icon-translate"), c$1.get("icon-translate-anchor")), g$2 = je$1(_$2, this.transform, p$1);
					this.retainedQueryData[o$1.bucketInstanceId] = new ut$1(o$1.bucketInstanceId, s$1, o$1.sourceLayerIndex, o$1.index, a$1.tileID);
					const v$1 = {
						bucket: o$1,
						layout: l$1,
						translationText: m$1,
						translationIcon: f$1,
						unwrappedTileID: d$1,
						pitchedLabelPlaneMatrix: g$2,
						scale: h$1,
						textPixelRatio: u$1,
						holdingForFade: a$1.holdingForSymbolFade(),
						collisionBoxArray: n$1,
						partiallyEvaluatedTextSize: t.az(o$1.textSizeData, this.transform.zoom),
						collisionGroup: this.collisionGroups.get(o$1.sourceID)
					};
					if (r$1) for (const t$1 of o$1.sortKeyRanges) {
						const { sortKey: i$2, symbolInstanceStart: a$2, symbolInstanceEnd: r$2 } = t$1;
						e$1.push({
							sortKey: i$2,
							symbolInstanceStart: a$2,
							symbolInstanceEnd: r$2,
							parameters: v$1
						});
					}
					else e$1.push({
						symbolInstanceStart: 0,
						symbolInstanceEnd: o$1.symbolInstances.length,
						parameters: v$1
					});
				}
				attemptAnchorPlacement(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1, m$1, f$1, g$2, v$1, x$1, b$1) {
					const y$1 = t.aQ[e$1.textAnchor], w$2 = [e$1.textOffset0, e$1.textOffset1], T$1 = _t$1(y$1, a$1, r$1, w$2, o$1), P$2 = this.collisionIndex.placeCollisionBox(i$1, d$1, l$1, c$1, h$1, n$1, s$1, f$1, u$1.predicate, x$1, T$1, b$1);
					if ((!v$1 || this.collisionIndex.placeCollisionBox(v$1, d$1, l$1, c$1, h$1, n$1, s$1, g$2, u$1.predicate, x$1, T$1, b$1).placeable) && P$2.placeable) {
						let e$2;
						if (this.prevPlacement && this.prevPlacement.variableOffsets[_$2.crossTileID] && this.prevPlacement.placements[_$2.crossTileID] && this.prevPlacement.placements[_$2.crossTileID].text && (e$2 = this.prevPlacement.variableOffsets[_$2.crossTileID].anchor), 0 === _$2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						return this.variableOffsets[_$2.crossTileID] = {
							textOffset: w$2,
							width: a$1,
							height: r$1,
							anchor: y$1,
							textBoxScale: o$1,
							prevAnchor: e$2
						}, this.markUsedJustification(p$1, y$1, _$2, m$1), p$1.allowVerticalPlacement && (this.markUsedOrientation(p$1, m$1, _$2), this.placedOrientations[_$2.crossTileID] = m$1), {
							shift: T$1,
							placedGlyphBoxes: P$2
						};
					}
				}
				placeLayerBucketPart(e$1, i$1, a$1) {
					const { bucket: r$1, layout: o$1, translationText: s$1, translationIcon: n$1, unwrappedTileID: l$1, pitchedLabelPlaneMatrix: c$1, textPixelRatio: h$1, holdingForFade: u$1, collisionBoxArray: d$1, partiallyEvaluatedTextSize: _$2, collisionGroup: p$1 } = e$1.parameters, m$1 = o$1.get("text-optional"), f$1 = o$1.get("icon-optional"), g$2 = t.aR(o$1, "text-overlap", "text-allow-overlap"), v$1 = "always" === g$2, x$1 = t.aR(o$1, "icon-overlap", "icon-allow-overlap"), b$1 = "always" === x$1, y$1 = "map" === o$1.get("text-rotation-alignment"), w$2 = "map" === o$1.get("text-pitch-alignment"), T$1 = "none" !== o$1.get("icon-text-fit"), P$2 = "viewport-y" === o$1.get("symbol-z-order"), I$2 = v$1 && (b$1 || !r$1.hasIconData() || f$1), C$1 = b$1 && (v$1 || !r$1.hasTextData() || m$1);
					!r$1.collisionArrays && d$1 && r$1.deserializeCollisionBoxes(d$1);
					const M$2 = this.retainedQueryData[r$1.bucketInstanceId].tileID, E$1 = this._getTerrainElevationFunc(M$2), S$2 = this.transform.getFastPathSimpleProjectionMatrix(M$2), R$3 = (e$2, d$2, b$2) => {
						var P$3, R$4;
						if (i$1[e$2.crossTileID]) return;
						if (u$1) return void (this.placements[e$2.crossTileID] = new ht$1(!1, !1, !1));
						let z$2 = !1, D$2 = !1, A$2 = !0, L$2 = null, k$2 = {
							box: null,
							placeable: !1,
							offscreen: null,
							occluded: !1
						}, F$2 = { placeable: !1 }, B$2 = null, O$2 = null, j$2 = null, N$1 = 0, Z$2 = 0, G$2 = 0;
						d$2.textFeatureIndex ? N$1 = d$2.textFeatureIndex : e$2.useRuntimeCollisionCircles && (N$1 = e$2.featureIndex), d$2.verticalTextFeatureIndex && (Z$2 = d$2.verticalTextFeatureIndex);
						const U$2 = d$2.textBox;
						if (U$2) {
							const i$2 = (i$3) => {
								let a$2 = t.aA.horizontal;
								if (r$1.allowVerticalPlacement && !i$3 && this.prevPlacement) {
									const t$1 = this.prevPlacement.placedOrientations[e$2.crossTileID];
									t$1 && (this.placedOrientations[e$2.crossTileID] = t$1, a$2 = t$1, this.markUsedOrientation(r$1, a$2, e$2));
								}
								return a$2;
							}, o$2 = (i$3, a$2) => {
								if (r$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && d$2.verticalTextBox) {
									for (const e$3 of r$1.writingModes) if (e$3 === t.aA.vertical ? (k$2 = a$2(), F$2 = k$2) : k$2 = i$3(), k$2 && k$2.placeable) break;
								} else k$2 = i$3();
							}, c$2 = e$2.textAnchorOffsetStartIndex, u$2 = e$2.textAnchorOffsetEndIndex;
							if (u$2 === c$2) {
								const a$2 = (t$1, i$3) => {
									const a$3 = this.collisionIndex.placeCollisionBox(t$1, g$2, h$1, M$2, l$1, w$2, y$1, s$1, p$1.predicate, E$1, void 0, S$2);
									return a$3 && a$3.placeable && (this.markUsedOrientation(r$1, i$3, e$2), this.placedOrientations[e$2.crossTileID] = i$3), a$3;
								};
								o$2((() => a$2(U$2, t.aA.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return r$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && i$3 ? a$2(i$3, t.aA.vertical) : {
										box: null,
										offscreen: null
									};
								})), i$2(k$2 && k$2.placeable);
							} else {
								let _$3 = t.aQ[null === (R$4 = null === (P$3 = this.prevPlacement) || void 0 === P$3 ? void 0 : P$3.variableOffsets[e$2.crossTileID]) || void 0 === R$4 ? void 0 : R$4.anchor];
								const m$2 = (t$1, i$3, o$3) => {
									const d$3 = t$1.x2 - t$1.x1, m$3 = t$1.y2 - t$1.y1, f$3 = e$2.textBoxScale, v$2 = T$1 && "never" === x$1 ? i$3 : null;
									let b$3 = null, P$4 = "never" === g$2 ? 1 : 2, I$3 = "never";
									_$3 && P$4++;
									for (let i$4 = 0; i$4 < P$4; i$4++) {
										for (let i$5 = c$2; i$5 < u$2; i$5++) {
											const a$2 = r$1.textAnchorOffsets.get(i$5);
											if (_$3 && a$2.textAnchor !== _$3) continue;
											const c$3 = this.attemptAnchorPlacement(a$2, t$1, d$3, m$3, f$3, y$1, w$2, h$1, M$2, l$1, p$1, I$3, e$2, r$1, o$3, s$1, n$1, v$2, E$1);
											if (c$3 && (b$3 = c$3.placedGlyphBoxes, b$3 && b$3.placeable)) return z$2 = !0, L$2 = c$3.shift, b$3;
										}
										_$3 ? _$3 = null : I$3 = g$2;
									}
									return a$1 && !b$3 && (b$3 = {
										box: this.collisionIndex.placeCollisionBox(U$2, "always", h$1, M$2, l$1, w$2, y$1, s$1, p$1.predicate, E$1, void 0, S$2).box,
										offscreen: !1,
										placeable: !1,
										occluded: !1
									}), b$3;
								};
								o$2((() => m$2(U$2, d$2.iconBox, t.aA.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return r$1.allowVerticalPlacement && (!k$2 || !k$2.placeable) && e$2.numVerticalGlyphVertices > 0 && i$3 ? m$2(i$3, d$2.verticalIconBox, t.aA.vertical) : {
										box: null,
										occluded: !0,
										offscreen: null
									};
								})), k$2 && (z$2 = k$2.placeable, A$2 = k$2.offscreen);
								const f$2 = i$2(k$2 && k$2.placeable);
								if (!z$2 && this.prevPlacement) {
									const t$1 = this.prevPlacement.variableOffsets[e$2.crossTileID];
									t$1 && (this.variableOffsets[e$2.crossTileID] = t$1, this.markUsedJustification(r$1, t$1.anchor, e$2, f$2));
								}
							}
						}
						if (B$2 = k$2, z$2 = B$2 && B$2.placeable, A$2 = B$2 && B$2.offscreen, e$2.useRuntimeCollisionCircles && e$2.centerJustifiedTextSymbolIndex >= 0) {
							const i$2 = r$1.text.placedSymbolArray.get(e$2.centerJustifiedTextSymbolIndex), n$2 = t.aB(r$1.textSizeData, _$2, i$2), h$2 = o$1.get("text-padding");
							O$2 = this.collisionIndex.placeCollisionCircles(g$2, i$2, r$1.lineVertexArray, r$1.glyphOffsetArray, n$2, l$1, c$1, a$1, w$2, p$1.predicate, e$2.collisionCircleDiameter, h$2, s$1, E$1), O$2.circles.length && O$2.collisionDetected && !a$1 && t.w("Collisions detected, but collision boxes are not shown"), z$2 = v$1 || O$2.circles.length > 0 && !O$2.collisionDetected, A$2 = A$2 && O$2.offscreen;
						}
						if (d$2.iconFeatureIndex && (G$2 = d$2.iconFeatureIndex), d$2.iconBox) {
							const e$3 = (e$4) => this.collisionIndex.placeCollisionBox(e$4, x$1, h$1, M$2, l$1, w$2, y$1, n$1, p$1.predicate, E$1, T$1 && L$2 ? L$2 : void 0, S$2);
							F$2 && F$2.placeable && d$2.verticalIconBox ? (j$2 = e$3(d$2.verticalIconBox), D$2 = j$2.placeable) : (j$2 = e$3(d$2.iconBox), D$2 = j$2.placeable), A$2 = A$2 && j$2.offscreen;
						}
						const V$2 = m$1 || 0 === e$2.numHorizontalGlyphVertices && 0 === e$2.numVerticalGlyphVertices, q$2 = f$1 || 0 === e$2.numIconVertices;
						V$2 || q$2 ? q$2 ? V$2 || (D$2 = D$2 && z$2) : z$2 = D$2 && z$2 : D$2 = z$2 = D$2 && z$2;
						const W$2 = D$2 && j$2.placeable;
						if (z$2 && B$2.placeable && this.collisionIndex.insertCollisionBox(B$2.box, g$2, o$1.get("text-ignore-placement"), r$1.bucketInstanceId, F$2 && F$2.placeable && Z$2 ? Z$2 : N$1, p$1.ID), W$2 && this.collisionIndex.insertCollisionBox(j$2.box, x$1, o$1.get("icon-ignore-placement"), r$1.bucketInstanceId, G$2, p$1.ID), O$2 && z$2 && this.collisionIndex.insertCollisionCircles(O$2.circles, g$2, o$1.get("text-ignore-placement"), r$1.bucketInstanceId, N$1, p$1.ID), a$1 && this.storeCollisionData(r$1.bucketInstanceId, b$2, d$2, B$2, j$2, O$2), 0 === e$2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						if (0 === r$1.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
						this.placements[e$2.crossTileID] = new ht$1((z$2 || I$2) && !(null == B$2 ? void 0 : B$2.occluded), (D$2 || C$1) && !(null == j$2 ? void 0 : j$2.occluded), A$2 || r$1.justReloaded), i$1[e$2.crossTileID] = !0;
					};
					if (P$2) {
						if (0 !== e$1.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
						const t$1 = r$1.getSortedSymbolIndexes(-this.transform.bearingInRadians);
						for (let e$2 = t$1.length - 1; e$2 >= 0; --e$2) {
							const i$2 = t$1[e$2];
							R$3(r$1.symbolInstances.get(i$2), r$1.collisionArrays[i$2], i$2);
						}
					} else for (let t$1 = e$1.symbolInstanceStart; t$1 < e$1.symbolInstanceEnd; t$1++) R$3(r$1.symbolInstances.get(t$1), r$1.collisionArrays[t$1], t$1);
					r$1.justReloaded = !1;
				}
				storeCollisionData(e$1, t$1, i$1, a$1, r$1, o$1) {
					if (i$1.textBox || i$1.iconBox) {
						let o$2, s$1;
						this.collisionBoxArrays.has(e$1) ? o$2 = this.collisionBoxArrays.get(e$1) : (o$2 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e$1, o$2)), o$2.has(t$1) ? s$1 = o$2.get(t$1) : (s$1 = {
							text: null,
							icon: null
						}, o$2.set(t$1, s$1)), i$1.textBox && (s$1.text = a$1.box), i$1.iconBox && (s$1.icon = r$1.box);
					}
					if (o$1) {
						let t$2 = this.collisionCircleArrays[e$1];
						void 0 === t$2 && (t$2 = this.collisionCircleArrays[e$1] = []);
						for (let e$2 = 0; e$2 < o$1.circles.length; e$2 += 4) t$2.push(o$1.circles[e$2 + 0] - st$1), t$2.push(o$1.circles[e$2 + 1] - st$1), t$2.push(o$1.circles[e$2 + 2]), t$2.push(o$1.collisionDetected ? 1 : 0);
					}
				}
				markUsedJustification(e$1, i$1, a$1, r$1) {
					let o$1;
					o$1 = r$1 === t.aA.vertical ? a$1.verticalPlacedTextSymbolIndex : {
						left: a$1.leftJustifiedTextSymbolIndex,
						center: a$1.centerJustifiedTextSymbolIndex,
						right: a$1.rightJustifiedTextSymbolIndex
					}[t.aS(i$1)];
					const s$1 = [
						a$1.leftJustifiedTextSymbolIndex,
						a$1.centerJustifiedTextSymbolIndex,
						a$1.rightJustifiedTextSymbolIndex,
						a$1.verticalPlacedTextSymbolIndex
					];
					for (const t$1 of s$1) t$1 >= 0 && (e$1.text.placedSymbolArray.get(t$1).crossTileID = o$1 >= 0 && t$1 !== o$1 ? 0 : a$1.crossTileID);
				}
				markUsedOrientation(e$1, i$1, a$1) {
					const r$1 = i$1 === t.aA.horizontal || i$1 === t.aA.horizontalOnly ? i$1 : 0, o$1 = i$1 === t.aA.vertical ? i$1 : 0, s$1 = [
						a$1.leftJustifiedTextSymbolIndex,
						a$1.centerJustifiedTextSymbolIndex,
						a$1.rightJustifiedTextSymbolIndex
					];
					for (const t$1 of s$1) e$1.text.placedSymbolArray.get(t$1).placedOrientation = r$1;
					a$1.verticalPlacedTextSymbolIndex && (e$1.text.placedSymbolArray.get(a$1.verticalPlacedTextSymbolIndex).placedOrientation = o$1);
				}
				commit(e$1) {
					this.commitTime = e$1, this.zoomAtLastRecencyCheck = this.transform.zoom;
					const t$1 = this.prevPlacement;
					let i$1 = !1;
					this.prevZoomAdjustment = t$1 ? t$1.zoomAdjustment(this.transform.zoom) : 0;
					const a$1 = t$1 ? t$1.symbolFadeChange(e$1) : 1, r$1 = t$1 ? t$1.opacities : {}, o$1 = t$1 ? t$1.variableOffsets : {}, s$1 = t$1 ? t$1.placedOrientations : {};
					for (const e$2 in this.placements) {
						const t$2 = this.placements[e$2], o$2 = r$1[e$2];
						o$2 ? (this.opacities[e$2] = new ct$1(o$2, a$1, t$2.text, t$2.icon), i$1 = i$1 || t$2.text !== o$2.text.placed || t$2.icon !== o$2.icon.placed) : (this.opacities[e$2] = new ct$1(null, a$1, t$2.text, t$2.icon, t$2.skipFade), i$1 = i$1 || t$2.text || t$2.icon);
					}
					for (const e$2 in r$1) {
						const t$2 = r$1[e$2];
						if (!this.opacities[e$2]) {
							const r$2 = new ct$1(t$2, a$1, !1, !1);
							r$2.isHidden() || (this.opacities[e$2] = r$2, i$1 = i$1 || t$2.text.placed || t$2.icon.placed);
						}
					}
					for (const e$2 in o$1) this.variableOffsets[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.variableOffsets[e$2] = o$1[e$2]);
					for (const e$2 in s$1) this.placedOrientations[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.placedOrientations[e$2] = s$1[e$2]);
					if (t$1 && void 0 === t$1.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
					i$1 ? this.lastPlacementChangeTime = e$1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t$1 ? t$1.lastPlacementChangeTime : e$1);
				}
				updateLayerOpacities(e$1, t$1) {
					const i$1 = {};
					for (const a$1 of t$1) {
						const t$2 = a$1.getBucket(e$1);
						t$2 && a$1.latestFeatureIndex && e$1.id === t$2.layerIds[0] && this.updateBucketOpacities(t$2, a$1.tileID, i$1, a$1.collisionBoxArray);
					}
				}
				updateBucketOpacities(e$1, i$1, a$1, r$1) {
					e$1.hasTextData() && (e$1.text.opacityVertexArray.clear(), e$1.text.hasVisibleVertices = !1), e$1.hasIconData() && (e$1.icon.opacityVertexArray.clear(), e$1.icon.hasVisibleVertices = !1), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexArray.clear(), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexArray.clear();
					const o$1 = e$1.layers[0], s$1 = o$1.layout, n$1 = new ct$1(null, 0, !1, !1, !0), l$1 = s$1.get("text-allow-overlap"), c$1 = s$1.get("icon-allow-overlap"), h$1 = o$1._unevaluatedLayout.hasValue("text-variable-anchor") || o$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u$1 = "map" === s$1.get("text-rotation-alignment"), d$1 = "map" === s$1.get("text-pitch-alignment"), _$2 = "none" !== s$1.get("icon-text-fit"), p$1 = new ct$1(null, 0, l$1 && (c$1 || !e$1.hasIconData() || s$1.get("icon-optional")), c$1 && (l$1 || !e$1.hasTextData() || s$1.get("text-optional")), !0);
					!e$1.collisionArrays && r$1 && (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) && e$1.deserializeCollisionBoxes(r$1);
					const m$1 = (e$2, t$1, i$2) => {
						for (let a$2 = 0; a$2 < t$1 / 4; a$2++) e$2.opacityVertexArray.emplaceBack(i$2);
						e$2.hasVisibleVertices = e$2.hasVisibleVertices || i$2 !== Pt$1;
					}, f$1 = this.collisionBoxArrays.get(e$1.bucketInstanceId);
					for (let i$2 = 0; i$2 < e$1.symbolInstances.length; i$2++) {
						const r$2 = e$1.symbolInstances.get(i$2), { numHorizontalGlyphVertices: o$2, numVerticalGlyphVertices: s$2, crossTileID: l$2 } = r$2;
						let c$2 = this.opacities[l$2];
						a$1[l$2] ? c$2 = n$1 : c$2 || (c$2 = p$1, this.opacities[l$2] = c$2), a$1[l$2] = !0;
						const g$2 = r$2.numIconVertices > 0, v$1 = this.placedOrientations[r$2.crossTileID], x$1 = v$1 === t.aA.vertical, b$1 = v$1 === t.aA.horizontal || v$1 === t.aA.horizontalOnly;
						if (o$2 > 0 || s$2 > 0) {
							const t$1 = Tt$1(c$2.text);
							m$1(e$1.text, o$2, x$1 ? Pt$1 : t$1), m$1(e$1.text, s$2, b$1 ? Pt$1 : t$1);
							const i$3 = c$2.text.isHidden();
							[
								r$2.rightJustifiedTextSymbolIndex,
								r$2.centerJustifiedTextSymbolIndex,
								r$2.leftJustifiedTextSymbolIndex
							].forEach(((t$2) => {
								t$2 >= 0 && (e$1.text.placedSymbolArray.get(t$2).hidden = i$3 || x$1 ? 1 : 0);
							})), r$2.verticalPlacedTextSymbolIndex >= 0 && (e$1.text.placedSymbolArray.get(r$2.verticalPlacedTextSymbolIndex).hidden = i$3 || b$1 ? 1 : 0);
							const a$2 = this.variableOffsets[r$2.crossTileID];
							a$2 && this.markUsedJustification(e$1, a$2.anchor, r$2, v$1);
							const n$2 = this.placedOrientations[r$2.crossTileID];
							n$2 && (this.markUsedJustification(e$1, "left", r$2, n$2), this.markUsedOrientation(e$1, n$2, r$2));
						}
						if (g$2) {
							const t$1 = Tt$1(c$2.icon), i$3 = !(_$2 && r$2.verticalPlacedIconSymbolIndex && x$1);
							r$2.placedIconSymbolIndex >= 0 && (m$1(e$1.icon, r$2.numIconVertices, i$3 ? t$1 : Pt$1), e$1.icon.placedSymbolArray.get(r$2.placedIconSymbolIndex).hidden = c$2.icon.isHidden()), r$2.verticalPlacedIconSymbolIndex >= 0 && (m$1(e$1.icon, r$2.numVerticalIconVertices, i$3 ? Pt$1 : t$1), e$1.icon.placedSymbolArray.get(r$2.verticalPlacedIconSymbolIndex).hidden = c$2.icon.isHidden());
						}
						const y$1 = f$1 && f$1.has(i$2) ? f$1.get(i$2) : {
							text: null,
							icon: null
						};
						if (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) {
							const a$2 = e$1.collisionArrays[i$2];
							if (a$2) {
								let i$3 = new t.P(0, 0);
								if (a$2.textBox || a$2.verticalTextBox) {
									let t$1 = !0;
									if (h$1) {
										const e$2 = this.variableOffsets[l$2];
										e$2 ? (i$3 = _t$1(e$2.anchor, e$2.width, e$2.height, e$2.textOffset, e$2.textBoxScale), u$1 && i$3._rotate(d$1 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t$1 = !1;
									}
									if (a$2.textBox || a$2.verticalTextBox) {
										let r$3;
										a$2.textBox && (r$3 = x$1), a$2.verticalTextBox && (r$3 = b$1), mt$1(e$1.textCollisionBox.collisionVertexArray, c$2.text.placed, !t$1 || r$3, y$1.text, i$3.x, i$3.y);
									}
								}
								if (a$2.iconBox || a$2.verticalIconBox) {
									const t$1 = Boolean(!b$1 && a$2.verticalIconBox);
									let r$3;
									a$2.iconBox && (r$3 = t$1), a$2.verticalIconBox && (r$3 = !t$1), mt$1(e$1.iconCollisionBox.collisionVertexArray, c$2.icon.placed, r$3, y$1.icon, _$2 ? i$3.x : 0, _$2 ? i$3.y : 0);
								}
							}
						}
					}
					if (e$1.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e$1.bucketInstanceId] && (this.retainedQueryData[e$1.bucketInstanceId].featureSortOrder = e$1.featureSortOrder), e$1.hasTextData() && e$1.text.opacityVertexBuffer && e$1.text.opacityVertexBuffer.updateData(e$1.text.opacityVertexArray), e$1.hasIconData() && e$1.icon.opacityVertexBuffer && e$1.icon.opacityVertexBuffer.updateData(e$1.icon.opacityVertexArray), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexBuffer && e$1.iconCollisionBox.collisionVertexBuffer.updateData(e$1.iconCollisionBox.collisionVertexArray), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexBuffer && e$1.textCollisionBox.collisionVertexBuffer.updateData(e$1.textCollisionBox.collisionVertexArray), e$1.text.opacityVertexArray.length !== e$1.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e$1.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e$1.text.layoutVertexArray.length}) / 4`);
					if (e$1.icon.opacityVertexArray.length !== e$1.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e$1.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e$1.icon.layoutVertexArray.length}) / 4`);
					e$1.bucketInstanceId in this.collisionCircleArrays && (e$1.collisionCircleArray = this.collisionCircleArrays[e$1.bucketInstanceId], delete this.collisionCircleArrays[e$1.bucketInstanceId]);
				}
				symbolFadeChange(e$1) {
					return 0 === this.fadeDuration ? 1 : (e$1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
				}
				zoomAdjustment(e$1) {
					return Math.max(0, (this.transform.zoom - e$1) / 1.5);
				}
				hasTransitions(e$1) {
					return this.stale || e$1 - this.lastPlacementChangeTime < this.fadeDuration;
				}
				stillRecent(e$1, t$1) {
					const i$1 = this.zoomAtLastRecencyCheck === t$1 ? 1 - this.zoomAdjustment(t$1) : 1;
					return this.zoomAtLastRecencyCheck = t$1, this.commitTime + this.fadeDuration * i$1 > e$1;
				}
				setStale() {
					this.stale = !0;
				}
			}
			function mt$1(e$1, t$1, i$1, a$1, r$1, o$1) {
				a$1 && 0 !== a$1.length || (a$1 = [
					0,
					0,
					0,
					0
				]);
				const s$1 = a$1[0] - st$1, n$1 = a$1[1] - st$1, l$1 = a$1[2] - st$1, c$1 = a$1[3] - st$1;
				e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, o$1 || 0, s$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, o$1 || 0, l$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, o$1 || 0, l$1, c$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, o$1 || 0, s$1, c$1);
			}
			const ft = Math.pow(2, 25), gt$1 = Math.pow(2, 24), vt$1 = Math.pow(2, 17), xt$1 = Math.pow(2, 16), bt$1 = Math.pow(2, 9), yt$1 = Math.pow(2, 8), wt$1 = Math.pow(2, 1);
			function Tt$1(e$1) {
				if (0 === e$1.opacity && !e$1.placed) return 0;
				if (1 === e$1.opacity && e$1.placed) return 4294967295;
				const t$1 = e$1.placed ? 1 : 0, i$1 = Math.floor(127 * e$1.opacity);
				return i$1 * ft + t$1 * gt$1 + i$1 * vt$1 + t$1 * xt$1 + i$1 * bt$1 + t$1 * yt$1 + i$1 * wt$1 + t$1;
			}
			const Pt$1 = 0;
			class It$1 {
				constructor(e$1) {
					this._sortAcrossTiles = "viewport-y" !== e$1.layout.get("symbol-z-order") && !e$1.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
				}
				continuePlacement(e$1, t$1, i$1, a$1, r$1) {
					const o$1 = this._bucketParts;
					for (; this._currentTileIndex < e$1.length;) if (t$1.getBucketParts(o$1, a$1, e$1[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r$1()) return !0;
					for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, o$1.sort(((e$2, t$2) => e$2.sortKey - t$2.sortKey))); this._currentPartIndex < o$1.length;) if (t$1.placeLayerBucketPart(o$1[this._currentPartIndex], this._seenCrossTileIDs, i$1), this._currentPartIndex++, r$1()) return !0;
					return !1;
				}
			}
			class Ct$1 {
				constructor(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1) {
					this.placement = new pt$1(e$1, t$1, o$1, s$1, n$1), this._currentPlacementIndex = i$1.length - 1, this._forceFullPlacement = a$1, this._showCollisionBoxes = r$1, this._done = !1;
				}
				isDone() {
					return this._done;
				}
				continuePlacement(e$1, t$1, i$1) {
					const a$1 = c(), r$1 = () => !this._forceFullPlacement && c() - a$1 > 2;
					for (; this._currentPlacementIndex >= 0;) {
						const a$2 = t$1[e$1[this._currentPlacementIndex]], o$1 = this.placement.collisionIndex.transform.zoom;
						if ("symbol" === a$2.type && (!a$2.minzoom || a$2.minzoom <= o$1) && (!a$2.maxzoom || a$2.maxzoom > o$1)) {
							if (this._inProgressLayer || (this._inProgressLayer = new It$1(a$2)), this._inProgressLayer.continuePlacement(i$1[a$2.source], this.placement, this._showCollisionBoxes, a$2, r$1)) return;
							delete this._inProgressLayer;
						}
						this._currentPlacementIndex--;
					}
					this._done = !0;
				}
				commit(e$1) {
					return this.placement.commit(e$1), this.placement;
				}
			}
			const Mt$1 = 512 / t.a5 / 2;
			class Et$1 {
				constructor(e$1, i$1, a$1) {
					this.tileID = e$1, this.bucketInstanceId = a$1, this._symbolsByKey = {};
					const r$1 = /* @__PURE__ */ new Map();
					for (let e$2 = 0; e$2 < i$1.length; e$2++) {
						const t$1 = i$1.get(e$2), a$2 = t$1.key, o$1 = r$1.get(a$2);
						o$1 ? o$1.push(t$1) : r$1.set(a$2, [t$1]);
					}
					for (const [e$2, i$2] of r$1) {
						const a$2 = {
							positions: i$2.map(((e$3) => ({
								x: Math.floor(e$3.anchorX * Mt$1),
								y: Math.floor(e$3.anchorY * Mt$1)
							}))),
							crossTileIDs: i$2.map(((e$3) => e$3.crossTileID))
						};
						if (a$2.positions.length > 128) {
							const e$3 = new t.aU(a$2.positions.length, 16, Uint16Array);
							for (const { x: t$1, y: i$3 } of a$2.positions) e$3.add(t$1, i$3);
							e$3.finish(), delete a$2.positions, a$2.index = e$3;
						}
						this._symbolsByKey[e$2] = a$2;
					}
				}
				getScaledCoordinates(e$1, i$1) {
					const { x: a$1, y: r$1, z: o$1 } = this.tileID.canonical, { x: s$1, y: n$1, z: l$1 } = i$1.canonical, c$1 = Mt$1 / Math.pow(2, l$1 - o$1), h$1 = (n$1 * t.a5 + e$1.anchorY) * c$1, u$1 = r$1 * t.a5 * Mt$1;
					return {
						x: Math.floor((s$1 * t.a5 + e$1.anchorX) * c$1 - a$1 * t.a5 * Mt$1),
						y: Math.floor(h$1 - u$1)
					};
				}
				findMatches(e$1, t$1, i$1) {
					const a$1 = this.tileID.canonical.z < t$1.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t$1.canonical.z);
					for (let r$1 = 0; r$1 < e$1.length; r$1++) {
						const o$1 = e$1.get(r$1);
						if (o$1.crossTileID) continue;
						const s$1 = this._symbolsByKey[o$1.key];
						if (!s$1) continue;
						const n$1 = this.getScaledCoordinates(o$1, t$1);
						if (s$1.index) {
							const e$2 = s$1.index.range(n$1.x - a$1, n$1.y - a$1, n$1.x + a$1, n$1.y + a$1).sort();
							for (const t$2 of e$2) {
								const e$3 = s$1.crossTileIDs[t$2];
								if (!i$1[e$3]) {
									i$1[e$3] = !0, o$1.crossTileID = e$3;
									break;
								}
							}
						} else if (s$1.positions) for (let e$2 = 0; e$2 < s$1.positions.length; e$2++) {
							const t$2 = s$1.positions[e$2], r$2 = s$1.crossTileIDs[e$2];
							if (Math.abs(t$2.x - n$1.x) <= a$1 && Math.abs(t$2.y - n$1.y) <= a$1 && !i$1[r$2]) {
								i$1[r$2] = !0, o$1.crossTileID = r$2;
								break;
							}
						}
					}
				}
				getCrossTileIDsLists() {
					return Object.values(this._symbolsByKey).map((({ crossTileIDs: e$1 }) => e$1));
				}
			}
			class St$1 {
				constructor() {
					this.maxCrossTileID = 0;
				}
				generate() {
					return ++this.maxCrossTileID;
				}
			}
			class Rt$1 {
				constructor() {
					this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - this.lng) / 360);
					if (0 !== t$1) for (const e$2 in this.indexes) {
						const i$1 = this.indexes[e$2], a$1 = {};
						for (const e$3 in i$1) {
							const r$1 = i$1[e$3];
							r$1.tileID = r$1.tileID.unwrapTo(r$1.tileID.wrap + t$1), a$1[r$1.tileID.key] = r$1;
						}
						this.indexes[e$2] = a$1;
					}
					this.lng = e$1;
				}
				addBucket(e$1, t$1, i$1) {
					if (this.indexes[e$1.overscaledZ] && this.indexes[e$1.overscaledZ][e$1.key]) {
						if (this.indexes[e$1.overscaledZ][e$1.key].bucketInstanceId === t$1.bucketInstanceId) return !1;
						this.removeBucketCrossTileIDs(e$1.overscaledZ, this.indexes[e$1.overscaledZ][e$1.key]);
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) t$1.symbolInstances.get(e$2).crossTileID = 0;
					this.usedCrossTileIDs[e$1.overscaledZ] || (this.usedCrossTileIDs[e$1.overscaledZ] = {});
					const a$1 = this.usedCrossTileIDs[e$1.overscaledZ];
					for (const i$2 in this.indexes) {
						const r$1 = this.indexes[i$2];
						if (Number(i$2) > e$1.overscaledZ) for (const i$3 in r$1) {
							const o$1 = r$1[i$3];
							o$1.tileID.isChildOf(e$1) && o$1.findMatches(t$1.symbolInstances, e$1, a$1);
						}
						else {
							const o$1 = r$1[e$1.scaledTo(Number(i$2)).key];
							o$1 && o$1.findMatches(t$1.symbolInstances, e$1, a$1);
						}
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) {
						const r$1 = t$1.symbolInstances.get(e$2);
						r$1.crossTileID || (r$1.crossTileID = i$1.generate(), a$1[r$1.crossTileID] = !0);
					}
					return void 0 === this.indexes[e$1.overscaledZ] && (this.indexes[e$1.overscaledZ] = {}), this.indexes[e$1.overscaledZ][e$1.key] = new Et$1(e$1, t$1.symbolInstances, t$1.bucketInstanceId), !0;
				}
				removeBucketCrossTileIDs(e$1, t$1) {
					for (const i$1 of t$1.getCrossTileIDsLists()) for (const t$2 of i$1) delete this.usedCrossTileIDs[e$1][t$2];
				}
				removeStaleBuckets(e$1) {
					let t$1 = !1;
					for (const i$1 in this.indexes) {
						const a$1 = this.indexes[i$1];
						for (const r$1 in a$1) e$1[a$1[r$1].bucketInstanceId] || (this.removeBucketCrossTileIDs(i$1, a$1[r$1]), delete a$1[r$1], t$1 = !0);
					}
					return t$1;
				}
			}
			class zt$1 {
				constructor() {
					this.layerIndexes = {}, this.crossTileIDs = new St$1(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
				}
				addLayer(e$1, t$1, i$1) {
					let a$1 = this.layerIndexes[e$1.id];
					void 0 === a$1 && (a$1 = this.layerIndexes[e$1.id] = new Rt$1());
					let r$1 = !1;
					const o$1 = {};
					a$1.handleWrapJump(i$1);
					for (const i$2 of t$1) {
						const t$2 = i$2.getBucket(e$1);
						t$2 && e$1.id === t$2.layerIds[0] && (t$2.bucketInstanceId || (t$2.bucketInstanceId = ++this.maxBucketInstanceId), a$1.addBucket(i$2.tileID, t$2, this.crossTileIDs) && (r$1 = !0), o$1[t$2.bucketInstanceId] = !0);
					}
					return a$1.removeStaleBuckets(o$1) && (r$1 = !0), r$1;
				}
				pruneUnusedLayers(e$1) {
					const t$1 = {};
					e$1.forEach(((e$2) => {
						t$1[e$2] = !0;
					}));
					for (const e$2 in this.layerIndexes) t$1[e$2] || delete this.layerIndexes[e$2];
				}
			}
			var Dt$1 = "void main() {fragColor=vec4(1.0);}";
			const At$1 = {
				prelude: Lt$1("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"),
				projectionMercator: Lt$1("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
				projectionGlobe: Lt$1("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"),
				background: Lt$1("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				backgroundPattern: Lt$1("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
				circle: Lt$1("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),
				clippingMask: Lt$1(Dt$1, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				heatmap: Lt$1("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"),
				heatmapTexture: Lt$1("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
				collisionBox: Lt$1("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
				collisionCircle: Lt$1("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
				colorRelief: Lt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				debug: Lt$1("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
				depth: Lt$1(Dt$1, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"),
				fill: Lt$1("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"),
				fillOutline: Lt$1("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillOutlinePattern: Lt$1("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillPattern: Lt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),
				fillExtrusion: Lt$1("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),
				fillExtrusionPattern: Lt$1("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),
				hillshadePrepare: Lt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
				hillshade: Lt$1("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				line: Lt$1("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				lineGradient: Lt$1("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				linePattern: Lt$1("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),
				lineSDF: Lt$1("uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"),
				lineGradientSDF: Lt$1("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"),
				raster: Lt$1("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
				symbolIcon: Lt$1("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"),
				symbolSDF: Lt$1("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),
				symbolTextAndIcon: Lt$1("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"),
				terrain: Lt$1("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
				terrainDepth: Lt$1("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
				terrainCoords: Lt$1("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
				projectionErrorMeasurement: Lt$1("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
				atmosphere: Lt$1("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
				sky: Lt$1("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
			};
			function Lt$1(e$1, t$1) {
				const i$1 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a$1 = t$1.match(/in ([\w]+) ([\w]+)/g), r$1 = e$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o$1 = t$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s$1 = o$1 ? o$1.concat(r$1) : r$1, n$1 = {};
				return {
					fragmentSource: e$1 = e$1.replace(i$1, ((e$2, t$2, i$2, a$2, r$2) => (n$1[r$2] = !0, "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nin ${i$2} ${a$2} ${r$2};\n#else\nuniform ${i$2} ${a$2} u_${r$2};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${a$2} ${r$2} = u_${r$2};\n#endif\n`))),
					vertexSource: t$1 = t$1.replace(i$1, ((e$2, t$2, i$2, a$2, r$2) => {
						const o$2 = "float" === a$2 ? "vec2" : "vec4", s$2 = r$2.match(/color/) ? "color" : o$2;
						return n$1[r$2] ? "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\nin ${i$2} ${o$2} a_${r$2};\nout ${i$2} ${a$2} ${r$2};\n#else\nuniform ${i$2} ${a$2} u_${r$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${r$2} = a_${r$2};\n#else\n    ${i$2} ${a$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${r$2} = unpack_mix_${s$2}(a_${r$2}, u_${r$2}_t);\n#else\n    ${i$2} ${a$2} ${r$2} = u_${r$2};\n#endif\n` : "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\nin ${i$2} ${o$2} a_${r$2};\n#else\nuniform ${i$2} ${a$2} u_${r$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${a$2} ${r$2} = a_${r$2};\n#else\n    ${i$2} ${a$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${a$2} ${r$2} = unpack_mix_${s$2}(a_${r$2}, u_${r$2}_t);\n#else\n    ${i$2} ${a$2} ${r$2} = u_${r$2};\n#endif\n`;
					})),
					staticAttributes: a$1,
					staticUniforms: s$1
				};
			}
			class kt$1 {
				constructor(e$1, t$1, i$1) {
					this.vertexBuffer = e$1, this.indexBuffer = t$1, this.segments = i$1;
				}
				destroy() {
					this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
				}
			}
			var Ft$1 = t.aV([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}]);
			const Bt$1 = "#define PROJECTION_MERCATOR", Ot$1 = "mercator";
			class jt$1 {
				constructor() {
					this._cachedMesh = null;
				}
				get name() {
					return "mercator";
				}
				get useSubdivision() {
					return !1;
				}
				get shaderVariantName() {
					return Ot$1;
				}
				get shaderDefine() {
					return Bt$1;
				}
				get shaderPreludeCode() {
					return At$1.projectionMercator;
				}
				get vertexShaderPreludeCode() {
					return At$1.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return t.aW.noSubdivision;
				}
				get useGlobeControls() {
					return !1;
				}
				get transitionState() {
					return 0;
				}
				get latitudeErrorCorrectionRadians() {
					return 0;
				}
				destroy() {}
				updateGPUdependent(e$1) {}
				getMeshFromTileID(e$1, i$1, a$1, r$1, o$1) {
					if (this._cachedMesh) return this._cachedMesh;
					const s$1 = new t.aX();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(t.a5, 0), s$1.emplaceBack(0, t.a5), s$1.emplaceBack(t.a5, t.a5);
					const n$1 = e$1.createVertexBuffer(s$1, Ft$1.members), l$1 = t.aY.simpleSegment(0, 0, 4, 2), c$1 = new t.aZ();
					c$1.emplaceBack(1, 0, 2), c$1.emplaceBack(1, 2, 3);
					return this._cachedMesh = new kt$1(n$1, e$1.createIndexBuffer(c$1), l$1), this._cachedMesh;
				}
				recalculate() {}
				hasTransition() {
					return !1;
				}
				setErrorQueryLatitudeDegrees(e$1) {}
			}
			class Nt$1 {
				constructor(e$1 = 0, t$1 = 0, i$1 = 0, a$1 = 0) {
					if (isNaN(e$1) || e$1 < 0 || isNaN(t$1) || t$1 < 0 || isNaN(i$1) || i$1 < 0 || isNaN(a$1) || a$1 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
					this.top = e$1, this.bottom = t$1, this.left = i$1, this.right = a$1;
				}
				interpolate(e$1, i$1, a$1) {
					return null != i$1.top && null != e$1.top && (this.top = t.G.number(e$1.top, i$1.top, a$1)), null != i$1.bottom && null != e$1.bottom && (this.bottom = t.G.number(e$1.bottom, i$1.bottom, a$1)), null != i$1.left && null != e$1.left && (this.left = t.G.number(e$1.left, i$1.left, a$1)), null != i$1.right && null != e$1.right && (this.right = t.G.number(e$1.right, i$1.right, a$1)), this;
				}
				getCenter(e$1, i$1) {
					const a$1 = t.ao((this.left + e$1 - this.right) / 2, 0, e$1), r$1 = t.ao((this.top + i$1 - this.bottom) / 2, 0, i$1);
					return new t.P(a$1, r$1);
				}
				equals(e$1) {
					return this.top === e$1.top && this.bottom === e$1.bottom && this.left === e$1.left && this.right === e$1.right;
				}
				clone() {
					return new Nt$1(this.top, this.bottom, this.left, this.right);
				}
				toJSON() {
					return {
						top: this.top,
						bottom: this.bottom,
						left: this.left,
						right: this.right
					};
				}
			}
			function Zt$1(e$1, t$1) {
				if (!e$1.renderWorldCopies || e$1.lngRange) return;
				const i$1 = t$1.lng - e$1.center.lng;
				t$1.lng += i$1 > 180 ? -360 : i$1 < -180 ? 360 : 0;
			}
			function Gt$1(e$1) {
				return Math.max(0, Math.floor(e$1));
			}
			class Ut$1 {
				constructor(e$1, i$1) {
					var a$1;
					this.applyConstrain = (e$2, t$1) => null !== this._constrainOverride ? this._constrainOverride(e$2, t$1) : this._callbacks.defaultConstrain(e$2, t$1), this._callbacks = e$1, this._tileSize = 512, this._renderWorldCopies = void 0 === (null == i$1 ? void 0 : i$1.renderWorldCopies) || !!(null == i$1 ? void 0 : i$1.renderWorldCopies), this._minZoom = (null == i$1 ? void 0 : i$1.minZoom) || 0, this._maxZoom = (null == i$1 ? void 0 : i$1.maxZoom) || 22, this._minPitch = null == (null == i$1 ? void 0 : i$1.minPitch) ? 0 : null == i$1 ? void 0 : i$1.minPitch, this._maxPitch = null == (null == i$1 ? void 0 : i$1.maxPitch) ? 60 : null == i$1 ? void 0 : i$1.maxPitch, this._constrainOverride = null !== (a$1 = null == i$1 ? void 0 : i$1.constrainOverride) && void 0 !== a$1 ? a$1 : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Gt$1(this._zoom), this._scale = t.ar(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Nt$1(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
				}
				apply(e$1, i$1, a$1) {
					this._constrainOverride = e$1.constrainOverride, this._latRange = e$1.latRange, this._lngRange = e$1.lngRange, this._width = e$1.width, this._height = e$1.height, this._center = e$1.center, this._elevation = e$1.elevation, this._minElevationForCurrentTile = e$1.minElevationForCurrentTile, this._zoom = e$1.zoom, this._tileZoom = Gt$1(this._zoom), this._scale = t.ar(this._zoom), this._bearingInRadians = e$1.bearingInRadians, this._fovInRadians = e$1.fovInRadians, this._pitchInRadians = e$1.pitchInRadians, this._rollInRadians = e$1.rollInRadians, this._unmodified = e$1.unmodified, this._edgeInsets = new Nt$1(e$1.padding.top, e$1.padding.bottom, e$1.padding.left, e$1.padding.right), this._minZoom = e$1.minZoom, this._maxZoom = e$1.maxZoom, this._minPitch = e$1.minPitch, this._maxPitch = e$1.maxPitch, this._renderWorldCopies = e$1.renderWorldCopies, this._cameraToCenterDistance = e$1.cameraToCenterDistance, this._nearZ = e$1.nearZ, this._farZ = e$1.farZ, this._autoCalculateNearFarZ = !a$1 && e$1.autoCalculateNearFarZ, i$1 && this.constrainInternal(), this._calcMatrices();
				}
				get pixelsToClipSpaceMatrix() {
					return this._pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._clipSpaceToPixelsMatrix;
				}
				get minElevationForCurrentTile() {
					return this._minElevationForCurrentTile;
				}
				setMinElevationForCurrentTile(e$1) {
					this._minElevationForCurrentTile = e$1;
				}
				get tileSize() {
					return this._tileSize;
				}
				get tileZoom() {
					return this._tileZoom;
				}
				get scale() {
					return this._scale;
				}
				get width() {
					return this._width;
				}
				get height() {
					return this._height;
				}
				get bearingInRadians() {
					return this._bearingInRadians;
				}
				get lngRange() {
					return this._lngRange;
				}
				get latRange() {
					return this._latRange;
				}
				get pixelsToGLUnits() {
					return this._pixelsToGLUnits;
				}
				get minZoom() {
					return this._minZoom;
				}
				setMinZoom(e$1) {
					this._minZoom !== e$1 && (this._minZoom = e$1, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
				}
				get maxZoom() {
					return this._maxZoom;
				}
				setMaxZoom(e$1) {
					this._maxZoom !== e$1 && (this._maxZoom = e$1, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
				}
				get minPitch() {
					return this._minPitch;
				}
				setMinPitch(e$1) {
					this._minPitch !== e$1 && (this._minPitch = e$1, this.setPitch(Math.max(this.pitch, e$1)));
				}
				get maxPitch() {
					return this._maxPitch;
				}
				setMaxPitch(e$1) {
					this._maxPitch !== e$1 && (this._maxPitch = e$1, this.setPitch(Math.min(this.pitch, e$1)));
				}
				get renderWorldCopies() {
					return this._renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					void 0 === e$1 ? e$1 = !0 : null === e$1 && (e$1 = !1), this._renderWorldCopies = e$1;
				}
				get constrainOverride() {
					return this._constrainOverride;
				}
				setConstrainOverride(e$1) {
					void 0 === e$1 && (e$1 = null), this._constrainOverride !== e$1 && (this._constrainOverride = e$1, this.constrainInternal(), this._calcMatrices());
				}
				get worldSize() {
					return this._tileSize * this._scale;
				}
				get centerOffset() {
					return this.centerPoint._sub(this.size._div(2));
				}
				get size() {
					return new t.P(this._width, this._height);
				}
				get bearing() {
					return this._bearingInRadians / Math.PI * 180;
				}
				setBearing(e$1) {
					const i$1 = t.W(e$1, -180, 180) * Math.PI / 180;
					var r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1;
					this._bearingInRadians !== i$1 && (this._unmodified = !1, this._bearingInRadians = i$1, this._calcMatrices(), this._rotationMatrix = a(), r$1 = this._rotationMatrix, s$1 = -this._bearingInRadians, n$1 = (o$1 = this._rotationMatrix)[0], l$1 = o$1[1], c$1 = o$1[2], h$1 = o$1[3], u$1 = Math.sin(s$1), d$1 = Math.cos(s$1), r$1[0] = n$1 * d$1 + c$1 * u$1, r$1[1] = l$1 * d$1 + h$1 * u$1, r$1[2] = n$1 * -u$1 + c$1 * d$1, r$1[3] = l$1 * -u$1 + h$1 * d$1);
				}
				get rotationMatrix() {
					return this._rotationMatrix;
				}
				get pitchInRadians() {
					return this._pitchInRadians;
				}
				get pitch() {
					return this._pitchInRadians / Math.PI * 180;
				}
				setPitch(e$1) {
					const i$1 = t.ao(e$1, this.minPitch, this.maxPitch) / 180 * Math.PI;
					this._pitchInRadians !== i$1 && (this._unmodified = !1, this._pitchInRadians = i$1, this._calcMatrices());
				}
				get rollInRadians() {
					return this._rollInRadians;
				}
				get roll() {
					return this._rollInRadians / Math.PI * 180;
				}
				setRoll(e$1) {
					const t$1 = e$1 / 180 * Math.PI;
					this._rollInRadians !== t$1 && (this._unmodified = !1, this._rollInRadians = t$1, this._calcMatrices());
				}
				get fovInRadians() {
					return this._fovInRadians;
				}
				get fov() {
					return t.a_(this._fovInRadians);
				}
				setFov(e$1) {
					e$1 = t.ao(e$1, .1, 150), this.fov !== e$1 && (this._unmodified = !1, this._fovInRadians = t.aq(e$1), this._calcMatrices());
				}
				get zoom() {
					return this._zoom;
				}
				setZoom(e$1) {
					const i$1 = this.applyConstrain(this._center, e$1).zoom;
					this._zoom !== i$1 && (this._unmodified = !1, this._zoom = i$1, this._tileZoom = Math.max(0, Math.floor(i$1)), this._scale = t.ar(i$1), this.constrainInternal(), this._calcMatrices());
				}
				get center() {
					return this._center;
				}
				setCenter(e$1) {
					e$1.lat === this._center.lat && e$1.lng === this._center.lng || (this._unmodified = !1, this._center = e$1, this.constrainInternal(), this._calcMatrices());
				}
				get elevation() {
					return this._elevation;
				}
				setElevation(e$1) {
					e$1 !== this._elevation && (this._elevation = e$1, this.constrainInternal(), this._calcMatrices());
				}
				get padding() {
					return this._edgeInsets.toJSON();
				}
				setPadding(e$1) {
					this._edgeInsets.equals(e$1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e$1, 1), this._calcMatrices());
				}
				get centerPoint() {
					return this._edgeInsets.getCenter(this._width, this._height);
				}
				get pixelsPerMeter() {
					return this._pixelPerMeter;
				}
				get unmodified() {
					return this._unmodified;
				}
				get cameraToCenterDistance() {
					return this._cameraToCenterDistance;
				}
				get nearZ() {
					return this._nearZ;
				}
				get farZ() {
					return this._farZ;
				}
				get autoCalculateNearFarZ() {
					return this._autoCalculateNearFarZ;
				}
				overrideNearFarZ(e$1, t$1) {
					this._autoCalculateNearFarZ = !1, this._nearZ = e$1, this._farZ = t$1, this._calcMatrices();
				}
				clearNearFarZOverride() {
					this._autoCalculateNearFarZ = !0, this._calcMatrices();
				}
				isPaddingEqual(e$1) {
					return this._edgeInsets.equals(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					this._unmodified = !1, this._edgeInsets.interpolate(e$1, t$1, i$1), this.constrainInternal(), this._calcMatrices();
				}
				resize(e$1, t$1, i$1 = !0) {
					this._width = e$1, this._height = t$1, i$1 && this.constrainInternal(), this._calcMatrices();
				}
				getMaxBounds() {
					return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new $$1([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
				}
				setMaxBounds(e$1) {
					e$1 ? (this._lngRange = [e$1.getWest(), e$1.getEast()], this._latRange = [e$1.getSouth(), e$1.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-t.ap, t.ap]);
				}
				getCameraQueryGeometry(e$1, i$1) {
					if (1 === i$1.length) return [i$1[0], e$1];
					{
						const { minX: a$1, minY: r$1, maxX: o$1, maxY: s$1 } = t.ac.fromPoints(i$1).extend(e$1);
						return [
							new t.P(a$1, r$1),
							new t.P(o$1, r$1),
							new t.P(o$1, s$1),
							new t.P(a$1, s$1),
							new t.P(a$1, r$1)
						];
					}
				}
				constrainInternal() {
					if (!this.center || !this._width || !this._height || this._constraining) return;
					this._constraining = !0;
					const e$1 = this._unmodified, { center: t$1, zoom: i$1 } = this.applyConstrain(this.center, this.zoom);
					this.setCenter(t$1), this.setZoom(i$1), this._unmodified = e$1, this._constraining = !1;
				}
				_calcMatrices() {
					if (this._width && this._height) {
						this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
						let e$1 = t.as(new Float64Array(16));
						t.Q(e$1, e$1, [
							this._width / 2,
							-this._height / 2,
							1
						]), t.O(e$1, e$1, [
							1,
							-1,
							0
						]), this._clipSpaceToPixelsMatrix = e$1, e$1 = t.as(new Float64Array(16)), t.Q(e$1, e$1, [
							1,
							-1,
							1
						]), t.O(e$1, e$1, [
							-1,
							-1,
							0
						]), t.Q(e$1, e$1, [
							2 / this._width,
							2 / this._height,
							1
						]), this._pixelsToClipSpaceMatrix = e$1, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height;
					}
					this._callbacks.calcMatrices();
				}
				calculateCenterFromCameraLngLatAlt(e$1, i$1, a$1, r$1) {
					const o$1 = void 0 !== a$1 ? a$1 : this.bearing, s$1 = r$1 = void 0 !== r$1 ? r$1 : this.pitch, { distanceToCenter: n$1, clampedElevation: l$1 } = this._distanceToCenterFromAltElevationPitch(i$1, this.elevation, s$1), { x: c$1, y: h$1 } = be$1(s$1, o$1), u$1 = t.ab.fromLngLat(e$1, i$1);
					let d$1, _$2, p$1 = t.a$(1, u$1.y), m$1 = 0;
					do {
						if (m$1 += 1, m$1 > 10) break;
						_$2 = n$1 / p$1, d$1 = new t.ab(u$1.x + c$1 * _$2, u$1.y + h$1 * _$2), p$1 = 1 / d$1.meterInMercatorCoordinateUnits();
					} while (Math.abs(n$1 - _$2 * p$1) > 1e-12);
					return {
						center: d$1.toLngLat(),
						elevation: l$1,
						zoom: t.au(this.height / 2 / Math.tan(this.fovInRadians / 2) / _$2 / this.tileSize)
					};
				}
				recalculateZoomAndCenter(e$1) {
					if (this.elevation - e$1 == 0) return;
					const i$1 = 1 / this.worldSize, a$1 = t.at(1, this.center.lat) * this.worldSize, r$1 = t.ab.fromLngLat(this.center, this.elevation), o$1 = r$1.x / i$1, s$1 = r$1.y / i$1, n$1 = r$1.z / i$1, l$1 = this.pitch, c$1 = this.bearing, { x: h$1, y: u$1, z: d$1 } = be$1(l$1, c$1), _$2 = this.cameraToCenterDistance, p$1 = o$1 + _$2 * -h$1, m$1 = s$1 + _$2 * -u$1, f$1 = n$1 + _$2 * d$1, { distanceToCenter: g$2, clampedElevation: v$1 } = this._distanceToCenterFromAltElevationPitch(f$1 / a$1, e$1, l$1), x$1 = g$2 * a$1, b$1 = new t.ab((p$1 + h$1 * x$1) * i$1, (m$1 + u$1 * x$1) * i$1, 0).toLngLat(), y$1 = t.at(1, b$1.lat), w$2 = t.au(this.height / 2 / Math.tan(this.fovInRadians / 2) / g$2 / y$1 / this.tileSize);
					this._elevation = v$1, this._center = b$1, this.setZoom(w$2);
				}
				_distanceToCenterFromAltElevationPitch(e$1, i$1, a$1) {
					const r$1 = -Math.cos(t.aq(a$1)), o$1 = e$1 - i$1;
					let s$1, n$1 = i$1;
					return r$1 * o$1 >= 0 || Math.abs(r$1) < .1 ? (s$1 = 1e4, n$1 = e$1 + s$1 * r$1) : s$1 = -o$1 / r$1, {
						distanceToCenter: s$1,
						clampedElevation: n$1
					};
				}
				getCameraPoint() {
					const e$1 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
					return this.centerPoint.add(new t.P(e$1 * Math.sin(this.rollInRadians), e$1 * Math.cos(this.rollInRadians)));
				}
				getCameraAltitude() {
					return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
				}
				getCameraLngLat() {
					const e$1 = t.at(1, this.center.lat) * this.worldSize;
					return xe$1(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e$1).toLngLat();
				}
				getMercatorTileCoordinates(e$1) {
					if (!e$1) return [
						0,
						0,
						1,
						1
					];
					const i$1 = e$1.canonical.z >= 0 ? 1 << e$1.canonical.z : Math.pow(2, e$1.canonical.z);
					return [
						e$1.canonical.x / i$1,
						e$1.canonical.y / i$1,
						1 / i$1 / t.a5,
						1 / i$1 / t.a5
					];
				}
			}
			class Vt$1 {
				constructor(e$1, i$1) {
					this.min = e$1, this.max = i$1, this.center = t.b0([], t.b1([], this.min, this.max), .5);
				}
				quadrant(e$1) {
					const i$1 = [e$1 % 2 == 0, e$1 < 2], a$1 = t.b2(this.min), r$1 = t.b2(this.max);
					for (let e$2 = 0; e$2 < i$1.length; e$2++) a$1[e$2] = i$1[e$2] ? this.min[e$2] : this.center[e$2], r$1[e$2] = i$1[e$2] ? this.center[e$2] : this.max[e$2];
					return r$1[2] = this.max[2], new Vt$1(a$1, r$1);
				}
				distanceX(e$1) {
					return Math.max(Math.min(this.max[0], e$1[0]), this.min[0]) - e$1[0];
				}
				distanceY(e$1) {
					return Math.max(Math.min(this.max[1], e$1[1]), this.min[1]) - e$1[1];
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					for (let i$1 = 0; i$1 < e$1.planes.length; i$1++) {
						const a$1 = this.intersectsPlane(e$1.planes[i$1]);
						if (0 === a$1) return 0;
						1 === a$1 && (t$1 = !1);
					}
					return t$1 ? 2 : e$1.aabb.min[0] > this.max[0] || e$1.aabb.min[1] > this.max[1] || e$1.aabb.min[2] > this.max[2] || e$1.aabb.max[0] < this.min[0] || e$1.aabb.max[1] < this.min[1] || e$1.aabb.max[2] < this.min[2] ? 0 : 1;
				}
				intersectsPlane(e$1) {
					let t$1 = e$1[3], i$1 = e$1[3];
					for (let a$1 = 0; a$1 < 3; a$1++) e$1[a$1] > 0 ? (t$1 += e$1[a$1] * this.min[a$1], i$1 += e$1[a$1] * this.max[a$1]) : (i$1 += e$1[a$1] * this.min[a$1], t$1 += e$1[a$1] * this.max[a$1]);
					return t$1 >= 0 ? 2 : i$1 < 0 ? 0 : 1;
				}
			}
			class qt$1 {
				distanceToTile2d(e$1, t$1, i$1, a$1) {
					const r$1 = a$1.distanceX([e$1, t$1]), o$1 = a$1.distanceY([e$1, t$1]);
					return Math.hypot(r$1, o$1);
				}
				getWrap(e$1, t$1, i$1) {
					return i$1;
				}
				getTileBoundingVolume(e$1, i$1, a$1, r$1) {
					var o$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == r$1 ? void 0 : r$1.terrain) {
						const c$2 = new t.a2(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = r$1.terrain.getMinMaxElevation(c$2);
						n$1 = null !== (o$1 = h$1.minElevation) && void 0 !== o$1 ? o$1 : Math.min(0, a$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, a$1);
					}
					const c$1 = 1 << e$1.z;
					return new Vt$1([
						i$1 + e$1.x / c$1,
						e$1.y / c$1,
						n$1
					], [
						i$1 + (e$1.x + 1) / c$1,
						(e$1.y + 1) / c$1,
						l$1
					]);
				}
				allowVariableZoom(e$1, i$1) {
					const a$1 = e$1.fov * (Math.abs(Math.cos(e$1.rollInRadians)) * e$1.height + Math.abs(Math.sin(e$1.rollInRadians)) * e$1.width) / e$1.height, r$1 = t.ao(78.5 - a$1 / 2, 0, 60);
					return !!i$1.terrain || e$1.pitch > r$1;
				}
				allowWorldCopies() {
					return !0;
				}
				prepareNextFrame() {}
			}
			class Wt$1 {
				constructor(e$1, t$1, i$1) {
					this.points = e$1, this.planes = t$1, this.aabb = i$1;
				}
				static fromInvProjectionMatrix(e$1, i$1 = 1, a$1 = 0, r$1, o$1) {
					const s$1 = o$1 ? [
						[
							6,
							5,
							4
						],
						[
							0,
							1,
							2
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					] : [
						[
							0,
							1,
							2
						],
						[
							6,
							5,
							4
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					], n$1 = Math.pow(2, a$1), l$1 = [
						[
							-1,
							1,
							-1,
							1
						],
						[
							1,
							1,
							-1,
							1
						],
						[
							1,
							-1,
							-1,
							1
						],
						[
							-1,
							-1,
							-1,
							1
						],
						[
							-1,
							1,
							1,
							1
						],
						[
							1,
							1,
							1,
							1
						],
						[
							1,
							-1,
							1,
							1
						],
						[
							-1,
							-1,
							1,
							1
						]
					].map(((a$2) => function(e$2, i$2, a$3, r$2) {
						const o$2 = t.aI([], e$2, i$2), s$2 = 1 / o$2[3] / a$3 * r$2;
						return t.b7(o$2, o$2, [
							s$2,
							s$2,
							1 / o$2[3],
							s$2
						]);
					}(a$2, e$1, i$1, n$1)));
					r$1 && function(e$2, i$2, a$2, r$2) {
						const o$2 = r$2 ? 4 : 0, s$2 = r$2 ? 0 : 4;
						let n$2 = 0;
						const l$2 = [], c$2 = [];
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const a$3 = t.b3([], e$2[i$3 + s$2], e$2[i$3 + o$2]), r$3 = t.b8(a$3);
							t.b0(a$3, a$3, 1 / r$3), l$2.push(r$3), c$2.push(a$3);
						}
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const r$3 = t.b9(e$2[i$3 + o$2], c$2[i$3], a$2);
							n$2 = null !== r$3 && r$3 >= 0 ? Math.max(n$2, r$3) : Math.max(n$2, l$2[i$3]);
						}
						const h$2 = function(e$3, i$3) {
							const a$3 = t.b3([], e$3[i$3[0]], e$3[i$3[1]]), r$3 = t.b3([], e$3[i$3[2]], e$3[i$3[1]]), o$3 = [
								0,
								0,
								0,
								0
							];
							return t.b4(o$3, t.b5([], a$3, r$3)), o$3[3] = -t.b6(o$3, e$3[i$3[0]]), o$3;
						}(e$2, i$2), u$2 = function(e$3, i$3) {
							const a$3 = t.ba(e$3), r$3 = t.bb([], e$3, 1 / a$3), o$3 = t.b3([], i$3, t.b0([], r$3, t.b6(i$3, r$3))), s$3 = t.ba(o$3);
							if (s$3 > 0) {
								const e$4 = Math.sqrt(1 - r$3[3] * r$3[3]), a$4 = t.b0([], r$3, -r$3[3]), n$3 = t.b1([], a$4, t.b0([], o$3, e$4 / s$3));
								return t.bc(i$3, n$3);
							}
							return null;
						}(a$2, h$2);
						if (null !== u$2) {
							const e$3 = u$2 / t.b6(c$2[0], h$2);
							n$2 = Math.min(n$2, e$3);
						}
						for (let t$1 = 0; t$1 < 4; t$1++) {
							const i$3 = Math.min(n$2, l$2[t$1]);
							e$2[t$1 + s$2] = [
								e$2[t$1 + o$2][0] + c$2[t$1][0] * i$3,
								e$2[t$1 + o$2][1] + c$2[t$1][1] * i$3,
								e$2[t$1 + o$2][2] + c$2[t$1][2] * i$3,
								1
							];
						}
					}(l$1, s$1[0], r$1, o$1);
					const c$1 = s$1.map(((e$2) => {
						const i$2 = t.b3([], l$1[e$2[0]], l$1[e$2[1]]), a$2 = t.b3([], l$1[e$2[2]], l$1[e$2[1]]), r$2 = t.b4([], t.b5([], i$2, a$2)), o$2 = -t.b6(r$2, l$1[e$2[1]]);
						return r$2.concat(o$2);
					})), h$1 = [
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY
					], u$1 = [
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY
					];
					for (const e$2 of l$1) for (let t$1 = 0; t$1 < 3; t$1++) h$1[t$1] = Math.min(h$1[t$1], e$2[t$1]), u$1[t$1] = Math.max(u$1[t$1], e$2[t$1]);
					return new Wt$1(l$1, c$1, new Vt$1(h$1, u$1));
				}
			}
			class $t$1 {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				setConstrainOverride(e$1) {
					this._helper.setConstrainOverride(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get constrainOverride() {
					return this._helper.constrainOverride;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1, t$1) {}
				constructor(e$1) {
					this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (e$2, i$1) => {
						i$1 = t.ao(+i$1, this.minZoom, this.maxZoom);
						const a$1 = {
							center: new t.V(e$2.lng, e$2.lat),
							zoom: i$1
						};
						let r$1 = this._helper._lngRange;
						if (!this._helper._renderWorldCopies && null === r$1) {
							const e$3 = 179.9999999999;
							r$1 = [-e$3, e$3];
						}
						const o$1 = this.tileSize * t.ar(a$1.zoom);
						let s$1 = 0, n$1 = o$1, l$1 = 0, c$1 = o$1, h$1 = 0, u$1 = 0;
						const { x: d$1, y: _$2 } = this.size;
						if (this._helper._latRange) {
							const e$3 = this._helper._latRange;
							s$1 = t.X(e$3[1]) * o$1, n$1 = t.X(e$3[0]) * o$1, n$1 - s$1 < _$2 && (h$1 = _$2 / (n$1 - s$1));
						}
						r$1 && (l$1 = t.W(t.Y(r$1[0]) * o$1, 0, o$1), c$1 = t.W(t.Y(r$1[1]) * o$1, 0, o$1), c$1 < l$1 && (c$1 += o$1), c$1 - l$1 < d$1 && (u$1 = d$1 / (c$1 - l$1)));
						const { x: p$1, y: m$1 } = me$1(o$1, e$2);
						let f$1, g$2;
						const v$1 = Math.max(u$1 || 0, h$1 || 0);
						if (v$1) return a$1.center = fe$1(o$1, new t.P(u$1 ? (c$1 + l$1) / 2 : p$1, h$1 ? (n$1 + s$1) / 2 : m$1)).wrap(), a$1.zoom += t.au(v$1), a$1;
						if (this._helper._latRange) {
							const e$3 = _$2 / 2;
							m$1 - e$3 < s$1 && (g$2 = s$1 + e$3), m$1 + e$3 > n$1 && (g$2 = n$1 - e$3);
						}
						if (r$1) {
							const e$3 = (l$1 + c$1) / 2;
							let i$2 = p$1;
							this._helper._renderWorldCopies && (i$2 = t.W(p$1, e$3 - o$1 / 2, e$3 + o$1 / 2));
							const a$2 = d$1 / 2;
							i$2 - a$2 < l$1 && (f$1 = l$1 + a$2), i$2 + a$2 > c$1 && (f$1 = c$1 - a$2);
						}
						if (void 0 !== f$1 || void 0 !== g$2) a$1.center = fe$1(o$1, new t.P(null != f$1 ? f$1 : p$1, null != g$2 ? g$2 : m$1)).wrap();
						return a$1;
					}, this.applyConstrain = (e$2, t$1) => this._helper.applyConstrain(e$2, t$1), this._helper = new Ut$1({
						calcMatrices: () => {
							this._calcMatrices();
						},
						defaultConstrain: (e$2, t$1) => this.defaultConstrain(e$2, t$1)
					}, e$1), this._coveringTilesDetailsProvider = new qt$1();
				}
				clone() {
					const e$1 = new $t$1();
					return e$1.apply(this), e$1;
				}
				apply(e$1, t$1, i$1) {
					this._helper.apply(e$1, t$1, i$1);
				}
				get cameraPosition() {
					return this._cameraPosition;
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._viewProjMatrix;
				}
				get inverseProjectionMatrix() {
					return this._invProjMatrix;
				}
				get mercatorMatrix() {
					return this._mercatorMatrix;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					const i$1 = [new t.bd(0, e$1)];
					if (this._helper._renderWorldCopies) {
						const a$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), r$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), o$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s$1 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n$1 = Math.floor(Math.min(a$1.x, r$1.x, o$1.x, s$1.x)), l$1 = Math.floor(Math.max(a$1.x, r$1.x, o$1.x, s$1.x)), c$1 = 1;
						for (let a$2 = n$1 - c$1; a$2 <= l$1 + c$1; a$2++) 0 !== a$2 && i$1.push(new t.bd(a$2, e$1));
					}
					return i$1;
				}
				getCameraFrustum() {
					return Wt$1.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
				}
				getClippingPlane() {
					return null;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					const t$1 = this.screenPointToLocation(this.centerPoint, e$1), i$1 = e$1 ? e$1.getElevationForLngLatZoom(t$1, this._helper._tileZoom) : 0;
					this._helper.recalculateZoomAndCenter(i$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const a$1 = t.at(this.elevation, this.center.lat), r$1 = this.screenPointToMercatorCoordinateAtZ(i$1, a$1), o$1 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, a$1), s$1 = t.ab.fromLngLat(e$1), n$1 = new t.ab(s$1.x - (r$1.x - o$1.x), s$1.y - (r$1.y - o$1.y));
					this.setCenter(null == n$1 ? void 0 : n$1.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
				}
				locationToScreenPoint(e$1, i$1) {
					return i$1 ? this.coordinatePoint(t.ab.fromLngLat(e$1), i$1.getElevationForLngLat(e$1), this._pixelMatrix3D) : this.coordinatePoint(t.ab.fromLngLat(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					if (t$1) {
						const i$1 = t$1.pointCoordinate(e$1);
						if (null != i$1) return i$1;
					}
					return this.screenPointToMercatorCoordinateAtZ(e$1);
				}
				screenPointToMercatorCoordinateAtZ(e$1, i$1) {
					const a$1 = i$1 || 0, r$1 = [
						e$1.x,
						e$1.y,
						0,
						1
					], o$1 = [
						e$1.x,
						e$1.y,
						1,
						1
					];
					t.aI(r$1, r$1, this._pixelMatrixInverse), t.aI(o$1, o$1, this._pixelMatrixInverse);
					const s$1 = r$1[3], n$1 = o$1[3], l$1 = r$1[1] / s$1, c$1 = o$1[1] / n$1, h$1 = r$1[2] / s$1, u$1 = o$1[2] / n$1, d$1 = h$1 === u$1 ? 0 : (a$1 - h$1) / (u$1 - h$1);
					return new t.ab(t.G.number(r$1[0] / s$1, o$1[0] / n$1, d$1) / this.worldSize, t.G.number(l$1, c$1, d$1) / this.worldSize, a$1);
				}
				coordinatePoint(e$1, i$1 = 0, a$1 = this._pixelMatrix) {
					const r$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aI(r$1, r$1, a$1), new t.P(r$1[0] / r$1[3], r$1[1] / r$1[3]);
				}
				getBounds() {
					const e$1 = Math.max(0, this._helper._height / 2 - ge(this));
					return new $$1().extend(this.screenPointToLocation(new t.P(0, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
				}
				isPointOnMapSurface(e$1, t$1) {
					return t$1 ? null != t$1.pointCoordinate(e$1) : e$1.y > this.height / 2 - ge(this);
				}
				calculatePosMatrix(e$1, i$1 = !1, a$1) {
					var r$1;
					const o$1 = null !== (r$1 = e$1.key) && void 0 !== r$1 ? r$1 : t.be(e$1.wrap, e$1.canonical.z, e$1.canonical.z, e$1.canonical.x, e$1.canonical.y), s$1 = i$1 ? this._alignedPosMatrixCache : this._posMatrixCache;
					if (s$1.has(o$1)) {
						const e$2 = s$1.get(o$1);
						return a$1 ? e$2.f32 : e$2.f64;
					}
					const n$1 = ve$1(e$1, this.worldSize);
					t.S(n$1, i$1 ? this._alignedProjMatrix : this._viewProjMatrix, n$1);
					const l$1 = {
						f64: n$1,
						f32: new Float32Array(n$1)
					};
					return s$1.set(o$1, l$1), a$1 ? l$1.f32 : l$1.f64;
				}
				calculateFogMatrix(e$1) {
					const i$1 = e$1.key, a$1 = this._fogMatrixCacheF32;
					if (a$1.has(i$1)) return a$1.get(i$1);
					const r$1 = ve$1(e$1, this.worldSize);
					return t.S(r$1, this._fogMatrix, r$1), a$1.set(i$1, new Float32Array(r$1)), a$1.get(i$1);
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
				}
				_calculateNearFarZIfNeeded(e$1, i$1, a$1) {
					if (!this._helper.autoCalculateNearFarZ) return;
					const r$1 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), o$1 = e$1 - r$1 * this._helper._pixelPerMeter / Math.cos(i$1), s$1 = r$1 < 0 ? o$1 : e$1, n$1 = Math.PI / 2 + this.pitchInRadians, l$1 = t.aq(this.fov) * (Math.abs(Math.cos(t.aq(this.roll))) * this.height + Math.abs(Math.sin(t.aq(this.roll))) * this.width) / this.height * (.5 + a$1.y / this.height), c$1 = Math.sin(l$1) * s$1 / Math.sin(t.ao(Math.PI - n$1 - l$1, .01, Math.PI - .01)), h$1 = ge(this), u$1 = Math.atan(h$1 / this._helper.cameraToCenterDistance), d$1 = t.aq(.75), _$2 = u$1 > d$1 ? 2 * u$1 * (.5 + a$1.y / (2 * h$1)) : d$1, p$1 = Math.sin(_$2) * s$1 / Math.sin(t.ao(Math.PI - n$1 - _$2, .01, Math.PI - .01)), m$1 = Math.min(c$1, p$1);
					this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i$1) * m$1 + s$1), this._helper._nearZ = this._helper._height / 50;
				}
				_calcMatrices() {
					if (!this._helper._height) return;
					const e$1 = this.centerOffset, i$1 = me$1(this.worldSize, this.center), a$1 = i$1.x, r$1 = i$1.y;
					this._helper._pixelPerMeter = t.at(1, this.center.lat) * this.worldSize;
					const o$1 = t.aq(Math.min(this.pitch, pe$1)), s$1 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(o$1));
					let n$1;
					this._calculateNearFarZIfNeeded(s$1, o$1, e$1), n$1 = new Float64Array(16), t.bf(n$1, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.aC(this._invProjMatrix, n$1), n$1[8] = 2 * -e$1.x / this._helper._width, n$1[9] = 2 * e$1.y / this._helper._height, this._projectionMatrix = t.bg(n$1), t.Q(n$1, n$1, [
						1,
						-1,
						1
					]), t.O(n$1, n$1, [
						0,
						0,
						-this._helper.cameraToCenterDistance
					]), t.bh(n$1, n$1, -this.rollInRadians), t.bi(n$1, n$1, this.pitchInRadians), t.bh(n$1, n$1, -this.bearingInRadians), t.O(n$1, n$1, [
						-a$1,
						-r$1,
						0
					]), this._mercatorMatrix = t.Q([], n$1, [
						this.worldSize,
						this.worldSize,
						this.worldSize
					]), t.Q(n$1, n$1, [
						1,
						1,
						this._helper._pixelPerMeter
					]), this._pixelMatrix = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1), t.O(n$1, n$1, [
						0,
						0,
						-this.elevation
					]), this._viewProjMatrix = n$1, this._invViewProjMatrix = t.aC([], n$1);
					const l$1 = [
						0,
						0,
						-1,
						1
					];
					t.aI(l$1, l$1, this._invViewProjMatrix), this._cameraPosition = [
						l$1[0] / l$1[3],
						l$1[1] / l$1[3],
						l$1[2] / l$1[3]
					], this._fogMatrix = new Float64Array(16), t.bf(this._fogMatrix, this.fovInRadians, this.width / this.height, s$1, this._helper._farZ), this._fogMatrix[8] = 2 * -e$1.x / this.width, this._fogMatrix[9] = 2 * e$1.y / this.height, t.Q(this._fogMatrix, this._fogMatrix, [
						1,
						-1,
						1
					]), t.O(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.bh(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.bi(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.bh(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.O(this._fogMatrix, this._fogMatrix, [
						-a$1,
						-r$1,
						0
					]), t.Q(this._fogMatrix, this._fogMatrix, [
						1,
						1,
						this._helper._pixelPerMeter
					]), t.O(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.elevation
					]), this._pixelMatrix3D = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1);
					const c$1 = this._helper._width % 2 / 2, h$1 = this._helper._height % 2 / 2, u$1 = Math.cos(this.bearingInRadians), d$1 = Math.sin(-this.bearingInRadians), _$2 = a$1 - Math.round(a$1) + u$1 * c$1 + d$1 * h$1, p$1 = r$1 - Math.round(r$1) + u$1 * h$1 + d$1 * c$1, m$1 = new Float64Array(n$1);
					if (t.O(m$1, m$1, [
						_$2 > .5 ? _$2 - 1 : _$2,
						p$1 > .5 ? p$1 - 1 : p$1,
						0
					]), this._alignedProjMatrix = m$1, n$1 = t.aC(new Float64Array(16), this._pixelMatrix), !n$1) throw new Error("failed to invert matrix");
					this._pixelMatrixInverse = n$1, this._clearMatrixCaches();
				}
				_clearMatrixCaches() {
					this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
				}
				maxPitchScaleFactor() {
					if (!this._pixelMatrixInverse) return 1;
					const e$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						0,
						1
					];
					return t.aI(i$1, i$1, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					const e$1 = t.at(1, this.center.lat) * this.worldSize;
					return xe$1(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e$1).toLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					const a$1 = t.ab.fromLngLat(e$1), r$1 = [
						a$1.x * this.worldSize,
						a$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aI(r$1, r$1, this._viewProjMatrix), r$1[2] / r$1[3];
				}
				getProjectionData(e$1) {
					const { overscaledTileID: i$1, aligned: a$1, applyTerrainMatrix: r$1 } = e$1, o$1 = this._helper.getMercatorTileCoordinates(i$1), s$1 = i$1 ? this.calculatePosMatrix(i$1, a$1, !0) : null;
					let n$1;
					return n$1 = i$1 && i$1.terrainRttPosMatrix32f && r$1 ? i$1.terrainRttPosMatrix32f : s$1 || t.bj(), {
						mainMatrix: n$1,
						tileMercatorCoords: o$1,
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: n$1
					};
				}
				isLocationOccluded(e$1) {
					return !1;
				}
				getPixelScale() {
					return 1;
				}
				getCircleRadiusCorrection() {
					return 1;
				}
				getPitchedTextCorrection(e$1, t$1, i$1) {
					return 1;
				}
				transformLightDirection(e$1) {
					return t.b2(e$1);
				}
				getRayDirectionFromPixel(e$1) {
					throw new Error("Not implemented.");
				}
				projectTileCoordinates(e$1, i$1, a$1, r$1) {
					const o$1 = this.calculatePosMatrix(a$1);
					let s$1;
					r$1 ? (s$1 = [
						e$1,
						i$1,
						r$1(e$1, i$1),
						1
					], t.aI(s$1, s$1, o$1)) : (s$1 = [
						e$1,
						i$1,
						0,
						1
					], ot$1(s$1, s$1, o$1));
					const n$1 = s$1[3];
					return {
						point: new t.P(s$1[0] / n$1, s$1[1] / n$1),
						signedDistanceFromCamera: n$1,
						isOccluded: !1
					};
				}
				populateCache(e$1) {
					for (const t$1 of e$1) this.calculatePosMatrix(t$1);
				}
				getMatrixForModel(e$1, i$1) {
					const a$1 = t.ab.fromLngLat(e$1, i$1), r$1 = a$1.meterInMercatorCoordinateUnits(), o$1 = t.bk();
					return t.O(o$1, o$1, [
						a$1.x,
						a$1.y,
						a$1.z
					]), t.bh(o$1, o$1, Math.PI), t.bi(o$1, o$1, Math.PI / 2), t.Q(o$1, o$1, [
						-r$1,
						r$1,
						r$1
					]), o$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = new t.a2(0, 0, 0, 0, 0), a$1 = this.getProjectionData({
						overscaledTileID: i$1,
						applyGlobeMatrix: e$1
					}), r$1 = ve$1(i$1, this.worldSize);
					t.S(r$1, this._viewProjMatrix, r$1), a$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					];
					const o$1 = [
						t.a5,
						t.a5,
						this.worldSize / this._helper.pixelsPerMeter
					], s$1 = t.bl();
					return t.Q(s$1, r$1, o$1), a$1.fallbackMatrix = s$1, a$1.mainMatrix = s$1, a$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.calculatePosMatrix(e$1);
				}
			}
			function Ht$1() {
				t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
			}
			function Xt$1(e$1) {
				if (e$1.useSlerp) if (e$1.k < 1) {
					const i$1 = t.bm(e$1.startEulerAngles.roll, e$1.startEulerAngles.pitch, e$1.startEulerAngles.bearing), a$1 = t.bm(e$1.endEulerAngles.roll, e$1.endEulerAngles.pitch, e$1.endEulerAngles.bearing), r$1 = new Float64Array(4);
					t.bn(r$1, i$1, a$1, e$1.k);
					const o$1 = t.bo(r$1);
					e$1.tr.setRoll(o$1.roll), e$1.tr.setPitch(o$1.pitch), e$1.tr.setBearing(o$1.bearing);
				} else e$1.tr.setRoll(e$1.endEulerAngles.roll), e$1.tr.setPitch(e$1.endEulerAngles.pitch), e$1.tr.setBearing(e$1.endEulerAngles.bearing);
				else e$1.tr.setRoll(t.G.number(e$1.startEulerAngles.roll, e$1.endEulerAngles.roll, e$1.k)), e$1.tr.setPitch(t.G.number(e$1.startEulerAngles.pitch, e$1.endEulerAngles.pitch, e$1.k)), e$1.tr.setBearing(t.G.number(e$1.startEulerAngles.bearing, e$1.endEulerAngles.bearing, e$1.k));
			}
			function Kt$1(e$1, i$1, a$1, r$1, o$1) {
				const s$1 = o$1.padding, n$1 = me$1(o$1.worldSize, a$1.getNorthWest()), l$1 = me$1(o$1.worldSize, a$1.getNorthEast()), c$1 = me$1(o$1.worldSize, a$1.getSouthEast()), h$1 = me$1(o$1.worldSize, a$1.getSouthWest()), u$1 = t.aq(-r$1), d$1 = n$1.rotate(u$1), _$2 = l$1.rotate(u$1), p$1 = c$1.rotate(u$1), m$1 = h$1.rotate(u$1), f$1 = new t.P(Math.max(d$1.x, _$2.x, m$1.x, p$1.x), Math.max(d$1.y, _$2.y, m$1.y, p$1.y)), g$2 = new t.P(Math.min(d$1.x, _$2.x, m$1.x, p$1.x), Math.min(d$1.y, _$2.y, m$1.y, p$1.y)), v$1 = f$1.sub(g$2), x$1 = (o$1.width - (s$1.left + s$1.right + i$1.left + i$1.right)) / v$1.x, b$1 = (o$1.height - (s$1.top + s$1.bottom + i$1.top + i$1.bottom)) / v$1.y;
				if (b$1 < 0 || x$1 < 0) return void Ht$1();
				const y$1 = Math.min(t.au(o$1.scale * Math.min(x$1, b$1)), e$1.maxZoom), w$2 = t.P.convert(e$1.offset), T$1 = new t.P((i$1.left - i$1.right) / 2, (i$1.top - i$1.bottom) / 2).rotate(t.aq(r$1)), P$2 = w$2.add(T$1).mult(o$1.scale / t.ar(y$1));
				return {
					center: fe$1(o$1.worldSize, n$1.add(c$1).div(2).sub(P$2)),
					zoom: y$1,
					bearing: r$1
				};
			}
			class Yt$1 {
				get useGlobeControls() {
					return !1;
				}
				handlePanInertia(e$1, t$1) {
					const i$1 = e$1.mag(), a$1 = Math.abs(ge(t$1));
					return {
						easingOffset: e$1.mult(Math.min(.75 * a$1 / i$1, 1)),
						easingCenter: t$1.center
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					e$1.bearingDelta && t$1.setBearing(t$1.bearing + e$1.bearingDelta), e$1.pitchDelta && t$1.setPitch(t$1.pitch + e$1.pitchDelta), e$1.rollDelta && t$1.setRoll(t$1.roll + e$1.rollDelta), e$1.zoomDelta && t$1.setZoom(t$1.zoom + e$1.zoomDelta);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					e$1.around.distSqr(t$1.centerPoint) < .01 || t$1.setLocationAtPoint(i$1, e$1.around);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, a$1, r$1) {
					return Kt$1(e$1, t$1, i$1, a$1, r$1);
				}
				handleJumpToCenterZoom(e$1, i$1) {
					e$1.zoom !== (void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom) && e$1.setZoom(+i$1.zoom), void 0 !== i$1.center && e$1.setCenter(t.V.convert(i$1.center));
				}
				handleEaseTo(e$1, i$1) {
					const a$1 = e$1.zoom, r$1 = e$1.padding, o$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, s$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, n$1 = void 0 !== i$1.zoom, l$1 = !e$1.isPaddingEqual(i$1.padding);
					let c$1 = !1;
					const h$1 = n$1 ? +i$1.zoom : e$1.zoom;
					let u$1 = e$1.centerPoint.add(i$1.offsetAsPoint);
					const d$1 = e$1.screenPointToLocation(u$1), { center: _$2, zoom: p$1 } = e$1.applyConstrain(t.V.convert(i$1.center || d$1), null != h$1 ? h$1 : a$1);
					Zt$1(e$1, _$2);
					const m$1 = me$1(e$1.worldSize, d$1), f$1 = me$1(e$1.worldSize, _$2).sub(m$1), g$2 = t.ar(p$1 - a$1);
					return c$1 = p$1 !== a$1, {
						easeFunc: (n$2) => {
							if (c$1 && e$1.setZoom(t.G.number(a$1, p$1, n$2)), t.bp(o$1, s$1) || Xt$1({
								startEulerAngles: o$1,
								endEulerAngles: s$1,
								tr: e$1,
								k: n$2,
								useSlerp: o$1.roll != s$1.roll
							}), l$1 && (e$1.interpolatePadding(r$1, i$1.padding, n$2), u$1 = e$1.centerPoint.add(i$1.offsetAsPoint)), i$1.around) e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const i$2 = t.ar(e$1.zoom - a$1), r$2 = p$1 > a$1 ? Math.min(2, g$2) : Math.max(.5, g$2), o$2 = Math.pow(r$2, 1 - n$2), s$2 = fe$1(e$1.worldSize, m$1.add(f$1.mult(n$2 * o$2)).mult(i$2));
								e$1.setLocationAtPoint(e$1.renderWorldCopies ? s$2.wrap() : s$2, u$1);
							}
						},
						isZooming: c$1,
						elevationCenter: _$2
					};
				}
				handleFlyTo(e$1, i$1) {
					const a$1 = void 0 !== i$1.zoom, r$1 = e$1.zoom, o$1 = e$1.applyConstrain(t.V.convert(i$1.center || i$1.locationAtOffset), a$1 ? +i$1.zoom : r$1), s$1 = o$1.center, n$1 = o$1.zoom;
					Zt$1(e$1, s$1);
					const l$1 = me$1(e$1.worldSize, i$1.locationAtOffset), c$1 = me$1(e$1.worldSize, s$1).sub(l$1), h$1 = c$1.mag(), u$1 = t.ar(n$1 - r$1);
					let d$1;
					if (void 0 !== i$1.minZoom) {
						const a$2 = Math.min(+i$1.minZoom, r$1, n$1), o$2 = e$1.applyConstrain(s$1, a$2).zoom;
						d$1 = t.ar(o$2 - r$1);
					}
					return {
						easeFunc: (i$2, a$2, o$2, h$2) => {
							e$1.setZoom(1 === i$2 ? n$1 : r$1 + t.au(a$2));
							const u$2 = 1 === i$2 ? s$1 : fe$1(e$1.worldSize, l$1.add(c$1.mult(o$2)).mult(a$2));
							e$1.setLocationAtPoint(e$1.renderWorldCopies ? u$2.wrap() : u$2, h$2);
						},
						scaleOfZoom: u$1,
						targetCenter: s$1,
						scaleOfMinZoom: d$1,
						pixelPathLength: h$1
					};
				}
			}
			class Qt$1 {
				constructor(e$1, t$1, i$1) {
					this.blendFunction = e$1, this.blendColor = t$1, this.mask = i$1;
				}
			}
			Qt$1.Replace = [1, 0], Qt$1.disabled = new Qt$1(Qt$1.Replace, t.bq.transparent, [
				!1,
				!1,
				!1,
				!1
			]), Qt$1.unblended = new Qt$1(Qt$1.Replace, t.bq.transparent, [
				!0,
				!0,
				!0,
				!0
			]), Qt$1.alphaBlended = new Qt$1([1, 771], t.bq.transparent, [
				!0,
				!0,
				!0,
				!0
			]);
			const Jt$1 = 2305;
			class ei$1 {
				constructor(e$1, t$1, i$1) {
					this.enable = e$1, this.mode = t$1, this.frontFace = i$1;
				}
			}
			ei$1.disabled = new ei$1(!1, 1029, Jt$1), ei$1.backCCW = new ei$1(!0, 1029, Jt$1), ei$1.frontCCW = new ei$1(!0, 1028, Jt$1);
			class ti$1 {
				constructor(e$1, t$1, i$1) {
					this.func = e$1, this.mask = t$1, this.range = i$1;
				}
			}
			ti$1.ReadOnly = !1, ti$1.ReadWrite = !0, ti$1.disabled = new ti$1(519, ti$1.ReadOnly, [0, 1]);
			const ii$1 = 7680;
			class ai$1 {
				constructor(e$1, t$1, i$1, a$1, r$1, o$1) {
					this.test = e$1, this.ref = t$1, this.mask = i$1, this.fail = a$1, this.depthFail = r$1, this.pass = o$1;
				}
			}
			ai$1.disabled = new ai$1({
				func: 519,
				mask: 0
			}, 0, 0, ii$1, ii$1, ii$1);
			const ri$1 = /* @__PURE__ */ new WeakMap();
			function oi$1(e$1) {
				var t$1;
				if (ri$1.has(e$1)) return ri$1.get(e$1);
				{
					const i$1 = null === (t$1 = e$1.getParameter(e$1.VERSION)) || void 0 === t$1 ? void 0 : t$1.startsWith("WebGL 2.0");
					return ri$1.set(e$1, i$1), i$1;
				}
			}
			class si$1 {
				get awaitingQuery() {
					return !!this._readbackQueue;
				}
				constructor(e$1) {
					this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e$1;
					const i$1 = e$1.context, a$1 = i$1.gl;
					this._texFormat = a$1.RGBA, this._texType = a$1.UNSIGNED_BYTE;
					const r$1 = new t.aX();
					r$1.emplaceBack(-1, -1), r$1.emplaceBack(2, -1), r$1.emplaceBack(-1, 2);
					const o$1 = new t.aZ();
					o$1.emplaceBack(0, 1, 2), this._fullscreenTriangle = new kt$1(i$1.createVertexBuffer(r$1, Ft$1.members), i$1.createIndexBuffer(o$1), t.aY.simpleSegment(0, 0, r$1.length, o$1.length)), this._resultBuffer = new Uint8Array(4), i$1.activeTexture.set(a$1.TEXTURE1);
					const s$1 = a$1.createTexture();
					a$1.bindTexture(a$1.TEXTURE_2D, s$1), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_S, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_T, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MIN_FILTER, a$1.NEAREST), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MAG_FILTER, a$1.NEAREST), a$1.texImage2D(a$1.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i$1.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(s$1), oi$1(a$1) && (this._pbo = a$1.createBuffer(), a$1.bindBuffer(a$1.PIXEL_PACK_BUFFER, this._pbo), a$1.bufferData(a$1.PIXEL_PACK_BUFFER, 4, a$1.STREAM_READ), a$1.bindBuffer(a$1.PIXEL_PACK_BUFFER, null));
				}
				destroy() {
					const e$1 = this._cachedRenderContext.context.gl;
					this._fullscreenTriangle.destroy(), this._fbo.destroy(), e$1.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
				}
				updateErrorLoop(e$1, t$1) {
					const i$1 = this._updateCount;
					return this._readbackQueue ? i$1 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i$1 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e$1, t$1), this._updateCount++, this._measuredError;
				}
				_bindFramebuffer() {
					const e$1 = this._cachedRenderContext.context, t$1 = e$1.gl;
					e$1.activeTexture.set(t$1.TEXTURE1), t$1.bindTexture(t$1.TEXTURE_2D, this._fbo.colorAttachment.get()), e$1.bindFramebuffer.set(this._fbo.framebuffer);
				}
				_renderErrorTexture(e$1, i$1) {
					const a$1 = this._cachedRenderContext.context, r$1 = a$1.gl;
					if (this._bindFramebuffer(), a$1.viewport.set([
						0,
						0,
						this._texWidth,
						this._texHeight
					]), a$1.clear({ color: t.bq.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(a$1, r$1.TRIANGLES, ti$1.disabled, ai$1.disabled, Qt$1.unblended, ei$1.disabled, ((e$2, t$1) => ({
						u_input: e$2,
						u_output_expected: t$1
					}))(e$1, i$1), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && oi$1(r$1)) {
						r$1.bindBuffer(r$1.PIXEL_PACK_BUFFER, this._pbo), r$1.readBuffer(r$1.COLOR_ATTACHMENT0), r$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), r$1.bindBuffer(r$1.PIXEL_PACK_BUFFER, null);
						const e$2 = r$1.fenceSync(r$1.SYNC_GPU_COMMANDS_COMPLETE, 0);
						r$1.flush(), this._readbackQueue = {
							frameNumberIssued: this._updateCount,
							sync: e$2
						};
					} else this._readbackQueue = {
						frameNumberIssued: this._updateCount,
						sync: null
					};
				}
				_tryReadback() {
					const e$1 = this._cachedRenderContext.context.gl;
					if (this._pbo && this._readbackQueue && oi$1(e$1)) {
						const i$1 = e$1.clientWaitSync(this._readbackQueue.sync, 0, 0);
						if (i$1 === e$1.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
						if (i$1 === e$1.TIMEOUT_EXPIRED) return;
						e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, this._pbo), e$1.getBufferSubData(e$1.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, null);
					} else this._bindFramebuffer(), e$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
					this._readbackQueue = null, this._measuredError = si$1._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
				}
				static _parseRGBA8float(e$1) {
					let t$1 = 0;
					return t$1 += e$1[0] / 256, t$1 += e$1[1] / 65536, t$1 += e$1[2] / 16777216, e$1[3] < 127 && (t$1 = -t$1), t$1 / 128;
				}
			}
			const ni$1 = t.a5 / 128;
			function li(e$1, i$1) {
				const a$1 = void 0 !== e$1.granularity ? Math.max(e$1.granularity, 1) : 1, r$1 = a$1 + (e$1.generateBorders ? 2 : 0), o$1 = a$1 + (e$1.extendToNorthPole || e$1.generateBorders ? 1 : 0) + (e$1.extendToSouthPole || e$1.generateBorders ? 1 : 0), s$1 = r$1 + 1, n$1 = o$1 + 1, l$1 = e$1.generateBorders ? -1 : 0, c$1 = e$1.generateBorders || e$1.extendToNorthPole ? -1 : 0, h$1 = a$1 + (e$1.generateBorders ? 1 : 0), u$1 = a$1 + (e$1.generateBorders || e$1.extendToSouthPole ? 1 : 0), d$1 = s$1 * n$1, _$2 = r$1 * o$1 * 6, p$1 = s$1 * n$1 > 65536;
				if (p$1 && "16bit" === i$1) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
				const m$1 = p$1 || "32bit" === i$1, f$1 = new Int16Array(2 * d$1);
				let g$2 = 0;
				for (let i$2 = c$1; i$2 <= u$1; i$2++) for (let r$2 = l$1; r$2 <= h$1; r$2++) {
					let o$2 = r$2 / a$1 * t.a5;
					-1 === r$2 && (o$2 = -ni$1), r$2 === a$1 + 1 && (o$2 = t.a5 + ni$1);
					let s$2 = i$2 / a$1 * t.a5;
					-1 === i$2 && (s$2 = e$1.extendToNorthPole ? t.bs : -ni$1), i$2 === a$1 + 1 && (s$2 = e$1.extendToSouthPole ? t.bt : t.a5 + ni$1), f$1[g$2++] = o$2, f$1[g$2++] = s$2;
				}
				const v$1 = m$1 ? new Uint32Array(_$2) : new Uint16Array(_$2);
				let x$1 = 0;
				for (let e$2 = 0; e$2 < o$1; e$2++) for (let t$1 = 0; t$1 < r$1; t$1++) {
					const i$2 = t$1 + 1 + e$2 * s$1, a$2 = t$1 + (e$2 + 1) * s$1, r$2 = t$1 + 1 + (e$2 + 1) * s$1;
					v$1[x$1++] = t$1 + e$2 * s$1, v$1[x$1++] = a$2, v$1[x$1++] = i$2, v$1[x$1++] = i$2, v$1[x$1++] = a$2, v$1[x$1++] = r$2;
				}
				return {
					vertices: f$1.buffer.slice(0),
					indices: v$1.buffer.slice(0),
					uses32bitIndices: m$1
				};
			}
			const ci = new t.aW({
				fill: new t.bu(128, 2),
				line: new t.bu(512, 0),
				tile: new t.bu(128, 32),
				stencil: new t.bu(128, 1),
				circle: 3
			});
			class hi {
				constructor() {
					this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
				}
				get name() {
					return "vertical-perspective";
				}
				get transitionState() {
					return 1;
				}
				get useSubdivision() {
					return !0;
				}
				get shaderVariantName() {
					return "globe";
				}
				get shaderDefine() {
					return "#define GLOBE";
				}
				get shaderPreludeCode() {
					return At$1.projectionGlobe;
				}
				get vertexShaderPreludeCode() {
					return At$1.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return ci;
				}
				get useGlobeControls() {
					return !0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._errorCorrectionUsable;
				}
				destroy() {
					this._errorMeasurement && this._errorMeasurement.destroy();
				}
				updateGPUdependent(e$1) {
					this._errorMeasurement || (this._errorMeasurement = new si$1(e$1));
					const i$1 = t.X(this._errorQueryLatitudeDegrees), a$1 = 2 * Math.atan(Math.exp(Math.PI - i$1 * Math.PI * 2)) - .5 * Math.PI, r$1 = this._errorMeasurement.updateErrorLoop(i$1, a$1), o$1 = c();
					r$1 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = r$1, this._errorMeasurementLastChangeTime = o$1);
					const s$1 = Math.min(Math.max((o$1 - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
					this._errorCorrectionUsable = t.bv(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bw(s$1));
				}
				_getMeshKey(e$1) {
					return `${e$1.granularity.toString(36)}_${e$1.generateBorders ? "b" : ""}${e$1.extendToNorthPole ? "n" : ""}${e$1.extendToSouthPole ? "s" : ""}`;
				}
				getMeshFromTileID(e$1, t$1, i$1, a$1, r$1) {
					const o$1 = ("stencil" === r$1 ? ci.stencil : ci.tile).getGranularityForZoomLevel(t$1.z);
					return this._getMesh(e$1, {
						granularity: o$1,
						generateBorders: i$1,
						extendToNorthPole: 0 === t$1.y && a$1,
						extendToSouthPole: t$1.y === (1 << t$1.z) - 1 && a$1
					});
				}
				_getMesh(e$1, i$1) {
					const a$1 = this._getMeshKey(i$1);
					if (a$1 in this._tileMeshCache) return this._tileMeshCache[a$1];
					const r$1 = function(e$2, i$2) {
						const a$2 = li(i$2, "16bit"), r$2 = t.aX.deserialize({
							arrayBuffer: a$2.vertices,
							length: a$2.vertices.byteLength / 2 / 2
						}), o$1 = t.aZ.deserialize({
							arrayBuffer: a$2.indices,
							length: a$2.indices.byteLength / 2 / 3
						});
						return new kt$1(e$2.createVertexBuffer(r$2, Ft$1.members), e$2.createIndexBuffer(o$1), t.aY.simpleSegment(0, 0, r$2.length, o$1.length));
					}(e$1, i$1);
					return this._tileMeshCache[a$1] = r$1, r$1;
				}
				recalculate(e$1) {}
				hasTransition() {
					const e$1 = c();
					let t$1 = !1;
					return t$1 = t$1 || (e$1 - this._errorMeasurementLastChangeTime) / 1e3 < .7, t$1 = t$1 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t$1;
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._errorQueryLatitudeDegrees = e$1;
				}
			}
			const ui = new t.t({ type: new t.D(t.u.projection.type) });
			class di extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.x(ui, void 0), this.setProjection(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0)), this._mercatorProjection = new jt$1(), this._verticalPerspectiveProjection = new hi();
				}
				get transitionState() {
					const e$1 = this.properties.get("type");
					if ("string" == typeof e$1 && "mercator" === e$1) return 0;
					if ("string" == typeof e$1 && "vertical-perspective" === e$1) return 1;
					if (e$1 instanceof t.bx) {
						if ("vertical-perspective" === e$1.from && "mercator" === e$1.to) return 1 - e$1.transition;
						if ("mercator" === e$1.from && "vertical-perspective" === e$1.to) return e$1.transition;
					}
					return 1;
				}
				get useGlobeRendering() {
					return this.transitionState > 0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
				}
				get currentProjection() {
					return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
				}
				get name() {
					return "globe";
				}
				get useSubdivision() {
					return this.currentProjection.useSubdivision;
				}
				get shaderVariantName() {
					return this.currentProjection.shaderVariantName;
				}
				get shaderDefine() {
					return this.currentProjection.shaderDefine;
				}
				get shaderPreludeCode() {
					return this.currentProjection.shaderPreludeCode;
				}
				get vertexShaderPreludeCode() {
					return this.currentProjection.vertexShaderPreludeCode;
				}
				get subdivisionGranularity() {
					return this.currentProjection.subdivisionGranularity;
				}
				get useGlobeControls() {
					return this.transitionState > 0;
				}
				destroy() {
					this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
				}
				updateGPUdependent(e$1) {
					this._mercatorProjection.updateGPUdependent(e$1), this._verticalPerspectiveProjection.updateGPUdependent(e$1);
				}
				getMeshFromTileID(e$1, t$1, i$1, a$1, r$1) {
					return this.currentProjection.getMeshFromTileID(e$1, t$1, i$1, a$1, r$1);
				}
				setProjection(e$1) {
					this._transitionable.setValue("type", (null == e$1 ? void 0 : e$1.type) || "mercator");
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e$1), this._mercatorProjection.setErrorQueryLatitudeDegrees(e$1);
				}
			}
			function _i$1(e$1) {
				const t$1 = fi(e$1.worldSize, e$1.center.lat);
				return 2 * Math.PI * t$1;
			}
			function pi(e$1, i$1, a$1, r$1, o$1) {
				const s$1 = 1 / (1 << o$1), n$1 = i$1 / t.a5 * s$1 + r$1 * s$1, l$1 = t.bz((e$1 / t.a5 * s$1 + a$1 * s$1) * Math.PI * 2 + Math.PI, 2 * Math.PI), c$1 = 2 * Math.atan(Math.exp(Math.PI - n$1 * Math.PI * 2)) - .5 * Math.PI, h$1 = Math.cos(c$1), u$1 = new Float64Array(3);
				return u$1[0] = Math.sin(l$1) * h$1, u$1[1] = Math.sin(c$1), u$1[2] = Math.cos(l$1) * h$1, u$1;
			}
			function mi$1(e$1) {
				return function(e$2, t$1) {
					const i$1 = Math.cos(t$1), a$1 = new Float64Array(3);
					return a$1[0] = Math.sin(e$2) * i$1, a$1[1] = Math.sin(t$1), a$1[2] = Math.cos(e$2) * i$1, a$1;
				}(e$1.lng * Math.PI / 180, e$1.lat * Math.PI / 180);
			}
			function fi(e$1, t$1) {
				return e$1 / (2 * Math.PI) / Math.cos(t$1 * Math.PI / 180);
			}
			function gi(e$1) {
				const i$1 = Math.asin(e$1[1]) / Math.PI * 180, a$1 = Math.sqrt(e$1[0] * e$1[0] + e$1[2] * e$1[2]);
				if (a$1 > 1e-6) {
					const r$1 = e$1[0] / a$1, o$1 = Math.acos(e$1[2] / a$1), s$1 = (r$1 > 0 ? o$1 : -o$1) / Math.PI * 180;
					return new t.V(t.W(s$1, -180, 180), i$1);
				}
				return new t.V(0, i$1);
			}
			function vi$1(e$1) {
				return Math.cos(e$1 * Math.PI / 180);
			}
			function xi(e$1, i$1) {
				const a$1 = vi$1(e$1), r$1 = vi$1(i$1);
				return t.au(r$1 / a$1);
			}
			function bi(e$1, i$1) {
				const a$1 = e$1.rotate(i$1.bearingInRadians), r$1 = i$1.zoom + xi(i$1.center.lat, 0), o$1 = t.bv(1 / vi$1(i$1.center.lat), 1 / vi$1(Math.min(Math.abs(i$1.center.lat), 60)), t.by(r$1, 7, 3, 0, 1)), s$1 = 360 / _i$1({
					worldSize: i$1.worldSize,
					center: { lat: i$1.center.lat }
				});
				return new t.V(i$1.center.lng - a$1.x * s$1 * o$1, t.ao(i$1.center.lat + a$1.y * s$1, -t.ap, t.ap));
			}
			function yi$1(e$1) {
				const t$1 = .5 * e$1, i$1 = Math.sin(t$1), a$1 = Math.cos(t$1);
				return Math.log(i$1 + a$1) - Math.log(a$1 - i$1);
			}
			function wi(e$1, i$1, a$1, r$1) {
				const o$1 = e$1.lat + a$1 * r$1;
				if (Math.abs(a$1) > 1) {
					const s$1 = (Math.sign(e$1.lat + a$1) !== Math.sign(e$1.lat) ? -Math.abs(e$1.lat) : Math.abs(e$1.lat)) * Math.PI / 180, n$1 = Math.abs(e$1.lat + a$1) * Math.PI / 180, l$1 = yi$1(s$1 + r$1 * (n$1 - s$1)), c$1 = yi$1(s$1), h$1 = yi$1(n$1);
					return new t.V(e$1.lng + i$1 * ((l$1 - c$1) / (h$1 - c$1)), o$1);
				}
				return new t.V(e$1.lng + i$1 * r$1, o$1);
			}
			class Ti$1 {
				constructor(e$1) {
					this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e$1;
				}
				swapBuffers() {
					if (!this._hadAnyChanges) return;
					const e$1 = this._cachePrevious;
					this._cachePrevious = this._cache, this._cache = e$1, this._cache.clear(), this._hadAnyChanges = !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, a$1) {
					const r$1 = `${e$1.z}_${e$1.x}_${e$1.y}_${(null == a$1 ? void 0 : a$1.terrain) ? "t" : ""}`, o$1 = this._cache.get(r$1);
					if (o$1) return o$1;
					const s$1 = this._cachePrevious.get(r$1);
					if (s$1) return this._cache.set(r$1, s$1), s$1;
					const n$1 = this._boundingVolumeFactory(e$1, t$1, i$1, a$1);
					return this._cache.set(r$1, n$1), this._hadAnyChanges = !0, n$1;
				}
			}
			class Pi$1 {
				constructor(e$1, t$1, i$1, a$1) {
					this.min = i$1, this.max = a$1, this.points = e$1, this.planes = t$1;
				}
				static fromAabb(e$1, t$1) {
					const i$1 = [];
					for (let a$1 = 0; a$1 < 8; a$1++) i$1.push([
						1 & ~a$1 ? e$1[0] : t$1[0],
						1 == (a$1 >> 1 & 1) ? t$1[1] : e$1[1],
						1 == (a$1 >> 2 & 1) ? t$1[2] : e$1[2]
					]);
					return new Pi$1(i$1, [
						[
							-1,
							0,
							0,
							t$1[0]
						],
						[
							1,
							0,
							0,
							-e$1[0]
						],
						[
							0,
							-1,
							0,
							t$1[1]
						],
						[
							0,
							1,
							0,
							-e$1[1]
						],
						[
							0,
							0,
							-1,
							t$1[2]
						],
						[
							0,
							0,
							1,
							-e$1[2]
						]
					], e$1, t$1);
				}
				static fromCenterSizeAngles(e$1, i$1, a$1) {
					const r$1 = t.bC([], a$1[0], a$1[1], a$1[2]), o$1 = t.bD([], [
						i$1[0],
						0,
						0
					], r$1), s$1 = t.bD([], [
						0,
						i$1[1],
						0
					], r$1), n$1 = t.bD([], [
						0,
						0,
						i$1[2]
					], r$1), l$1 = [...e$1], c$1 = [...e$1];
					for (let t$1 = 0; t$1 < 8; t$1++) for (let i$2 = 0; i$2 < 3; i$2++) {
						const a$2 = e$1[i$2] + o$1[i$2] * (1 & ~t$1 ? -1 : 1) + s$1[i$2] * (1 == (t$1 >> 1 & 1) ? 1 : -1) + n$1[i$2] * (1 == (t$1 >> 2 & 1) ? 1 : -1);
						l$1[i$2] = Math.min(l$1[i$2], a$2), c$1[i$2] = Math.max(c$1[i$2], a$2);
					}
					const h$1 = [];
					for (let i$2 = 0; i$2 < 8; i$2++) {
						const a$2 = [...e$1];
						t.b1(a$2, a$2, t.b0([], o$1, 1 & ~i$2 ? -1 : 1)), t.b1(a$2, a$2, t.b0([], s$1, 1 == (i$2 >> 1 & 1) ? 1 : -1)), t.b1(a$2, a$2, t.b0([], n$1, 1 == (i$2 >> 2 & 1) ? 1 : -1)), h$1.push(a$2);
					}
					return new Pi$1(h$1, [
						[...o$1, -t.b6(o$1, h$1[0])],
						[...s$1, -t.b6(s$1, h$1[0])],
						[...n$1, -t.b6(n$1, h$1[0])],
						[
							-o$1[0],
							-o$1[1],
							-o$1[2],
							-t.b6(o$1, h$1[7])
						],
						[
							-s$1[0],
							-s$1[1],
							-s$1[2],
							-t.b6(s$1, h$1[7])
						],
						[
							-n$1[0],
							-n$1[1],
							-n$1[2],
							-t.b6(n$1, h$1[7])
						]
					], l$1, c$1);
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					const i$1 = this.points.length, a$1 = this.planes.length, r$1 = e$1.planes.length, o$1 = e$1.points.length;
					for (let a$2 = 0; a$2 < r$1; a$2++) {
						const r$2 = e$1.planes[a$2];
						let o$2 = 0;
						for (let e$2 = 0; e$2 < i$1; e$2++) {
							const t$2 = this.points[e$2];
							r$2[0] * t$2[0] + r$2[1] * t$2[1] + r$2[2] * t$2[2] + r$2[3] >= 0 && o$2++;
						}
						if (0 === o$2) return 0;
						o$2 < i$1 && (t$1 = !1);
					}
					if (t$1) return 2;
					for (let t$2 = 0; t$2 < a$1; t$2++) {
						const i$2 = this.planes[t$2];
						let a$2 = 0;
						for (let t$3 = 0; t$3 < o$1; t$3++) {
							const r$2 = e$1.points[t$3];
							i$2[0] * r$2[0] + i$2[1] * r$2[1] + i$2[2] * r$2[2] + i$2[3] >= 0 && a$2++;
						}
						if (0 === a$2) return 0;
					}
					return 1;
				}
				intersectsPlane(e$1) {
					const t$1 = this.points.length;
					let i$1 = 0;
					for (let a$1 = 0; a$1 < t$1; a$1++) {
						const t$2 = this.points[a$1];
						e$1[0] * t$2[0] + e$1[1] * t$2[1] + e$1[2] * t$2[2] + e$1[3] >= 0 && i$1++;
					}
					return i$1 === t$1 ? 2 : 0 === i$1 ? 0 : 1;
				}
			}
			function Ii$1(e$1, t$1, i$1) {
				const a$1 = e$1 - t$1;
				return a$1 < 0 ? -a$1 : Math.max(0, a$1 - i$1);
			}
			function Ci$1(e$1, t$1, i$1, a$1, r$1) {
				const o$1 = e$1 - i$1;
				let s$1;
				return s$1 = o$1 < 0 ? Math.min(-o$1, 1 + o$1 - r$1) : o$1 > 1 ? Math.min(Math.max(o$1 - r$1, 0), 1 - o$1) : 0, Math.max(s$1, Ii$1(t$1, a$1, r$1));
			}
			class Mi$1 {
				constructor() {
					this._boundingVolumeCache = new Ti$1(this._computeTileBoundingVolume);
				}
				prepareNextFrame() {
					this._boundingVolumeCache.swapBuffers();
				}
				distanceToTile2d(e$1, t$1, i$1, a$1) {
					const r$1 = 1 << i$1.z, o$1 = 1 / r$1, s$1 = i$1.x / r$1, n$1 = i$1.y / r$1;
					let l$1 = 2;
					return l$1 = Math.min(l$1, Ci$1(e$1, t$1, s$1, n$1, o$1)), l$1 = Math.min(l$1, Ci$1(e$1, t$1, s$1 + .5, -n$1 - o$1, o$1)), l$1 = Math.min(l$1, Ci$1(e$1, t$1, s$1 + .5, 2 - n$1 - o$1, o$1)), l$1;
				}
				getWrap(e$1, t$1, i$1) {
					const a$1 = 1 << t$1.z, r$1 = 1 / a$1, o$1 = t$1.x / a$1, s$1 = Ii$1(e$1.x, o$1, r$1), n$1 = Ii$1(e$1.x, o$1 - 1, r$1), l$1 = Ii$1(e$1.x, o$1 + 1, r$1), c$1 = Math.min(s$1, n$1, l$1);
					return c$1 === l$1 ? 1 : c$1 === n$1 ? -1 : 0;
				}
				allowVariableZoom(e$1, t$1) {
					return Ie$1(e$1, t$1) > 4;
				}
				allowWorldCopies() {
					return !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, a$1) {
					return this._boundingVolumeCache.getTileBoundingVolume(e$1, t$1, i$1, a$1);
				}
				_computeTileBoundingVolume(e$1, i$1, a$1, r$1) {
					var o$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == r$1 ? void 0 : r$1.terrain) {
						const c$1 = new t.a2(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = r$1.terrain.getMinMaxElevation(c$1);
						n$1 = null !== (o$1 = h$1.minElevation) && void 0 !== o$1 ? o$1 : Math.min(0, a$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, a$1);
					}
					if (n$1 /= t.bF, l$1 /= t.bF, n$1 += 1, l$1 += 1, e$1.z <= 0) return Pi$1.fromAabb([
						-l$1,
						-l$1,
						-l$1
					], [
						l$1,
						l$1,
						l$1
					]);
					if (1 === e$1.z) return Pi$1.fromAabb([
						0 === e$1.x ? -l$1 : 0,
						0 === e$1.y ? 0 : -l$1,
						-l$1
					], [
						0 === e$1.x ? 0 : l$1,
						0 === e$1.y ? l$1 : 0,
						l$1
					]);
					{
						const i$2 = [
							pi(0, 0, e$1.x, e$1.y, e$1.z),
							pi(t.a5, 0, e$1.x, e$1.y, e$1.z),
							pi(t.a5, t.a5, e$1.x, e$1.y, e$1.z),
							pi(0, t.a5, e$1.x, e$1.y, e$1.z)
						], a$2 = [];
						for (const e$2 of i$2) a$2.push(t.b0([], e$2, l$1));
						if (l$1 !== n$1) for (const e$2 of i$2) a$2.push(t.b0([], e$2, n$1));
						0 === e$1.y && a$2.push([
							0,
							1,
							0
						]), e$1.y === (1 << e$1.z) - 1 && a$2.push([
							0,
							-1,
							0
						]);
						const r$2 = [
							1,
							1,
							1
						], o$2 = [
							-1,
							-1,
							-1
						];
						for (const e$2 of a$2) for (let t$1 = 0; t$1 < 3; t$1++) r$2[t$1] = Math.min(r$2[t$1], e$2[t$1]), o$2[t$1] = Math.max(o$2[t$1], e$2[t$1]);
						const s$2 = pi(t.a5 / 2, t.a5 / 2, e$1.x, e$1.y, e$1.z), c$1 = t.b5([], [
							0,
							1,
							0
						], s$2);
						t.b4(c$1, c$1);
						const h$1 = t.b5([], s$2, c$1);
						t.b4(h$1, h$1);
						const u$1 = t.b5([], i$2[2], i$2[1]);
						t.b4(u$1, u$1);
						const d$1 = t.b5([], i$2[0], i$2[3]);
						t.b4(d$1, d$1), a$2.push(t.b0([], s$2, l$1)), e$1.y >= (1 << e$1.z) / 2 && a$2.push(t.b0([], pi(t.a5 / 2, 0, e$1.x, e$1.y, e$1.z), l$1)), e$1.y < (1 << e$1.z) / 2 && a$2.push(t.b0([], pi(t.a5 / 2, t.a5, e$1.x, e$1.y, e$1.z), l$1));
						const _$2 = Ei$1(s$2, a$2), p$1 = Ei$1(h$1, a$2), m$1 = [
							-s$2[0],
							-s$2[1],
							-s$2[2],
							_$2.max
						], f$1 = [
							s$2[0],
							s$2[1],
							s$2[2],
							-_$2.min
						], g$2 = [
							-h$1[0],
							-h$1[1],
							-h$1[2],
							p$1.max
						], v$1 = [
							h$1[0],
							h$1[1],
							h$1[2],
							-p$1.min
						], x$1 = [...u$1, 0], b$1 = [...d$1, 0], y$1 = [];
						return 0 === e$1.y ? y$1.push(t.bE(b$1, x$1, m$1), t.bE(b$1, x$1, f$1)) : y$1.push(t.bE(g$2, x$1, m$1), t.bE(g$2, x$1, f$1), t.bE(g$2, b$1, m$1), t.bE(g$2, b$1, f$1)), e$1.y === (1 << e$1.z) - 1 ? y$1.push(t.bE(b$1, x$1, m$1), t.bE(b$1, x$1, f$1)) : y$1.push(t.bE(v$1, x$1, m$1), t.bE(v$1, x$1, f$1), t.bE(v$1, b$1, m$1), t.bE(v$1, b$1, f$1)), new Pi$1(y$1, [
							m$1,
							f$1,
							g$2,
							v$1,
							x$1,
							b$1
						], r$2, o$2);
					}
				}
			}
			function Ei$1(e$1, i$1) {
				let a$1 = Infinity, r$1 = -Infinity;
				for (const o$1 of i$1) {
					const i$2 = t.b6(e$1, o$1);
					a$1 = Math.min(a$1, i$2), r$1 = Math.max(r$1, i$2);
				}
				return {
					min: a$1,
					max: r$1
				};
			}
			class Si {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1) {
					this._helper.resize(e$1, t$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				setConstrainOverride(e$1) {
					this._helper.setConstrainOverride(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get constrainOverride() {
					return this._helper.constrainOverride;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1) {}
				constructor(e$1) {
					this._cachedClippingPlane = t.bG(), this._projectionMatrix = t.bk(), this._globeViewProjMatrix32f = t.bj(), this._globeViewProjMatrixNoCorrection = t.bk(), this._globeViewProjMatrixNoCorrectionInverted = t.bk(), this._globeProjMatrixInverted = t.bk(), this._cameraPosition = t.bA(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (e$2, i$1) => {
						const a$1 = t.ao(e$2.lat, -t.ap, t.ap), r$1 = t.ao(+i$1, this.minZoom + xi(0, a$1), this.maxZoom);
						return {
							center: new t.V(e$2.lng, a$1),
							zoom: r$1
						};
					}, this.applyConstrain = (e$2, t$1) => this._helper.applyConstrain(e$2, t$1), this._helper = new Ut$1({
						calcMatrices: () => {
							this._calcMatrices();
						},
						defaultConstrain: (e$2, t$1) => this.defaultConstrain(e$2, t$1)
					}, e$1), this._coveringTilesDetailsProvider = new Mi$1();
				}
				clone() {
					const e$1 = new Si();
					return e$1.apply(this), e$1;
				}
				apply(e$1, t$1) {
					this._globeLatitudeErrorCorrectionRadians = t$1 || 0, this._helper.apply(e$1);
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._globeViewProjMatrixNoCorrection;
				}
				get inverseProjectionMatrix() {
					return this._globeProjMatrixInverted;
				}
				get cameraPosition() {
					const e$1 = t.bA();
					return e$1[0] = this._cameraPosition[0], e$1[1] = this._cameraPosition[1], e$1[2] = this._cameraPosition[2], e$1;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				getProjectionData(e$1) {
					const { overscaledTileID: t$1, applyGlobeMatrix: i$1 } = e$1, a$1 = this._helper.getMercatorTileCoordinates(t$1);
					return {
						mainMatrix: this._globeViewProjMatrix32f,
						tileMercatorCoords: a$1,
						clippingPlane: this._cachedClippingPlane,
						projectionTransition: i$1 ? 1 : 0,
						fallbackMatrix: this._globeViewProjMatrix32f
					};
				}
				_computeClippingPlane(e$1) {
					const i$1 = this.pitchInRadians, a$1 = this.cameraToCenterDistance / e$1, r$1 = Math.sin(i$1) * a$1, o$1 = Math.cos(i$1) * a$1 + 1, s$1 = 1 / Math.sqrt(r$1 * r$1 + o$1 * o$1) * 1;
					let n$1 = -r$1, l$1 = o$1;
					const c$1 = Math.sqrt(n$1 * n$1 + l$1 * l$1);
					n$1 /= c$1, l$1 /= c$1;
					const h$1 = [
						0,
						n$1,
						l$1
					];
					t.bH(h$1, h$1, [
						0,
						0,
						0
					], -this.bearingInRadians), t.bI(h$1, h$1, [
						0,
						0,
						0
					], -1 * this.center.lat * Math.PI / 180), t.bJ(h$1, h$1, [
						0,
						0,
						0
					], this.center.lng * Math.PI / 180);
					const u$1 = 1 / t.b8(h$1);
					return t.b0(h$1, h$1, u$1), [...h$1, -s$1 * u$1];
				}
				isLocationOccluded(e$1) {
					return !this.isSurfacePointVisible(mi$1(e$1));
				}
				transformLightDirection(e$1) {
					const i$1 = this._helper._center.lng * Math.PI / 180, a$1 = this._helper._center.lat * Math.PI / 180, r$1 = Math.cos(a$1), o$1 = [
						Math.sin(i$1) * r$1,
						Math.sin(a$1),
						Math.cos(i$1) * r$1
					], s$1 = [
						o$1[2],
						0,
						-o$1[0]
					], n$1 = [
						0,
						0,
						0
					];
					t.b5(n$1, s$1, o$1), t.b4(s$1, s$1), t.b4(n$1, n$1);
					const l$1 = [
						0,
						0,
						0
					];
					return t.b4(l$1, [
						s$1[0] * e$1[0] + n$1[0] * e$1[1] + o$1[0] * e$1[2],
						s$1[1] * e$1[0] + n$1[1] * e$1[1] + o$1[1] * e$1[2],
						s$1[2] * e$1[0] + n$1[2] * e$1[1] + o$1[2] * e$1[2]
					]), l$1;
				}
				getPixelScale() {
					return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getCircleRadiusCorrection() {
					return Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getPitchedTextCorrection(e$1, i$1, a$1) {
					const r$1 = function(e$2, i$2, a$2) {
						const r$2 = 1 / (1 << a$2.z);
						return new t.ab(e$2 / t.a5 * r$2 + a$2.x * r$2, i$2 / t.a5 * r$2 + a$2.y * r$2);
					}(e$1, i$1, a$1.canonical), o$1 = (s$1 = r$1.y, [t.bz(r$1.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s$1 * Math.PI * 2)) - .5 * Math.PI]);
					var s$1;
					return this.getCircleRadiusCorrection() / Math.cos(o$1[1]);
				}
				projectTileCoordinates(e$1, i$1, a$1, r$1) {
					const o$1 = a$1.canonical, s$1 = pi(e$1, i$1, o$1.x, o$1.y, o$1.z), n$1 = 1 + (r$1 ? r$1(e$1, i$1) : 0) / t.bF, l$1 = [
						s$1[0] * n$1,
						s$1[1] * n$1,
						s$1[2] * n$1,
						1
					];
					t.aI(l$1, l$1, this._globeViewProjMatrixNoCorrection);
					const c$1 = this._cachedClippingPlane, h$1 = c$1[0] * s$1[0] + c$1[1] * s$1[1] + c$1[2] * s$1[2] + c$1[3] < 0;
					return {
						point: new t.P(l$1[0] / l$1[3], l$1[1] / l$1[3]),
						signedDistanceFromCamera: l$1[3],
						isOccluded: h$1
					};
				}
				_calcMatrices() {
					if (!this._helper._width || !this._helper._height) return;
					const e$1 = fi(this.worldSize, this.center.lat), i$1 = t.bl(), a$1 = t.bl();
					this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e$1), t.bf(i$1, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
					const r$1 = this.centerOffset;
					i$1[8] = 2 * -r$1.x / this._helper._width, i$1[9] = 2 * r$1.y / this._helper._height, this._projectionMatrix = t.bg(i$1), this._globeProjMatrixInverted = t.bl(), t.aC(this._globeProjMatrixInverted, i$1), t.O(i$1, i$1, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.bh(i$1, i$1, this.rollInRadians), t.bi(i$1, i$1, -this.pitchInRadians), t.bh(i$1, i$1, this.bearingInRadians), t.O(i$1, i$1, [
						0,
						0,
						-e$1
					]);
					const o$1 = t.bA();
					o$1[0] = e$1, o$1[1] = e$1, o$1[2] = e$1, t.bi(a$1, i$1, this.center.lat * Math.PI / 180), t.bK(a$1, a$1, -this.center.lng * Math.PI / 180), t.Q(a$1, a$1, o$1), this._globeViewProjMatrixNoCorrection = a$1, t.bi(i$1, i$1, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bK(i$1, i$1, -this.center.lng * Math.PI / 180), t.Q(i$1, i$1, o$1), this._globeViewProjMatrix32f = new Float32Array(i$1), this._globeViewProjMatrixNoCorrectionInverted = t.bl(), t.aC(this._globeViewProjMatrixNoCorrectionInverted, a$1);
					const s$1 = t.bA();
					this._cameraPosition = t.bA(), this._cameraPosition[2] = this.cameraToCenterDistance / e$1, t.bH(this._cameraPosition, this._cameraPosition, s$1, -this.rollInRadians), t.bI(this._cameraPosition, this._cameraPosition, s$1, this.pitchInRadians), t.bH(this._cameraPosition, this._cameraPosition, s$1, -this.bearingInRadians), t.b1(this._cameraPosition, this._cameraPosition, [
						0,
						0,
						1
					]), t.bI(this._cameraPosition, this._cameraPosition, s$1, -this.center.lat * Math.PI / 180), t.bJ(this._cameraPosition, this._cameraPosition, s$1, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e$1);
					const n$1 = t.bg(this._globeViewProjMatrixNoCorrectionInverted);
					t.Q(n$1, n$1, [
						1,
						1,
						-1
					]), this._cachedFrustum = Wt$1.fromInvProjectionMatrix(n$1, 1, 0, this._cachedClippingPlane, !0);
				}
				calculateFogMatrix(e$1) {
					t.w("calculateFogMatrix is not supported on globe projection.");
					const i$1 = t.bl();
					return t.as(i$1), i$1;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return [new t.bd(0, e$1)];
				}
				getCameraFrustum() {
					return this._cachedFrustum;
				}
				getClippingPlane() {
					return this._cachedClippingPlane;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					e$1 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
				}
				maxPitchScaleFactor() {
					return 1;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					if (!this._globeViewProjMatrixNoCorrection) return 1;
					const a$1 = mi$1(e$1);
					t.b0(a$1, a$1, 1 + i$1 / t.bF);
					const r$1 = t.bG();
					return t.aI(r$1, [
						a$1[0],
						a$1[1],
						a$1[2],
						1
					], this._globeViewProjMatrixNoCorrection), r$1[2] / r$1[3];
				}
				populateCache(e$1) {}
				getBounds() {
					const e$1 = .5 * this.width, i$1 = .5 * this.height, a$1 = [
						new t.P(0, 0),
						new t.P(e$1, 0),
						new t.P(this.width, 0),
						new t.P(this.width, i$1),
						new t.P(this.width, this.height),
						new t.P(e$1, this.height),
						new t.P(0, this.height),
						new t.P(0, i$1)
					], r$1 = [];
					for (const e$2 of a$1) r$1.push(this.unprojectScreenPoint(e$2));
					let o$1 = 0, s$1 = 0, n$1 = 0, l$1 = 0;
					const c$1 = this.center;
					for (const e$2 of r$1) {
						const i$2 = t.bL(c$1.lng, e$2.lng), a$2 = t.bL(c$1.lat, e$2.lat);
						i$2 < s$1 && (s$1 = i$2), i$2 > o$1 && (o$1 = i$2), a$2 < l$1 && (l$1 = a$2), a$2 > n$1 && (n$1 = a$2);
					}
					const h$1 = [
						c$1.lng + s$1,
						c$1.lat + l$1,
						c$1.lng + o$1,
						c$1.lat + n$1
					];
					return this.isSurfacePointOnScreen([
						0,
						1,
						0
					]) && (h$1[3] = 90, h$1[0] = -180, h$1[2] = 180), this.isSurfacePointOnScreen([
						0,
						-1,
						0
					]) && (h$1[1] = -90, h$1[0] = -180, h$1[2] = 180), new $$1(h$1);
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const a$1 = mi$1(this.unprojectScreenPoint(i$1)), r$1 = mi$1(e$1), o$1 = t.bA();
					t.bM(o$1);
					const s$1 = t.bA();
					t.bJ(s$1, a$1, o$1, -this.center.lng * Math.PI / 180), t.bI(s$1, s$1, o$1, this.center.lat * Math.PI / 180);
					const n$1 = r$1[0] * r$1[0] + r$1[2] * r$1[2], l$1 = s$1[0] * s$1[0];
					if (n$1 < l$1) return;
					const c$1 = Math.sqrt(n$1 - l$1), h$1 = -c$1, u$1 = t.bN(r$1[0], r$1[2], s$1[0], c$1), d$1 = t.bN(r$1[0], r$1[2], s$1[0], h$1), _$2 = t.bA();
					t.bJ(_$2, r$1, o$1, -u$1);
					const p$1 = t.bN(_$2[1], _$2[2], s$1[1], s$1[2]), m$1 = t.bA();
					t.bJ(m$1, r$1, o$1, -d$1);
					const f$1 = t.bN(m$1[1], m$1[2], s$1[1], s$1[2]), g$2 = .5 * Math.PI, v$1 = p$1 >= -g$2 && p$1 <= g$2, x$1 = f$1 >= -g$2 && f$1 <= g$2;
					let b$1, y$1;
					if (v$1 && x$1) {
						const e$2 = this.center.lng * Math.PI / 180, i$2 = this.center.lat * Math.PI / 180;
						t.bO(u$1, e$2) + t.bO(p$1, i$2) < t.bO(d$1, e$2) + t.bO(f$1, i$2) ? (b$1 = u$1, y$1 = p$1) : (b$1 = d$1, y$1 = f$1);
					} else if (v$1) b$1 = u$1, y$1 = p$1;
					else {
						if (!x$1) return;
						b$1 = d$1, y$1 = f$1;
					}
					const w$2 = b$1 / Math.PI * 180, T$1 = y$1 / Math.PI * 180, P$2 = this.center.lat;
					this.setCenter(new t.V(w$2, t.ao(T$1, -90, 90))), this.setZoom(this.zoom + xi(P$2, this.center.lat));
				}
				locationToScreenPoint(e$1, i$1) {
					const a$1 = mi$1(e$1);
					if (i$1) {
						const r$1 = i$1.getElevationForLngLatZoom(e$1, this._helper._tileZoom);
						t.b0(a$1, a$1, 1 + r$1 / t.bF);
					}
					return this._projectSurfacePointToScreen(a$1);
				}
				_projectSurfacePointToScreen(e$1) {
					const i$1 = t.bG();
					return t.aI(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], new t.P((.5 * i$1[0] + .5) * this.width, (.5 * -i$1[1] + .5) * this.height);
				}
				screenPointToMercatorCoordinate(e$1, i$1) {
					if (i$1) {
						const t$1 = i$1.pointCoordinate(e$1);
						if (t$1) return t$1;
					}
					return t.ab.fromLngLat(this.unprojectScreenPoint(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				isPointOnMapSurface(e$1, t$1) {
					const i$1 = this._cameraPosition, a$1 = this.getRayDirectionFromPixel(e$1);
					return !!this.rayPlanetIntersection(i$1, a$1);
				}
				getRayDirectionFromPixel(e$1) {
					const i$1 = t.bG();
					i$1[0] = e$1.x / this.width * 2 - 1, i$1[1] = -1 * (e$1.y / this.height * 2 - 1), i$1[2] = 1, i$1[3] = 1, t.aI(i$1, i$1, this._globeViewProjMatrixNoCorrectionInverted), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3];
					const a$1 = t.bA();
					a$1[0] = i$1[0] - this._cameraPosition[0], a$1[1] = i$1[1] - this._cameraPosition[1], a$1[2] = i$1[2] - this._cameraPosition[2];
					const r$1 = t.bA();
					return t.b4(r$1, a$1), r$1;
				}
				isSurfacePointVisible(e$1) {
					const t$1 = this._cachedClippingPlane;
					return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3] >= 0;
				}
				isSurfacePointOnScreen(e$1) {
					if (!this.isSurfacePointVisible(e$1)) return !1;
					const i$1 = t.bG();
					return t.aI(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3], i$1[0] > -1 && i$1[0] < 1 && i$1[1] > -1 && i$1[1] < 1 && i$1[2] > -1 && i$1[2] < 1;
				}
				rayPlanetIntersection(e$1, i$1) {
					const a$1 = t.b6(e$1, i$1), r$1 = t.bA(), o$1 = t.bA();
					t.b0(o$1, i$1, a$1), t.b3(r$1, e$1, o$1);
					const s$1 = 1 - t.b6(r$1, r$1);
					if (s$1 < 0) return null;
					const n$1 = t.b6(e$1, e$1) - 1, l$1 = -a$1 + (a$1 < 0 ? 1 : -1) * Math.sqrt(s$1), c$1 = n$1 / l$1, h$1 = l$1;
					return {
						tMin: Math.min(c$1, h$1),
						tMax: Math.max(c$1, h$1)
					};
				}
				unprojectScreenPoint(e$1) {
					const i$1 = this._cameraPosition, a$1 = this.getRayDirectionFromPixel(e$1), r$1 = this.rayPlanetIntersection(i$1, a$1);
					if (r$1) {
						const e$2 = t.bA();
						t.b1(e$2, i$1, [
							a$1[0] * r$1.tMin,
							a$1[1] * r$1.tMin,
							a$1[2] * r$1.tMin
						]);
						const o$2 = t.bA();
						return t.b4(o$2, e$2), gi(o$2);
					}
					const o$1 = this._cachedClippingPlane, s$1 = o$1[0] * a$1[0] + o$1[1] * a$1[1] + o$1[2] * a$1[2], n$1 = -t.bc(o$1, i$1) / s$1, l$1 = t.bA();
					if (n$1 > 0) t.b1(l$1, i$1, [
						a$1[0] * n$1,
						a$1[1] * n$1,
						a$1[2] * n$1
					]);
					else {
						const e$2 = t.bA();
						t.b1(e$2, i$1, [
							2 * a$1[0],
							2 * a$1[1],
							2 * a$1[2]
						]);
						const r$2 = t.bc(this._cachedClippingPlane, e$2);
						t.b3(l$1, e$2, [
							this._cachedClippingPlane[0] * r$2,
							this._cachedClippingPlane[1] * r$2,
							this._cachedClippingPlane[2] * r$2
						]);
					}
					const c$1 = function(e$2) {
						const i$2 = t.bA();
						return i$2[0] = e$2[0] * -e$2[3], i$2[1] = e$2[1] * -e$2[3], i$2[2] = e$2[2] * -e$2[3], {
							center: i$2,
							radius: Math.sqrt(1 - e$2[3] * e$2[3])
						};
					}(o$1);
					return gi(function(e$2, i$2, a$2) {
						const r$2 = t.bA();
						t.b3(r$2, a$2, e$2);
						const o$2 = t.bA();
						return t.bB(o$2, e$2, r$2, i$2 / t.ba(r$2)), o$2;
					}(c$1.center, c$1.radius, l$1));
				}
				getMatrixForModel(e$1, i$1) {
					const a$1 = t.V.convert(e$1), r$1 = 1 / t.bF, o$1 = t.bk();
					return t.bK(o$1, o$1, a$1.lng / 180 * Math.PI), t.bi(o$1, o$1, -a$1.lat / 180 * Math.PI), t.O(o$1, o$1, [
						0,
						0,
						1 + i$1 / t.bF
					]), t.bi(o$1, o$1, .5 * Math.PI), t.Q(o$1, o$1, [
						r$1,
						r$1,
						r$1
					]), o$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = this.getProjectionData({
						overscaledTileID: new t.a2(0, 0, 0, 0, 0),
						applyGlobeMatrix: e$1
					});
					return i$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					], i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {}
			}
			class Ri$1 {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				setConstrainOverride(e$1) {
					this._helper.setConstrainOverride(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get constrainOverride() {
					return this._helper.constrainOverride;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				get isGlobeRendering() {
					return this._globeness > 0;
				}
				setTransitionState(e$1, t$1) {
					this._globeness = e$1, this._globeLatitudeErrorCorrectionRadians = t$1, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
				}
				get currentTransform() {
					return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
				}
				constructor(e$1) {
					this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (e$2, t$1) => this.currentTransform.defaultConstrain(e$2, t$1), this.applyConstrain = (e$2, t$1) => this._helper.applyConstrain(e$2, t$1), this._helper = new Ut$1({
						calcMatrices: () => {
							this._calcMatrices();
						},
						defaultConstrain: (e$2, t$1) => this.defaultConstrain(e$2, t$1)
					}, e$1), this._globeness = 1, this._mercatorTransform = new $t$1(), this._verticalPerspectiveTransform = new Si();
				}
				clone() {
					const e$1 = new Ri$1();
					return e$1._globeness = this._globeness, e$1._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e$1.apply(this), e$1;
				}
				apply(e$1) {
					this._helper.apply(e$1), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
				}
				get projectionMatrix() {
					return this.currentTransform.projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this.currentTransform.modelViewProjectionMatrix;
				}
				get inverseProjectionMatrix() {
					return this.currentTransform.inverseProjectionMatrix;
				}
				get cameraPosition() {
					return this.currentTransform.cameraPosition;
				}
				getProjectionData(e$1) {
					const t$1 = this._mercatorTransform.getProjectionData(e$1), i$1 = this._verticalPerspectiveTransform.getProjectionData(e$1);
					return {
						mainMatrix: this.isGlobeRendering ? i$1.mainMatrix : t$1.mainMatrix,
						clippingPlane: i$1.clippingPlane,
						tileMercatorCoords: i$1.tileMercatorCoords,
						projectionTransition: e$1.applyGlobeMatrix ? this._globeness : 0,
						fallbackMatrix: t$1.fallbackMatrix
					};
				}
				isLocationOccluded(e$1) {
					return this.currentTransform.isLocationOccluded(e$1);
				}
				transformLightDirection(e$1) {
					return this.currentTransform.transformLightDirection(e$1);
				}
				getPixelScale() {
					return t.bv(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
				}
				getCircleRadiusCorrection() {
					return t.bv(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
				}
				getPitchedTextCorrection(e$1, i$1, a$1) {
					const r$1 = this._mercatorTransform.getPitchedTextCorrection(e$1, i$1, a$1), o$1 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e$1, i$1, a$1);
					return t.bv(r$1, o$1, this._globeness);
				}
				projectTileCoordinates(e$1, t$1, i$1, a$1) {
					return this.currentTransform.projectTileCoordinates(e$1, t$1, i$1, a$1);
				}
				_calcMatrices() {
					this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
				}
				calculateFogMatrix(e$1) {
					return this.currentTransform.calculateFogMatrix(e$1);
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return this.currentTransform.getVisibleUnwrappedCoordinates(e$1);
				}
				getCameraFrustum() {
					return this.currentTransform.getCameraFrustum();
				}
				getClippingPlane() {
					return this.currentTransform.getClippingPlane();
				}
				getCoveringTilesDetailsProvider() {
					return this.currentTransform.getCoveringTilesDetailsProvider();
				}
				recalculateZoomAndCenter(e$1) {
					this._mercatorTransform.recalculateZoomAndCenter(e$1), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e$1);
				}
				maxPitchScaleFactor() {
					return this._mercatorTransform.maxPitchScaleFactor();
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, t$1) {
					return this.currentTransform.lngLatToCameraDepth(e$1, t$1);
				}
				populateCache(e$1) {
					this._mercatorTransform.populateCache(e$1), this._verticalPerspectiveTransform.populateCache(e$1);
				}
				getBounds() {
					return this.currentTransform.getBounds();
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
				}
				setLocationAtPoint(e$1, t$1) {
					if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e$1, t$1), void this.apply(this._mercatorTransform);
					this._verticalPerspectiveTransform.setLocationAtPoint(e$1, t$1), this.apply(this._verticalPerspectiveTransform);
				}
				locationToScreenPoint(e$1, t$1) {
					return this.currentTransform.locationToScreenPoint(e$1, t$1);
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					return this.currentTransform.screenPointToMercatorCoordinate(e$1, t$1);
				}
				screenPointToLocation(e$1, t$1) {
					return this.currentTransform.screenPointToLocation(e$1, t$1);
				}
				isPointOnMapSurface(e$1, t$1) {
					return this.currentTransform.isPointOnMapSurface(e$1, t$1);
				}
				getRayDirectionFromPixel(e$1) {
					return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e$1);
				}
				getMatrixForModel(e$1, t$1) {
					return this.currentTransform.getMatrixForModel(e$1, t$1);
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const t$1 = this._mercatorTransform.getProjectionDataForCustomLayer(e$1);
					if (!this.isGlobeRendering) return t$1;
					const i$1 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e$1);
					return i$1.fallbackMatrix = t$1.mainMatrix, i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.currentTransform.getFastPathSimpleProjectionMatrix(e$1);
				}
			}
			class zi$1 {
				get useGlobeControls() {
					return !0;
				}
				handlePanInertia(e$1, i$1) {
					const a$1 = bi(e$1, i$1);
					return Math.abs(a$1.lng - i$1.center.lng) > 180 && (a$1.lng = i$1.center.lng + 179.5 * Math.sign(a$1.lng - i$1.center.lng)), {
						easingCenter: a$1,
						easingOffset: new t.P(0, 0)
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, i$1) {
					const a$1 = e$1.around, r$1 = i$1.screenPointToLocation(a$1);
					e$1.bearingDelta && i$1.setBearing(i$1.bearing + e$1.bearingDelta), e$1.pitchDelta && i$1.setPitch(i$1.pitch + e$1.pitchDelta), e$1.rollDelta && i$1.setRoll(i$1.roll + e$1.rollDelta);
					const o$1 = i$1.zoom;
					e$1.zoomDelta && i$1.setZoom(i$1.zoom + e$1.zoomDelta);
					const s$1 = i$1.zoom - o$1;
					if (0 === s$1) return;
					const n$1 = t.bL(i$1.center.lng, r$1.lng), l$1 = n$1 / (Math.abs(n$1 / 180) + 1), c$1 = t.bL(i$1.center.lat, r$1.lat), h$1 = i$1.getRayDirectionFromPixel(a$1), u$1 = i$1.cameraPosition, d$1 = -1 * t.b6(u$1, h$1), _$2 = t.bA();
					t.b1(_$2, u$1, [
						h$1[0] * d$1,
						h$1[1] * d$1,
						h$1[2] * d$1
					]);
					const p$1 = t.b8(_$2) - 1, m$1 = Math.exp(.5 * -Math.max(p$1 - .3, 0)), f$1 = fi(i$1.worldSize, i$1.center.lat) / Math.min(i$1.width, i$1.height), g$2 = t.by(f$1, .9, .5, 1, .25), v$1 = (1 - t.ar(-s$1)) * Math.min(m$1, g$2), x$1 = i$1.center.lat, b$1 = i$1.zoom, y$1 = new t.V(i$1.center.lng + l$1 * v$1, t.ao(i$1.center.lat + c$1 * v$1, -t.ap, t.ap));
					i$1.setLocationAtPoint(r$1, a$1);
					const w$2 = i$1.center, T$1 = t.by(Math.abs(n$1), 45, 85, 0, 1), P$2 = t.by(f$1, .75, .35, 0, 1), I$2 = Math.pow(Math.max(T$1, P$2), .25), C$1 = t.bL(w$2.lng, y$1.lng), M$2 = t.bL(w$2.lat, y$1.lat);
					i$1.setCenter(new t.V(w$2.lng + C$1 * I$2, w$2.lat + M$2 * I$2).wrap()), i$1.setZoom(b$1 + xi(x$1, i$1.center.lat));
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					if (!e$1.panDelta) return;
					const a$1 = t$1.center.lat, r$1 = t$1.zoom;
					t$1.setCenter(bi(e$1.panDelta, t$1).wrap()), t$1.setZoom(r$1 + xi(a$1, t$1.center.lat));
				}
				cameraForBoxAndBearing(e$1, i$1, a$1, r$1, o$1) {
					const s$1 = Kt$1(e$1, i$1, a$1, r$1, o$1), n$1 = i$1.left / o$1.width * 2 - 1, l$1 = (o$1.width - i$1.right) / o$1.width * 2 - 1, c$1 = i$1.top / o$1.height * -2 + 1, h$1 = (o$1.height - i$1.bottom) / o$1.height * -2 + 1, u$1 = t.bL(a$1.getWest(), a$1.getEast()) < 0, d$1 = u$1 ? a$1.getEast() : a$1.getWest(), _$2 = u$1 ? a$1.getWest() : a$1.getEast(), p$1 = Math.max(a$1.getNorth(), a$1.getSouth()), m$1 = Math.min(a$1.getNorth(), a$1.getSouth()), f$1 = d$1 + .5 * t.bL(d$1, _$2), g$2 = p$1 + .5 * t.bL(p$1, m$1), v$1 = o$1.clone();
					v$1.setCenter(s$1.center), v$1.setBearing(s$1.bearing), v$1.setPitch(0), v$1.setRoll(0), v$1.setZoom(s$1.zoom);
					const x$1 = v$1.modelViewProjectionMatrix, b$1 = [
						mi$1(a$1.getNorthWest()),
						mi$1(a$1.getNorthEast()),
						mi$1(a$1.getSouthWest()),
						mi$1(a$1.getSouthEast()),
						mi$1(new t.V(_$2, g$2)),
						mi$1(new t.V(d$1, g$2)),
						mi$1(new t.V(f$1, p$1)),
						mi$1(new t.V(f$1, m$1))
					], y$1 = mi$1(s$1.center);
					let w$2 = Number.POSITIVE_INFINITY;
					for (const e$2 of b$1) n$1 < 0 && (w$2 = zi$1.getLesserNonNegativeNonNull(w$2, zi$1.solveVectorScale(e$2, y$1, x$1, "x", n$1))), l$1 > 0 && (w$2 = zi$1.getLesserNonNegativeNonNull(w$2, zi$1.solveVectorScale(e$2, y$1, x$1, "x", l$1))), c$1 > 0 && (w$2 = zi$1.getLesserNonNegativeNonNull(w$2, zi$1.solveVectorScale(e$2, y$1, x$1, "y", c$1))), h$1 < 0 && (w$2 = zi$1.getLesserNonNegativeNonNull(w$2, zi$1.solveVectorScale(e$2, y$1, x$1, "y", h$1)));
					if (Number.isFinite(w$2) && 0 !== w$2) return s$1.zoom = v$1.zoom + t.au(w$2), s$1;
					Ht$1();
				}
				handleJumpToCenterZoom(e$1, i$1) {
					const a$1 = e$1.center.lat, r$1 = e$1.applyConstrain(i$1.center ? t.V.convert(i$1.center) : e$1.center, e$1.zoom).center;
					e$1.setCenter(r$1.wrap());
					const o$1 = void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom + xi(a$1, r$1.lat);
					e$1.zoom !== o$1 && e$1.setZoom(o$1);
				}
				handleEaseTo(e$1, i$1) {
					const a$1 = e$1.zoom, r$1 = e$1.center, o$1 = e$1.padding, s$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, n$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, l$1 = void 0 !== i$1.zoom, c$1 = !e$1.isPaddingEqual(i$1.padding);
					let h$1 = !1;
					const u$1 = i$1.center ? t.V.convert(i$1.center) : r$1, d$1 = e$1.applyConstrain(u$1, a$1).center;
					Zt$1(e$1, d$1);
					const _$2 = e$1.clone();
					_$2.setCenter(d$1), _$2.setZoom(l$1 ? +i$1.zoom : a$1 + xi(r$1.lat, u$1.lat)), _$2.setBearing(i$1.bearing);
					const p$1 = new t.P(t.ao(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.ao(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					_$2.setLocationAtPoint(d$1, p$1);
					const m$1 = (i$1.offset && i$1.offsetAsPoint.mag()) > 0 ? _$2.center : d$1, f$1 = l$1 ? +i$1.zoom : a$1 + xi(r$1.lat, m$1.lat), g$2 = a$1 + xi(r$1.lat, 0), v$1 = f$1 + xi(m$1.lat, 0), x$1 = t.bL(r$1.lng, m$1.lng), b$1 = t.bL(r$1.lat, m$1.lat), y$1 = t.ar(v$1 - g$2);
					return h$1 = f$1 !== a$1, {
						easeFunc: (a$2) => {
							if (t.bp(s$1, n$1) || Xt$1({
								startEulerAngles: s$1,
								endEulerAngles: n$1,
								tr: e$1,
								k: a$2,
								useSlerp: s$1.roll != n$1.roll
							}), c$1 && e$1.interpolatePadding(o$1, i$1.padding, a$2), i$1.around) t.w("Easing around a point is not supported under globe projection."), e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const t$1 = v$1 > g$2 ? Math.min(2, y$1) : Math.max(.5, y$1), o$2 = wi(r$1, x$1, b$1, a$2 * Math.pow(t$1, 1 - a$2));
								e$1.setCenter(o$2.wrap());
							}
							if (h$1) {
								const i$2 = t.G.number(g$2, v$1, a$2) + xi(0, e$1.center.lat);
								e$1.setZoom(i$2);
							}
						},
						isZooming: h$1,
						elevationCenter: m$1
					};
				}
				handleFlyTo(e$1, i$1) {
					const a$1 = void 0 !== i$1.zoom, r$1 = e$1.center, o$1 = e$1.zoom, s$1 = e$1.padding, n$1 = !e$1.isPaddingEqual(i$1.padding), l$1 = e$1.applyConstrain(t.V.convert(i$1.center || i$1.locationAtOffset), o$1).center, c$1 = a$1 ? +i$1.zoom : e$1.zoom + xi(e$1.center.lat, l$1.lat), h$1 = e$1.clone();
					h$1.setCenter(l$1), h$1.setZoom(c$1), h$1.setBearing(i$1.bearing);
					const u$1 = new t.P(t.ao(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.ao(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					h$1.setLocationAtPoint(l$1, u$1);
					const d$1 = h$1.center;
					Zt$1(e$1, d$1);
					const _$2 = function(e$2, i$2, a$2) {
						const r$2 = mi$1(i$2), o$2 = mi$1(a$2), s$2 = t.b6(r$2, o$2), n$2 = Math.acos(s$2), l$2 = _i$1(e$2);
						return n$2 / (2 * Math.PI) * l$2;
					}(e$1, r$1, d$1), p$1 = o$1 + xi(r$1.lat, 0), m$1 = c$1 + xi(d$1.lat, 0), f$1 = t.ar(m$1 - p$1);
					let g$2;
					if ("number" == typeof i$1.minZoom) {
						const a$2 = +i$1.minZoom + xi(d$1.lat, 0), r$2 = Math.min(a$2, p$1, m$1) + xi(0, d$1.lat), o$2 = e$1.applyConstrain(d$1, r$2).zoom + xi(d$1.lat, 0);
						g$2 = t.ar(o$2 - p$1);
					}
					const v$1 = t.bL(r$1.lng, d$1.lng), x$1 = t.bL(r$1.lat, d$1.lat);
					return {
						easeFunc: (a$2, o$2, l$2, h$2) => {
							const u$2 = wi(r$1, v$1, x$1, l$2);
							n$1 && e$1.interpolatePadding(s$1, i$1.padding, a$2);
							const _$3 = 1 === a$2 ? d$1 : u$2;
							e$1.setCenter(_$3.wrap());
							const m$2 = p$1 + t.au(o$2);
							e$1.setZoom(1 === a$2 ? c$1 : m$2 + xi(0, _$3.lat));
						},
						scaleOfZoom: f$1,
						targetCenter: d$1,
						scaleOfMinZoom: g$2,
						pixelPathLength: _$2
					};
				}
				static solveVectorScale(e$1, t$1, i$1, a$1, r$1) {
					const o$1 = "x" === a$1 ? [
						i$1[0],
						i$1[4],
						i$1[8],
						i$1[12]
					] : [
						i$1[1],
						i$1[5],
						i$1[9],
						i$1[13]
					], s$1 = [
						i$1[3],
						i$1[7],
						i$1[11],
						i$1[15]
					], n$1 = e$1[0] * o$1[0] + e$1[1] * o$1[1] + e$1[2] * o$1[2], l$1 = e$1[0] * s$1[0] + e$1[1] * s$1[1] + e$1[2] * s$1[2], c$1 = t$1[0] * o$1[0] + t$1[1] * o$1[1] + t$1[2] * o$1[2], h$1 = t$1[0] * s$1[0] + t$1[1] * s$1[1] + t$1[2] * s$1[2];
					return c$1 + r$1 * l$1 === n$1 + r$1 * h$1 || s$1[3] * (n$1 - c$1) + o$1[3] * (h$1 - l$1) + n$1 * h$1 == c$1 * l$1 ? null : (c$1 + o$1[3] - r$1 * h$1 - r$1 * s$1[3]) / (c$1 - n$1 - r$1 * h$1 + r$1 * l$1);
				}
				static getLesserNonNegativeNonNull(e$1, t$1) {
					return null !== t$1 && t$1 >= 0 && t$1 < e$1 ? t$1 : e$1;
				}
			}
			class Di$1 {
				constructor(e$1) {
					this._globe = e$1, this._mercatorCameraHelper = new Yt$1(), this._verticalPerspectiveCameraHelper = new zi$1();
				}
				get useGlobeControls() {
					return this._globe.useGlobeRendering;
				}
				get currentHelper() {
					return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
				}
				handlePanInertia(e$1, t$1) {
					return this.currentHelper.handlePanInertia(e$1, t$1);
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					return this.currentHelper.handleMapControlsRollPitchBearingZoom(e$1, t$1);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					this.currentHelper.handleMapControlsPan(e$1, t$1, i$1);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, a$1, r$1) {
					return this.currentHelper.cameraForBoxAndBearing(e$1, t$1, i$1, a$1, r$1);
				}
				handleJumpToCenterZoom(e$1, t$1) {
					this.currentHelper.handleJumpToCenterZoom(e$1, t$1);
				}
				handleEaseTo(e$1, t$1) {
					return this.currentHelper.handleEaseTo(e$1, t$1);
				}
				handleFlyTo(e$1, t$1) {
					return this.currentHelper.handleFlyTo(e$1, t$1);
				}
			}
			const Ai$1 = (e$1, i$1) => t.B(e$1, i$1 && i$1.filter(((e$2) => "source.canvas" !== e$2.identifier))), Li = t.bP();
			class ki extends t.E {
				constructor(e$1, i$1 = {}) {
					var a$1, r$1;
					super(), this._rtlPluginLoaded = () => {
						for (const e$2 in this.tileManagers) {
							const t$1 = this.tileManagers[e$2].getSource().type;
							"vector" !== t$1 && "geojson" !== t$1 || this.tileManagers[e$2].reload();
						}
					}, this.map = e$1, this.dispatcher = new N(j$1(), e$1._getMapId()), this.dispatcher.registerMessageHandler("GG", ((e$2, t$1) => this.getGlyphs(e$2, t$1))), this.dispatcher.registerMessageHandler("GI", ((e$2, t$1) => this.getImages(e$2, t$1))), this.dispatcher.registerMessageHandler("GDA", ((e$2, t$1) => this.getDashes(e$2, t$1))), this.imageManager = new w$1(), this.imageManager.setEventedParent(this);
					const o$1 = (null === (a$1 = e$1._container) || void 0 === a$1 ? void 0 : a$1.lang) || "undefined" != typeof document && (null === (r$1 = document.documentElement) || void 0 === r$1 ? void 0 : r$1.lang) || void 0;
					this.glyphManager = new M$1(e$1._requestManager, i$1.localIdeographFontFamily, o$1), this.lineAtlas = new A$1(256, 512), this.crossTileSymbolIndex = new zt$1(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", t.bQ()), ce$1().on(se$1, this._rtlPluginLoaded), this.on("data", ((e$2) => {
						if ("source" !== e$2.dataType || "metadata" !== e$2.sourceDataType) return;
						const t$1 = this.tileManagers[e$2.sourceId];
						if (!t$1) return;
						const i$2 = t$1.getSource();
						if (i$2 && i$2.vectorLayerIds) for (const e$3 in this._layers) {
							const t$2 = this._layers[e$3];
							t$2.source === i$2.id && this._validateLayer(t$2);
						}
					}));
				}
				_setInitialValues() {
					var e$1;
					this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new t.bR(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = !1, this._changed = !1, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = !1, this._updatedPaintProps = {}, this._layerOrderChanged = !1, this.crossTileSymbolIndex = new ((null === (e$1 = this.crossTileSymbolIndex) || void 0 === e$1 ? void 0 : e$1.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
				}
				setGlobalStateProperty(e$1, i$1) {
					var a$1, r$1, o$1;
					this._checkLoaded();
					const s$1 = null === i$1 ? null !== (o$1 = null === (r$1 = null === (a$1 = this.stylesheet.state) || void 0 === a$1 ? void 0 : a$1[e$1]) || void 0 === r$1 ? void 0 : r$1.default) && void 0 !== o$1 ? o$1 : null : i$1;
					if (t.bS(s$1, this._globalState[e$1])) return this;
					this._globalState[e$1] = s$1, this._applyGlobalStateChanges([e$1]);
				}
				getGlobalState() {
					return this._globalState;
				}
				setGlobalState(e$1) {
					this._checkLoaded();
					const i$1 = [];
					for (const a$1 in e$1) !t.bS(this._globalState[a$1], e$1[a$1].default) && (i$1.push(a$1), this._globalState[a$1] = e$1[a$1].default);
					this._applyGlobalStateChanges(i$1);
				}
				_applyGlobalStateChanges(e$1) {
					if (0 === e$1.length) return;
					const t$1 = /* @__PURE__ */ new Set(), i$1 = {};
					for (const a$1 of e$1) {
						i$1[a$1] = this._globalState[a$1];
						for (const e$2 in this._layers) {
							const i$2 = this._layers[e$2], r$1 = i$2.getLayoutAffectingGlobalStateRefs(), o$1 = i$2.getPaintAffectingGlobalStateRefs();
							if (r$1.has(a$1) && t$1.add(i$2.source), o$1.has(a$1)) for (const { name: e$3, value: t$2 } of o$1.get(a$1)) this._updatePaintProperty(i$2, e$3, t$2);
						}
					}
					this.dispatcher.broadcast("UGS", i$1);
					for (const e$2 in this.tileManagers) t$1.has(e$2) && (this._reloadSource(e$2), this._changed = !0);
				}
				loadURL(e$1, i$1 = {}, a$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), i$1.validate = "boolean" != typeof i$1.validate || i$1.validate;
					const r$1 = this.map._requestManager.transformRequest(e$1, "Style");
					this._loadStyleRequest = new AbortController();
					const o$1 = this._loadStyleRequest;
					t.j(r$1, this._loadStyleRequest).then(((e$2) => {
						this._loadStyleRequest = null, this._load(e$2.data, i$1, a$1);
					})).catch(((e$2) => {
						this._loadStyleRequest = null, e$2 && !o$1.signal.aborted && this.fire(new t.k(e$2));
					}));
				}
				loadJSON(e$1, i$1 = {}, a$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), n.frameAsync(this._frameRequest).then((() => {
						this._frameRequest = null, i$1.validate = !1 !== i$1.validate, this._load(e$1, i$1, a$1);
					})).catch((() => {}));
				}
				loadEmpty() {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._load(Li, { validate: !1 });
				}
				_load(e$1, i$1, a$1) {
					var r$1, o$1;
					let s$1 = i$1.transformStyle ? i$1.transformStyle(a$1, e$1) : e$1;
					if (!i$1.validate || !Ai$1(this, t.C(s$1))) {
						s$1 = Object.assign({}, s$1), this._loaded = !0, this.stylesheet = s$1;
						for (const e$2 in s$1.sources) this.addSource(e$2, s$1.sources[e$2], { validate: !1 });
						s$1.sprite ? this._loadSprite(s$1.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(s$1.glyphs), this._createLayers(), this.light = new R$2(this.stylesheet.light), this._setProjectionInternal((null === (r$1 = this.stylesheet.projection) || void 0 === r$1 ? void 0 : r$1.type) || "mercator"), this.sky = new D$1(this.stylesheet.sky), this.map.setTerrain(null !== (o$1 = this.stylesheet.terrain) && void 0 !== o$1 ? o$1 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
					}
				}
				_createLayers() {
					var e$1, i$1, a$1;
					const r$1 = t.bT(this.stylesheet.layers);
					this.setGlobalState(null !== (e$1 = this.stylesheet.state) && void 0 !== e$1 ? e$1 : null), this.dispatcher.broadcast("SL", r$1), this._order = r$1.map(((e$2) => e$2.id)), this._layers = {}, this._serializedLayers = null;
					for (const e$2 of r$1) {
						const r$2 = t.bU(e$2, this._globalState);
						if (r$2.setEventedParent(this, { layer: { id: e$2.id } }), this._layers[e$2.id] = r$2, t.bV(r$2) && this.tileManagers[r$2.source]) {
							const t$1 = null !== (a$1 = null === (i$1 = e$2.paint) || void 0 === i$1 ? void 0 : i$1["raster-fade-duration"]) && void 0 !== a$1 ? a$1 : r$2.paint.get("raster-fade-duration");
							this.tileManagers[r$2.source].setRasterFadeDuration(t$1);
						}
					}
				}
				_loadSprite(e$1, i$1 = !1, a$1 = void 0) {
					this.imageManager.setLoaded(!1);
					const r$1 = new AbortController();
					let o$1;
					this._spriteRequest = r$1, function(e$2, i$2, a$2, r$2) {
						return t._(this, void 0, void 0, (function* () {
							const o$2 = x(e$2), s$1 = a$2 > 1 ? "@2x" : "", l$1 = {}, c$1 = {};
							for (const { id: e$3, url: a$3 } of o$2) {
								const o$3 = i$2.transformRequest(b(a$3, s$1, ".json"), "SpriteJSON");
								l$1[e$3] = t.j(o$3, r$2);
								const n$1 = i$2.transformRequest(b(a$3, s$1, ".png"), "SpriteImage");
								c$1[e$3] = g$1.getImage(n$1, r$2);
							}
							return yield Promise.all([...Object.values(l$1), ...Object.values(c$1)]), function(e$3, i$3) {
								return t._(this, void 0, void 0, (function* () {
									const t$1 = {};
									for (const a$3 in e$3) {
										t$1[a$3] = {};
										const r$3 = n.getImageCanvasContext((yield i$3[a$3]).data), o$3 = (yield e$3[a$3]).data;
										for (const e$4 in o$3) {
											const { width: i$4, height: s$2, x: n$1, y: l$2, sdf: c$2, pixelRatio: h$1, stretchX: u$1, stretchY: d$1, content: _$2, textFitWidth: p$1, textFitHeight: m$1 } = o$3[e$4];
											t$1[a$3][e$4] = {
												data: null,
												pixelRatio: h$1,
												sdf: c$2,
												stretchX: u$1,
												stretchY: d$1,
												content: _$2,
												textFitWidth: p$1,
												textFitHeight: m$1,
												spriteData: {
													width: i$4,
													height: s$2,
													x: n$1,
													y: l$2,
													context: r$3
												}
											};
										}
									}
									return t$1;
								}));
							}(l$1, c$1);
						}));
					}(e$1, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((e$2) => {
						if (this._spriteRequest = null, e$2) for (const t$1 in e$2) {
							this._spritesImagesIds[t$1] = [];
							const a$2 = this._spritesImagesIds[t$1] ? this._spritesImagesIds[t$1].filter(((t$2) => !(t$2 in e$2))) : [];
							for (const e$3 of a$2) this.imageManager.removeImage(e$3), this._changedImages[e$3] = !0;
							for (const a$3 in e$2[t$1]) {
								const r$2 = "default" === t$1 ? a$3 : `${t$1}:${a$3}`;
								this._spritesImagesIds[t$1].push(r$2), r$2 in this.imageManager.images ? this.imageManager.updateImage(r$2, e$2[t$1][a$3], !1) : this.imageManager.addImage(r$2, e$2[t$1][a$3]), i$1 && (this._changedImages[r$2] = !0);
							}
						}
					})).catch(((e$2) => {
						this._spriteRequest = null, o$1 = e$2, r$1.signal.aborted || this.fire(new t.k(o$1));
					})).finally((() => {
						this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i$1 && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), a$1 && a$1(o$1);
					}));
				}
				_unloadSprite() {
					for (const e$1 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e$1), this._changedImages[e$1] = !0;
					this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				_validateLayer(e$1) {
					const i$1 = this.tileManagers[e$1.source];
					if (!i$1) return;
					const a$1 = e$1.sourceLayer;
					if (!a$1) return;
					const r$1 = i$1.getSource();
					("geojson" === r$1.type || r$1.vectorLayerIds && -1 === r$1.vectorLayerIds.indexOf(a$1)) && this.fire(new t.k(/* @__PURE__ */ new Error(`Source layer "${a$1}" does not exist on source "${r$1.id}" as specified by style layer "${e$1.id}".`)));
				}
				loaded() {
					if (!this._loaded) return !1;
					if (Object.keys(this._updatedSources).length) return !1;
					for (const e$1 in this.tileManagers) if (!this.tileManagers[e$1].loaded()) return !1;
					return !!this.imageManager.isLoaded();
				}
				_serializeByIds(e$1, i$1 = !1) {
					const a$1 = this._serializedAllLayers();
					if (!e$1 || 0 === e$1.length) return Object.values(i$1 ? t.bW(a$1) : a$1);
					const r$1 = [];
					for (const o$1 of e$1) if (a$1[o$1]) {
						const e$2 = i$1 ? t.bW(a$1[o$1]) : a$1[o$1];
						r$1.push(e$2);
					}
					return r$1;
				}
				_serializedAllLayers() {
					let e$1 = this._serializedLayers;
					if (e$1) return e$1;
					e$1 = this._serializedLayers = {};
					const t$1 = Object.keys(this._layers);
					for (const i$1 of t$1) {
						const t$2 = this._layers[i$1];
						"custom" !== t$2.type && (e$1[i$1] = t$2.serialize());
					}
					return e$1;
				}
				hasTransitions() {
					var e$1, t$1, i$1;
					if (null === (e$1 = this.light) || void 0 === e$1 ? void 0 : e$1.hasTransition()) return !0;
					if (null === (t$1 = this.sky) || void 0 === t$1 ? void 0 : t$1.hasTransition()) return !0;
					if (null === (i$1 = this.projection) || void 0 === i$1 ? void 0 : i$1.hasTransition()) return !0;
					for (const e$2 in this.tileManagers) if (this.tileManagers[e$2].hasTransition()) return !0;
					for (const e$2 in this._layers) if (this._layers[e$2].hasTransition()) return !0;
					return !1;
				}
				_checkLoaded() {
					if (!this._loaded) throw new Error("Style is not done loading.");
				}
				update(e$1) {
					if (!this._loaded) return;
					const i$1 = this._changed;
					if (i$1) {
						const t$1 = Object.keys(this._updatedLayers), i$2 = Object.keys(this._removedLayers);
						(t$1.length || i$2.length) && this._updateWorkerLayers(t$1, i$2);
						for (const e$2 in this._updatedSources) {
							const t$2 = this._updatedSources[e$2];
							if ("reload" === t$2) this._reloadSource(e$2);
							else {
								if ("clear" !== t$2) throw new Error(`Invalid action ${t$2}`);
								this._clearSource(e$2);
							}
						}
						this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
						for (const t$2 in this._updatedPaintProps) this._layers[t$2].updateTransitions(e$1);
						this.light.updateTransitions(e$1), this.sky.updateTransitions(e$1), this._resetUpdates();
					}
					const a$1 = {};
					for (const e$2 in this.tileManagers) {
						const t$1 = this.tileManagers[e$2];
						a$1[e$2] = t$1.used, t$1.used = !1;
					}
					for (const t$1 of this._order) {
						const i$2 = this._layers[t$1];
						i$2.recalculate(e$1, this._availableImages), !i$2.isHidden(e$1.zoom) && i$2.source && (this.tileManagers[i$2.source].used = !0);
					}
					for (const e$2 in a$1) {
						const i$2 = this.tileManagers[e$2];
						!!a$1[e$2] != !!i$2.used && i$2.fire(new t.l("data", {
							sourceDataType: "visibility",
							dataType: "source",
							sourceId: e$2
						}));
					}
					this.light.recalculate(e$1), this.sky.recalculate(e$1), this.projection.recalculate(e$1), this.z = e$1.zoom, i$1 && this.fire(new t.l("data", { dataType: "style" }));
				}
				_updateTilesForChangedImages() {
					const e$1 = Object.keys(this._changedImages);
					if (e$1.length) {
						for (const t$1 in this.tileManagers) this.tileManagers[t$1].reloadTilesForDependencies(["icons", "patterns"], e$1);
						this._changedImages = {};
					}
				}
				_updateTilesForChangedGlyphs() {
					if (this._glyphsDidChange) {
						for (const e$1 in this.tileManagers) this.tileManagers[e$1].reloadTilesForDependencies(["glyphs"], [""]);
						this._glyphsDidChange = !1;
					}
				}
				_updateWorkerLayers(e$1, t$1) {
					this.dispatcher.broadcast("UL", {
						layers: this._serializeByIds(e$1, !1),
						removedIds: t$1
					});
				}
				_resetUpdates() {
					this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
				}
				setState(e$1, i$1 = {}) {
					var a$1;
					this._checkLoaded();
					const r$1 = this.serialize();
					if (e$1 = i$1.transformStyle ? i$1.transformStyle(r$1, e$1) : e$1, (null === (a$1 = i$1.validate) || void 0 === a$1 || a$1) && Ai$1(this, t.C(e$1))) return !1;
					(e$1 = t.bW(e$1)).layers = t.bT(e$1.layers);
					const o$1 = t.bX(r$1, e$1), s$1 = this._getOperationsToPerform(o$1);
					if (s$1.unimplemented.length > 0) throw new Error(`Unimplemented: ${s$1.unimplemented.join(", ")}.`);
					if (0 === s$1.operations.length) return !1;
					for (const e$2 of s$1.operations) e$2();
					return this.stylesheet = e$1, this._serializedLayers = null, !0;
				}
				_getOperationsToPerform(e$1) {
					const t$1 = [], i$1 = [];
					for (const a$1 of e$1) switch (a$1.command) {
						case "setCenter":
						case "setZoom":
						case "setBearing":
						case "setPitch":
						case "setRoll": continue;
						case "addLayer":
							t$1.push((() => this.addLayer.apply(this, a$1.args)));
							break;
						case "removeLayer":
							t$1.push((() => this.removeLayer.apply(this, a$1.args)));
							break;
						case "setPaintProperty":
							t$1.push((() => this.setPaintProperty.apply(this, a$1.args)));
							break;
						case "setLayoutProperty":
							t$1.push((() => this.setLayoutProperty.apply(this, a$1.args)));
							break;
						case "setFilter":
							t$1.push((() => this.setFilter.apply(this, a$1.args)));
							break;
						case "addSource":
							t$1.push((() => this.addSource.apply(this, a$1.args)));
							break;
						case "removeSource":
							t$1.push((() => this.removeSource.apply(this, a$1.args)));
							break;
						case "setLayerZoomRange":
							t$1.push((() => this.setLayerZoomRange.apply(this, a$1.args)));
							break;
						case "setLight":
							t$1.push((() => this.setLight.apply(this, a$1.args)));
							break;
						case "setGeoJSONSourceData":
							t$1.push((() => this.setGeoJSONSourceData.apply(this, a$1.args)));
							break;
						case "setGlyphs":
							t$1.push((() => this.setGlyphs.apply(this, a$1.args)));
							break;
						case "setSprite":
							t$1.push((() => this.setSprite.apply(this, a$1.args)));
							break;
						case "setTerrain":
							t$1.push((() => this.map.setTerrain.apply(this, a$1.args)));
							break;
						case "setSky":
							t$1.push((() => this.setSky.apply(this, a$1.args)));
							break;
						case "setProjection":
							this.setProjection.apply(this, a$1.args);
							break;
						case "setGlobalState":
							t$1.push((() => this.setGlobalState.apply(this, a$1.args)));
							break;
						case "setTransition":
							t$1.push((() => {}));
							break;
						default: i$1.push(a$1.command);
					}
					return {
						operations: t$1,
						unimplemented: i$1
					};
				}
				addImage(e$1, i$1) {
					if (this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" already exists.`)));
					this.imageManager.addImage(e$1, i$1), this._afterImageUpdated(e$1);
				}
				updateImage(e$1, t$1) {
					this.imageManager.updateImage(e$1, t$1);
				}
				getImage(e$1) {
					return this.imageManager.getImage(e$1);
				}
				removeImage(e$1) {
					if (!this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" does not exist.`)));
					this.imageManager.removeImage(e$1), this._afterImageUpdated(e$1);
				}
				_afterImageUpdated(e$1) {
					this._availableImages = this.imageManager.listImages(), this._changedImages[e$1] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				listImages() {
					return this._checkLoaded(), this.imageManager.listImages();
				}
				addSource(e$1, i$1, a$1 = {}) {
					if (this._checkLoaded(), void 0 !== this.tileManagers[e$1]) throw new Error(`Source "${e$1}" already exists.`);
					if (!i$1.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i$1).join(", ")}.`);
					if ([
						"vector",
						"raster",
						"geojson",
						"video",
						"image"
					].indexOf(i$1.type) >= 0 && this._validate(t.C.source, `sources.${e$1}`, i$1, null, a$1)) return;
					this.map && this.map._collectResourceTiming && (i$1.collectResourceTiming = !0);
					const r$1 = this.tileManagers[e$1] = new ke$1(e$1, i$1, this.dispatcher);
					r$1.style = this, r$1.setEventedParent(this, (() => ({
						isSourceLoaded: r$1.loaded(),
						source: r$1.serialize(),
						sourceId: e$1
					}))), r$1.onAdd(this.map), this._changed = !0;
				}
				removeSource(e$1) {
					if (this._checkLoaded(), void 0 === this.tileManagers[e$1]) throw new Error("There is no source with this ID");
					for (const i$2 in this._layers) if (this._layers[i$2].source === e$1) return this.fire(new t.k(/* @__PURE__ */ new Error(`Source "${e$1}" cannot be removed while layer "${i$2}" is using it.`)));
					const i$1 = this.tileManagers[e$1];
					delete this.tileManagers[e$1], delete this._updatedSources[e$1], i$1.fire(new t.l("data", {
						sourceDataType: "metadata",
						dataType: "source",
						sourceId: e$1
					})), i$1.setEventedParent(null), i$1.onRemove(this.map), this._changed = !0;
				}
				setGeoJSONSourceData(e$1, t$1) {
					if (this._checkLoaded(), void 0 === this.tileManagers[e$1]) throw new Error(`There is no source with this ID=${e$1}`);
					const i$1 = this.tileManagers[e$1].getSource();
					if ("geojson" !== i$1.type) throw new Error(`geojsonSource.type is ${i$1.type}, which is !== 'geojson`);
					i$1.setData(t$1), this._changed = !0;
				}
				getSource(e$1) {
					return this.tileManagers[e$1] && this.tileManagers[e$1].getSource();
				}
				addLayer(e$1, i$1, a$1 = {}) {
					this._checkLoaded();
					const r$1 = e$1.id;
					if (this.getLayer(r$1)) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Layer "${r$1}" already exists on this map.`)));
					let o$1;
					if ("custom" === e$1.type) {
						if (Ai$1(this, t.bY(e$1))) return;
						o$1 = t.bU(e$1, this._globalState);
					} else {
						if ("source" in e$1 && "object" == typeof e$1.source && (this.addSource(r$1, e$1.source), e$1 = t.bW(e$1), e$1 = t.e(e$1, { source: r$1 })), this._validate(t.C.layer, `layers.${r$1}`, e$1, { arrayIndex: -1 }, a$1)) return;
						o$1 = t.bU(e$1, this._globalState), this._validateLayer(o$1), o$1.setEventedParent(this, { layer: { id: r$1 } });
					}
					const s$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					if (i$1 && -1 === s$1) this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot add layer "${r$1}" before non-existing layer "${i$1}".`)));
					else {
						if (this._order.splice(s$1, 0, r$1), this._layerOrderChanged = !0, this._layers[r$1] = o$1, this._removedLayers[r$1] && o$1.source && "custom" !== o$1.type) {
							const e$2 = this._removedLayers[r$1];
							delete this._removedLayers[r$1], e$2.type !== o$1.type ? this._updatedSources[o$1.source] = "clear" : (this._updatedSources[o$1.source] = "reload", this.tileManagers[o$1.source].pause());
						}
						this._updateLayer(o$1), o$1.onAdd && o$1.onAdd(this.map);
					}
				}
				moveLayer(e$1, i$1) {
					if (this._checkLoaded(), this._changed = !0, !this._layers[e$1]) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$1}' does not exist in the map's style and cannot be moved.`)));
					if (e$1 === i$1) return;
					const a$1 = this._order.indexOf(e$1);
					this._order.splice(a$1, 1);
					const r$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					i$1 && -1 === r$1 ? this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot move layer "${e$1}" before non-existing layer "${i$1}".`))) : (this._order.splice(r$1, 0, e$1), this._layerOrderChanged = !0);
				}
				removeLayer(e$1) {
					this._checkLoaded();
					const i$1 = this._layers[e$1];
					if (!i$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot remove non-existing layer "${e$1}".`)));
					i$1.setEventedParent(null);
					const a$1 = this._order.indexOf(e$1);
					this._order.splice(a$1, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e$1] = i$1, delete this._layers[e$1], this._serializedLayers && delete this._serializedLayers[e$1], delete this._updatedLayers[e$1], delete this._updatedPaintProps[e$1], i$1.onRemove && i$1.onRemove(this.map);
				}
				getLayer(e$1) {
					return this._layers[e$1];
				}
				getLayersOrder() {
					return [...this._order];
				}
				hasLayer(e$1) {
					return e$1 in this._layers;
				}
				setLayerZoomRange(e$1, i$1, a$1) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					r$1 ? r$1.minzoom === i$1 && r$1.maxzoom === a$1 || (null != i$1 && (r$1.minzoom = i$1), null != a$1 && (r$1.maxzoom = a$1), this._updateLayer(r$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot set the zoom range of non-existing layer "${e$1}".`)));
				}
				setFilter(e$1, i$1, a$1 = {}) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					if (r$1) {
						if (!t.bS(r$1.filter, i$1)) return null == i$1 ? (r$1.setFilter(void 0), void this._updateLayer(r$1)) : void (this._validate(t.C.filter, `layers.${r$1.id}.filter`, i$1, null, a$1) || (r$1.setFilter(t.bW(i$1)), this._updateLayer(r$1)));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot filter non-existing layer "${e$1}".`)));
				}
				getFilter(e$1) {
					return t.bW(this.getLayer(e$1).filter);
				}
				setLayoutProperty(e$1, i$1, a$1, r$1 = {}) {
					this._checkLoaded();
					const o$1 = this.getLayer(e$1);
					o$1 ? t.bS(o$1.getLayoutProperty(i$1), a$1) || (o$1.setLayoutProperty(i$1, a$1, r$1), this._updateLayer(o$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				getLayoutProperty(e$1, i$1) {
					const a$1 = this.getLayer(e$1);
					if (a$1) return a$1.getLayoutProperty(i$1);
					this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot get style of non-existing layer "${e$1}".`)));
				}
				setPaintProperty(e$1, i$1, a$1, r$1 = {}) {
					this._checkLoaded();
					const o$1 = this.getLayer(e$1);
					o$1 ? t.bS(o$1.getPaintProperty(i$1), a$1) || this._updatePaintProperty(o$1, i$1, a$1, r$1) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				_updatePaintProperty(e$1, i$1, a$1, r$1 = {}) {
					e$1.setPaintProperty(i$1, a$1, r$1) && this._updateLayer(e$1), t.bV(e$1) && "raster-fade-duration" === i$1 && this.tileManagers[e$1.source].setRasterFadeDuration(a$1), this._changed = !0, this._updatedPaintProps[e$1.id] = !0, this._serializedLayers = null;
				}
				getPaintProperty(e$1, t$1) {
					return this.getLayer(e$1).getPaintProperty(t$1);
				}
				setFeatureState(e$1, i$1) {
					this._checkLoaded();
					const a$1 = e$1.source, r$1 = e$1.sourceLayer, o$1 = this.tileManagers[a$1];
					if (void 0 === o$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${a$1}' does not exist in the map's style.`)));
					const s$1 = o$1.getSource().type;
					"geojson" === s$1 && r$1 ? this.fire(new t.k(/* @__PURE__ */ new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s$1 || r$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), o$1.setFeatureState(r$1, e$1.id, i$1)) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				removeFeatureState(e$1, i$1) {
					this._checkLoaded();
					const a$1 = e$1.source, r$1 = this.tileManagers[a$1];
					if (void 0 === r$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${a$1}' does not exist in the map's style.`)));
					const o$1 = r$1.getSource().type, s$1 = "vector" === o$1 ? e$1.sourceLayer : void 0;
					"vector" !== o$1 || s$1 ? i$1 && "string" != typeof e$1.id && "number" != typeof e$1.id ? this.fire(new t.k(/* @__PURE__ */ new Error("A feature id is required to remove its specific state property."))) : r$1.removeFeatureState(s$1, e$1.id, i$1) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				getFeatureState(e$1) {
					this._checkLoaded();
					const i$1 = e$1.source, a$1 = e$1.sourceLayer, r$1 = this.tileManagers[i$1];
					if (void 0 !== r$1) return "vector" !== r$1.getSource().type || a$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), r$1.getFeatureState(a$1, e$1.id)) : void this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
					this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${i$1}' does not exist in the map's style.`)));
				}
				getTransition() {
					return t.e({
						duration: 300,
						delay: 0
					}, this.stylesheet && this.stylesheet.transition);
				}
				serialize() {
					if (!this._loaded) return;
					const e$1 = t.bZ(this.tileManagers, ((e$2) => e$2.serialize())), i$1 = this._serializeByIds(this._order, !0), a$1 = this.map.getTerrain() || void 0, r$1 = this.stylesheet;
					return t.b_({
						version: r$1.version,
						name: r$1.name,
						metadata: r$1.metadata,
						light: r$1.light,
						sky: r$1.sky,
						center: r$1.center,
						zoom: r$1.zoom,
						bearing: r$1.bearing,
						pitch: r$1.pitch,
						sprite: r$1.sprite,
						glyphs: r$1.glyphs,
						transition: r$1.transition,
						projection: r$1.projection,
						sources: e$1,
						layers: i$1,
						terrain: a$1
					}, ((e$2) => void 0 !== e$2));
				}
				_updateLayer(e$1) {
					this._updatedLayers[e$1.id] = !0, e$1.source && !this._updatedSources[e$1.source] && "raster" !== this.tileManagers[e$1.source].getSource().type && (this._updatedSources[e$1.source] = "reload", this.tileManagers[e$1.source].pause()), this._serializedLayers = null, this._changed = !0;
				}
				_flattenAndSortRenderedFeatures(e$1) {
					const t$1 = (e$2) => "fill-extrusion" === this._layers[e$2].type, i$1 = {}, a$1 = [];
					for (let r$2 = this._order.length - 1; r$2 >= 0; r$2--) {
						const o$1 = this._order[r$2];
						if (t$1(o$1)) {
							i$1[o$1] = r$2;
							for (const t$2 of e$1) {
								const e$2 = t$2[o$1];
								if (e$2) for (const t$3 of e$2) a$1.push(t$3);
							}
						}
					}
					a$1.sort(((e$2, t$2) => t$2.intersectionZ - e$2.intersectionZ));
					const r$1 = [];
					for (let o$1 = this._order.length - 1; o$1 >= 0; o$1--) {
						const s$1 = this._order[o$1];
						if (t$1(s$1)) for (let e$2 = a$1.length - 1; e$2 >= 0; e$2--) {
							const t$2 = a$1[e$2].feature;
							if (i$1[t$2.layer.id] < o$1) break;
							r$1.push(t$2), a$1.pop();
						}
						else for (const t$2 of e$1) {
							const e$2 = t$2[s$1];
							if (e$2) for (const t$3 of e$2) r$1.push(t$3.feature);
						}
					}
					return r$1;
				}
				queryRenderedFeatures(e$1, i$1, a$1) {
					i$1 && i$1.filter && this._validate(t.C.filter, "queryRenderedFeatures.filter", i$1.filter, null, i$1);
					const r$1 = {};
					if (i$1 && i$1.layers) {
						if (!(Array.isArray(i$1.layers) || i$1.layers instanceof Set)) return this.fire(new t.k(/* @__PURE__ */ new Error("parameters.layers must be an Array or a Set of strings"))), [];
						for (const e$2 of i$1.layers) {
							const i$2 = this._layers[e$2];
							if (!i$2) return this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$2}' does not exist in the map's style and cannot be queried for features.`))), [];
							r$1[i$2.source] = !0;
						}
					}
					const o$1 = [];
					i$1.availableImages = this._availableImages;
					const s$1 = this._serializedAllLayers(), n$1 = i$1.layers instanceof Set ? i$1.layers : Array.isArray(i$1.layers) ? new Set(i$1.layers) : null, l$1 = Object.assign(Object.assign({}, i$1), {
						layers: n$1,
						globalState: this._globalState
					});
					for (const t$1 in this.tileManagers) i$1.layers && !r$1[t$1] || o$1.push(U$1(this.tileManagers[t$1], this._layers, s$1, e$1, l$1, a$1, this.map.terrain ? (e$2, t$2, i$2) => this.map.terrain.getElevation(e$2, t$2, i$2) : void 0));
					return this.placement && o$1.push(function(e$2, t$1, i$2, a$2, r$2, o$2, s$2) {
						const n$2 = {}, l$2 = o$2.queryRenderedSymbols(a$2), c$1 = [];
						for (const e$3 of Object.keys(l$2).map(Number)) c$1.push(s$2[e$3]);
						c$1.sort(V$1);
						for (const i$3 of c$1) {
							const a$3 = i$3.featureIndex.lookupSymbolFeatures(l$2[i$3.bucketInstanceId], t$1, i$3.bucketIndex, i$3.sourceLayerIndex, {
								filterSpec: r$2.filter,
								globalState: r$2.globalState
							}, r$2.layers, r$2.availableImages, e$2);
							for (const e$3 in a$3) {
								const t$2 = n$2[e$3] = n$2[e$3] || [], r$3 = a$3[e$3];
								r$3.sort(((e$4, t$3) => {
									const a$4 = i$3.featureSortOrder;
									if (a$4) {
										const i$4 = a$4.indexOf(e$4.featureIndex);
										return a$4.indexOf(t$3.featureIndex) - i$4;
									}
									return t$3.featureIndex - e$4.featureIndex;
								}));
								for (const e$4 of r$3) t$2.push(e$4);
							}
						}
						return function(e$3, t$2, i$3) {
							for (const a$3 in e$3) for (const r$3 of e$3[a$3]) q$1(r$3, i$3[t$2[a$3].source]);
							return e$3;
						}(n$2, e$2, i$2);
					}(this._layers, s$1, this.tileManagers, e$1, l$1, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o$1);
				}
				querySourceFeatures(e$1, i$1) {
					null != i$1 && i$1.filter && this._validate(t.C.filter, "querySourceFeatures.filter", i$1.filter, null, i$1);
					const a$1 = this.tileManagers[e$1];
					return a$1 ? function(e$2, t$1) {
						const i$2 = e$2.getRenderableIds().map(((t$2) => e$2.getTileByID(t$2))), a$2 = [], r$1 = {};
						for (let e$3 = 0; e$3 < i$2.length; e$3++) {
							const o$1 = i$2[e$3], s$1 = o$1.tileID.canonical.key;
							r$1[s$1] || (r$1[s$1] = !0, o$1.querySourceFeatures(a$2, t$1));
						}
						return a$2;
					}(a$1, i$1 ? Object.assign(Object.assign({}, i$1), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
				}
				getLight() {
					return this.light.getLight();
				}
				setLight(e$1, i$1 = {}) {
					this._checkLoaded();
					const a$1 = this.light.getLight();
					let r$1 = !1;
					for (const i$2 in e$1) if (!t.bS(e$1[i$2], a$1[i$2])) {
						r$1 = !0;
						break;
					}
					if (!r$1) return;
					const o$1 = {
						now: c(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.light.setLight(e$1, i$1), this.light.updateTransitions(o$1);
				}
				getProjection() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.projection;
				}
				setProjection(e$1) {
					if (this._checkLoaded(), this.projection) {
						if (this.projection.name === e$1.type) return;
						this.projection.destroy(), delete this.projection;
					}
					this.stylesheet.projection = e$1, this._setProjectionInternal(e$1.type);
				}
				getSky() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.sky;
				}
				setSky(e$1, i$1 = {}) {
					this._checkLoaded();
					const a$1 = this.getSky();
					let r$1 = !1;
					if (!e$1 && !a$1) return;
					if (e$1 && !a$1) r$1 = !0;
					else if (!e$1 && a$1) r$1 = !0;
					else for (const i$2 in e$1) if (!t.bS(e$1[i$2], a$1[i$2])) {
						r$1 = !0;
						break;
					}
					if (!r$1) return;
					const o$1 = {
						now: c(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.stylesheet.sky = e$1, this.sky.setSky(e$1, i$1), this.sky.updateTransitions(o$1);
				}
				_setProjectionInternal(e$1) {
					const i$1 = function(e$2, i$2) {
						const a$1 = { constrainOverride: i$2 };
						if (Array.isArray(e$2)) {
							const t$1 = new di({ type: e$2 });
							return {
								projection: t$1,
								transform: new Ri$1(a$1),
								cameraHelper: new Di$1(t$1)
							};
						}
						switch (e$2) {
							case "mercator": return {
								projection: new jt$1(),
								transform: new $t$1(a$1),
								cameraHelper: new Yt$1()
							};
							case "globe": {
								const e$3 = new di({ type: [
									"interpolate",
									["linear"],
									["zoom"],
									11,
									"vertical-perspective",
									12,
									"mercator"
								] });
								return {
									projection: e$3,
									transform: new Ri$1(a$1),
									cameraHelper: new Di$1(e$3)
								};
							}
							case "vertical-perspective": return {
								projection: new hi(),
								transform: new Si(a$1),
								cameraHelper: new zi$1()
							};
							default: return t.w(`Unknown projection name: ${e$2}. Falling back to mercator projection.`), {
								projection: new jt$1(),
								transform: new $t$1(a$1),
								cameraHelper: new Yt$1()
							};
						}
					}(e$1, this.map.transformConstrain);
					this.projection = i$1.projection, this.map.migrateProjection(i$1.transform, i$1.cameraHelper);
					for (const e$2 in this.tileManagers) this.tileManagers[e$2].reload();
				}
				_validate(e$1, i$1, a$1, r$1, o$1 = {}) {
					return (!o$1 || !1 !== o$1.validate) && Ai$1(this, e$1.call(t.C, t.e({
						key: i$1,
						style: this.serialize(),
						value: a$1,
						styleSpec: t.u
					}, r$1)));
				}
				_remove(e$1 = !0) {
					this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ce$1().off(se$1, this._rtlPluginLoaded);
					for (const e$2 in this._layers) this._layers[e$2].setEventedParent(null);
					for (const e$2 in this.tileManagers) {
						const t$1 = this.tileManagers[e$2];
						t$1.setEventedParent(null), t$1.onRemove(this.map);
					}
					this.imageManager.setEventedParent(null), this.setEventedParent(null), e$1 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e$1);
				}
				_clearSource(e$1) {
					this.tileManagers[e$1].clearTiles();
				}
				_reloadSource(e$1) {
					this.tileManagers[e$1].resume(), this.tileManagers[e$1].reload();
				}
				_updateSources(e$1) {
					for (const t$1 in this.tileManagers) this.tileManagers[t$1].update(e$1, this.map.terrain);
				}
				_generateCollisionBoxes() {
					for (const e$1 in this.tileManagers) this._reloadSource(e$1);
				}
				_updatePlacement(e$1, t$1, i$1, a$1, r$1 = !1) {
					let o$1 = !1, s$1 = !1;
					const n$1 = {};
					for (const t$2 of this._order) {
						const i$2 = this._layers[t$2];
						if ("symbol" !== i$2.type) continue;
						if (!n$1[i$2.source]) {
							const e$2 = this.tileManagers[i$2.source];
							n$1[i$2.source] = e$2.getRenderableIds(!0).map(((t$3) => e$2.getTileByID(t$3))).sort(((e$3, t$3) => t$3.tileID.overscaledZ - e$3.tileID.overscaledZ || (e$3.tileID.isLessThan(t$3.tileID) ? -1 : 1)));
						}
						const a$2 = this.crossTileSymbolIndex.addLayer(i$2, n$1[i$2.source], e$1.center.lng);
						o$1 = o$1 || a$2;
					}
					if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r$1 = r$1 || this._layerOrderChanged || 0 === i$1) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(c(), e$1.zoom)) && (this.pauseablePlacement = new Ct$1(e$1, this.map.terrain, this._order, r$1, t$1, i$1, a$1, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, n$1), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(c()), s$1 = !0), o$1 && this.pauseablePlacement.placement.setStale()), s$1 || o$1) for (const e$2 of this._order) {
						const t$2 = this._layers[e$2];
						"symbol" === t$2.type && this.placement.updateLayerOpacities(t$2, n$1[t$2.source]);
					}
					return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(c());
				}
				_releaseSymbolFadeTiles() {
					for (const e$1 in this.tileManagers) this.tileManagers[e$1].releaseSymbolFadeTiles();
				}
				getImages(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.imageManager.getImages(i$1.icons);
						this._updateTilesForChangedImages();
						const t$1 = this.tileManagers[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, i$1.icons), e$2;
					}));
				}
				getGlyphs(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.glyphManager.getGlyphs(i$1.stacks), t$1 = this.tileManagers[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, [""]), e$2;
					}));
				}
				getGlyphsUrl() {
					return this.stylesheet.glyphs || null;
				}
				setGlyphs(e$1, i$1 = {}) {
					this._checkLoaded(), e$1 && this._validate(t.C.glyphs, "glyphs", e$1, null, i$1) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e$1, this.glyphManager.entries = {}, this.glyphManager.setURL(e$1));
				}
				getDashes(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = {};
						for (const [t$1, a$1] of Object.entries(i$1.dashes)) e$2[t$1] = this.lineAtlas.getDash(a$1.dasharray, a$1.round);
						return e$2;
					}));
				}
				addSprite(e$1, i$1, a$1 = {}, r$1) {
					this._checkLoaded();
					const o$1 = [{
						id: e$1,
						url: i$1
					}], s$1 = [...x(this.stylesheet.sprite), ...o$1];
					this._validate(t.C.sprite, "sprite", s$1, null, a$1) || (this.stylesheet.sprite = s$1, this._loadSprite(o$1, !0, r$1));
				}
				removeSprite(e$1) {
					this._checkLoaded();
					const i$1 = x(this.stylesheet.sprite);
					if (i$1.find(((t$1) => t$1.id === e$1))) {
						if (this._spritesImagesIds[e$1]) for (const t$1 of this._spritesImagesIds[e$1]) this.imageManager.removeImage(t$1), this._changedImages[t$1] = !0;
						i$1.splice(i$1.findIndex(((t$1) => t$1.id === e$1)), 1), this.stylesheet.sprite = i$1.length > 0 ? i$1 : void 0, delete this._spritesImagesIds[e$1], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Sprite "${e$1}" doesn't exists on this map.`)));
				}
				getSprite() {
					return x(this.stylesheet.sprite);
				}
				setSprite(e$1, i$1 = {}, a$1) {
					this._checkLoaded(), e$1 && this._validate(t.C.sprite, "sprite", e$1, null, i$1) || (this.stylesheet.sprite = e$1, e$1 ? this._loadSprite(e$1, !0, a$1) : (this._unloadSprite(), a$1 && a$1(null)));
				}
				destroy() {
					this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
					for (const e$1 in this.tileManagers) {
						const t$1 = this.tileManagers[e$1];
						t$1.setEventedParent(null), t$1.onRemove(this.map);
					}
					this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
					for (const e$1 in this._layers) {
						const t$1 = this._layers[e$1];
						t$1.setEventedParent(null), t$1.onRemove && t$1.onRemove(this.map);
					}
					this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(!0), this._listeners = {}, this._oneTimeListeners = {};
				}
			}
			var Fi$1 = t.aV([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}, {
				name: "a_texture_pos",
				type: "Int16",
				components: 2
			}]);
			class Bi$1 {
				constructor() {
					this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
				}
				bind(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
					this.context = e$1;
					let c$1 = this.boundPaintVertexBuffers.length !== a$1.length;
					for (let e$2 = 0; !c$1 && e$2 < a$1.length; e$2++) this.boundPaintVertexBuffers[e$2] !== a$1[e$2] && (c$1 = !0);
					!this.vao || this.boundProgram !== t$1 || this.boundLayoutVertexBuffer !== i$1 || c$1 || this.boundIndexBuffer !== r$1 || this.boundVertexOffset !== o$1 || this.boundDynamicVertexBuffer !== s$1 || this.boundDynamicVertexBuffer2 !== n$1 || this.boundDynamicVertexBuffer3 !== l$1 ? this.freshBind(t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) : (e$1.bindVertexArray.set(this.vao), s$1 && s$1.bind(), r$1 && r$1.dynamicDraw && r$1.bind(), n$1 && n$1.bind(), l$1 && l$1.bind());
				}
				freshBind(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1) {
					const l$1 = e$1.numAttributes, c$1 = this.context, h$1 = c$1.gl;
					this.vao && this.destroy(), this.vao = c$1.createVertexArray(), c$1.bindVertexArray.set(this.vao), this.boundProgram = e$1, this.boundLayoutVertexBuffer = t$1, this.boundPaintVertexBuffers = i$1, this.boundIndexBuffer = a$1, this.boundVertexOffset = r$1, this.boundDynamicVertexBuffer = o$1, this.boundDynamicVertexBuffer2 = s$1, this.boundDynamicVertexBuffer3 = n$1, t$1.enableAttributes(h$1, e$1);
					for (const t$2 of i$1) t$2.enableAttributes(h$1, e$1);
					o$1 && o$1.enableAttributes(h$1, e$1), s$1 && s$1.enableAttributes(h$1, e$1), n$1 && n$1.enableAttributes(h$1, e$1), t$1.bind(), t$1.setVertexAttribPointers(h$1, e$1, r$1);
					for (const t$2 of i$1) t$2.bind(), t$2.setVertexAttribPointers(h$1, e$1, r$1);
					o$1 && (o$1.bind(), o$1.setVertexAttribPointers(h$1, e$1, r$1)), a$1 && a$1.bind(), s$1 && (s$1.bind(), s$1.setVertexAttribPointers(h$1, e$1, r$1)), n$1 && (n$1.bind(), n$1.setVertexAttribPointers(h$1, e$1, r$1)), c$1.currentNumAttributes = l$1;
				}
				destroy() {
					this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
				}
			}
			const Oi$1 = (e$1, i$1, a$1, r$1, o$1) => ({
				u_texture: 0,
				u_ele_delta: e$1,
				u_fog_matrix: i$1,
				u_fog_color: a$1 ? a$1.properties.get("fog-color") : t.bq.white,
				u_fog_ground_blend: a$1 ? a$1.properties.get("fog-ground-blend") : 1,
				u_fog_ground_blend_opacity: o$1 ? 0 : a$1 ? a$1.calculateFogBlendOpacity(r$1) : 0,
				u_horizon_color: a$1 ? a$1.properties.get("horizon-color") : t.bq.white,
				u_horizon_fog_blend: a$1 ? a$1.properties.get("horizon-fog-blend") : 1,
				u_is_globe_mode: o$1 ? 1 : 0
			}), ji$1 = {
				mainMatrix: "u_projection_matrix",
				tileMercatorCoords: "u_projection_tile_mercator_coords",
				clippingPlane: "u_projection_clipping_plane",
				projectionTransition: "u_projection_transition",
				fallbackMatrix: "u_projection_fallback_matrix"
			};
			function Ni$1(e$1) {
				const t$1 = [];
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					if (null === e$1[i$1]) continue;
					const a$1 = e$1[i$1].split(" ");
					t$1.push(a$1.pop());
				}
				return t$1;
			}
			class Zi$1 {
				constructor(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1 = []) {
					const h$1 = e$1.gl;
					this.program = h$1.createProgram();
					const u$1 = Ni$1(i$1.staticAttributes), d$1 = a$1 ? a$1.getBinderAttributes() : [], _$2 = u$1.concat(d$1), p$1 = At$1.prelude.staticUniforms ? Ni$1(At$1.prelude.staticUniforms) : [], m$1 = n$1.staticUniforms ? Ni$1(n$1.staticUniforms) : [], f$1 = i$1.staticUniforms ? Ni$1(i$1.staticUniforms) : [], g$2 = a$1 ? a$1.getBinderUniforms() : [], v$1 = p$1.concat(m$1).concat(f$1).concat(g$2), x$1 = [];
					for (const e$2 of v$1) x$1.indexOf(e$2) < 0 && x$1.push(e$2);
					const b$1 = a$1 ? a$1.defines() : [];
					oi$1(h$1) && b$1.unshift("#version 300 es"), o$1 && b$1.push("#define OVERDRAW_INSPECTOR;"), s$1 && b$1.push("#define TERRAIN3D;"), l$1 && b$1.push(l$1), c$1 && b$1.push(...c$1);
					let y$1 = b$1.concat(At$1.prelude.fragmentSource, n$1.fragmentSource, i$1.fragmentSource).join("\n"), w$2 = b$1.concat(At$1.prelude.vertexSource, n$1.vertexSource, i$1.vertexSource).join("\n");
					oi$1(h$1) || (y$1 = function(e$2) {
						return e$2.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
					}(y$1), w$2 = function(e$2) {
						return e$2.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
					}(w$2));
					const T$1 = h$1.createShader(h$1.FRAGMENT_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(T$1, y$1), h$1.compileShader(T$1), !h$1.getShaderParameter(T$1, h$1.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${h$1.getShaderInfoLog(T$1)}`);
					h$1.attachShader(this.program, T$1);
					const P$2 = h$1.createShader(h$1.VERTEX_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(P$2, w$2), h$1.compileShader(P$2), !h$1.getShaderParameter(P$2, h$1.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${h$1.getShaderInfoLog(P$2)}`);
					h$1.attachShader(this.program, P$2), this.attributes = {};
					const I$2 = {};
					this.numAttributes = _$2.length;
					for (let e$2 = 0; e$2 < this.numAttributes; e$2++) _$2[e$2] && (h$1.bindAttribLocation(this.program, e$2, _$2[e$2]), this.attributes[_$2[e$2]] = e$2);
					if (h$1.linkProgram(this.program), !h$1.getProgramParameter(this.program, h$1.LINK_STATUS)) throw new Error(`Program failed to link: ${h$1.getProgramInfoLog(this.program)}`);
					h$1.deleteShader(P$2), h$1.deleteShader(T$1);
					for (let e$2 = 0; e$2 < x$1.length; e$2++) {
						const t$1 = x$1[e$2];
						if (t$1 && !I$2[t$1]) {
							const e$3 = h$1.getUniformLocation(this.program, t$1);
							e$3 && (I$2[t$1] = e$3);
						}
					}
					this.fixedUniforms = r$1(e$1, I$2), this.terrainUniforms = ((e$2, i$2) => ({
						u_depth: new t.b$(e$2, i$2.u_depth),
						u_terrain: new t.b$(e$2, i$2.u_terrain),
						u_terrain_dim: new t.br(e$2, i$2.u_terrain_dim),
						u_terrain_matrix: new t.c1(e$2, i$2.u_terrain_matrix),
						u_terrain_unpack: new t.c2(e$2, i$2.u_terrain_unpack),
						u_terrain_exaggeration: new t.br(e$2, i$2.u_terrain_exaggeration)
					}))(e$1, I$2), this.projectionUniforms = ((e$2, i$2) => ({
						u_projection_matrix: new t.c1(e$2, i$2.u_projection_matrix),
						u_projection_tile_mercator_coords: new t.c2(e$2, i$2.u_projection_tile_mercator_coords),
						u_projection_clipping_plane: new t.c2(e$2, i$2.u_projection_clipping_plane),
						u_projection_transition: new t.br(e$2, i$2.u_projection_transition),
						u_projection_fallback_matrix: new t.c1(e$2, i$2.u_projection_fallback_matrix)
					}))(e$1, I$2), this.binderUniforms = a$1 ? a$1.getUniforms(e$1, I$2) : [];
				}
				draw(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1, m$1, f$1, g$2, v$1) {
					const x$1 = e$1.gl;
					if (this.failedToCreate) return;
					if (e$1.program.set(this.program), e$1.setDepthMode(i$1), e$1.setStencilMode(a$1), e$1.setColorMode(r$1), e$1.setCullFace(o$1), n$1) {
						e$1.activeTexture.set(x$1.TEXTURE2), x$1.bindTexture(x$1.TEXTURE_2D, n$1.depthTexture), e$1.activeTexture.set(x$1.TEXTURE3), x$1.bindTexture(x$1.TEXTURE_2D, n$1.texture);
						for (const e$2 in this.terrainUniforms) this.terrainUniforms[e$2].set(n$1[e$2]);
					}
					if (l$1) for (const e$2 in l$1) this.projectionUniforms[ji$1[e$2]].set(l$1[e$2]);
					if (s$1) for (const e$2 in this.fixedUniforms) this.fixedUniforms[e$2].set(s$1[e$2]);
					m$1 && m$1.setUniforms(e$1, this.binderUniforms, _$2, { zoom: p$1 });
					let b$1 = 0;
					switch (t$1) {
						case x$1.LINES:
							b$1 = 2;
							break;
						case x$1.TRIANGLES:
							b$1 = 3;
							break;
						case x$1.LINE_STRIP: b$1 = 1;
					}
					for (const i$2 of d$1.get()) {
						const a$2 = i$2.vaos || (i$2.vaos = {});
						(a$2[c$1] || (a$2[c$1] = new Bi$1())).bind(e$1, this, h$1, m$1 ? m$1.getPaintVertexBuffers() : [], u$1, i$2.vertexOffset, f$1, g$2, v$1), x$1.drawElements(t$1, i$2.primitiveLength * b$1, x$1.UNSIGNED_SHORT, i$2.primitiveOffset * b$1 * 2);
					}
				}
			}
			function Gi$1(e$1, i$1, a$1) {
				const r$1 = 1 / t.aO(a$1, 1, i$1.transform.tileZoom), o$1 = Math.pow(2, a$1.tileID.overscaledZ), s$1 = a$1.tileSize * Math.pow(2, i$1.transform.tileZoom) / o$1, n$1 = s$1 * (a$1.tileID.canonical.x + a$1.tileID.wrap * o$1), l$1 = s$1 * a$1.tileID.canonical.y;
				return {
					u_image: 0,
					u_texsize: a$1.imageAtlasTexture.size,
					u_scale: [
						r$1,
						e$1.fromScale,
						e$1.toScale
					],
					u_fade: e$1.t,
					u_pixel_coord_upper: [n$1 >> 16, l$1 >> 16],
					u_pixel_coord_lower: [65535 & n$1, 65535 & l$1]
				};
			}
			const Ui$1 = (e$1, i$1, a$1, r$1) => {
				const o$1 = e$1.style.light, s$1 = o$1.properties.get("position"), n$1 = [
					s$1.x,
					s$1.y,
					s$1.z
				], l$1 = t.c5();
				"viewport" === o$1.properties.get("anchor") && t.c6(l$1, e$1.transform.bearingInRadians), t.c7(n$1, n$1, l$1);
				const c$1 = e$1.transform.transformLightDirection(n$1), h$1 = o$1.properties.get("color");
				return {
					u_lightpos: n$1,
					u_lightpos_globe: c$1,
					u_lightintensity: o$1.properties.get("intensity"),
					u_lightcolor: [
						h$1.r,
						h$1.g,
						h$1.b
					],
					u_vertical_gradient: +i$1,
					u_opacity: a$1,
					u_fill_translate: r$1
				};
			}, Vi$1 = (e$1, i$1, a$1, r$1, o$1, s$1, n$1) => t.e(Ui$1(e$1, i$1, a$1, r$1), Gi$1(s$1, e$1, n$1), { u_height_factor: -Math.pow(2, o$1.overscaledZ) / n$1.tileSize / 8 }), qi$1 = (e$1, i$1, a$1, r$1) => t.e(Gi$1(i$1, e$1, a$1), { u_fill_translate: r$1 }), Wi$1 = (e$1, t$1) => ({
				u_world: e$1,
				u_fill_translate: t$1
			}), $i$1 = (e$1, i$1, a$1, r$1, o$1) => t.e(qi$1(e$1, i$1, a$1, o$1), { u_world: r$1 }), Hi$1 = (e$1, i$1, a$1, r$1, o$1) => {
				const s$1 = e$1.transform;
				let n$1, l$1, c$1 = 0;
				if ("map" === a$1.paint.get("circle-pitch-alignment")) {
					const e$2 = t.aO(i$1, 1, s$1.zoom);
					n$1 = !0, l$1 = [e$2, e$2], c$1 = e$2 / (t.a5 * Math.pow(2, i$1.tileID.overscaledZ)) * 2 * Math.PI * o$1;
				} else n$1 = !1, l$1 = s$1.pixelsToGLUnits;
				return {
					u_camera_to_center_distance: s$1.cameraToCenterDistance,
					u_scale_with_map: +("map" === a$1.paint.get("circle-pitch-scale")),
					u_pitch_with_map: +n$1,
					u_device_pixel_ratio: e$1.pixelRatio,
					u_extrude_scale: l$1,
					u_globe_extrude_scale: c$1,
					u_translate: r$1
				};
			}, Xi$1 = (e$1) => ({ u_pixel_extrude_scale: [1 / e$1.width, 1 / e$1.height] }), Ki$1 = (e$1) => ({ u_viewport_size: [e$1.width, e$1.height] }), Yi$1 = (e$1, t$1 = 1) => ({
				u_color: e$1,
				u_overlay: 0,
				u_overlay_scale: t$1
			}), Qi$1 = (e$1, i$1, a$1, r$1) => {
				const o$1 = t.aO(e$1, 1, i$1) / (t.a5 * Math.pow(2, e$1.tileID.overscaledZ)) * 2 * Math.PI * r$1;
				return {
					u_extrude_scale: t.aO(e$1, 1, i$1),
					u_intensity: a$1,
					u_globe_extrude_scale: o$1
				};
			}, Ji$1 = (e$1, i$1, a$1, r$1) => {
				const o$1 = t.N();
				t.c8(o$1, 0, e$1.width, e$1.height, 0, 0, 1);
				const s$1 = e$1.context.gl;
				return {
					u_matrix: o$1,
					u_world: [s$1.drawingBufferWidth, s$1.drawingBufferHeight],
					u_image: a$1,
					u_color_ramp: r$1,
					u_opacity: i$1.paint.get("heatmap-opacity")
				};
			}, ea$1 = (e$1, t$1, i$1) => {
				const a$1 = i$1.paint.get("hillshade-accent-color");
				let r$1;
				switch (i$1.paint.get("hillshade-method")) {
					case "basic":
						r$1 = 4;
						break;
					case "combined":
						r$1 = 1;
						break;
					case "igor":
						r$1 = 2;
						break;
					case "multidirectional":
						r$1 = 3;
						break;
					default: r$1 = 0;
				}
				const o$1 = i$1.getIlluminationProperties();
				for (let t$2 = 0; t$2 < o$1.directionRadians.length; t$2++) "viewport" === i$1.paint.get("hillshade-illumination-anchor") && (o$1.directionRadians[t$2] += e$1.transform.bearingInRadians);
				return {
					u_image: 0,
					u_latrange: ia$1(0, t$1.tileID),
					u_exaggeration: i$1.paint.get("hillshade-exaggeration"),
					u_altitudes: o$1.altitudeRadians,
					u_azimuths: o$1.directionRadians,
					u_accent: a$1,
					u_method: r$1,
					u_highlights: o$1.highlightColor,
					u_shadows: o$1.shadowColor
				};
			}, ta$1 = (e$1, i$1) => {
				const a$1 = i$1.stride, r$1 = t.N();
				return t.c8(r$1, 0, t.a5, -t.a5, 0, 0, 1), t.O(r$1, r$1, [
					0,
					-t.a5,
					0
				]), {
					u_matrix: r$1,
					u_image: 1,
					u_dimension: [a$1, a$1],
					u_zoom: e$1.overscaledZ,
					u_unpack: i$1.getUnpackVector()
				};
			};
			function ia$1(e$1, i$1) {
				const a$1 = Math.pow(2, i$1.canonical.z), r$1 = i$1.canonical.y;
				return [new t.ab(0, r$1 / a$1).toLngLat().lat, new t.ab(0, (r$1 + 1) / a$1).toLngLat().lat];
			}
			const aa$1 = (e$1, t$1, i$1 = 0) => ({
				u_image: 0,
				u_unpack: t$1.getUnpackVector(),
				u_dimension: [t$1.stride, t$1.stride],
				u_elevation_stops: 1,
				u_color_stops: 4,
				u_color_ramp_size: i$1,
				u_opacity: e$1.paint.get("color-relief-opacity")
			}), ra$1 = (e$1, i$1, a$1, r$1) => {
				const o$1 = e$1.transform;
				return {
					u_translation: ha$1(e$1, i$1, a$1),
					u_ratio: r$1 / t.aO(i$1, 1, o$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_units_to_pixels: [1 / o$1.pixelsToGLUnits[0], 1 / o$1.pixelsToGLUnits[1]]
				};
			}, oa$1 = (e$1, i$1, a$1, r$1, o$1) => t.e(ra$1(e$1, i$1, a$1, r$1), {
				u_image: 0,
				u_image_height: o$1
			}), sa$1 = (e$1, i$1, a$1, r$1, o$1) => {
				const s$1 = e$1.transform, n$1 = ca$1(i$1, s$1);
				return {
					u_translation: ha$1(e$1, i$1, a$1),
					u_texsize: i$1.imageAtlasTexture.size,
					u_ratio: r$1 / t.aO(i$1, 1, s$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_image: 0,
					u_scale: [
						n$1,
						o$1.fromScale,
						o$1.toScale
					],
					u_fade: o$1.t,
					u_units_to_pixels: [1 / s$1.pixelsToGLUnits[0], 1 / s$1.pixelsToGLUnits[1]]
				};
			}, na$1 = (e$1, i$1, a$1, r$1, o$1) => {
				const s$1 = ca$1(i$1, e$1.transform);
				return t.e(ra$1(e$1, i$1, a$1, r$1), {
					u_tileratio: s$1,
					u_crossfade_from: o$1.fromScale,
					u_crossfade_to: o$1.toScale,
					u_image: 0,
					u_mix: o$1.t,
					u_lineatlas_width: e$1.lineAtlas.width,
					u_lineatlas_height: e$1.lineAtlas.height
				});
			}, la$1 = (e$1, i$1, a$1, r$1, o$1, s$1) => {
				const n$1 = ca$1(i$1, e$1.transform);
				return t.e(ra$1(e$1, i$1, a$1, r$1), {
					u_image: 0,
					u_image_height: s$1,
					u_tileratio: n$1,
					u_crossfade_from: o$1.fromScale,
					u_crossfade_to: o$1.toScale,
					u_image_dash: 1,
					u_mix: o$1.t,
					u_lineatlas_width: e$1.lineAtlas.width,
					u_lineatlas_height: e$1.lineAtlas.height
				});
			};
			function ca$1(e$1, i$1) {
				return 1 / t.aO(e$1, 1, i$1.tileZoom);
			}
			function ha$1(e$1, i$1, a$1) {
				return t.aP(e$1.transform, i$1, a$1.paint.get("line-translate"), a$1.paint.get("line-translate-anchor"));
			}
			const ua$1 = (e$1, t$1, i$1, a$1, r$1) => {
				return {
					u_tl_parent: e$1,
					u_scale_parent: t$1,
					u_buffer_scale: 1,
					u_fade_t: i$1.mix,
					u_opacity: i$1.opacity * a$1.paint.get("raster-opacity"),
					u_image0: 0,
					u_image1: 1,
					u_brightness_low: a$1.paint.get("raster-brightness-min"),
					u_brightness_high: a$1.paint.get("raster-brightness-max"),
					u_saturation_factor: (s$1 = a$1.paint.get("raster-saturation"), s$1 > 0 ? 1 - 1 / (1.001 - s$1) : -s$1),
					u_contrast_factor: (o$1 = a$1.paint.get("raster-contrast"), o$1 > 0 ? 1 / (1 - o$1) : 1 + o$1),
					u_spin_weights: da$1(a$1.paint.get("raster-hue-rotate")),
					u_coords_top: [
						r$1[0].x,
						r$1[0].y,
						r$1[1].x,
						r$1[1].y
					],
					u_coords_bottom: [
						r$1[3].x,
						r$1[3].y,
						r$1[2].x,
						r$1[2].y
					]
				};
				var o$1, s$1;
			};
			function da$1(e$1) {
				e$1 *= Math.PI / 180;
				const t$1 = Math.sin(e$1), i$1 = Math.cos(e$1);
				return [
					(2 * i$1 + 1) / 3,
					(-Math.sqrt(3) * t$1 - i$1 + 1) / 3,
					(Math.sqrt(3) * t$1 - i$1 + 1) / 3
				];
			}
			const _a$1 = (e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) => {
				const _$2 = s$1.transform;
				return {
					u_is_size_zoom_constant: +("constant" === e$1 || "source" === e$1),
					u_is_size_feature_constant: +("constant" === e$1 || "camera" === e$1),
					u_size_t: t$1 ? t$1.uSizeT : 0,
					u_size: t$1 ? t$1.uSize : 0,
					u_camera_to_center_distance: _$2.cameraToCenterDistance,
					u_pitch: _$2.pitch / 360 * 2 * Math.PI,
					u_rotate_symbol: +i$1,
					u_aspect_ratio: _$2.width / _$2.height,
					u_fade_change: s$1.options.fadeDuration ? s$1.symbolFadeChange : 1,
					u_label_plane_matrix: n$1,
					u_coord_matrix: l$1,
					u_is_text: +h$1,
					u_pitch_with_map: +a$1,
					u_is_along_line: r$1,
					u_is_variable_anchor: o$1,
					u_texsize: u$1,
					u_texture: 0,
					u_translation: c$1,
					u_pitched_scale: d$1
				};
			}, pa$1 = (e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2, p$1) => {
				const m$1 = n$1.transform;
				return t.e(_a$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, p$1), {
					u_gamma_scale: r$1 ? Math.cos(m$1.pitch * Math.PI / 180) * m$1.cameraToCenterDistance : 1,
					u_device_pixel_ratio: n$1.pixelRatio,
					u_is_halo: 1
				});
			}, ma$1 = (e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2) => t.e(pa$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, !0, u$1, 0, _$2), {
				u_texsize_icon: d$1,
				u_texture_icon: 1
			}), fa$1 = (e$1, t$1) => ({
				u_opacity: e$1,
				u_color: t$1
			}), ga$1 = (e$1, i$1, a$1, r$1, o$1) => t.e(function(e$2, i$2, a$2, r$2) {
				const o$2 = a$2.imageManager.getPattern(e$2.from.toString()), s$1 = a$2.imageManager.getPattern(e$2.to.toString()), { width: n$1, height: l$1 } = a$2.imageManager.getPixelSize(), c$1 = Math.pow(2, r$2.tileID.overscaledZ), h$1 = r$2.tileSize * Math.pow(2, a$2.transform.tileZoom) / c$1, u$1 = h$1 * (r$2.tileID.canonical.x + r$2.tileID.wrap * c$1), d$1 = h$1 * r$2.tileID.canonical.y;
				return {
					u_image: 0,
					u_pattern_tl_a: o$2.tl,
					u_pattern_br_a: o$2.br,
					u_pattern_tl_b: s$1.tl,
					u_pattern_br_b: s$1.br,
					u_texsize: [n$1, l$1],
					u_mix: i$2.t,
					u_pattern_size_a: o$2.displaySize,
					u_pattern_size_b: s$1.displaySize,
					u_scale_a: i$2.fromScale,
					u_scale_b: i$2.toScale,
					u_tile_units_to_pixels: 1 / t.aO(r$2, 1, a$2.transform.tileZoom),
					u_pixel_coord_upper: [u$1 >> 16, d$1 >> 16],
					u_pixel_coord_lower: [65535 & u$1, 65535 & d$1]
				};
			}(a$1, o$1, i$1, r$1), { u_opacity: e$1 }), va$1 = (e$1, t$1) => {}, xa$1 = {
				fillExtrusion: (e$1, i$1) => ({
					u_lightpos: new t.c3(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.c3(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.br(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.c3(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.br(e$1, i$1.u_vertical_gradient),
					u_opacity: new t.br(e$1, i$1.u_opacity),
					u_fill_translate: new t.c4(e$1, i$1.u_fill_translate)
				}),
				fillExtrusionPattern: (e$1, i$1) => ({
					u_lightpos: new t.c3(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.c3(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.br(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.c3(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.br(e$1, i$1.u_vertical_gradient),
					u_height_factor: new t.br(e$1, i$1.u_height_factor),
					u_opacity: new t.br(e$1, i$1.u_opacity),
					u_fill_translate: new t.c4(e$1, i$1.u_fill_translate),
					u_image: new t.b$(e$1, i$1.u_image),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.c4(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c4(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.c3(e$1, i$1.u_scale),
					u_fade: new t.br(e$1, i$1.u_fade)
				}),
				fill: (e$1, i$1) => ({ u_fill_translate: new t.c4(e$1, i$1.u_fill_translate) }),
				fillPattern: (e$1, i$1) => ({
					u_image: new t.b$(e$1, i$1.u_image),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.c4(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c4(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.c3(e$1, i$1.u_scale),
					u_fade: new t.br(e$1, i$1.u_fade),
					u_fill_translate: new t.c4(e$1, i$1.u_fill_translate)
				}),
				fillOutline: (e$1, i$1) => ({
					u_world: new t.c4(e$1, i$1.u_world),
					u_fill_translate: new t.c4(e$1, i$1.u_fill_translate)
				}),
				fillOutlinePattern: (e$1, i$1) => ({
					u_world: new t.c4(e$1, i$1.u_world),
					u_image: new t.b$(e$1, i$1.u_image),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.c4(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c4(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.c3(e$1, i$1.u_scale),
					u_fade: new t.br(e$1, i$1.u_fade),
					u_fill_translate: new t.c4(e$1, i$1.u_fill_translate)
				}),
				circle: (e$1, i$1) => ({
					u_camera_to_center_distance: new t.br(e$1, i$1.u_camera_to_center_distance),
					u_scale_with_map: new t.b$(e$1, i$1.u_scale_with_map),
					u_pitch_with_map: new t.b$(e$1, i$1.u_pitch_with_map),
					u_extrude_scale: new t.c4(e$1, i$1.u_extrude_scale),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_globe_extrude_scale: new t.br(e$1, i$1.u_globe_extrude_scale),
					u_translate: new t.c4(e$1, i$1.u_translate)
				}),
				collisionBox: (e$1, i$1) => ({ u_pixel_extrude_scale: new t.c4(e$1, i$1.u_pixel_extrude_scale) }),
				collisionCircle: (e$1, i$1) => ({ u_viewport_size: new t.c4(e$1, i$1.u_viewport_size) }),
				debug: (e$1, i$1) => ({
					u_color: new t.c0(e$1, i$1.u_color),
					u_overlay: new t.b$(e$1, i$1.u_overlay),
					u_overlay_scale: new t.br(e$1, i$1.u_overlay_scale)
				}),
				depth: va$1,
				clippingMask: va$1,
				heatmap: (e$1, i$1) => ({
					u_extrude_scale: new t.br(e$1, i$1.u_extrude_scale),
					u_intensity: new t.br(e$1, i$1.u_intensity),
					u_globe_extrude_scale: new t.br(e$1, i$1.u_globe_extrude_scale)
				}),
				heatmapTexture: (e$1, i$1) => ({
					u_matrix: new t.c1(e$1, i$1.u_matrix),
					u_world: new t.c4(e$1, i$1.u_world),
					u_image: new t.b$(e$1, i$1.u_image),
					u_color_ramp: new t.b$(e$1, i$1.u_color_ramp),
					u_opacity: new t.br(e$1, i$1.u_opacity)
				}),
				hillshade: (e$1, i$1) => ({
					u_image: new t.b$(e$1, i$1.u_image),
					u_latrange: new t.c4(e$1, i$1.u_latrange),
					u_exaggeration: new t.br(e$1, i$1.u_exaggeration),
					u_altitudes: new t.ca(e$1, i$1.u_altitudes),
					u_azimuths: new t.ca(e$1, i$1.u_azimuths),
					u_accent: new t.c0(e$1, i$1.u_accent),
					u_method: new t.b$(e$1, i$1.u_method),
					u_shadows: new t.c9(e$1, i$1.u_shadows),
					u_highlights: new t.c9(e$1, i$1.u_highlights)
				}),
				hillshadePrepare: (e$1, i$1) => ({
					u_matrix: new t.c1(e$1, i$1.u_matrix),
					u_image: new t.b$(e$1, i$1.u_image),
					u_dimension: new t.c4(e$1, i$1.u_dimension),
					u_zoom: new t.br(e$1, i$1.u_zoom),
					u_unpack: new t.c2(e$1, i$1.u_unpack)
				}),
				colorRelief: (e$1, i$1) => ({
					u_image: new t.b$(e$1, i$1.u_image),
					u_unpack: new t.c2(e$1, i$1.u_unpack),
					u_dimension: new t.c4(e$1, i$1.u_dimension),
					u_elevation_stops: new t.b$(e$1, i$1.u_elevation_stops),
					u_color_stops: new t.b$(e$1, i$1.u_color_stops),
					u_color_ramp_size: new t.b$(e$1, i$1.u_color_ramp_size),
					u_opacity: new t.br(e$1, i$1.u_opacity)
				}),
				line: (e$1, i$1) => ({
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_ratio: new t.br(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c4(e$1, i$1.u_units_to_pixels)
				}),
				lineGradient: (e$1, i$1) => ({
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_ratio: new t.br(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c4(e$1, i$1.u_units_to_pixels),
					u_image: new t.b$(e$1, i$1.u_image),
					u_image_height: new t.br(e$1, i$1.u_image_height)
				}),
				linePattern: (e$1, i$1) => ({
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_ratio: new t.br(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_image: new t.b$(e$1, i$1.u_image),
					u_units_to_pixels: new t.c4(e$1, i$1.u_units_to_pixels),
					u_scale: new t.c3(e$1, i$1.u_scale),
					u_fade: new t.br(e$1, i$1.u_fade)
				}),
				lineSDF: (e$1, i$1) => ({
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_ratio: new t.br(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c4(e$1, i$1.u_units_to_pixels),
					u_image: new t.b$(e$1, i$1.u_image),
					u_mix: new t.br(e$1, i$1.u_mix),
					u_tileratio: new t.br(e$1, i$1.u_tileratio),
					u_crossfade_from: new t.br(e$1, i$1.u_crossfade_from),
					u_crossfade_to: new t.br(e$1, i$1.u_crossfade_to),
					u_lineatlas_width: new t.br(e$1, i$1.u_lineatlas_width),
					u_lineatlas_height: new t.br(e$1, i$1.u_lineatlas_height)
				}),
				lineGradientSDF: (e$1, i$1) => ({
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_ratio: new t.br(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c4(e$1, i$1.u_units_to_pixels),
					u_image: new t.b$(e$1, i$1.u_image),
					u_image_height: new t.br(e$1, i$1.u_image_height),
					u_tileratio: new t.br(e$1, i$1.u_tileratio),
					u_crossfade_from: new t.br(e$1, i$1.u_crossfade_from),
					u_crossfade_to: new t.br(e$1, i$1.u_crossfade_to),
					u_image_dash: new t.b$(e$1, i$1.u_image_dash),
					u_mix: new t.br(e$1, i$1.u_mix),
					u_lineatlas_width: new t.br(e$1, i$1.u_lineatlas_width),
					u_lineatlas_height: new t.br(e$1, i$1.u_lineatlas_height)
				}),
				raster: (e$1, i$1) => ({
					u_tl_parent: new t.c4(e$1, i$1.u_tl_parent),
					u_scale_parent: new t.br(e$1, i$1.u_scale_parent),
					u_buffer_scale: new t.br(e$1, i$1.u_buffer_scale),
					u_fade_t: new t.br(e$1, i$1.u_fade_t),
					u_opacity: new t.br(e$1, i$1.u_opacity),
					u_image0: new t.b$(e$1, i$1.u_image0),
					u_image1: new t.b$(e$1, i$1.u_image1),
					u_brightness_low: new t.br(e$1, i$1.u_brightness_low),
					u_brightness_high: new t.br(e$1, i$1.u_brightness_high),
					u_saturation_factor: new t.br(e$1, i$1.u_saturation_factor),
					u_contrast_factor: new t.br(e$1, i$1.u_contrast_factor),
					u_spin_weights: new t.c3(e$1, i$1.u_spin_weights),
					u_coords_top: new t.c2(e$1, i$1.u_coords_top),
					u_coords_bottom: new t.c2(e$1, i$1.u_coords_bottom)
				}),
				symbolIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.b$(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.b$(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.br(e$1, i$1.u_size_t),
					u_size: new t.br(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.br(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.br(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.b$(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.br(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.br(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.c1(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.c1(e$1, i$1.u_coord_matrix),
					u_is_text: new t.b$(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.b$(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.b$(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.b$(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_texture: new t.b$(e$1, i$1.u_texture),
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_pitched_scale: new t.br(e$1, i$1.u_pitched_scale)
				}),
				symbolSDF: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.b$(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.b$(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.br(e$1, i$1.u_size_t),
					u_size: new t.br(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.br(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.br(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.b$(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.br(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.br(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.c1(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.c1(e$1, i$1.u_coord_matrix),
					u_is_text: new t.b$(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.b$(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.b$(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.b$(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_texture: new t.b$(e$1, i$1.u_texture),
					u_gamma_scale: new t.br(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.b$(e$1, i$1.u_is_halo),
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_pitched_scale: new t.br(e$1, i$1.u_pitched_scale)
				}),
				symbolTextAndIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.b$(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.b$(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.br(e$1, i$1.u_size_t),
					u_size: new t.br(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.br(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.br(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.b$(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.br(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.br(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.c1(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.c1(e$1, i$1.u_coord_matrix),
					u_is_text: new t.b$(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.b$(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.b$(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.b$(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_texsize_icon: new t.c4(e$1, i$1.u_texsize_icon),
					u_texture: new t.b$(e$1, i$1.u_texture),
					u_texture_icon: new t.b$(e$1, i$1.u_texture_icon),
					u_gamma_scale: new t.br(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.br(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.b$(e$1, i$1.u_is_halo),
					u_translation: new t.c4(e$1, i$1.u_translation),
					u_pitched_scale: new t.br(e$1, i$1.u_pitched_scale)
				}),
				background: (e$1, i$1) => ({
					u_opacity: new t.br(e$1, i$1.u_opacity),
					u_color: new t.c0(e$1, i$1.u_color)
				}),
				backgroundPattern: (e$1, i$1) => ({
					u_opacity: new t.br(e$1, i$1.u_opacity),
					u_image: new t.b$(e$1, i$1.u_image),
					u_pattern_tl_a: new t.c4(e$1, i$1.u_pattern_tl_a),
					u_pattern_br_a: new t.c4(e$1, i$1.u_pattern_br_a),
					u_pattern_tl_b: new t.c4(e$1, i$1.u_pattern_tl_b),
					u_pattern_br_b: new t.c4(e$1, i$1.u_pattern_br_b),
					u_texsize: new t.c4(e$1, i$1.u_texsize),
					u_mix: new t.br(e$1, i$1.u_mix),
					u_pattern_size_a: new t.c4(e$1, i$1.u_pattern_size_a),
					u_pattern_size_b: new t.c4(e$1, i$1.u_pattern_size_b),
					u_scale_a: new t.br(e$1, i$1.u_scale_a),
					u_scale_b: new t.br(e$1, i$1.u_scale_b),
					u_pixel_coord_upper: new t.c4(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c4(e$1, i$1.u_pixel_coord_lower),
					u_tile_units_to_pixels: new t.br(e$1, i$1.u_tile_units_to_pixels)
				}),
				terrain: (e$1, i$1) => ({
					u_texture: new t.b$(e$1, i$1.u_texture),
					u_ele_delta: new t.br(e$1, i$1.u_ele_delta),
					u_fog_matrix: new t.c1(e$1, i$1.u_fog_matrix),
					u_fog_color: new t.c0(e$1, i$1.u_fog_color),
					u_fog_ground_blend: new t.br(e$1, i$1.u_fog_ground_blend),
					u_fog_ground_blend_opacity: new t.br(e$1, i$1.u_fog_ground_blend_opacity),
					u_horizon_color: new t.c0(e$1, i$1.u_horizon_color),
					u_horizon_fog_blend: new t.br(e$1, i$1.u_horizon_fog_blend),
					u_is_globe_mode: new t.br(e$1, i$1.u_is_globe_mode)
				}),
				terrainDepth: (e$1, i$1) => ({ u_ele_delta: new t.br(e$1, i$1.u_ele_delta) }),
				terrainCoords: (e$1, i$1) => ({
					u_texture: new t.b$(e$1, i$1.u_texture),
					u_terrain_coords_id: new t.br(e$1, i$1.u_terrain_coords_id),
					u_ele_delta: new t.br(e$1, i$1.u_ele_delta)
				}),
				projectionErrorMeasurement: (e$1, i$1) => ({
					u_input: new t.br(e$1, i$1.u_input),
					u_output_expected: new t.br(e$1, i$1.u_output_expected)
				}),
				atmosphere: (e$1, i$1) => ({
					u_sun_pos: new t.c3(e$1, i$1.u_sun_pos),
					u_atmosphere_blend: new t.br(e$1, i$1.u_atmosphere_blend),
					u_globe_position: new t.c3(e$1, i$1.u_globe_position),
					u_globe_radius: new t.br(e$1, i$1.u_globe_radius),
					u_inv_proj_matrix: new t.c1(e$1, i$1.u_inv_proj_matrix)
				}),
				sky: (e$1, i$1) => ({
					u_sky_color: new t.c0(e$1, i$1.u_sky_color),
					u_horizon_color: new t.c0(e$1, i$1.u_horizon_color),
					u_horizon: new t.c4(e$1, i$1.u_horizon),
					u_horizon_normal: new t.c4(e$1, i$1.u_horizon_normal),
					u_sky_horizon_blend: new t.br(e$1, i$1.u_sky_horizon_blend),
					u_sky_blend: new t.br(e$1, i$1.u_sky_blend)
				})
			};
			class ba$1 {
				constructor(e$1, t$1, i$1) {
					this.context = e$1;
					const a$1 = e$1.gl;
					this.buffer = a$1.createBuffer(), this.dynamicDraw = Boolean(i$1), this.context.unbindVAO(), e$1.bindElementBuffer.set(this.buffer), a$1.bufferData(a$1.ELEMENT_ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? a$1.DYNAMIC_DRAW : a$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindElementBuffer.set(this.buffer);
				}
				updateData(e$1) {
					const t$1 = this.context.gl;
					if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
					this.context.unbindVAO(), this.bind(), t$1.bufferSubData(t$1.ELEMENT_ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			const ya$1 = {
				Int8: "BYTE",
				Uint8: "UNSIGNED_BYTE",
				Int16: "SHORT",
				Uint16: "UNSIGNED_SHORT",
				Int32: "INT",
				Uint32: "UNSIGNED_INT",
				Float32: "FLOAT"
			};
			class wa$1 {
				constructor(e$1, t$1, i$1, a$1) {
					this.length = t$1.length, this.attributes = i$1, this.itemSize = t$1.bytesPerElement, this.dynamicDraw = a$1, this.context = e$1;
					const r$1 = e$1.gl;
					this.buffer = r$1.createBuffer(), e$1.bindVertexBuffer.set(this.buffer), r$1.bufferData(r$1.ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? r$1.DYNAMIC_DRAW : r$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindVertexBuffer.set(this.buffer);
				}
				updateData(e$1) {
					if (e$1.length !== this.length) throw new Error(`Length of new data is ${e$1.length}, which doesn't match current length of ${this.length}`);
					const t$1 = this.context.gl;
					this.bind(), t$1.bufferSubData(t$1.ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				enableAttributes(e$1, t$1) {
					for (let i$1 = 0; i$1 < this.attributes.length; i$1++) {
						const a$1 = t$1.attributes[this.attributes[i$1].name];
						void 0 !== a$1 && e$1.enableVertexAttribArray(a$1);
					}
				}
				setVertexAttribPointers(e$1, t$1, i$1) {
					for (let a$1 = 0; a$1 < this.attributes.length; a$1++) {
						const r$1 = this.attributes[a$1], o$1 = t$1.attributes[r$1.name];
						void 0 !== o$1 && e$1.vertexAttribPointer(o$1, r$1.components, e$1[ya$1[r$1.type]], !1, this.itemSize, r$1.offset + this.itemSize * (i$1 || 0));
					}
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			class Ta$1 {
				constructor(e$1) {
					this.gl = e$1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
				}
				get() {
					return this.current;
				}
				set(e$1) {}
				getDefault() {
					return this.default;
				}
				setDefault() {
					this.set(this.default);
				}
			}
			class Pa$1 extends Ta$1 {
				getDefault() {
					return t.bq.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.clearColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class Ia$1 extends Ta$1 {
				getDefault() {
					return 1;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearDepth(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ca$1 extends Ta$1 {
				getDefault() {
					return 0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearStencil(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ma$1 extends Ta$1 {
				getDefault() {
					return [
						!0,
						!0,
						!0,
						!0
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.colorMask(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Ea$1 extends Ta$1 {
				getDefault() {
					return !0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Sa$1 extends Ta$1 {
				getDefault() {
					return 255;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.stencilMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ra$1 extends Ta$1 {
				getDefault() {
					return {
						func: this.gl.ALWAYS,
						ref: 0,
						mask: 255
					};
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.func !== t$1.func || e$1.ref !== t$1.ref || e$1.mask !== t$1.mask || this.dirty) && (this.gl.stencilFunc(e$1.func, e$1.ref, e$1.mask), this.current = e$1, this.dirty = !1);
				}
			}
			class za$1 extends Ta$1 {
				getDefault() {
					const e$1 = this.gl;
					return [
						e$1.KEEP,
						e$1.KEEP,
						e$1.KEEP
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || this.dirty) && (this.gl.stencilOp(e$1[0], e$1[1], e$1[2]), this.current = e$1, this.dirty = !1);
				}
			}
			class Da$1 extends Ta$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.STENCIL_TEST) : t$1.disable(t$1.STENCIL_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class Aa$1 extends Ta$1 {
				getDefault() {
					return [0, 1];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.depthRange(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class La$1 extends Ta$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.DEPTH_TEST) : t$1.disable(t$1.DEPTH_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class ka$1 extends Ta$1 {
				getDefault() {
					return this.gl.LESS;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthFunc(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Fa$1 extends Ta$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.BLEND) : t$1.disable(t$1.BLEND), this.current = e$1, this.dirty = !1;
				}
			}
			class Ba$1 extends Ta$1 {
				getDefault() {
					const e$1 = this.gl;
					return [e$1.ONE, e$1.ZERO];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.blendFunc(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class Oa$1 extends Ta$1 {
				getDefault() {
					return t.bq.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.blendColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class ja$1 extends Ta$1 {
				getDefault() {
					return this.gl.FUNC_ADD;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.blendEquation(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Na$1 extends Ta$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.CULL_FACE) : t$1.disable(t$1.CULL_FACE), this.current = e$1, this.dirty = !1;
				}
			}
			class Za$1 extends Ta$1 {
				getDefault() {
					return this.gl.BACK;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.cullFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ga$1 extends Ta$1 {
				getDefault() {
					return this.gl.CCW;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.frontFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ua$1 extends Ta$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.useProgram(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Va$1 extends Ta$1 {
				getDefault() {
					return this.gl.TEXTURE0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.activeTexture(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class qa$1 extends Ta$1 {
				getDefault() {
					const e$1 = this.gl;
					return [
						0,
						0,
						e$1.drawingBufferWidth,
						e$1.drawingBufferHeight
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.viewport(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Wa$1 extends Ta$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindFramebuffer(t$1.FRAMEBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class $a$1 extends Ta$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindRenderbuffer(t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ha$1 extends Ta$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindTexture(t$1.TEXTURE_2D, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Xa$1 extends Ta$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ka$1 extends Ta$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ELEMENT_ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ya$1 extends Ta$1 {
				getDefault() {
					return null;
				}
				set(e$1) {
					var t$1;
					if (e$1 === this.current && !this.dirty) return;
					const i$1 = this.gl;
					oi$1(i$1) ? i$1.bindVertexArray(e$1) : null === (t$1 = i$1.getExtension("OES_vertex_array_object")) || void 0 === t$1 || t$1.bindVertexArrayOES(e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Qa extends Ta$1 {
				getDefault() {
					return 4;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_ALIGNMENT, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ja$1 extends Ta$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class er$1 extends Ta$1 {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_FLIP_Y_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class tr$1 extends Ta$1 {
				constructor(e$1, t$1) {
					super(e$1), this.context = e$1, this.parent = t$1;
				}
				getDefault() {
					return null;
				}
			}
			class ir$1 extends tr$1 {
				setDirty() {
					this.dirty = !0;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferTexture2D(t$1.FRAMEBUFFER, t$1.COLOR_ATTACHMENT0, t$1.TEXTURE_2D, e$1, 0), this.current = e$1, this.dirty = !1;
				}
			}
			class ar$1 extends tr$1 {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class rr$1 extends tr$1 {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_STENCIL_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			const or$1 = "Framebuffer is not complete";
			class sr$1 {
				constructor(e$1, t$1, i$1, a$1, r$1) {
					this.context = e$1, this.width = t$1, this.height = i$1;
					const o$1 = e$1.gl, s$1 = this.framebuffer = o$1.createFramebuffer();
					if (this.colorAttachment = new ir$1(e$1, s$1), a$1) this.depthAttachment = r$1 ? new rr$1(e$1, s$1) : new ar$1(e$1, s$1);
					else if (r$1) throw new Error("Stencil cannot be set without depth");
					if (o$1.checkFramebufferStatus(o$1.FRAMEBUFFER) !== o$1.FRAMEBUFFER_COMPLETE) throw new Error(or$1);
				}
				destroy() {
					const e$1 = this.context.gl, t$1 = this.colorAttachment.get();
					if (t$1 && e$1.deleteTexture(t$1), this.depthAttachment) {
						const t$2 = this.depthAttachment.get();
						t$2 && e$1.deleteRenderbuffer(t$2);
					}
					e$1.deleteFramebuffer(this.framebuffer);
				}
			}
			class nr$1 {
				constructor(e$1) {
					var t$1, i$1;
					if (this.gl = e$1, this.clearColor = new Pa$1(this), this.clearDepth = new Ia$1(this), this.clearStencil = new Ca$1(this), this.colorMask = new Ma$1(this), this.depthMask = new Ea$1(this), this.stencilMask = new Sa$1(this), this.stencilFunc = new Ra$1(this), this.stencilOp = new za$1(this), this.stencilTest = new Da$1(this), this.depthRange = new Aa$1(this), this.depthTest = new La$1(this), this.depthFunc = new ka$1(this), this.blend = new Fa$1(this), this.blendFunc = new Ba$1(this), this.blendColor = new Oa$1(this), this.blendEquation = new ja$1(this), this.cullFace = new Na$1(this), this.cullFaceSide = new Za$1(this), this.frontFace = new Ga$1(this), this.program = new Ua$1(this), this.activeTexture = new Va$1(this), this.viewport = new qa$1(this), this.bindFramebuffer = new Wa$1(this), this.bindRenderbuffer = new $a$1(this), this.bindTexture = new Ha$1(this), this.bindVertexBuffer = new Xa$1(this), this.bindElementBuffer = new Ka$1(this), this.bindVertexArray = new Ya$1(this), this.pixelStoreUnpack = new Qa(this), this.pixelStoreUnpackPremultiplyAlpha = new Ja$1(this), this.pixelStoreUnpackFlipY = new er$1(this), this.extTextureFilterAnisotropic = e$1.getExtension("EXT_texture_filter_anisotropic") || e$1.getExtension("MOZ_EXT_texture_filter_anisotropic") || e$1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e$1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e$1.getParameter(e$1.MAX_TEXTURE_SIZE), oi$1(e$1)) {
						this.HALF_FLOAT = e$1.HALF_FLOAT;
						const a$1 = e$1.getExtension("EXT_color_buffer_half_float");
						this.RGBA16F = null !== (t$1 = e$1.RGBA16F) && void 0 !== t$1 ? t$1 : null == a$1 ? void 0 : a$1.RGBA16F_EXT, this.RGB16F = null !== (i$1 = e$1.RGB16F) && void 0 !== i$1 ? i$1 : null == a$1 ? void 0 : a$1.RGB16F_EXT, e$1.getExtension("EXT_color_buffer_float");
					} else {
						e$1.getExtension("EXT_color_buffer_half_float"), e$1.getExtension("OES_texture_half_float_linear");
						const t$2 = e$1.getExtension("OES_texture_half_float");
						this.HALF_FLOAT = null == t$2 ? void 0 : t$2.HALF_FLOAT_OES;
					}
				}
				setDefault() {
					this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
				}
				setDirty() {
					this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
				}
				createIndexBuffer(e$1, t$1) {
					return new ba$1(this, e$1, t$1);
				}
				createVertexBuffer(e$1, t$1, i$1) {
					return new wa$1(this, e$1, t$1, i$1);
				}
				createRenderbuffer(e$1, t$1, i$1) {
					const a$1 = this.gl, r$1 = a$1.createRenderbuffer();
					return this.bindRenderbuffer.set(r$1), a$1.renderbufferStorage(a$1.RENDERBUFFER, e$1, t$1, i$1), this.bindRenderbuffer.set(null), r$1;
				}
				createFramebuffer(e$1, t$1, i$1, a$1) {
					return new sr$1(this, e$1, t$1, i$1, a$1);
				}
				clear({ color: e$1, depth: t$1, stencil: i$1 }) {
					const a$1 = this.gl;
					let r$1 = 0;
					e$1 && (r$1 |= a$1.COLOR_BUFFER_BIT, this.clearColor.set(e$1), this.colorMask.set([
						!0,
						!0,
						!0,
						!0
					])), void 0 !== t$1 && (r$1 |= a$1.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t$1), this.depthMask.set(!0)), void 0 !== i$1 && (r$1 |= a$1.STENCIL_BUFFER_BIT, this.clearStencil.set(i$1), this.stencilMask.set(255)), a$1.clear(r$1);
				}
				setCullFace(e$1) {
					!1 === e$1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e$1.mode), this.frontFace.set(e$1.frontFace));
				}
				setDepthMode(e$1) {
					e$1.func !== this.gl.ALWAYS || e$1.mask ? (this.depthTest.set(!0), this.depthFunc.set(e$1.func), this.depthMask.set(e$1.mask), this.depthRange.set(e$1.range)) : this.depthTest.set(!1);
				}
				setStencilMode(e$1) {
					e$1.test.func !== this.gl.ALWAYS || e$1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e$1.mask), this.stencilOp.set([
						e$1.fail,
						e$1.depthFail,
						e$1.pass
					]), this.stencilFunc.set({
						func: e$1.test.func,
						ref: e$1.ref,
						mask: e$1.test.mask
					})) : this.stencilTest.set(!1);
				}
				setColorMode(e$1) {
					t.bS(e$1.blendFunction, Qt$1.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e$1.blendFunction), this.blendColor.set(e$1.blendColor)), this.colorMask.set(e$1.mask);
				}
				createVertexArray() {
					var e$1;
					return oi$1(this.gl) ? this.gl.createVertexArray() : null === (e$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e$1 ? void 0 : e$1.createVertexArrayOES();
				}
				deleteVertexArray(e$1) {
					var t$1;
					return oi$1(this.gl) ? this.gl.deleteVertexArray(e$1) : null === (t$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t$1 ? void 0 : t$1.deleteVertexArrayOES(e$1);
				}
				unbindVAO() {
					this.bindVertexArray.set(null);
				}
			}
			let lr$1;
			function cr$1(e$1, i$1, a$1, r$1, o$1) {
				const s$1 = e$1.context, n$1 = e$1.transform, l$1 = s$1.gl, c$1 = e$1.useProgram("collisionBox"), h$1 = [];
				let u$1 = 0, d$1 = 0;
				for (let t$1 = 0; t$1 < r$1.length; t$1++) {
					const _$3 = r$1[t$1], p$2 = i$1.getTile(_$3).getBucket(a$1);
					if (!p$2) continue;
					const m$2 = o$1 ? p$2.textCollisionBox : p$2.iconCollisionBox, f$2 = p$2.collisionCircleArray;
					f$2.length > 0 && (h$1.push({
						circleArray: f$2,
						circleOffset: d$1,
						coord: _$3
					}), u$1 += f$2.length / 4, d$1 = u$1), m$2 && c$1.draw(s$1, l$1.LINES, ti$1.disabled, ai$1.disabled, e$1.colorModeForRenderPass(), ei$1.disabled, Xi$1(e$1.transform), e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(_$3), n$1.getProjectionData({
						overscaledTileID: _$3,
						applyGlobeMatrix: !0,
						applyTerrainMatrix: !0
					}), a$1.id, m$2.layoutVertexBuffer, m$2.indexBuffer, m$2.segments, null, e$1.transform.zoom, null, null, m$2.collisionVertexBuffer);
				}
				if (!o$1 || !h$1.length) return;
				const _$2 = e$1.useProgram("collisionCircle"), p$1 = new t.cb();
				p$1.resize(4 * u$1), p$1._trim();
				let m$1 = 0;
				for (const e$2 of h$1) for (let t$1 = 0; t$1 < e$2.circleArray.length / 4; t$1++) {
					const i$2 = 4 * t$1, a$2 = e$2.circleArray[i$2 + 0], r$2 = e$2.circleArray[i$2 + 1], o$2 = e$2.circleArray[i$2 + 2], s$2 = e$2.circleArray[i$2 + 3];
					p$1.emplace(m$1++, a$2, r$2, o$2, s$2, 0), p$1.emplace(m$1++, a$2, r$2, o$2, s$2, 1), p$1.emplace(m$1++, a$2, r$2, o$2, s$2, 2), p$1.emplace(m$1++, a$2, r$2, o$2, s$2, 3);
				}
				(!lr$1 || lr$1.length < 2 * u$1) && (lr$1 = function(e$2) {
					const i$2 = 2 * e$2, a$2 = new t.cd();
					a$2.resize(i$2), a$2._trim();
					for (let e$3 = 0; e$3 < i$2; e$3++) {
						const t$1 = 6 * e$3;
						a$2.uint16[t$1 + 0] = 4 * e$3 + 0, a$2.uint16[t$1 + 1] = 4 * e$3 + 1, a$2.uint16[t$1 + 2] = 4 * e$3 + 2, a$2.uint16[t$1 + 3] = 4 * e$3 + 2, a$2.uint16[t$1 + 4] = 4 * e$3 + 3, a$2.uint16[t$1 + 5] = 4 * e$3 + 0;
					}
					return a$2;
				}(u$1));
				const f$1 = s$1.createIndexBuffer(lr$1, !0), g$2 = s$1.createVertexBuffer(p$1, t.cc.members, !0);
				for (const i$2 of h$1) {
					const r$2 = Ki$1(e$1.transform);
					_$2.draw(s$1, l$1.TRIANGLES, ti$1.disabled, ai$1.disabled, e$1.colorModeForRenderPass(), ei$1.disabled, r$2, e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(i$2.coord), null, a$1.id, g$2, f$1, t.aY.simpleSegment(0, 2 * i$2.circleOffset, i$2.circleArray.length, i$2.circleArray.length / 2), null, e$1.transform.zoom, null, null, null);
				}
				g$2.destroy(), f$1.destroy();
			}
			const hr$1 = t.as(new Float32Array(16));
			function ur$1(e$1, i$1, a$1, r$1, o$1, s$1) {
				const { horizontalAlign: n$1, verticalAlign: l$1 } = t.aT(e$1);
				return new t.P((-(n$1 - .5) * i$1 / o$1 + r$1[0]) * s$1, (-(l$1 - .5) * a$1 / o$1 + r$1[1]) * s$1);
			}
			function dr$1(e$1, i$1, a$1, r$1, o$1, s$1) {
				const n$1 = i$1.tileAnchorPoint.add(new t.P(i$1.translation[0], i$1.translation[1]));
				if (i$1.pitchWithMap) {
					let e$2 = r$1.mult(s$1);
					a$1 || (e$2 = e$2.rotate(-o$1));
					const t$1 = n$1.add(e$2);
					return Ge$1(t$1.x, t$1.y, i$1.pitchedLabelPlaneMatrix, i$1.getElevation).point;
				}
				if (a$1) {
					const t$1 = Ye(i$1.tileAnchorPoint.x + 1, i$1.tileAnchorPoint.y, i$1).point.sub(e$1), a$2 = Math.atan(t$1.y / t$1.x) + (t$1.x < 0 ? Math.PI : 0);
					return e$1.add(r$1.rotate(a$2));
				}
				return e$1.add(r$1);
			}
			function _r$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) {
				const _$2 = e$1.text.placedSymbolArray, p$1 = e$1.text.dynamicLayoutVertexArray, m$1 = e$1.icon.dynamicLayoutVertexArray, f$1 = {};
				p$1.clear();
				for (let m$2 = 0; m$2 < _$2.length; m$2++) {
					const g$2 = _$2.get(m$2), v$1 = g$2.hidden || !g$2.crossTileID || e$1.allowVerticalPlacement && !g$2.placedOrientation ? null : r$1[g$2.crossTileID];
					if (v$1) {
						const r$2 = new t.P(g$2.anchorX, g$2.anchorY), _$3 = {
							getElevation: d$1,
							width: o$1.width,
							height: o$1.height,
							pitchedLabelPlaneMatrix: s$1,
							pitchWithMap: a$1,
							transform: o$1,
							tileAnchorPoint: r$2,
							translation: h$1,
							unwrappedTileID: u$1
						}, m$3 = a$1 ? Je$1(r$2.x, r$2.y, _$3) : Ye(r$2.x, r$2.y, _$3), x$1 = Ue$1(o$1.cameraToCenterDistance, m$3.signedDistanceFromCamera);
						let b$1 = t.aB(e$1.textSizeData, l$1, g$2) * x$1 / t.aN;
						a$1 && (b$1 *= e$1.tilePixelRatio / n$1);
						const { width: y$1, height: w$2, anchor: T$1, textOffset: P$2, textBoxScale: I$2 } = v$1, C$1 = ur$1(T$1, y$1, w$2, P$2, I$2, b$1), M$2 = o$1.getPitchedTextCorrection(r$2.x + h$1[0], r$2.y + h$1[1], u$1), E$1 = dr$1(m$3.point, _$3, i$1, C$1, -o$1.bearingInRadians, M$2), S$2 = e$1.allowVerticalPlacement && g$2.placedOrientation === t.aA.vertical ? Math.PI / 2 : 0;
						for (let e$2 = 0; e$2 < g$2.numGlyphs; e$2++) t.aH(p$1, E$1, S$2);
						c$1 && g$2.associatedIconIndex >= 0 && (f$1[g$2.associatedIconIndex] = {
							shiftedAnchor: E$1,
							angle: S$2
						});
					} else rt$1(g$2.numGlyphs, p$1);
				}
				if (c$1) {
					m$1.clear();
					const i$2 = e$1.icon.placedSymbolArray;
					for (let e$2 = 0; e$2 < i$2.length; e$2++) {
						const a$2 = i$2.get(e$2);
						if (a$2.hidden) rt$1(a$2.numGlyphs, m$1);
						else {
							const i$3 = f$1[e$2];
							if (i$3) for (let e$3 = 0; e$3 < a$2.numGlyphs; e$3++) t.aH(m$1, i$3.shiftedAnchor, i$3.angle);
							else rt$1(a$2.numGlyphs, m$1);
						}
					}
					e$1.icon.dynamicLayoutVertexBuffer.updateData(m$1);
				}
				e$1.text.dynamicLayoutVertexBuffer.updateData(p$1);
			}
			function pr$1(e$1, t$1, i$1) {
				return i$1.iconsInText && t$1 ? "symbolTextAndIcon" : e$1 ? "symbolSDF" : "symbolIcon";
			}
			function mr$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$2) {
				const p$1 = e$1.context, m$1 = p$1.gl, f$1 = e$1.transform, g$2 = "map" === l$1, v$1 = "map" === c$1, x$1 = "viewport" !== l$1 && "point" !== a$1.layout.get("symbol-placement"), b$1 = g$2 && !v$1 && !x$1, y$1 = !a$1.layout.get("symbol-sort-key").isConstant();
				let w$2 = !1;
				const T$1 = e$1.getDepthModeForSublayer(0, ti$1.ReadOnly), P$2 = a$1._unevaluatedLayout.hasValue("text-variable-anchor") || a$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), I$2 = [], C$1 = f$1.getCircleRadiusCorrection();
				for (const l$2 of r$1) {
					const r$2 = i$1.getTile(l$2), c$2 = r$2.getBucket(a$1);
					if (!c$2) continue;
					const u$2 = o$1 ? c$2.text : c$2.icon;
					if (!u$2 || !u$2.segments.get().length || !u$2.hasVisibleVertices) continue;
					const d$2 = u$2.programConfigurations.get(a$1.id), p$2 = o$1 || c$2.sdfIcons, T$2 = o$1 ? c$2.textSizeData : c$2.iconSizeData, M$2 = v$1 || 0 !== f$1.pitch, E$1 = e$1.useProgram(pr$1(p$2, o$1, c$2), d$2), S$2 = t.az(T$2, f$1.zoom), R$3 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(l$2);
					let z$2, D$2, A$2, L$2, k$2 = [0, 0], F$2 = null;
					if (o$1) D$2 = r$2.glyphAtlasTexture, A$2 = m$1.LINEAR, z$2 = r$2.glyphAtlasTexture.size, c$2.iconsInText && (k$2 = r$2.imageAtlasTexture.size, F$2 = r$2.imageAtlasTexture, L$2 = M$2 || e$1.options.rotating || e$1.options.zooming || "composite" === T$2.kind || "camera" === T$2.kind ? m$1.LINEAR : m$1.NEAREST);
					else {
						const t$1 = 1 !== a$1.layout.get("icon-size").constantOr(0) || c$2.iconsNeedLinear;
						D$2 = r$2.imageAtlasTexture, A$2 = p$2 || e$1.options.rotating || e$1.options.zooming || t$1 || M$2 ? m$1.LINEAR : m$1.NEAREST, z$2 = r$2.imageAtlasTexture.size;
					}
					const B$2 = t.aO(r$2, 1, e$1.transform.zoom), O$2 = je$1(g$2, e$1.transform, B$2), j$2 = t.N();
					t.aC(j$2, O$2);
					const N$1 = Ne$1(v$1, g$2, e$1.transform, B$2), Z$2 = t.aP(f$1, r$2, s$1, n$1), G$2 = f$1.getProjectionData({
						overscaledTileID: l$2,
						applyGlobeMatrix: !_$2,
						applyTerrainMatrix: !0
					}), U$2 = P$2 && c$2.hasTextData(), V$2 = "none" !== a$1.layout.get("icon-text-fit") && U$2 && c$2.hasIconData();
					if (x$1) {
						const t$1 = e$1.style.map.terrain ? (t$2, i$2) => e$1.style.map.terrain.getElevation(l$2, t$2, i$2) : null;
						qe$1(c$2, e$1, o$1, O$2, j$2, v$1, h$1, "map" === a$1.layout.get("text-rotation-alignment"), l$2.toUnwrapped(), f$1.width, f$1.height, Z$2, t$1);
					}
					const q$2 = o$1 && P$2 || V$2, W$2 = x$1 || q$2 ? hr$1 : v$1 ? O$2 : e$1.transform.clipSpaceToPixelsMatrix, $$2 = p$2 && 0 !== a$1.paint.get(o$1 ? "text-halo-width" : "icon-halo-width").constantOr(1);
					let H$2;
					H$2 = p$2 ? c$2.iconsInText ? ma$1(T$2.kind, S$2, b$1, v$1, x$1, q$2, e$1, W$2, N$1, Z$2, z$2, k$2, C$1) : pa$1(T$2.kind, S$2, b$1, v$1, x$1, q$2, e$1, W$2, N$1, Z$2, o$1, z$2, 0, C$1) : _a$1(T$2.kind, S$2, b$1, v$1, x$1, q$2, e$1, W$2, N$1, Z$2, o$1, z$2, C$1);
					const X$1 = {
						program: E$1,
						buffers: u$2,
						uniformValues: H$2,
						projectionData: G$2,
						atlasTexture: D$2,
						atlasTextureIcon: F$2,
						atlasInterpolation: A$2,
						atlasInterpolationIcon: L$2,
						isSDF: p$2,
						hasHalo: $$2
					};
					if (y$1 && c$2.canOverlap) {
						w$2 = !0;
						const e$2 = u$2.segments.get();
						for (const i$2 of e$2) I$2.push({
							segments: new t.aY([i$2]),
							sortKey: i$2.sortKey,
							state: X$1,
							terrainData: R$3
						});
					} else I$2.push({
						segments: u$2.segments,
						sortKey: 0,
						state: X$1,
						terrainData: R$3
					});
				}
				w$2 && I$2.sort(((e$2, t$1) => e$2.sortKey - t$1.sortKey));
				for (const t$1 of I$2) {
					const i$2 = t$1.state;
					if (p$1.activeTexture.set(m$1.TEXTURE0), i$2.atlasTexture.bind(i$2.atlasInterpolation, m$1.CLAMP_TO_EDGE), i$2.atlasTextureIcon && (p$1.activeTexture.set(m$1.TEXTURE1), i$2.atlasTextureIcon && i$2.atlasTextureIcon.bind(i$2.atlasInterpolationIcon, m$1.CLAMP_TO_EDGE)), i$2.isSDF) {
						const r$2 = i$2.uniformValues;
						i$2.hasHalo && (r$2.u_is_halo = 1, fr$1(i$2.buffers, t$1.segments, a$1, e$1, i$2.program, T$1, u$1, d$1, r$2, i$2.projectionData, t$1.terrainData)), r$2.u_is_halo = 0;
					}
					fr$1(i$2.buffers, t$1.segments, a$1, e$1, i$2.program, T$1, u$1, d$1, i$2.uniformValues, i$2.projectionData, t$1.terrainData);
				}
			}
			function fr$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1, h$1) {
				const u$1 = a$1.context;
				r$1.draw(u$1, u$1.gl.TRIANGLES, o$1, s$1, n$1, ei$1.backCCW, l$1, h$1, c$1, i$1.id, e$1.layoutVertexBuffer, e$1.indexBuffer, t$1, i$1.paint, a$1.transform.zoom, e$1.programConfigurations.get(i$1.id), e$1.dynamicLayoutVertexBuffer, e$1.opacityVertexBuffer);
			}
			function gr$1(e$1, i$1, a$1, r$1, o$1) {
				const s$1 = e$1.context, n$1 = s$1.gl, l$1 = ai$1.disabled, c$1 = new Qt$1([n$1.ONE, n$1.ONE], t.bq.transparent, [
					!0,
					!0,
					!0,
					!0
				]), h$1 = i$1.getBucket(a$1);
				if (!h$1) return;
				const u$1 = r$1.key;
				let d$1 = a$1.heatmapFbos.get(u$1);
				d$1 || (d$1 = xr$1(s$1, i$1.tileSize, i$1.tileSize), a$1.heatmapFbos.set(u$1, d$1)), s$1.bindFramebuffer.set(d$1.framebuffer), s$1.viewport.set([
					0,
					0,
					i$1.tileSize,
					i$1.tileSize
				]), s$1.clear({ color: t.bq.transparent });
				const _$2 = h$1.programConfigurations.get(a$1.id), p$1 = e$1.useProgram("heatmap", _$2, !o$1), m$1 = e$1.transform.getProjectionData({
					overscaledTileID: i$1.tileID,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				}), f$1 = e$1.style.map.terrain.getTerrainData(r$1);
				p$1.draw(s$1, n$1.TRIANGLES, ti$1.disabled, l$1, c$1, ei$1.disabled, Qi$1(i$1, e$1.transform.zoom, a$1.paint.get("heatmap-intensity"), 1), f$1, m$1, a$1.id, h$1.layoutVertexBuffer, h$1.indexBuffer, h$1.segments, a$1.paint, e$1.transform.zoom, _$2);
			}
			function vr(e$1, t$1, i$1, a$1, r$1) {
				const o$1 = e$1.context, s$1 = o$1.gl, n$1 = e$1.transform;
				o$1.setColorMode(e$1.colorModeForRenderPass());
				const l$1 = br(o$1, t$1), c$1 = i$1.key, h$1 = t$1.heatmapFbos.get(c$1);
				if (!h$1) return;
				o$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, h$1.colorAttachment.get()), o$1.activeTexture.set(s$1.TEXTURE1), l$1.bind(s$1.LINEAR, s$1.CLAMP_TO_EDGE);
				const u$1 = n$1.getProjectionData({
					overscaledTileID: i$1,
					applyTerrainMatrix: r$1,
					applyGlobeMatrix: !a$1
				});
				e$1.useProgram("heatmapTexture").draw(o$1, s$1.TRIANGLES, ti$1.disabled, ai$1.disabled, e$1.colorModeForRenderPass(), ei$1.disabled, Ji$1(e$1, t$1, 0, 1), null, u$1, t$1.id, e$1.rasterBoundsBuffer, e$1.quadTriangleIndexBuffer, e$1.rasterBoundsSegments, t$1.paint, n$1.zoom), h$1.destroy(), t$1.heatmapFbos.delete(c$1);
			}
			function xr$1(e$1, t$1, i$1) {
				var a$1, r$1;
				const o$1 = e$1.gl, s$1 = o$1.createTexture();
				o$1.bindTexture(o$1.TEXTURE_2D, s$1), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_S, o$1.CLAMP_TO_EDGE), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_T, o$1.CLAMP_TO_EDGE), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MIN_FILTER, o$1.LINEAR), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MAG_FILTER, o$1.LINEAR);
				const n$1 = null !== (a$1 = e$1.HALF_FLOAT) && void 0 !== a$1 ? a$1 : o$1.UNSIGNED_BYTE, l$1 = null !== (r$1 = e$1.RGBA16F) && void 0 !== r$1 ? r$1 : o$1.RGBA;
				o$1.texImage2D(o$1.TEXTURE_2D, 0, l$1, t$1, i$1, 0, o$1.RGBA, n$1, null);
				const c$1 = e$1.createFramebuffer(t$1, i$1, !1, !1);
				return c$1.colorAttachment.set(s$1), c$1;
			}
			function br(e$1, i$1) {
				return i$1.colorRampTexture || (i$1.colorRampTexture = new t.T(e$1, i$1.colorRamp, e$1.gl.RGBA)), i$1.colorRampTexture;
			}
			function yr$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
				let c$1 = 256;
				if (o$1.stepInterpolant) {
					const r$2 = i$1.getSource().maxzoom, o$2 = n$1.canonical.z === r$2 ? Math.ceil(1 << e$1.transform.maxZoom - n$1.canonical.z) : 1;
					c$1 = t.ao(t.cf(s$1.maxLineLength / t.a5 * 1024 * o$2), 256, a$1.maxTextureSize);
				}
				return l$1.gradient = t.cg({
					expression: o$1.gradientExpression(),
					evaluationKey: "lineProgress",
					resolution: c$1,
					image: l$1.gradient || void 0,
					clips: s$1.lineClipsArray
				}), l$1.texture ? l$1.texture.update(l$1.gradient) : l$1.texture = new t.T(a$1, l$1.gradient, r$1.RGBA), l$1.version = o$1.gradientVersion, l$1.texture;
			}
			function wr$1(e$1, t$1, i$1, a$1, r$1) {
				e$1.activeTexture.set(t$1.TEXTURE0), i$1.imageAtlasTexture.bind(t$1.LINEAR, t$1.CLAMP_TO_EDGE), a$1.updatePaintBuffers(r$1);
			}
			function Tr$1(e$1, t$1, i$1, a$1, r$1, o$1) {
				(r$1 || e$1.lineAtlas.dirty) && (t$1.activeTexture.set(i$1.TEXTURE0), e$1.lineAtlas.bind(t$1)), a$1.updatePaintBuffers(o$1);
			}
			function Pr$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1) {
				const n$1 = o$1.gradients[r$1.id];
				let l$1 = n$1.texture;
				r$1.gradientVersion !== n$1.version && (l$1 = yr$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1)), i$1.activeTexture.set(a$1.TEXTURE0), l$1.bind(r$1.stepInterpolant ? a$1.NEAREST : a$1.LINEAR, a$1.CLAMP_TO_EDGE);
			}
			function Ir$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
				const c$1 = o$1.gradients[r$1.id];
				let h$1 = c$1.texture;
				r$1.gradientVersion !== c$1.version && (h$1 = yr$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, c$1)), i$1.activeTexture.set(a$1.TEXTURE0), h$1.bind(r$1.stepInterpolant ? a$1.NEAREST : a$1.LINEAR, a$1.CLAMP_TO_EDGE), i$1.activeTexture.set(a$1.TEXTURE1), e$1.lineAtlas.bind(i$1), n$1.updatePaintBuffers(l$1);
			}
			function Cr$1(e$1, t$1, i$1, a$1, r$1) {
				if (!i$1 || !a$1 || !a$1.imageAtlas) return;
				const o$1 = a$1.imageAtlas.patternPositions;
				let s$1 = o$1[i$1.to.toString()], n$1 = o$1[i$1.from.toString()];
				if (!s$1 && n$1 && (s$1 = n$1), !n$1 && s$1 && (n$1 = s$1), !s$1 || !n$1) {
					const e$2 = r$1.getPaintProperty(t$1);
					s$1 = o$1[e$2], n$1 = o$1[e$2];
				}
				s$1 && n$1 && e$1.setConstantPatternPositions(s$1, n$1);
			}
			function Mr$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
				const c$1 = e$1.context.gl, h$1 = "fill-pattern", u$1 = a$1.paint.get(h$1), d$1 = u$1 && u$1.constantOr(1), _$2 = a$1.getCrossfadeParameters();
				let p$1, m$1, f$1, g$2, v$1;
				const x$1 = e$1.transform, b$1 = a$1.paint.get("fill-translate"), y$1 = a$1.paint.get("fill-translate-anchor");
				n$1 ? (m$1 = d$1 && !a$1.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p$1 = c$1.LINES) : (m$1 = d$1 ? "fillPattern" : "fill", p$1 = c$1.TRIANGLES);
				const w$2 = u$1.constantOr(null);
				for (const u$2 of r$1) {
					const r$2 = i$1.getTile(u$2);
					if (d$1 && !r$2.patternsLoaded()) continue;
					const T$1 = r$2.getBucket(a$1);
					if (!T$1) continue;
					const P$2 = T$1.programConfigurations.get(a$1.id), I$2 = e$1.useProgram(m$1, P$2), C$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(u$2);
					d$1 && (e$1.context.activeTexture.set(c$1.TEXTURE0), r$2.imageAtlasTexture.bind(c$1.LINEAR, c$1.CLAMP_TO_EDGE), P$2.updatePaintBuffers(_$2)), Cr$1(P$2, h$1, w$2, r$2, a$1);
					const M$2 = x$1.getProjectionData({
						overscaledTileID: u$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					}), E$1 = t.aP(x$1, r$2, b$1, y$1);
					if (n$1) {
						g$2 = T$1.indexBuffer2, v$1 = T$1.segments2;
						const t$1 = [c$1.drawingBufferWidth, c$1.drawingBufferHeight];
						f$1 = "fillOutlinePattern" === m$1 && d$1 ? $i$1(e$1, _$2, r$2, t$1, E$1) : Wi$1(t$1, E$1);
					} else g$2 = T$1.indexBuffer, v$1 = T$1.segments, f$1 = d$1 ? qi$1(e$1, _$2, r$2, E$1) : { u_fill_translate: E$1 };
					const S$2 = e$1.stencilModeForClipping(u$2);
					I$2.draw(e$1.context, p$1, o$1, S$2, s$1, ei$1.backCCW, f$1, C$1, M$2, a$1.id, T$1.layoutVertexBuffer, g$2, v$1, a$1.paint, e$1.transform.zoom, P$2);
				}
			}
			function Er$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
				const c$1 = e$1.context, h$1 = c$1.gl, u$1 = "fill-extrusion-pattern", d$1 = a$1.paint.get(u$1), _$2 = d$1.constantOr(1), p$1 = a$1.getCrossfadeParameters(), m$1 = a$1.paint.get("fill-extrusion-opacity"), f$1 = d$1.constantOr(null), g$2 = e$1.transform;
				for (const d$2 of r$1) {
					const r$2 = i$1.getTile(d$2), v$1 = r$2.getBucket(a$1);
					if (!v$1) continue;
					const x$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(d$2), b$1 = v$1.programConfigurations.get(a$1.id), y$1 = e$1.useProgram(_$2 ? "fillExtrusionPattern" : "fillExtrusion", b$1);
					_$2 && (e$1.context.activeTexture.set(h$1.TEXTURE0), r$2.imageAtlasTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE), b$1.updatePaintBuffers(p$1));
					const w$2 = g$2.getProjectionData({
						overscaledTileID: d$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					Cr$1(b$1, u$1, f$1, r$2, a$1);
					const T$1 = t.aP(g$2, r$2, a$1.paint.get("fill-extrusion-translate"), a$1.paint.get("fill-extrusion-translate-anchor")), P$2 = a$1.paint.get("fill-extrusion-vertical-gradient"), I$2 = _$2 ? Vi$1(e$1, P$2, m$1, T$1, d$2, p$1, r$2) : Ui$1(e$1, P$2, m$1, T$1);
					y$1.draw(c$1, c$1.gl.TRIANGLES, o$1, s$1, n$1, ei$1.backCCW, I$2, x$1, w$2, a$1.id, v$1.layoutVertexBuffer, v$1.indexBuffer, v$1.segments, a$1.paint, e$1.transform.zoom, b$1, e$1.style.map.terrain && v$1.centroidVertexBuffer);
				}
			}
			function Sr$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1) {
				var c$1;
				const h$1 = e$1.style.projection, u$1 = e$1.context, d$1 = e$1.transform, _$2 = u$1.gl, p$1 = [`#define NUM_ILLUMINATION_SOURCES ${i$1.paint.get("hillshade-highlight-color").values.length}`], m$1 = e$1.useProgram("hillshade", null, !1, p$1), f$1 = !e$1.options.moving;
				for (const p$2 of a$1) {
					const a$2 = t$1.getTile(p$2), g$2 = a$2.fbo;
					if (!g$2) continue;
					const v$1 = h$1.getMeshFromTileID(u$1, p$2.canonical, n$1, !0, "raster"), x$1 = null === (c$1 = e$1.style.map.terrain) || void 0 === c$1 ? void 0 : c$1.getTerrainData(p$2);
					u$1.activeTexture.set(_$2.TEXTURE0), _$2.bindTexture(_$2.TEXTURE_2D, g$2.colorAttachment.get());
					const b$1 = d$1.getProjectionData({
						overscaledTileID: p$2,
						aligned: f$1,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(u$1, _$2.TRIANGLES, o$1, r$1[p$2.overscaledZ], s$1, ei$1.backCCW, ea$1(e$1, a$2, i$1), x$1, b$1, i$1.id, v$1.vertexBuffer, v$1.indexBuffer, v$1.segments);
				}
			}
			function Rr$1(e$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1, c$1) {
				var h$1;
				const u$1 = e$1.style.projection, d$1 = e$1.context, _$2 = e$1.transform, p$1 = d$1.gl, m$1 = e$1.useProgram("colorRelief"), f$1 = !e$1.options.moving;
				let g$2 = !0, v$1 = 0;
				for (const x$1 of r$1) {
					const r$2 = i$1.getTile(x$1), b$1 = r$2.dem;
					if (g$2) {
						const e$2 = p$1.getParameter(p$1.MAX_TEXTURE_SIZE), { elevationTexture: t$1, colorTexture: i$2 } = a$1.getColorRampTextures(d$1, e$2, b$1.getUnpackVector());
						d$1.activeTexture.set(p$1.TEXTURE1), t$1.bind(p$1.NEAREST, p$1.CLAMP_TO_EDGE), d$1.activeTexture.set(p$1.TEXTURE4), i$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE), g$2 = !1, v$1 = t$1.size[0];
					}
					if (!b$1 || !b$1.data) continue;
					const y$1 = b$1.stride, w$2 = b$1.getPixels();
					if (d$1.activeTexture.set(p$1.TEXTURE0), d$1.pixelStoreUnpackPremultiplyAlpha.set(!1), r$2.demTexture = r$2.demTexture || e$1.getTileTexture(y$1), r$2.demTexture) {
						const e$2 = r$2.demTexture;
						e$2.update(w$2, { premultiply: !1 }), e$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					} else r$2.demTexture = new t.T(d$1, w$2, p$1.RGBA, { premultiply: !1 }), r$2.demTexture.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					const T$1 = u$1.getMeshFromTileID(d$1, x$1.canonical, l$1, !0, "raster"), P$2 = null === (h$1 = e$1.style.map.terrain) || void 0 === h$1 ? void 0 : h$1.getTerrainData(x$1), I$2 = _$2.getProjectionData({
						overscaledTileID: x$1,
						aligned: f$1,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(d$1, p$1.TRIANGLES, s$1, o$1[x$1.overscaledZ], n$1, ei$1.backCCW, aa$1(a$1, r$2.dem, v$1), P$2, I$2, a$1.id, T$1.vertexBuffer, T$1.indexBuffer, T$1.segments);
				}
			}
			const zr$1 = [
				new t.P(0, 0),
				new t.P(t.a5, 0),
				new t.P(t.a5, t.a5),
				new t.P(0, t.a5)
			];
			function Dr$1(e$1, t$1, i$1, a$1, r$1, o$1, s$1, n$1, l$1 = !1, c$1 = !1) {
				const h$1 = a$1[a$1.length - 1].overscaledZ, u$1 = e$1.context, d$1 = u$1.gl, _$2 = e$1.useProgram("raster"), p$1 = e$1.transform, m$1 = e$1.style.projection, f$1 = e$1.colorModeForRenderPass(), g$2 = !e$1.options.moving, v$1 = i$1.paint.get("raster-opacity"), x$1 = i$1.paint.get("raster-resampling"), b$1 = i$1.paint.get("raster-fade-duration"), y$1 = !!e$1.style.map.terrain;
				for (const w$2 of a$1) {
					const a$2 = e$1.getDepthModeForSublayer(w$2.overscaledZ - h$1, 1 === v$1 ? ti$1.ReadWrite : ti$1.ReadOnly, d$1.LESS), T$1 = t$1.getTile(w$2), P$2 = "nearest" === x$1 ? d$1.NEAREST : d$1.LINEAR;
					u$1.activeTexture.set(d$1.TEXTURE0), T$1.texture.bind(P$2, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), u$1.activeTexture.set(d$1.TEXTURE1);
					const { parentTile: I$2, parentScaleBy: C$1, parentTopLeft: M$2, fadeValues: E$1 } = Ar$1(T$1, t$1, b$1, y$1);
					T$1.fadeOpacity = E$1.tileOpacity, I$2 ? (I$2.fadeOpacity = E$1.parentTileOpacity, I$2.texture.bind(P$2, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST)) : T$1.texture.bind(P$2, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), T$1.texture.useMipmap && u$1.extTextureFilterAnisotropic && e$1.transform.pitch > 20 && d$1.texParameterf(d$1.TEXTURE_2D, u$1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u$1.extTextureFilterAnisotropicMax);
					const S$2 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(w$2), R$3 = p$1.getProjectionData({
						overscaledTileID: w$2,
						aligned: g$2,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					}), z$2 = ua$1(M$2, C$1, E$1.fadeMix, i$1, n$1), D$2 = m$1.getMeshFromTileID(u$1, w$2.canonical, o$1, s$1, "raster");
					_$2.draw(u$1, d$1.TRIANGLES, a$2, r$1 ? r$1[w$2.overscaledZ] : ai$1.disabled, f$1, l$1 ? ei$1.frontCCW : ei$1.backCCW, z$2, S$2, R$3, i$1.id, D$2.vertexBuffer, D$2.indexBuffer, D$2.segments);
				}
			}
			function Ar$1(e$1, i$1, a$1, r$1) {
				const o$1 = {
					parentTile: null,
					parentScaleBy: 1,
					parentTopLeft: [0, 0],
					fadeValues: {
						tileOpacity: 1,
						parentTileOpacity: 1,
						fadeMix: {
							opacity: 1,
							mix: 0
						}
					}
				};
				if (0 === a$1 || r$1) return o$1;
				if (e$1.fadingParentID) {
					const r$2 = i$1.getLoadedTile(e$1.fadingParentID);
					if (!r$2) return o$1;
					const s$1 = Math.pow(2, r$2.tileID.overscaledZ - e$1.tileID.overscaledZ);
					return {
						parentTile: r$2,
						parentScaleBy: s$1,
						parentTopLeft: [e$1.tileID.canonical.x * s$1 % 1, e$1.tileID.canonical.y * s$1 % 1],
						fadeValues: function(e$2, i$2, a$2) {
							const r$3 = c(), o$2 = (r$3 - i$2.timeAdded) / a$2, s$2 = e$2.fadingDirection === ue$1.Incoming, n$1 = t.ao((r$3 - e$2.timeAdded) / a$2, 0, 1), l$1 = t.ao(1 - o$2, 0, 1), h$1 = s$2 ? n$1 : l$1;
							return {
								tileOpacity: h$1,
								parentTileOpacity: s$2 ? l$1 : n$1,
								fadeMix: {
									opacity: 1,
									mix: 1 - h$1
								}
							};
						}(e$1, r$2, a$1)
					};
				}
				if (e$1.selfFading) return {
					parentTile: null,
					parentScaleBy: 1,
					parentTopLeft: [0, 0],
					fadeValues: function(e$2, i$2) {
						const a$2 = (c() - e$2.timeAdded) / i$2, r$2 = t.ao(a$2, 0, 1);
						return {
							tileOpacity: r$2,
							fadeMix: {
								opacity: r$2,
								mix: 0
							}
						};
					}(e$1, a$1)
				};
				return o$1;
			}
			const Lr$1 = new t.bq(1, 0, 0, 1), kr$1 = new t.bq(0, 1, 0, 1), Fr$1 = new t.bq(0, 0, 1, 1), Br$1 = new t.bq(1, 0, 1, 1), Or$1 = new t.bq(0, 1, 1, 1);
			function jr$1(e$1, t$1, i$1, a$1) {
				Zr$1(e$1, 0, t$1 + i$1 / 2, e$1.transform.width, i$1, a$1);
			}
			function Nr$1(e$1, t$1, i$1, a$1) {
				Zr$1(e$1, t$1 - i$1 / 2, 0, i$1, e$1.transform.height, a$1);
			}
			function Zr$1(e$1, t$1, i$1, a$1, r$1, o$1) {
				const s$1 = e$1.context, n$1 = s$1.gl;
				n$1.enable(n$1.SCISSOR_TEST), n$1.scissor(t$1 * e$1.pixelRatio, i$1 * e$1.pixelRatio, a$1 * e$1.pixelRatio, r$1 * e$1.pixelRatio), s$1.clear({ color: o$1 }), n$1.disable(n$1.SCISSOR_TEST);
			}
			function Gr$1(e$1, i$1, a$1) {
				const r$1 = e$1.context, o$1 = r$1.gl, s$1 = e$1.useProgram("debug"), n$1 = ti$1.disabled, l$1 = ai$1.disabled, c$1 = e$1.colorModeForRenderPass(), h$1 = "$debug", u$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(a$1);
				r$1.activeTexture.set(o$1.TEXTURE0);
				const d$1 = i$1.getTileByID(a$1.key).latestRawTileData, _$2 = Math.floor((d$1 && d$1.byteLength || 0) / 1024), p$1 = i$1.getTile(a$1).tileSize, m$1 = 512 / Math.min(p$1, 512) * (a$1.overscaledZ / e$1.transform.zoom) * .5;
				let f$1 = a$1.canonical.toString();
				a$1.overscaledZ !== a$1.canonical.z && (f$1 += ` => ${a$1.overscaledZ}`), function(e$2, t$1) {
					e$2.initDebugOverlayCanvas();
					const i$2 = e$2.debugOverlayCanvas, a$2 = e$2.context.gl, r$2 = e$2.debugOverlayCanvas.getContext("2d");
					r$2.clearRect(0, 0, i$2.width, i$2.height), r$2.shadowColor = "white", r$2.shadowBlur = 2, r$2.lineWidth = 1.5, r$2.strokeStyle = "white", r$2.textBaseline = "top", r$2.font = "bold 36px Open Sans, sans-serif", r$2.fillText(t$1, 5, 5), r$2.strokeText(t$1, 5, 5), e$2.debugOverlayTexture.update(i$2), e$2.debugOverlayTexture.bind(a$2.LINEAR, a$2.CLAMP_TO_EDGE);
				}(e$1, `${f$1} ${_$2}kB`);
				const g$2 = e$1.transform.getProjectionData({
					overscaledTileID: a$1,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				});
				s$1.draw(r$1, o$1.TRIANGLES, n$1, l$1, Qt$1.alphaBlended, ei$1.disabled, Yi$1(t.bq.transparent, m$1), null, g$2, h$1, e$1.debugBuffer, e$1.quadTriangleIndexBuffer, e$1.debugSegments), s$1.draw(r$1, o$1.LINE_STRIP, n$1, l$1, c$1, ei$1.disabled, Yi$1(t.bq.red), u$1, g$2, h$1, e$1.debugBuffer, e$1.tileBorderIndexBuffer, e$1.debugSegments);
			}
			function Ur$1(e$1, t$1, i$1, a$1) {
				const { isRenderingGlobe: r$1 } = a$1, o$1 = e$1.context, s$1 = o$1.gl, n$1 = e$1.transform, l$1 = e$1.colorModeForRenderPass(), c$1 = e$1.getDepthModeFor3D(), h$1 = e$1.useProgram("terrain");
				o$1.bindFramebuffer.set(null), o$1.viewport.set([
					0,
					0,
					e$1.width,
					e$1.height
				]);
				for (const a$2 of i$1) {
					const i$2 = t$1.getTerrainMesh(a$2.tileID), u$1 = e$1.renderToTexture.getTexture(a$2), d$1 = t$1.getTerrainData(a$2.tileID);
					o$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, u$1.texture);
					const m$1 = Oi$1(t$1.getMeshFrameDelta(n$1.zoom), n$1.calculateFogMatrix(a$2.tileID.toUnwrapped()), e$1.style.sky, n$1.pitch, r$1), f$1 = n$1.getProjectionData({
						overscaledTileID: a$2.tileID,
						applyTerrainMatrix: !1,
						applyGlobeMatrix: !0
					});
					h$1.draw(o$1, s$1.TRIANGLES, c$1, ai$1.disabled, l$1, ei$1.backCCW, m$1, d$1, f$1, "terrain", i$2.vertexBuffer, i$2.indexBuffer, i$2.segments);
				}
			}
			function Vr$1(e$1, i$1) {
				if (!i$1.mesh) {
					const a$1 = new t.aX();
					a$1.emplaceBack(-1, -1), a$1.emplaceBack(1, -1), a$1.emplaceBack(1, 1), a$1.emplaceBack(-1, 1);
					const r$1 = new t.aZ();
					r$1.emplaceBack(0, 1, 2), r$1.emplaceBack(0, 2, 3), i$1.mesh = new kt$1(e$1.createVertexBuffer(a$1, Ft$1.members), e$1.createIndexBuffer(r$1), t.aY.simpleSegment(0, 0, a$1.length, r$1.length));
				}
				return i$1.mesh;
			}
			class qr$1 {
				constructor(e$1, i$1) {
					this.context = new nr$1(e$1), this.transform = i$1, this._tileTextures = {}, this.terrainFacilitator = {
						dirty: !0,
						matrix: t.as(new Float64Array(16)),
						renderTime: 0
					}, this.setup(), this.numSublayers = ke$1.maxOverzooming + ke$1.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new zt$1();
				}
				resize(e$1, t$1, i$1) {
					if (this.width = Math.floor(e$1 * i$1), this.height = Math.floor(t$1 * i$1), this.pixelRatio = i$1, this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.style) for (const e$2 of this.style._order) this.style._layers[e$2].resize();
				}
				setup() {
					const e$1 = this.context, i$1 = new t.aX();
					i$1.emplaceBack(0, 0), i$1.emplaceBack(t.a5, 0), i$1.emplaceBack(0, t.a5), i$1.emplaceBack(t.a5, t.a5), this.tileExtentBuffer = e$1.createVertexBuffer(i$1, Ft$1.members), this.tileExtentSegments = t.aY.simpleSegment(0, 0, 4, 2);
					const a$1 = new t.aX();
					a$1.emplaceBack(0, 0), a$1.emplaceBack(t.a5, 0), a$1.emplaceBack(0, t.a5), a$1.emplaceBack(t.a5, t.a5), this.debugBuffer = e$1.createVertexBuffer(a$1, Ft$1.members), this.debugSegments = t.aY.simpleSegment(0, 0, 4, 5);
					const r$1 = new t.ci();
					r$1.emplaceBack(0, 0, 0, 0), r$1.emplaceBack(t.a5, 0, t.a5, 0), r$1.emplaceBack(0, t.a5, 0, t.a5), r$1.emplaceBack(t.a5, t.a5, t.a5, t.a5), this.rasterBoundsBuffer = e$1.createVertexBuffer(r$1, Fi$1.members), this.rasterBoundsSegments = t.aY.simpleSegment(0, 0, 4, 2);
					const o$1 = new t.aX();
					o$1.emplaceBack(0, 0), o$1.emplaceBack(t.a5, 0), o$1.emplaceBack(0, t.a5), o$1.emplaceBack(t.a5, t.a5), this.rasterBoundsBufferPosOnly = e$1.createVertexBuffer(o$1, Ft$1.members), this.rasterBoundsSegmentsPosOnly = t.aY.simpleSegment(0, 0, 4, 5);
					const s$1 = new t.aX();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(1, 0), s$1.emplaceBack(0, 1), s$1.emplaceBack(1, 1), this.viewportBuffer = e$1.createVertexBuffer(s$1, Ft$1.members), this.viewportSegments = t.aY.simpleSegment(0, 0, 4, 2);
					const n$1 = new t.cj();
					n$1.emplaceBack(0), n$1.emplaceBack(1), n$1.emplaceBack(3), n$1.emplaceBack(2), n$1.emplaceBack(0), this.tileBorderIndexBuffer = e$1.createIndexBuffer(n$1);
					const l$1 = new t.aZ();
					l$1.emplaceBack(1, 0, 2), l$1.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e$1.createIndexBuffer(l$1);
					const c$1 = this.context.gl;
					this.stencilClearMode = new ai$1({
						func: c$1.ALWAYS,
						mask: 0
					}, 0, 255, c$1.ZERO, c$1.ZERO, c$1.ZERO), this.tileExtentMesh = new kt$1(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
				}
				clearStencil() {
					const e$1 = this.context, i$1 = e$1.gl;
					this.nextStencilID = 1, this.currentStencilSource = void 0;
					const a$1 = t.N();
					t.c8(a$1, 0, this.width, this.height, 0, 0, 1), t.Q(a$1, a$1, [
						i$1.drawingBufferWidth,
						i$1.drawingBufferHeight,
						0
					]);
					const r$1 = {
						mainMatrix: a$1,
						tileMercatorCoords: [
							0,
							0,
							1,
							1
						],
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: a$1
					};
					this.useProgram("clippingMask", null, !0).draw(e$1, i$1.TRIANGLES, ti$1.disabled, this.stencilClearMode, Qt$1.disabled, ei$1.disabled, null, null, r$1, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
				}
				_renderTileClippingMasks(e$1, t$1, i$1) {
					if (this.currentStencilSource === e$1.source || !e$1.isTileClipped() || !t$1 || !t$1.length) return;
					this.currentStencilSource = e$1.source, this.nextStencilID + t$1.length > 256 && this.clearStencil();
					const a$1 = this.context;
					a$1.setColorMode(Qt$1.disabled), a$1.setDepthMode(ti$1.disabled);
					const r$1 = {};
					for (const e$2 of t$1) r$1[e$2.key] = this.nextStencilID++;
					this._renderTileMasks(r$1, t$1, i$1, !0), this._renderTileMasks(r$1, t$1, i$1, !1), this._tileClippingMaskIDs = r$1;
				}
				_renderTileMasks(e$1, t$1, i$1, a$1) {
					const r$1 = this.context, o$1 = r$1.gl, s$1 = this.style.projection, n$1 = this.transform, l$1 = this.useProgram("clippingMask");
					for (const c$1 of t$1) {
						const t$2 = e$1[c$1.key], h$1 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c$1), u$1 = s$1.getMeshFromTileID(this.context, c$1.canonical, a$1, !0, "stencil"), d$1 = n$1.getProjectionData({
							overscaledTileID: c$1,
							applyGlobeMatrix: !i$1,
							applyTerrainMatrix: !0
						});
						l$1.draw(r$1, o$1.TRIANGLES, ti$1.disabled, new ai$1({
							func: o$1.ALWAYS,
							mask: 0
						}, t$2, 255, o$1.KEEP, o$1.KEEP, o$1.REPLACE), Qt$1.disabled, i$1 ? ei$1.disabled : ei$1.backCCW, null, h$1, d$1, "$clipping", u$1.vertexBuffer, u$1.indexBuffer, u$1.segments);
					}
				}
				_renderTilesDepthBuffer() {
					const e$1 = this.context, t$1 = e$1.gl, i$1 = this.style.projection, a$1 = this.transform, r$1 = this.useProgram("depth"), o$1 = this.getDepthModeFor3D(), s$1 = Ce$1(a$1, { tileSize: a$1.tileSize });
					for (const n$1 of s$1) {
						const s$2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n$1), l$1 = i$1.getMeshFromTileID(this.context, n$1.canonical, !0, !0, "raster"), c$1 = a$1.getProjectionData({
							overscaledTileID: n$1,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						});
						r$1.draw(e$1, t$1.TRIANGLES, o$1, ai$1.disabled, Qt$1.disabled, ei$1.backCCW, null, s$2, c$1, "$clipping", l$1.vertexBuffer, l$1.indexBuffer, l$1.segments);
					}
				}
				stencilModeFor3D() {
					this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
					const e$1 = this.nextStencilID++, t$1 = this.context.gl;
					return new ai$1({
						func: t$1.NOTEQUAL,
						mask: 255
					}, e$1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				stencilModeForClipping(e$1) {
					const t$1 = this.context.gl;
					return new ai$1({
						func: t$1.EQUAL,
						mask: 255
					}, this._tileClippingMaskIDs[e$1.key], 0, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				getStencilConfigForOverlapAndUpdateStencilID(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), a$1 = i$1[i$1.length - 1].overscaledZ, r$1 = i$1[0].overscaledZ - a$1 + 1;
					if (r$1 > 1) {
						this.currentStencilSource = void 0, this.nextStencilID + r$1 > 256 && this.clearStencil();
						const e$2 = {};
						for (let i$2 = 0; i$2 < r$1; i$2++) e$2[i$2 + a$1] = new ai$1({
							func: t$1.GEQUAL,
							mask: 255
						}, i$2 + this.nextStencilID, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID += r$1, [e$2, i$1];
					}
					return [{ [a$1]: ai$1.disabled }, i$1];
				}
				stencilConfigForOverlapTwoPass(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), a$1 = i$1[i$1.length - 1].overscaledZ, r$1 = i$1[0].overscaledZ - a$1 + 1;
					if (this.clearStencil(), r$1 > 1) {
						const e$2 = {}, o$1 = {};
						for (let i$2 = 0; i$2 < r$1; i$2++) e$2[i$2 + a$1] = new ai$1({
							func: t$1.GREATER,
							mask: 255
						}, r$1 + 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE), o$1[i$2 + a$1] = new ai$1({
							func: t$1.GREATER,
							mask: 255
						}, 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID = 2 * r$1 + 1, [
							e$2,
							o$1,
							i$1
						];
					}
					return this.nextStencilID = 3, [
						{ [a$1]: new ai$1({
							func: t$1.GREATER,
							mask: 255
						}, 2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						{ [a$1]: new ai$1({
							func: t$1.GREATER,
							mask: 255
						}, 1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						i$1
					];
				}
				colorModeForRenderPass() {
					const e$1 = this.context.gl;
					if (this._showOverdrawInspector) {
						const i$1 = 1 / 8;
						return new Qt$1([e$1.CONSTANT_COLOR, e$1.ONE], new t.bq(i$1, i$1, i$1, 0), [
							!0,
							!0,
							!0,
							!0
						]);
					}
					return "opaque" === this.renderPass ? Qt$1.unblended : Qt$1.alphaBlended;
				}
				getDepthModeForSublayer(e$1, t$1, i$1) {
					if (!this.opaquePassEnabledForLayer()) return ti$1.disabled;
					const a$1 = 1 - ((1 + this.currentLayer) * this.numSublayers + e$1) * this.depthEpsilon;
					return new ti$1(i$1 || this.context.gl.LEQUAL, t$1, [a$1, a$1]);
				}
				getDepthModeFor3D() {
					return new ti$1(this.context.gl.LEQUAL, ti$1.ReadWrite, this.depthRangeFor3D);
				}
				opaquePassEnabledForLayer() {
					return this.currentLayer < this.opaquePassCutoff;
				}
				render(e$1, i$1) {
					var a$1, r$1;
					this.style = e$1, this.options = i$1, this.lineAtlas = e$1.lineAtlas, this.imageManager = e$1.imageManager, this.glyphManager = e$1.glyphManager, this.symbolFadeChange = e$1.placement.symbolFadeChange(c()), this.imageManager.beginFrame();
					const o$1 = this.style._order, s$1 = this.style.tileManagers, n$1 = {}, l$1 = {}, h$1 = {}, u$1 = {
						isRenderingToTexture: !1,
						isRenderingGlobe: (null === (a$1 = e$1.projection) || void 0 === a$1 ? void 0 : a$1.transitionState) > 0
					};
					for (const e$2 in s$1) {
						const t$1 = s$1[e$2];
						t$1.used && t$1.prepare(this.context), n$1[e$2] = t$1.getVisibleCoordinates(!1), l$1[e$2] = n$1[e$2].slice().reverse(), h$1[e$2] = t$1.getVisibleCoordinates(!0).reverse();
					}
					this.opaquePassCutoff = Infinity;
					for (let e$2 = 0; e$2 < o$1.length; e$2++) if (this.style._layers[o$1[e$2]].is3D()) {
						this.opaquePassCutoff = e$2;
						break;
					}
					this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
					for (const e$2 of o$1) {
						const t$1 = this.style._layers[e$2];
						if (!t$1.hasOffscreenPass() || t$1.isHidden(this.transform.zoom)) continue;
						const i$2 = l$1[t$1.source];
						("custom" === t$1.type || i$2.length) && this.renderLayer(this, s$1[t$1.source], t$1, i$2, u$1);
					}
					if (null === (r$1 = this.style.projection) || void 0 === r$1 || r$1.updateGPUdependent({
						context: this.context,
						useProgram: (e$2) => this.useProgram(e$2)
					}), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.bindFramebuffer.set(null), this.context.clear({
						color: i$1.showOverdrawInspector ? t.bq.black : t.bq.transparent,
						depth: 1
					}), this.clearStencil(), this.style.sky && function(e$2, t$1) {
						const i$2 = e$2.context, a$2 = i$2.gl, r$2 = ((e$3, t$2, i$3) => {
							const a$3 = Math.cos(t$2.rollInRadians), r$3 = Math.sin(t$2.rollInRadians), o$3 = ge(t$2), s$3 = t$2.getProjectionData({
								overscaledTileID: null,
								applyGlobeMatrix: !0,
								applyTerrainMatrix: !0
							}).projectionTransition;
							return {
								u_sky_color: e$3.properties.get("sky-color"),
								u_horizon_color: e$3.properties.get("horizon-color"),
								u_horizon: [(t$2.width / 2 - o$3 * r$3) * i$3, (t$2.height / 2 + o$3 * a$3) * i$3],
								u_horizon_normal: [-r$3, a$3],
								u_sky_horizon_blend: e$3.properties.get("sky-horizon-blend") * t$2.height / 2 * i$3,
								u_sky_blend: s$3
							};
						})(t$1, e$2.style.map.transform, e$2.pixelRatio), o$2 = new ti$1(a$2.LEQUAL, ti$1.ReadWrite, [0, 1]), s$2 = ai$1.disabled, n$2 = e$2.colorModeForRenderPass(), l$2 = e$2.useProgram("sky"), c$1 = Vr$1(i$2, t$1);
						l$2.draw(i$2, a$2.TRIANGLES, o$2, s$2, n$2, ei$1.disabled, r$2, null, void 0, "sky", c$1.vertexBuffer, c$1.indexBuffer, c$1.segments);
					}(this, this.style.sky), this._showOverdrawInspector = i$1.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e$1._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = o$1.length - 1; this.currentLayer >= 0; this.currentLayer--) {
						const e$2 = this.style._layers[o$1[this.currentLayer]], t$1 = s$1[e$2.source], i$2 = n$1[e$2.source];
						this._renderTileClippingMasks(e$2, i$2, !1), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					this.renderPass = "translucent";
					let d$1 = !1;
					for (this.currentLayer = 0; this.currentLayer < o$1.length; this.currentLayer++) {
						const e$2 = this.style._layers[o$1[this.currentLayer]], t$1 = s$1[e$2.source];
						if (this.renderToTexture && this.renderToTexture.renderLayer(e$2, u$1)) continue;
						this.opaquePassEnabledForLayer() || d$1 || (d$1 = !0, u$1.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
						const i$2 = ("symbol" === e$2.type ? h$1 : l$1)[e$2.source];
						this._renderTileClippingMasks(e$2, n$1[e$2.source], !!this.renderToTexture), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					if (u$1.isRenderingGlobe && function(e$2, i$2, a$2) {
						const r$2 = e$2.context, o$2 = r$2.gl, s$2 = e$2.useProgram("atmosphere"), n$2 = new ti$1(o$2.LEQUAL, ti$1.ReadOnly, [0, 1]), l$2 = e$2.transform, c$1 = function(e$3, i$3) {
							const a$3 = e$3.properties.get("position"), r$3 = [
								-a$3.x,
								-a$3.y,
								-a$3.z
							], o$3 = t.as(new Float64Array(16));
							return "map" === e$3.properties.get("anchor") && (t.bh(o$3, o$3, i$3.rollInRadians), t.bi(o$3, o$3, -i$3.pitchInRadians), t.bh(o$3, o$3, i$3.bearingInRadians), t.bi(o$3, o$3, i$3.center.lat * Math.PI / 180), t.bK(o$3, o$3, -i$3.center.lng * Math.PI / 180)), t.ch(r$3, r$3, o$3), r$3;
						}(a$2, e$2.transform), h$2 = l$2.getProjectionData({
							overscaledTileID: null,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						}), u$2 = i$2.properties.get("atmosphere-blend") * h$2.projectionTransition;
						if (0 === u$2) return;
						const d$2 = fi(l$2.worldSize, l$2.center.lat), _$2 = l$2.inverseProjectionMatrix, p$1 = new Float64Array(4);
						p$1[3] = 1, t.aI(p$1, p$1, l$2.modelViewProjectionMatrix), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1, t.aI(p$1, p$1, _$2), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1;
						const m$1 = ((e$3, t$1, i$3, a$3, r$3) => ({
							u_sun_pos: e$3,
							u_atmosphere_blend: t$1,
							u_globe_position: i$3,
							u_globe_radius: a$3,
							u_inv_proj_matrix: r$3
						}))(c$1, u$2, [
							p$1[0],
							p$1[1],
							p$1[2]
						], d$2, _$2), f$1 = Vr$1(r$2, i$2);
						s$2.draw(r$2, o$2.TRIANGLES, n$2, ai$1.disabled, Qt$1.alphaBlended, ei$1.disabled, m$1, null, null, "atmosphere", f$1.vertexBuffer, f$1.indexBuffer, f$1.segments);
					}(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
						const e$2 = function(e$3, t$1) {
							let i$2 = null;
							const a$2 = Object.values(e$3._layers).flatMap(((i$3) => i$3.source && !i$3.isHidden(t$1) ? [e$3.tileManagers[i$3.source]] : [])), r$2 = a$2.filter(((e$4) => "vector" === e$4.getSource().type)), o$2 = a$2.filter(((e$4) => "vector" !== e$4.getSource().type)), s$2 = (e$4) => {
								(!i$2 || i$2.getSource().maxzoom < e$4.getSource().maxzoom) && (i$2 = e$4);
							};
							return r$2.forEach(((e$4) => s$2(e$4))), i$2 || o$2.forEach(((e$4) => s$2(e$4))), i$2;
						}(this.style, this.transform.zoom);
						e$2 && function(e$3, t$1, i$2) {
							for (let a$2 = 0; a$2 < i$2.length; a$2++) Gr$1(e$3, t$1, i$2[a$2]);
						}(this, e$2, e$2.getVisibleCoordinates());
					}
					this.options.showPadding && function(e$2) {
						const t$1 = e$2.transform.padding;
						jr$1(e$2, e$2.transform.height - (t$1.top || 0), 3, Lr$1), jr$1(e$2, t$1.bottom || 0, 3, kr$1), Nr$1(e$2, t$1.left || 0, 3, Fr$1), Nr$1(e$2, e$2.transform.width - (t$1.right || 0), 3, Br$1);
						const i$2 = e$2.transform.centerPoint;
						(function(e$3, t$2, i$3, a$2) {
							Zr$1(e$3, t$2 - 1, i$3 - 10, 2, 20, a$2), Zr$1(e$3, t$2 - 10, i$3 - 1, 20, 2, a$2);
						})(e$2, i$2.x, e$2.transform.height - i$2.y, Or$1);
					}(this), this.context.setDefault();
				}
				maybeDrawDepthAndCoords(e$1) {
					if (!this.style || !this.style.map || !this.style.map.terrain) return;
					const i$1 = this.terrainFacilitator.matrix, a$1 = this.transform.modelViewProjectionMatrix;
					let r$1 = this.terrainFacilitator.dirty;
					r$1 || (r$1 = e$1 ? !t.ck(i$1, a$1) : !t.cl(i$1, a$1)), r$1 || (r$1 = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), r$1 && (t.cm(i$1, a$1), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(e$2, i$2) {
						const a$2 = e$2.context, r$2 = a$2.gl, o$1 = e$2.transform, s$1 = Qt$1.unblended, n$1 = new ti$1(r$2.LEQUAL, ti$1.ReadWrite, [0, 1]), l$1 = i$2.tileManager.getRenderableTiles(), c$1 = e$2.useProgram("terrainDepth");
						a$2.bindFramebuffer.set(i$2.getFramebuffer("depth").framebuffer), a$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), a$2.clear({
							color: t.bq.transparent,
							depth: 1
						});
						for (const e$3 of l$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), l$2 = i$2.getTerrainData(e$3.tileID), h$1 = o$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							}), u$1 = { u_ele_delta: i$2.getMeshFrameDelta(o$1.zoom) };
							c$1.draw(a$2, r$2.TRIANGLES, n$1, ai$1.disabled, s$1, ei$1.backCCW, u$1, l$2, h$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments);
						}
						a$2.bindFramebuffer.set(null), a$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain), function(e$2, i$2) {
						const a$2 = e$2.context, r$2 = a$2.gl, o$1 = e$2.transform, s$1 = Qt$1.unblended, n$1 = new ti$1(r$2.LEQUAL, ti$1.ReadWrite, [0, 1]), l$1 = i$2.getCoordsTexture(), c$1 = i$2.tileManager.getRenderableTiles(), h$1 = e$2.useProgram("terrainCoords");
						a$2.bindFramebuffer.set(i$2.getFramebuffer("coords").framebuffer), a$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), a$2.clear({
							color: t.bq.transparent,
							depth: 1
						}), i$2.coordsIndex = [];
						for (const e$3 of c$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), c$2 = i$2.getTerrainData(e$3.tileID);
							a$2.activeTexture.set(r$2.TEXTURE0), r$2.bindTexture(r$2.TEXTURE_2D, l$1.texture);
							const u$1 = {
								u_terrain_coords_id: (255 - i$2.coordsIndex.length) / 255,
								u_texture: 0,
								u_ele_delta: i$2.getMeshFrameDelta(o$1.zoom)
							}, d$1 = o$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							});
							h$1.draw(a$2, r$2.TRIANGLES, n$1, ai$1.disabled, s$1, ei$1.backCCW, u$1, c$2, d$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments), i$2.coordsIndex.push(e$3.tileID.key);
						}
						a$2.bindFramebuffer.set(null), a$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain));
				}
				renderLayer(e$1, i$1, a$1, r$1, o$1) {
					a$1.isHidden(this.transform.zoom) || ("background" === a$1.type || "custom" === a$1.type || (r$1 || []).length) && (this.id = a$1.id, t.cn(a$1) ? function(e$2, i$2, a$2, r$2, o$2, s$1) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: n$1 } = s$1, l$1 = ai$1.disabled, c$1 = e$2.colorModeForRenderPass();
						(a$2._unevaluatedLayout.hasValue("text-variable-anchor") || a$2._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e$3, i$3, a$3, r$3, o$3, s$2, n$2, l$2, c$2) {
							const h$1 = i$3.transform, u$1 = i$3.style.map.terrain, d$1 = "map" === o$3, _$2 = "map" === s$2;
							for (const o$4 of e$3) {
								const e$4 = r$3.getTile(o$4), s$3 = e$4.getBucket(a$3);
								if (!s$3 || !s$3.text || !s$3.text.segments.get().length) continue;
								const p$1 = t.az(s$3.textSizeData, h$1.zoom), m$1 = t.aO(e$4, 1, i$3.transform.zoom), f$1 = je$1(d$1, i$3.transform, m$1), g$2 = "none" !== a$3.layout.get("icon-text-fit") && s$3.hasIconData();
								if (p$1) {
									const i$4 = Math.pow(2, h$1.zoom - e$4.tileID.overscaledZ), a$4 = u$1 ? (e$5, t$1) => u$1.getElevation(o$4, e$5, t$1) : null;
									_r$1(s$3, d$1, _$2, c$2, h$1, f$1, i$4, p$1, g$2, t.aP(h$1, e$4, n$2, l$2), o$4.toUnwrapped(), a$4);
								}
							}
						}(r$2, e$2, a$2, i$2, a$2.layout.get("text-rotation-alignment"), a$2.layout.get("text-pitch-alignment"), a$2.paint.get("text-translate"), a$2.paint.get("text-translate-anchor"), o$2), 0 !== a$2.paint.get("icon-opacity").constantOr(1) && mr$1(e$2, i$2, a$2, r$2, !1, a$2.paint.get("icon-translate"), a$2.paint.get("icon-translate-anchor"), a$2.layout.get("icon-rotation-alignment"), a$2.layout.get("icon-pitch-alignment"), a$2.layout.get("icon-keep-upright"), l$1, c$1, n$1), 0 !== a$2.paint.get("text-opacity").constantOr(1) && mr$1(e$2, i$2, a$2, r$2, !0, a$2.paint.get("text-translate"), a$2.paint.get("text-translate-anchor"), a$2.layout.get("text-rotation-alignment"), a$2.layout.get("text-pitch-alignment"), a$2.layout.get("text-keep-upright"), l$1, c$1, n$1), i$2.map.showCollisionBoxes && (cr$1(e$2, i$2, a$2, r$2, !0), cr$1(e$2, i$2, a$2, r$2, !1));
					}(e$1, i$1, a$1, r$1, this.style.placement.variableOffsets, o$1) : t.co(a$1) ? function(e$2, i$2, a$2, r$2, o$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = o$2, n$1 = a$2.paint.get("circle-opacity"), l$1 = a$2.paint.get("circle-stroke-width"), c$1 = a$2.paint.get("circle-stroke-opacity"), h$1 = !a$2.layout.get("circle-sort-key").isConstant();
						if (0 === n$1.constantOr(1) && (0 === l$1.constantOr(1) || 0 === c$1.constantOr(1))) return;
						const u$1 = e$2.context, d$1 = u$1.gl, _$2 = e$2.transform, p$1 = e$2.getDepthModeForSublayer(0, ti$1.ReadOnly), m$1 = ai$1.disabled, f$1 = e$2.colorModeForRenderPass(), g$2 = [], v$1 = _$2.getCircleRadiusCorrection();
						for (let o$3 = 0; o$3 < r$2.length; o$3++) {
							const n$2 = r$2[o$3], l$2 = i$2.getTile(n$2), c$2 = l$2.getBucket(a$2);
							if (!c$2) continue;
							const u$2 = a$2.paint.get("circle-translate"), d$2 = a$2.paint.get("circle-translate-anchor"), p$2 = t.aP(_$2, l$2, u$2, d$2), m$2 = c$2.programConfigurations.get(a$2.id), f$2 = e$2.useProgram("circle", m$2), x$1 = c$2.layoutVertexBuffer, b$1 = c$2.indexBuffer, y$1 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(n$2), w$2 = {
								programConfiguration: m$2,
								program: f$2,
								layoutVertexBuffer: x$1,
								indexBuffer: b$1,
								uniformValues: Hi$1(e$2, l$2, a$2, p$2, v$1),
								terrainData: y$1,
								projectionData: _$2.getProjectionData({
									overscaledTileID: n$2,
									applyGlobeMatrix: !s$1,
									applyTerrainMatrix: !0
								})
							};
							if (h$1) {
								const e$3 = c$2.segments.get();
								for (const i$3 of e$3) g$2.push({
									segments: new t.aY([i$3]),
									sortKey: i$3.sortKey,
									state: w$2
								});
							} else g$2.push({
								segments: c$2.segments,
								sortKey: 0,
								state: w$2
							});
						}
						h$1 && g$2.sort(((e$3, t$1) => e$3.sortKey - t$1.sortKey));
						for (const t$1 of g$2) {
							const { programConfiguration: i$3, program: r$3, layoutVertexBuffer: o$3, indexBuffer: s$2, uniformValues: n$2, terrainData: l$2, projectionData: c$2 } = t$1.state;
							r$3.draw(u$1, d$1.TRIANGLES, p$1, m$1, f$1, ei$1.backCCW, n$2, l$2, c$2, a$2.id, o$3, s$2, t$1.segments, a$2.paint, e$2.transform.zoom, i$3);
						}
					}(e$1, i$1, a$1, r$1, o$1) : t.cp(a$1) ? function(e$2, i$2, a$2, r$2, o$2) {
						if (0 === a$2.paint.get("heatmap-opacity")) return;
						const s$1 = e$2.context, { isRenderingToTexture: n$1, isRenderingGlobe: l$1 } = o$2;
						if (e$2.style.map.terrain) {
							for (const t$1 of r$2) {
								const r$3 = i$2.getTile(t$1);
								i$2.hasRenderableParent(t$1) || ("offscreen" === e$2.renderPass ? gr$1(e$2, r$3, a$2, t$1, l$1) : "translucent" === e$2.renderPass && vr(e$2, a$2, t$1, n$1, l$1));
							}
							s$1.viewport.set([
								0,
								0,
								e$2.width,
								e$2.height
							]);
						} else "offscreen" === e$2.renderPass ? function(e$3, i$3, a$3, r$3) {
							const o$3 = e$3.context, s$2 = o$3.gl, n$2 = e$3.transform, l$2 = ai$1.disabled, c$1 = new Qt$1([s$2.ONE, s$2.ONE], t.bq.transparent, [
								!0,
								!0,
								!0,
								!0
							]);
							(function(e$4, i$4, a$4) {
								const r$4 = e$4.gl;
								e$4.activeTexture.set(r$4.TEXTURE1), e$4.viewport.set([
									0,
									0,
									i$4.width / 4,
									i$4.height / 4
								]);
								let o$4 = a$4.heatmapFbos.get(t.ce);
								o$4 ? (r$4.bindTexture(r$4.TEXTURE_2D, o$4.colorAttachment.get()), e$4.bindFramebuffer.set(o$4.framebuffer)) : (o$4 = xr$1(e$4, i$4.width / 4, i$4.height / 4), a$4.heatmapFbos.set(t.ce, o$4));
							})(o$3, e$3, a$3), o$3.clear({ color: t.bq.transparent });
							for (let t$1 = 0; t$1 < r$3.length; t$1++) {
								const h$1 = r$3[t$1];
								if (i$3.hasRenderableParent(h$1)) continue;
								const u$1 = i$3.getTile(h$1), d$1 = u$1.getBucket(a$3);
								if (!d$1) continue;
								const _$2 = d$1.programConfigurations.get(a$3.id), p$1 = e$3.useProgram("heatmap", _$2), m$1 = n$2.getProjectionData({
									overscaledTileID: h$1,
									applyGlobeMatrix: !0,
									applyTerrainMatrix: !1
								}), f$1 = n$2.getCircleRadiusCorrection();
								p$1.draw(o$3, s$2.TRIANGLES, ti$1.disabled, l$2, c$1, ei$1.backCCW, Qi$1(u$1, n$2.zoom, a$3.paint.get("heatmap-intensity"), f$1), null, m$1, a$3.id, d$1.layoutVertexBuffer, d$1.indexBuffer, d$1.segments, a$3.paint, n$2.zoom, _$2);
							}
							o$3.viewport.set([
								0,
								0,
								e$3.width,
								e$3.height
							]);
						}(e$2, i$2, a$2, r$2) : "translucent" === e$2.renderPass && function(e$3, i$3) {
							const a$3 = e$3.context, r$3 = a$3.gl;
							a$3.setColorMode(e$3.colorModeForRenderPass());
							const o$3 = i$3.heatmapFbos.get(t.ce);
							o$3 && (a$3.activeTexture.set(r$3.TEXTURE0), r$3.bindTexture(r$3.TEXTURE_2D, o$3.colorAttachment.get()), a$3.activeTexture.set(r$3.TEXTURE1), br(a$3, i$3).bind(r$3.LINEAR, r$3.CLAMP_TO_EDGE), e$3.useProgram("heatmapTexture").draw(a$3, r$3.TRIANGLES, ti$1.disabled, ai$1.disabled, e$3.colorModeForRenderPass(), ei$1.disabled, Ji$1(e$3, i$3, 0, 1), null, null, i$3.id, e$3.viewportBuffer, e$3.quadTriangleIndexBuffer, e$3.viewportSegments, i$3.paint, e$3.transform.zoom));
						}(e$2, a$2);
					}(e$1, i$1, a$1, r$1, o$1) : t.cq(a$1) ? function(e$2, t$1, i$2, a$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: o$2 } = r$2, s$1 = i$2.paint.get("line-opacity"), n$1 = i$2.paint.get("line-width");
						if (0 === s$1.constantOr(1) || 0 === n$1.constantOr(1)) return;
						const l$1 = e$2.getDepthModeForSublayer(0, ti$1.ReadOnly), c$1 = e$2.colorModeForRenderPass(), h$1 = i$2.paint.get("line-dasharray"), u$1 = h$1.constantOr(1), d$1 = i$2.paint.get("line-pattern"), _$2 = d$1.constantOr(1), p$1 = i$2.paint.get("line-gradient"), m$1 = i$2.getCrossfadeParameters();
						let f$1;
						f$1 = _$2 ? "linePattern" : u$1 && p$1 ? "lineGradientSDF" : u$1 ? "lineSDF" : p$1 ? "lineGradient" : "line";
						const g$2 = e$2.context, v$1 = g$2.gl, x$1 = e$2.transform;
						let b$1 = !0;
						for (const r$3 of a$2) {
							const a$3 = t$1.getTile(r$3);
							if (_$2 && !a$3.patternsLoaded()) continue;
							const s$2 = a$3.getBucket(i$2);
							if (!s$2) continue;
							const n$2 = s$2.programConfigurations.get(i$2.id), y$1 = e$2.context.program.get(), w$2 = e$2.useProgram(f$1, n$2), T$1 = b$1 || w$2.program !== y$1, P$2 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(r$3), I$2 = d$1.constantOr(null), C$1 = h$1 && h$1.constantOr(null);
							if (I$2 && a$3.imageAtlas) {
								const e$3 = a$3.imageAtlas, t$2 = e$3.patternPositions[I$2.to.toString()], i$3 = e$3.patternPositions[I$2.from.toString()];
								t$2 && i$3 && n$2.setConstantPatternPositions(t$2, i$3);
							} else if (C$1) {
								const t$2 = "round" === i$2.layout.get("line-cap"), a$4 = e$2.lineAtlas.getDash(C$1.to, t$2), r$4 = e$2.lineAtlas.getDash(C$1.from, t$2);
								n$2.setConstantDashPositions(a$4, r$4);
							}
							const M$2 = x$1.getProjectionData({
								overscaledTileID: r$3,
								applyGlobeMatrix: !o$2,
								applyTerrainMatrix: !0
							}), E$1 = x$1.getPixelScale();
							let S$2;
							_$2 ? (S$2 = sa$1(e$2, a$3, i$2, E$1, m$1), wr$1(g$2, v$1, a$3, n$2, m$1)) : u$1 && p$1 ? (S$2 = la$1(e$2, a$3, i$2, E$1, m$1, s$2.lineClipsArray.length), Ir$1(e$2, t$1, g$2, v$1, i$2, s$2, r$3, n$2, m$1)) : u$1 ? (S$2 = na$1(e$2, a$3, i$2, E$1, m$1), Tr$1(e$2, g$2, v$1, n$2, T$1, m$1)) : p$1 ? (S$2 = oa$1(e$2, a$3, i$2, E$1, s$2.lineClipsArray.length), Pr$1(e$2, t$1, g$2, v$1, i$2, s$2, r$3)) : S$2 = ra$1(e$2, a$3, i$2, E$1);
							const R$3 = e$2.stencilModeForClipping(r$3);
							w$2.draw(g$2, v$1.TRIANGLES, l$1, R$3, c$1, ei$1.disabled, S$2, P$2, M$2, i$2.id, s$2.layoutVertexBuffer, s$2.indexBuffer, s$2.segments, i$2.paint, e$2.transform.zoom, n$2, s$2.layoutVertexBuffer2), b$1 = !1;
						}
					}(e$1, i$1, a$1, r$1, o$1) : t.cr(a$1) ? function(e$2, i$2, a$2, r$2, o$2) {
						const s$1 = a$2.paint.get("fill-color"), n$1 = a$2.paint.get("fill-opacity");
						if (0 === n$1.constantOr(1)) return;
						const { isRenderingToTexture: l$1 } = o$2, c$1 = e$2.colorModeForRenderPass(), h$1 = a$2.paint.get("fill-pattern"), u$1 = e$2.opaquePassEnabledForLayer() && !h$1.constantOr(1) && 1 === s$1.constantOr(t.bq.transparent).a && 1 === n$1.constantOr(0) ? "opaque" : "translucent";
						if (e$2.renderPass === u$1) Mr$1(e$2, i$2, a$2, r$2, e$2.getDepthModeForSublayer(1, "opaque" === e$2.renderPass ? ti$1.ReadWrite : ti$1.ReadOnly), c$1, !1, l$1);
						if ("translucent" === e$2.renderPass && a$2.paint.get("fill-antialias")) Mr$1(e$2, i$2, a$2, r$2, e$2.getDepthModeForSublayer(a$2.getPaintProperty("fill-outline-color") ? 2 : 0, ti$1.ReadOnly), c$1, !0, l$1);
					}(e$1, i$1, a$1, r$1, o$1) : t.cs(a$1) ? function(e$2, t$1, i$2, a$2, r$2) {
						const o$2 = i$2.paint.get("fill-extrusion-opacity");
						if (0 === o$2) return;
						const { isRenderingToTexture: s$1 } = r$2;
						if ("translucent" === e$2.renderPass) {
							const r$3 = new ti$1(e$2.context.gl.LEQUAL, ti$1.ReadWrite, e$2.depthRangeFor3D);
							if (1 !== o$2 || i$2.paint.get("fill-extrusion-pattern").constantOr(1)) Er$1(e$2, t$1, i$2, a$2, r$3, ai$1.disabled, Qt$1.disabled, s$1), Er$1(e$2, t$1, i$2, a$2, r$3, e$2.stencilModeFor3D(), e$2.colorModeForRenderPass(), s$1);
							else {
								const o$3 = e$2.colorModeForRenderPass();
								Er$1(e$2, t$1, i$2, a$2, r$3, ai$1.disabled, o$3, s$1);
							}
						}
					}(e$1, i$1, a$1, r$1, o$1) : t.ct(a$1) ? function(e$2, i$2, a$2, r$2, o$2) {
						if ("offscreen" !== e$2.renderPass && "translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = o$2, n$1 = e$2.context, l$1 = e$2.style.projection.useSubdivision, c$1 = e$2.getDepthModeForSublayer(0, ti$1.ReadOnly), h$1 = e$2.colorModeForRenderPass();
						if ("offscreen" === e$2.renderPass) (function(e$3, i$3, a$3, r$3, o$3, s$2, n$2) {
							const l$2 = e$3.context, c$2 = l$2.gl;
							for (const h$2 of a$3) {
								const a$4 = i$3.getTile(h$2), u$1 = a$4.dem;
								if (!u$1 || !u$1.data) continue;
								if (!a$4.needsHillshadePrepare) continue;
								const d$1 = u$1.dim, _$2 = u$1.stride, p$1 = u$1.getPixels();
								if (l$2.activeTexture.set(c$2.TEXTURE1), l$2.pixelStoreUnpackPremultiplyAlpha.set(!1), a$4.demTexture = a$4.demTexture || e$3.getTileTexture(_$2), a$4.demTexture) {
									const e$4 = a$4.demTexture;
									e$4.update(p$1, { premultiply: !1 }), e$4.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								} else a$4.demTexture = new t.T(l$2, p$1, c$2.RGBA, { premultiply: !1 }), a$4.demTexture.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								l$2.activeTexture.set(c$2.TEXTURE0);
								let m$1 = a$4.fbo;
								if (!m$1) {
									const e$4 = new t.T(l$2, {
										width: d$1,
										height: d$1,
										data: null
									}, c$2.RGBA);
									e$4.bind(c$2.LINEAR, c$2.CLAMP_TO_EDGE), m$1 = a$4.fbo = l$2.createFramebuffer(d$1, d$1, !0, !1), m$1.colorAttachment.set(e$4.texture);
								}
								l$2.bindFramebuffer.set(m$1.framebuffer), l$2.viewport.set([
									0,
									0,
									d$1,
									d$1
								]), e$3.useProgram("hillshadePrepare").draw(l$2, c$2.TRIANGLES, o$3, s$2, n$2, ei$1.disabled, ta$1(a$4.tileID, u$1), null, null, r$3.id, e$3.rasterBoundsBuffer, e$3.quadTriangleIndexBuffer, e$3.rasterBoundsSegments), a$4.needsHillshadePrepare = !1;
							}
						})(e$2, i$2, r$2, a$2, c$1, ai$1.disabled, h$1), n$1.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
						else if ("translucent" === e$2.renderPass) if (l$1) {
							const [t$1, o$3, n$2] = e$2.stencilConfigForOverlapTwoPass(r$2);
							Sr$1(e$2, i$2, a$2, n$2, t$1, c$1, h$1, !1, s$1), Sr$1(e$2, i$2, a$2, n$2, o$3, c$1, h$1, !0, s$1);
						} else {
							const [t$1, o$3] = e$2.getStencilConfigForOverlapAndUpdateStencilID(r$2);
							Sr$1(e$2, i$2, a$2, o$3, t$1, c$1, h$1, !1, s$1);
						}
					}(e$1, i$1, a$1, r$1, o$1) : t.cu(a$1) ? function(e$2, t$1, i$2, a$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (!a$2.length) return;
						const { isRenderingToTexture: o$2 } = r$2, s$1 = e$2.style.projection.useSubdivision, n$1 = e$2.getDepthModeForSublayer(0, ti$1.ReadOnly), l$1 = e$2.colorModeForRenderPass();
						if (s$1) {
							const [r$3, s$2, c$1] = e$2.stencilConfigForOverlapTwoPass(a$2);
							Rr$1(e$2, t$1, i$2, c$1, r$3, n$1, l$1, !1, o$2), Rr$1(e$2, t$1, i$2, c$1, s$2, n$1, l$1, !0, o$2);
						} else {
							const [r$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(a$2);
							Rr$1(e$2, t$1, i$2, s$2, r$3, n$1, l$1, !1, o$2);
						}
					}(e$1, i$1, a$1, r$1, o$1) : t.bV(a$1) ? function(e$2, t$1, i$2, a$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (0 === i$2.paint.get("raster-opacity")) return;
						if (!a$2.length) return;
						const { isRenderingToTexture: o$2 } = r$2, s$1 = t$1.getSource(), n$1 = e$2.style.projection.useSubdivision;
						if (s$1 instanceof te$1) Dr$1(e$2, t$1, i$2, a$2, null, !1, !1, s$1.tileCoords, s$1.flippedWindingOrder, o$2);
						else if (n$1) {
							const [r$3, s$2, n$2] = e$2.stencilConfigForOverlapTwoPass(a$2);
							Dr$1(e$2, t$1, i$2, n$2, r$3, !1, !0, zr$1, !1, o$2), Dr$1(e$2, t$1, i$2, n$2, s$2, !0, !0, zr$1, !1, o$2);
						} else {
							const [r$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(a$2);
							Dr$1(e$2, t$1, i$2, s$2, r$3, !1, !0, zr$1, !1, o$2);
						}
					}(e$1, i$1, a$1, r$1, o$1) : t.cv(a$1) ? function(e$2, t$1, i$2, a$2, r$2) {
						const o$2 = i$2.paint.get("background-color"), s$1 = i$2.paint.get("background-opacity");
						if (0 === s$1) return;
						const { isRenderingToTexture: n$1 } = r$2, l$1 = e$2.context, c$1 = l$1.gl, h$1 = e$2.style.projection, u$1 = e$2.transform, d$1 = u$1.tileSize, _$2 = i$2.paint.get("background-pattern");
						if (e$2.isPatternMissing(_$2)) return;
						const p$1 = !_$2 && 1 === o$2.a && 1 === s$1 && e$2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
						if (e$2.renderPass !== p$1) return;
						const m$1 = ai$1.disabled, f$1 = e$2.getDepthModeForSublayer(0, "opaque" === p$1 ? ti$1.ReadWrite : ti$1.ReadOnly), g$2 = e$2.colorModeForRenderPass(), v$1 = e$2.useProgram(_$2 ? "backgroundPattern" : "background"), x$1 = a$2 || Ce$1(u$1, {
							tileSize: d$1,
							terrain: e$2.style.map.terrain
						});
						_$2 && (l$1.activeTexture.set(c$1.TEXTURE0), e$2.imageManager.bind(e$2.context));
						const b$1 = i$2.getCrossfadeParameters();
						for (const t$2 of x$1) {
							const a$3 = u$1.getProjectionData({
								overscaledTileID: t$2,
								applyGlobeMatrix: !n$1,
								applyTerrainMatrix: !0
							}), r$3 = _$2 ? ga$1(s$1, e$2, _$2, {
								tileID: t$2,
								tileSize: d$1
							}, b$1) : fa$1(s$1, o$2), p$2 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(t$2), x$2 = h$1.getMeshFromTileID(l$1, t$2.canonical, !1, !0, "raster");
							v$1.draw(l$1, c$1.TRIANGLES, f$1, m$1, g$2, ei$1.backCCW, r$3, p$2, a$3, i$2.id, x$2.vertexBuffer, x$2.indexBuffer, x$2.segments);
						}
					}(e$1, 0, a$1, r$1, o$1) : t.cw(a$1) && function(e$2, t$1, i$2, a$2) {
						const { isRenderingGlobe: r$2 } = a$2, o$2 = e$2.context, s$1 = i$2.implementation, n$1 = e$2.style.projection, l$1 = e$2.transform, c$1 = l$1.getProjectionDataForCustomLayer(r$2), h$1 = {
							farZ: l$1.farZ,
							nearZ: l$1.nearZ,
							fov: l$1.fov * Math.PI / 180,
							modelViewProjectionMatrix: l$1.modelViewProjectionMatrix,
							projectionMatrix: l$1.projectionMatrix,
							shaderData: {
								variantName: n$1.shaderVariantName,
								vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${n$1.shaderPreludeCode.vertexSource}`,
								define: n$1.shaderDefine
							},
							defaultProjectionData: c$1
						}, u$1 = s$1.renderingMode ? s$1.renderingMode : "2d";
						if ("offscreen" === e$2.renderPass) {
							const t$2 = s$1.prerender;
							t$2 && (e$2.setCustomLayerDefaults(), o$2.setColorMode(e$2.colorModeForRenderPass()), t$2.call(s$1, o$2.gl, h$1), o$2.setDirty(), e$2.setBaseState());
						} else if ("translucent" === e$2.renderPass) {
							e$2.setCustomLayerDefaults(), o$2.setColorMode(e$2.colorModeForRenderPass()), o$2.setStencilMode(ai$1.disabled);
							const t$2 = "3d" === u$1 ? e$2.getDepthModeFor3D() : e$2.getDepthModeForSublayer(0, ti$1.ReadOnly);
							o$2.setDepthMode(t$2), s$1.render(o$2.gl, h$1), o$2.setDirty(), e$2.setBaseState(), o$2.bindFramebuffer.set(null);
						}
					}(e$1, 0, a$1, o$1));
				}
				saveTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1.size[0]];
					t$1 ? t$1.push(e$1) : this._tileTextures[e$1.size[0]] = [e$1];
				}
				getTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1];
					return t$1 && t$1.length > 0 ? t$1.pop() : null;
				}
				isPatternMissing(e$1) {
					if (!e$1) return !1;
					if (!e$1.from || !e$1.to) return !0;
					const t$1 = this.imageManager.getPattern(e$1.from.toString()), i$1 = this.imageManager.getPattern(e$1.to.toString());
					return !t$1 || !i$1;
				}
				useProgram(e$1, t$1, i$1 = !1, a$1 = []) {
					this.cache = this.cache || {};
					const r$1 = !!this.style.map.terrain, o$1 = this.style.projection, s$1 = i$1 ? At$1.projectionMercator : o$1.shaderPreludeCode, n$1 = i$1 ? Bt$1 : o$1.shaderDefine, l$1 = e$1 + (t$1 ? t$1.cacheKey : "") + `/${i$1 ? Ot$1 : o$1.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r$1 ? "/terrain" : "") + (a$1 ? `/${a$1.join("/")}` : "");
					return this.cache[l$1] || (this.cache[l$1] = new Zi$1(this.context, At$1[e$1], t$1, xa$1[e$1], this._showOverdrawInspector, r$1, s$1, n$1, a$1)), this.cache[l$1];
				}
				setCustomLayerDefaults() {
					this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
				}
				setBaseState() {
					const e$1 = this.context.gl;
					this.context.cullFace.set(!1), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.blendEquation.set(e$1.FUNC_ADD);
				}
				initDebugOverlayCanvas() {
					this.debugOverlayCanvas ?? (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
				}
				destroy() {
					var e$1, t$1;
					if (this._tileTextures) {
						for (const e$2 in this._tileTextures) {
							const t$2 = this._tileTextures[e$2];
							if (t$2) for (const e$3 of t$2) e$3.destroy();
						}
						this._tileTextures = {};
					}
					if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && (null === (e$1 = this.tileExtentMesh.vertexBuffer) || void 0 === e$1 || e$1.destroy()), this.tileExtentMesh && (null === (t$1 = this.tileExtentMesh.indexBuffer) || void 0 === t$1 || t$1.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
						for (const e$2 in this.cache) {
							const t$2 = this.cache[e$2];
							t$2 && t$2.program && this.context.gl.deleteProgram(t$2.program);
						}
						this.cache = {};
					}
					this.context && this.context.setDefault();
				}
				overLimit() {
					const { drawingBufferWidth: e$1, drawingBufferHeight: t$1 } = this.context.gl;
					return this.width !== e$1 || this.height !== t$1;
				}
			}
			function Wr$1(e$1, t$1) {
				let i$1, a$1 = !1, r$1 = null, o$1 = null;
				const s$1 = () => {
					r$1 = null, a$1 && (e$1.apply(o$1, i$1), r$1 = setTimeout(s$1, t$1), a$1 = !1);
				};
				return (...e$2) => (a$1 = !0, o$1 = this, i$1 = e$2, r$1 || s$1(), r$1);
			}
			class $r$1 {
				constructor(e$1) {
					this._getCurrentHash = () => {
						const e$2 = window.location.hash.replace("#", "");
						if (this._hashName) {
							let t$1;
							return e$2.split("&").map(((e$3) => e$3.split("="))).forEach(((e$3) => {
								e$3[0] === this._hashName && (t$1 = e$3);
							})), (t$1 && t$1[1] || "").split("/");
						}
						return e$2.split("/");
					}, this._onHashChange = () => {
						const e$2 = this._getCurrentHash();
						if (!this._isValidHash(e$2)) return !1;
						const t$1 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e$2[3] || 0) : this._map.getBearing();
						return this._map.jumpTo({
							center: [+e$2[2], +e$2[1]],
							zoom: +e$2[0],
							bearing: t$1,
							pitch: +(e$2[4] || 0)
						}), !0;
					}, this._updateHashUnthrottled = () => {
						const e$2 = window.location.href.replace(/(#.*)?$/, this.getHashString());
						window.history.replaceState(window.history.state, null, e$2);
					}, this._removeHash = () => {
						const e$2 = this._getCurrentHash();
						if (0 === e$2.length) return;
						const t$1 = e$2.join("/");
						let i$1 = t$1;
						i$1.split("&").length > 0 && (i$1 = i$1.split("&")[0]), this._hashName && (i$1 = `${this._hashName}=${t$1}`);
						let a$1 = window.location.hash.replace(i$1, "");
						a$1.startsWith("#&") ? a$1 = a$1.slice(0, 1) + a$1.slice(2) : "#" === a$1 && (a$1 = "");
						let r$1 = window.location.href.replace(/(#.+)?$/, a$1);
						r$1 = r$1.replace("&&", "&"), window.history.replaceState(window.history.state, null, r$1);
					}, this._updateHash = Wr$1(this._updateHashUnthrottled, 300), this._hashName = e$1 && encodeURIComponent(e$1);
				}
				addTo(e$1) {
					return this._map = e$1, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
				}
				remove() {
					return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
				}
				getHashString(e$1) {
					const t$1 = this._map.getCenter(), i$1 = Math.round(100 * this._map.getZoom()) / 100, a$1 = Math.ceil((i$1 * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), r$1 = Math.pow(10, a$1), o$1 = Math.round(t$1.lng * r$1) / r$1, s$1 = Math.round(t$1.lat * r$1) / r$1, n$1 = this._map.getBearing(), l$1 = this._map.getPitch();
					let c$1 = "";
					if (c$1 += e$1 ? `/${o$1}/${s$1}/${i$1}` : `${i$1}/${s$1}/${o$1}`, (n$1 || l$1) && (c$1 += "/" + Math.round(10 * n$1) / 10), l$1 && (c$1 += `/${Math.round(l$1)}`), this._hashName) {
						const e$2 = this._hashName;
						let t$2 = !1;
						const i$2 = window.location.hash.slice(1).split("&").map(((i$3) => {
							const a$2 = i$3.split("=")[0];
							return a$2 === e$2 ? (t$2 = !0, `${a$2}=${c$1}`) : i$3;
						})).filter(((e$3) => e$3));
						return t$2 || i$2.push(`${e$2}=${c$1}`), `#${i$2.join("&")}`;
					}
					return `#${c$1}`;
				}
				_isValidHash(e$1) {
					if (e$1.length < 3 || e$1.some(isNaN)) return !1;
					try {
						new t.V(+e$1[2], +e$1[1]);
					} catch (e$2) {
						return !1;
					}
					const i$1 = +e$1[0], a$1 = +(e$1[3] || 0), r$1 = +(e$1[4] || 0);
					return i$1 >= this._map.getMinZoom() && i$1 <= this._map.getMaxZoom() && a$1 >= -180 && a$1 <= 180 && r$1 >= this._map.getMinPitch() && r$1 <= this._map.getMaxPitch();
				}
			}
			const Hr$1 = {
				linearity: .3,
				easing: t.cx(0, 0, .3, 1)
			}, Xr$1 = t.e({
				deceleration: 2500,
				maxSpeed: 1400
			}, Hr$1), Kr$1 = t.e({
				deceleration: 20,
				maxSpeed: 1400
			}, Hr$1), Yr$1 = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Hr$1), Qr$1 = t.e({
				deceleration: 1e3,
				maxSpeed: 90
			}, Hr$1), Jr$1 = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Hr$1);
			class eo$1 {
				constructor(e$1) {
					this._map = e$1, this.clear();
				}
				clear() {
					this._inertiaBuffer = [];
				}
				record(e$1) {
					this._drainInertiaBuffer(), this._inertiaBuffer.push({
						time: c(),
						settings: e$1
					});
				}
				_drainInertiaBuffer() {
					const e$1 = this._inertiaBuffer, t$1 = c();
					for (; e$1.length > 0 && t$1 - e$1[0].time > 160;) e$1.shift();
				}
				_onMoveEnd(e$1) {
					if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
					const i$1 = {
						zoom: 0,
						bearing: 0,
						pitch: 0,
						roll: 0,
						pan: new t.P(0, 0),
						pinchAround: void 0,
						around: void 0
					};
					for (const { settings: e$2 } of this._inertiaBuffer) i$1.zoom += e$2.zoomDelta || 0, i$1.bearing += e$2.bearingDelta || 0, i$1.pitch += e$2.pitchDelta || 0, i$1.roll += e$2.rollDelta || 0, e$2.panDelta && i$1.pan._add(e$2.panDelta), e$2.around && (i$1.around = e$2.around), e$2.pinchAround && (i$1.pinchAround = e$2.pinchAround);
					const a$1 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r$1 = {};
					if (i$1.pan.mag()) {
						const o$1 = io$1(i$1.pan.mag(), a$1, t.e({}, Xr$1, e$1 || {})), s$1 = i$1.pan.mult(o$1.amount / i$1.pan.mag()), n$1 = this._map.cameraHelper.handlePanInertia(s$1, this._map.transform);
						r$1.center = n$1.easingCenter, r$1.offset = n$1.easingOffset, to$1(r$1, o$1);
					}
					if (i$1.zoom) {
						const e$2 = io$1(i$1.zoom, a$1, Kr$1);
						r$1.zoom = this._map.transform.zoom + e$2.amount, to$1(r$1, e$2);
					}
					if (i$1.bearing) {
						const e$2 = io$1(i$1.bearing, a$1, Yr$1);
						r$1.bearing = this._map.transform.bearing + t.ao(e$2.amount, -179, 179), to$1(r$1, e$2);
					}
					if (i$1.pitch) {
						const e$2 = io$1(i$1.pitch, a$1, Qr$1);
						r$1.pitch = this._map.transform.pitch + e$2.amount, to$1(r$1, e$2);
					}
					if (i$1.roll) {
						const e$2 = io$1(i$1.roll, a$1, Jr$1);
						r$1.roll = this._map.transform.roll + t.ao(e$2.amount, -179, 179), to$1(r$1, e$2);
					}
					if (r$1.zoom || r$1.bearing) {
						const e$2 = void 0 === i$1.pinchAround ? i$1.around : i$1.pinchAround;
						r$1.around = e$2 ? this._map.unproject(e$2) : this._map.getCenter();
					}
					return this.clear(), t.e(r$1, { noMoveStart: !0 });
				}
			}
			function to$1(e$1, t$1) {
				(!e$1.duration || e$1.duration < t$1.duration) && (e$1.duration = t$1.duration, e$1.easing = t$1.easing);
			}
			function io$1(e$1, i$1, a$1) {
				const { maxSpeed: r$1, linearity: o$1, deceleration: s$1 } = a$1, n$1 = t.ao(e$1 * o$1 / (i$1 / 1e3), -r$1, r$1), l$1 = Math.abs(n$1) / (s$1 * o$1);
				return {
					easing: a$1.easing,
					duration: 1e3 * l$1,
					amount: n$1 * (l$1 / 2)
				};
			}
			class ao$1 extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, a$1, r$1 = {}) {
					a$1 = a$1 instanceof MouseEvent ? a$1 : new MouseEvent(e$1, a$1);
					const o$1 = h.mousePos(i$1.getCanvas(), a$1), s$1 = i$1.unproject(o$1);
					super(e$1, t.e({
						point: o$1,
						lngLat: s$1,
						originalEvent: a$1
					}, r$1)), this._defaultPrevented = !1, this.target = i$1;
				}
			}
			class ro$1 extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, a$1) {
					const r$1 = "touchend" === e$1 ? a$1.changedTouches : a$1.touches, o$1 = h.touchPos(i$1.getCanvasContainer(), r$1), s$1 = o$1.map(((e$2) => i$1.unproject(e$2))), n$1 = o$1.reduce(((e$2, t$1, i$2, a$2) => e$2.add(t$1.div(a$2.length))), new t.P(0, 0));
					super(e$1, {
						points: o$1,
						point: n$1,
						lngLats: s$1,
						lngLat: i$1.unproject(n$1),
						originalEvent: a$1
					}), this._defaultPrevented = !1;
				}
			}
			class oo$1 extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, t$1, i$1) {
					super(e$1, { originalEvent: i$1 }), this._defaultPrevented = !1;
				}
			}
			class so$1 {
				constructor(e$1, t$1) {
					this._map = e$1, this._clickTolerance = t$1.clickTolerance;
				}
				reset() {
					delete this._mousedownPos;
				}
				wheel(e$1) {
					return this._firePreventable(new oo$1(e$1.type, this._map, e$1));
				}
				mousedown(e$1, t$1) {
					return this._mousedownPos = t$1, this._firePreventable(new ao$1(e$1.type, this._map, e$1));
				}
				mouseup(e$1) {
					this._map.fire(new ao$1(e$1.type, this._map, e$1));
				}
				click(e$1, t$1) {
					this._mousedownPos && this._mousedownPos.dist(t$1) >= this._clickTolerance || this._map.fire(new ao$1(e$1.type, this._map, e$1));
				}
				dblclick(e$1) {
					return this._firePreventable(new ao$1(e$1.type, this._map, e$1));
				}
				mouseover(e$1) {
					this._map.fire(new ao$1(e$1.type, this._map, e$1));
				}
				mouseout(e$1) {
					this._map.fire(new ao$1(e$1.type, this._map, e$1));
				}
				touchstart(e$1) {
					return this._firePreventable(new ro$1(e$1.type, this._map, e$1));
				}
				touchmove(e$1) {
					this._map.fire(new ro$1(e$1.type, this._map, e$1));
				}
				touchend(e$1) {
					this._map.fire(new ro$1(e$1.type, this._map, e$1));
				}
				touchcancel(e$1) {
					this._map.fire(new ro$1(e$1.type, this._map, e$1));
				}
				_firePreventable(e$1) {
					if (this._map.fire(e$1), e$1.defaultPrevented) return {};
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class no$1 {
				constructor(e$1) {
					this._map = e$1;
				}
				reset() {
					this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
				}
				mousemove(e$1) {
					this._map.fire(new ao$1(e$1.type, this._map, e$1));
				}
				mousedown() {
					this._delayContextMenu = !0, this._ignoreContextMenu = !1;
				}
				mouseup() {
					this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ao$1("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
				}
				contextmenu(e$1) {
					this._delayContextMenu ? this._contextMenuEvent = e$1 : this._ignoreContextMenu || this._map.fire(new ao$1(e$1.type, this._map, e$1)), this._map.listens("contextmenu") && e$1.preventDefault();
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class lo$1 {
				constructor(e$1) {
					this._map = e$1;
				}
				get transform() {
					return this._map._requestedCameraState || this._map.transform;
				}
				get center() {
					return {
						lng: this.transform.center.lng,
						lat: this.transform.center.lat
					};
				}
				get zoom() {
					return this.transform.zoom;
				}
				get pitch() {
					return this.transform.pitch;
				}
				get bearing() {
					return this.transform.bearing;
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this._map.terrain);
				}
			}
			class co$1 {
				constructor(e$1, t$1) {
					this._map = e$1, this._tr = new lo$1(e$1), this._el = e$1.getCanvasContainer(), this._container = e$1.getContainer(), this._clickTolerance = t$1.clickTolerance || 1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
				enable() {
					this.isEnabled() || (this._enabled = !0);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				mousedown(e$1, t$1) {
					this.isEnabled() && e$1.shiftKey && 0 === e$1.button && (h.disableDrag(), this._startPos = this._lastPos = t$1, this._active = !0);
				}
				mousemoveWindow(e$1, t$1) {
					if (!this._active) return;
					const i$1 = t$1;
					if (this._lastPos.equals(i$1) || !this._box && i$1.dist(this._startPos) < this._clickTolerance) return;
					const a$1 = this._startPos;
					this._lastPos = i$1, this._box || (this._box = h.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e$1));
					const r$1 = Math.min(a$1.x, i$1.x), o$1 = Math.max(a$1.x, i$1.x), s$1 = Math.min(a$1.y, i$1.y), n$1 = Math.max(a$1.y, i$1.y);
					h.setTransform(this._box, `translate(${r$1}px,${s$1}px)`), this._box.style.width = o$1 - r$1 + "px", this._box.style.height = n$1 - s$1 + "px";
				}
				mouseupWindow(e$1, i$1) {
					if (!this._active) return;
					if (0 !== e$1.button) return;
					const a$1 = this._startPos, r$1 = i$1;
					if (this.reset(), h.suppressClick(), a$1.x !== r$1.x || a$1.y !== r$1.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e$1 })), { cameraAnimation: (e$2) => e$2.fitScreenCoordinates(a$1, r$1, this._tr.bearing, { linear: !0 }) };
					this._fireEvent("boxzoomcancel", e$1);
				}
				keydown(e$1) {
					this._active && 27 === e$1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e$1));
				}
				reset() {
					this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (h.remove(this._box), this._box = null), h.enableDrag(), delete this._startPos, delete this._lastPos;
				}
				_fireEvent(e$1, i$1) {
					return this._map.fire(new t.l(e$1, { originalEvent: i$1 }));
				}
			}
			function ho$1(e$1, t$1) {
				if (e$1.length !== t$1.length) throw new Error(`The number of touches and points are not equal - touches ${e$1.length}, points ${t$1.length}`);
				const i$1 = {};
				for (let a$1 = 0; a$1 < e$1.length; a$1++) i$1[e$1[a$1].identifier] = t$1[a$1];
				return i$1;
			}
			class uo$1 {
				constructor(e$1) {
					this.reset(), this.numTouches = e$1.numTouches;
				}
				reset() {
					delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
				}
				touchstart(e$1, i$1, a$1) {
					(this.centroid || a$1.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e$1.timeStamp), a$1.length === this.numTouches && (this.centroid = function(e$2) {
						const i$2 = new t.P(0, 0);
						for (const t$1 of e$2) i$2._add(t$1);
						return i$2.div(e$2.length);
					}(i$1), this.touches = ho$1(a$1, i$1)));
				}
				touchmove(e$1, t$1, i$1) {
					if (this.aborted || !this.centroid) return;
					const a$1 = ho$1(i$1, t$1);
					for (const e$2 in this.touches) {
						const t$2 = a$1[e$2];
						(!t$2 || t$2.dist(this.touches[e$2]) > 30) && (this.aborted = !0);
					}
				}
				touchend(e$1, t$1, i$1) {
					if ((!this.centroid || e$1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i$1.length) {
						const e$2 = !this.aborted && this.centroid;
						if (this.reset(), e$2) return e$2;
					}
				}
			}
			class _o$1 {
				constructor(e$1) {
					this.singleTap = new uo$1(e$1), this.numTaps = e$1.numTaps, this.reset();
				}
				reset() {
					this.lastTime = Infinity, delete this.lastTap, this.count = 0, this.singleTap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this.singleTap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this.singleTap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const a$1 = this.singleTap.touchend(e$1, t$1, i$1);
					if (a$1) {
						const t$2 = e$1.timeStamp - this.lastTime < 500, i$2 = !this.lastTap || this.lastTap.dist(a$1) < 30;
						if (t$2 && i$2 || this.reset(), this.count++, this.lastTime = e$1.timeStamp, this.lastTap = a$1, this.count === this.numTaps) return this.reset(), a$1;
					}
				}
			}
			class po$1 {
				constructor(e$1) {
					this._tr = new lo$1(e$1), this._zoomIn = new _o$1({
						numTouches: 1,
						numTaps: 2
					}), this._zoomOut = new _o$1({
						numTouches: 2,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this._zoomIn.touchstart(e$1, t$1, i$1), this._zoomOut.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this._zoomIn.touchmove(e$1, t$1, i$1), this._zoomOut.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const a$1 = this._zoomIn.touchend(e$1, t$1, i$1), r$1 = this._zoomOut.touchend(e$1, t$1, i$1), o$1 = this._tr;
					return a$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: o$1.zoom + 1,
						around: o$1.unproject(a$1)
					}, { originalEvent: e$1 }) }) : r$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: o$1.zoom - 1,
						around: o$1.unproject(r$1)
					}, { originalEvent: e$1 }) }) : void 0;
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class mo$1 {
				constructor(e$1) {
					this._enabled = !!e$1.enable, this._moveStateManager = e$1.moveStateManager, this._clickTolerance = e$1.clickTolerance || 1, this._moveFunction = e$1.move, this._activateOnStart = !!e$1.activateOnStart, e$1.assignEvents(this), this.reset();
				}
				reset(e$1) {
					this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e$1);
				}
				_move(...e$1) {
					const t$1 = this._moveFunction(...e$1);
					if (t$1.bearingDelta || t$1.pitchDelta || t$1.rollDelta || t$1.around || t$1.panDelta) return this._active = !0, t$1;
				}
				dragStart(e$1, t$1) {
					this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e$1) && (this._moveStateManager.startMove(e$1), this._lastPoint = Array.isArray(t$1) ? t$1[0] : t$1, this._activateOnStart && this._lastPoint && (this._active = !0));
				}
				dragMove(e$1, t$1) {
					if (!this.isEnabled()) return;
					const i$1 = this._lastPoint;
					if (!i$1) return;
					if (e$1.preventDefault(), !this._moveStateManager.isValidMoveEvent(e$1)) return void this.reset(e$1);
					const a$1 = Array.isArray(t$1) ? t$1[0] : t$1;
					return !this._moved && a$1.dist(i$1) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = a$1, this._move(i$1, a$1));
				}
				dragEnd(e$1) {
					this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e$1) && (this._moved && h.suppressClick(), this.reset(e$1));
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				getClickTolerance() {
					return this._clickTolerance;
				}
			}
			const fo$1 = 0, go$1 = 2, vo$1 = {
				[fo$1]: 1,
				[go$1]: 2
			};
			class xo$1 {
				constructor(e$1) {
					this._correctEvent = e$1.checkCorrectEvent;
				}
				startMove(e$1) {
					this._eventButton = h.mouseButton(e$1);
				}
				endMove(e$1) {
					delete this._eventButton;
				}
				isValidStartEvent(e$1) {
					return this._correctEvent(e$1);
				}
				isValidMoveEvent(e$1) {
					return !function(e$2, t$1) {
						const i$1 = vo$1[t$1];
						return void 0 === e$2.buttons || (e$2.buttons & i$1) !== i$1;
					}(e$1, this._eventButton);
				}
				isValidEndEvent(e$1) {
					return h.mouseButton(e$1) === this._eventButton;
				}
			}
			class bo$1 {
				constructor() {
					this._firstTouch = void 0;
				}
				_isOneFingerTouch(e$1) {
					return 1 === e$1.targetTouches.length;
				}
				_isSameTouchEvent(e$1) {
					return e$1.targetTouches[0].identifier === this._firstTouch;
				}
				startMove(e$1) {
					this._firstTouch = e$1.targetTouches[0].identifier;
				}
				endMove(e$1) {
					delete this._firstTouch;
				}
				isValidStartEvent(e$1) {
					return this._isOneFingerTouch(e$1);
				}
				isValidMoveEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
				isValidEndEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
			}
			class yo$1 {
				constructor(e$1 = new xo$1({ checkCorrectEvent: () => !0 }), t$1 = new bo$1()) {
					this.mouseMoveStateManager = e$1, this.oneFingerTouchMoveStateManager = t$1;
				}
				_executeRelevantHandler(e$1, t$1, i$1) {
					return e$1 instanceof MouseEvent ? t$1(e$1) : "undefined" != typeof TouchEvent && e$1 instanceof TouchEvent ? i$1(e$1) : void 0;
				}
				startMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.startMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.startMove(e$2)));
				}
				endMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.endMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.endMove(e$2)));
				}
				isValidStartEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidStartEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e$2)));
				}
				isValidMoveEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidMoveEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e$2)));
				}
				isValidEndEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidEndEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e$2)));
				}
			}
			const wo$1 = (e$1) => {
				e$1.mousedown = e$1.dragStart, e$1.mousemoveWindow = e$1.dragMove, e$1.mouseup = e$1.dragEnd, e$1.contextmenu = (e$2) => {
					e$2.preventDefault();
				};
			};
			class To$1 {
				constructor(e$1, t$1) {
					this._clickTolerance = e$1.clickTolerance || 1, this._map = t$1, this.reset();
				}
				reset() {
					this._active = !1, this._touches = {}, this._sum = new t.P(0, 0);
				}
				_shouldBePrevented(e$1) {
					return e$1 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
				}
				touchstart(e$1, t$1, i$1) {
					return this._calculateTransform(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._active) {
						if (!this._shouldBePrevented(i$1.length)) return e$1.preventDefault(), this._calculateTransform(e$1, t$1, i$1);
						this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e$1);
					}
				}
				touchend(e$1, t$1, i$1) {
					this._calculateTransform(e$1, t$1, i$1), this._active && this._shouldBePrevented(i$1.length) && this.reset();
				}
				touchcancel() {
					this.reset();
				}
				_calculateTransform(e$1, i$1, a$1) {
					a$1.length > 0 && (this._active = !0);
					const r$1 = ho$1(a$1, i$1), o$1 = new t.P(0, 0), s$1 = new t.P(0, 0);
					let n$1 = 0;
					for (const e$2 in r$1) {
						const t$1 = r$1[e$2], i$2 = this._touches[e$2];
						i$2 && (o$1._add(t$1), s$1._add(t$1.sub(i$2)), n$1++, r$1[e$2] = t$1);
					}
					if (this._touches = r$1, this._shouldBePrevented(n$1) || !s$1.mag()) return;
					const l$1 = s$1.div(n$1);
					return this._sum._add(l$1), this._sum.mag() < this._clickTolerance ? void 0 : {
						around: o$1.div(n$1),
						panDelta: l$1
					};
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Po$1 {
				constructor() {
					this.reset();
				}
				reset() {
					this._active = !1, delete this._firstTwoTouches;
				}
				touchstart(e$1, t$1, i$1) {
					this._firstTwoTouches || i$1.length < 2 || (this._firstTwoTouches = [i$1[0].identifier, i$1[1].identifier], this._start([t$1[0], t$1[1]]));
				}
				touchmove(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					e$1.preventDefault();
					const [a$1, r$1] = this._firstTwoTouches, o$1 = Io$1(i$1, t$1, a$1), s$1 = Io$1(i$1, t$1, r$1);
					if (!o$1 || !s$1) return;
					const n$1 = this._aroundCenter ? null : o$1.add(s$1).div(2);
					return this._move([o$1, s$1], n$1, e$1);
				}
				touchend(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					const [a$1, r$1] = this._firstTwoTouches, o$1 = Io$1(i$1, t$1, a$1), s$1 = Io$1(i$1, t$1, r$1);
					o$1 && s$1 || (this._active && h.suppressClick(), this.reset());
				}
				touchcancel() {
					this.reset();
				}
				enable(e$1) {
					this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
			}
			function Io$1(e$1, t$1, i$1) {
				for (let a$1 = 0; a$1 < e$1.length; a$1++) if (e$1[a$1].identifier === i$1) return t$1[a$1];
			}
			function Co$1(e$1, t$1) {
				return Math.log(e$1 / t$1) / Math.LN2;
			}
			class Mo$1 extends Po$1 {
				reset() {
					super.reset(), delete this._distance, delete this._startDistance;
				}
				_start(e$1) {
					this._startDistance = this._distance = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1) {
					const i$1 = this._distance;
					if (this._distance = e$1[0].dist(e$1[1]), this._active || !(Math.abs(Co$1(this._distance, this._startDistance)) < .1)) return this._active = !0, {
						zoomDelta: Co$1(this._distance, i$1),
						pinchAround: t$1
					};
				}
			}
			function Eo$1(e$1, t$1) {
				return 180 * e$1.angleWith(t$1) / Math.PI;
			}
			class So$1 extends Po$1 {
				reset() {
					super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
				}
				_start(e$1) {
					this._startVector = this._vector = e$1[0].sub(e$1[1]), this._minDiameter = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1, i$1) {
					const a$1 = this._vector;
					if (this._vector = e$1[0].sub(e$1[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
						bearingDelta: Eo$1(this._vector, a$1),
						pinchAround: t$1
					};
				}
				_isBelowThreshold(e$1) {
					this._minDiameter = Math.min(this._minDiameter, e$1.mag());
					const t$1 = 25 / (Math.PI * this._minDiameter) * 360, i$1 = Eo$1(e$1, this._startVector);
					return Math.abs(i$1) < t$1;
				}
			}
			function Ro(e$1) {
				return Math.abs(e$1.y) > Math.abs(e$1.x);
			}
			class zo$1 extends Po$1 {
				constructor(e$1) {
					super(), this._currentTouchCount = 0, this._map = e$1;
				}
				reset() {
					super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
				}
				touchstart(e$1, t$1, i$1) {
					super.touchstart(e$1, t$1, i$1), this._currentTouchCount = i$1.length;
				}
				_start(e$1) {
					this._lastPoints = e$1, Ro(e$1[0].sub(e$1[1])) && (this._valid = !1);
				}
				_move(e$1, t$1, i$1) {
					if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
					const a$1 = e$1[0].sub(this._lastPoints[0]), r$1 = e$1[1].sub(this._lastPoints[1]);
					return this._valid = this.gestureBeginsVertically(a$1, r$1, i$1.timeStamp), this._valid ? (this._lastPoints = e$1, this._active = !0, { pitchDelta: (a$1.y + r$1.y) / 2 * -.5 }) : void 0;
				}
				gestureBeginsVertically(e$1, t$1, i$1) {
					if (void 0 !== this._valid) return this._valid;
					const a$1 = e$1.mag() >= 2, r$1 = t$1.mag() >= 2;
					if (!a$1 && !r$1) return;
					if (!a$1 || !r$1) return void 0 === this._firstMove && (this._firstMove = i$1), i$1 - this._firstMove < 100 && void 0;
					const o$1 = e$1.y > 0 == t$1.y > 0;
					return Ro(e$1) && Ro(t$1) && o$1;
				}
			}
			const Do$1 = {
				panStep: 100,
				bearingStep: 15,
				pitchStep: 10
			};
			class Ao$1 {
				constructor(e$1) {
					this._tr = new lo$1(e$1);
					const t$1 = Do$1;
					this._panStep = t$1.panStep, this._bearingStep = t$1.bearingStep, this._pitchStep = t$1.pitchStep, this._rotationDisabled = !1;
				}
				reset() {
					this._active = !1;
				}
				keydown(e$1) {
					if (e$1.altKey || e$1.ctrlKey || e$1.metaKey) return;
					let t$1 = 0, i$1 = 0, a$1 = 0, r$1 = 0, o$1 = 0;
					switch (e$1.keyCode) {
						case 61:
						case 107:
						case 171:
						case 187:
							t$1 = 1;
							break;
						case 189:
						case 109:
						case 173:
							t$1 = -1;
							break;
						case 37:
							e$1.shiftKey ? i$1 = -1 : (e$1.preventDefault(), r$1 = -1);
							break;
						case 39:
							e$1.shiftKey ? i$1 = 1 : (e$1.preventDefault(), r$1 = 1);
							break;
						case 38:
							e$1.shiftKey ? a$1 = 1 : (e$1.preventDefault(), o$1 = -1);
							break;
						case 40:
							e$1.shiftKey ? a$1 = -1 : (e$1.preventDefault(), o$1 = 1);
							break;
						default: return;
					}
					return this._rotationDisabled && (i$1 = 0, a$1 = 0), { cameraAnimation: (s$1) => {
						const n$1 = this._tr;
						s$1.easeTo({
							duration: 300,
							easeId: "keyboardHandler",
							easing: Lo$1,
							zoom: t$1 ? Math.round(n$1.zoom) + t$1 * (e$1.shiftKey ? 2 : 1) : n$1.zoom,
							bearing: n$1.bearing + i$1 * this._bearingStep,
							pitch: n$1.pitch + a$1 * this._pitchStep,
							offset: [-r$1 * this._panStep, -o$1 * this._panStep],
							center: n$1.center
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				disableRotation() {
					this._rotationDisabled = !0;
				}
				enableRotation() {
					this._rotationDisabled = !1;
				}
			}
			function Lo$1(e$1) {
				return e$1 * (2 - e$1);
			}
			const ko$1 = 4.000244140625, Fo$1 = 1 / 450;
			class Bo$1 {
				constructor(e$1, t$1) {
					this._onTimeout = (e$2) => {
						this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e$2);
					}, this._map = e$1, this._tr = new lo$1(e$1), this._triggerRenderFrame = t$1, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Fo$1;
				}
				setZoomRate(e$1) {
					this._defaultZoomRate = e$1;
				}
				setWheelZoomRate(e$1) {
					this._wheelZoomRate = e$1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active || void 0 !== this._finishTimeout;
				}
				isZooming() {
					return !!this._zooming;
				}
				enable(e$1) {
					this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				_shouldBePrevented(e$1) {
					return !!this._map.cooperativeGestures.isEnabled() && !(e$1.ctrlKey || this._map.cooperativeGestures.isBypassed(e$1));
				}
				wheel(e$1) {
					if (!this.isEnabled()) return;
					if (this._shouldBePrevented(e$1)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e$1);
					let t$1 = e$1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e$1.deltaY : e$1.deltaY;
					const i$1 = c(), a$1 = i$1 - (this._lastWheelEventTime || 0);
					this._lastWheelEventTime = i$1, 0 !== t$1 && t$1 % ko$1 == 0 ? this._type = "wheel" : 0 !== t$1 && Math.abs(t$1) < 4 ? this._type = "trackpad" : a$1 > 400 ? (this._type = null, this._lastValue = t$1, this._timeout = setTimeout(this._onTimeout, 40, e$1)) : this._type || (this._type = Math.abs(a$1 * t$1) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t$1 += this._lastValue)), e$1.shiftKey && t$1 && (t$1 /= 4), this._type && (this._lastWheelEvent = e$1, this._delta -= t$1, this._active || this._start(e$1)), e$1.preventDefault();
				}
				_start(e$1) {
					if (!this._delta) return;
					this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
					const i$1 = h.mousePos(this._map.getCanvas(), e$1), a$1 = this._tr;
					this._aroundPoint = this._aroundCenter ? a$1.transform.locationToScreenPoint(t.V.convert(a$1.center)) : i$1, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
				}
				renderFrame() {
					if (!this._frameId) return;
					if (this._frameId = null, !this.isActive()) return;
					const e$1 = this._tr.transform;
					if ("number" == typeof this._lastExpectedZoom) {
						const t$1 = e$1.zoom - this._lastExpectedZoom;
						"number" == typeof this._startZoom && (this._startZoom += t$1), "number" == typeof this._targetZoom && (this._targetZoom += t$1);
					}
					if (0 !== this._delta) {
						const i$2 = "wheel" === this._type && Math.abs(this._delta) > ko$1 ? this._wheelZoomRate : this._defaultZoomRate;
						let a$2 = 2 / (1 + Math.exp(-Math.abs(this._delta * i$2)));
						this._delta < 0 && 0 !== a$2 && (a$2 = 1 / a$2);
						const r$2 = "number" != typeof this._targetZoom ? e$1.scale : t.ar(this._targetZoom);
						this._targetZoom = e$1.applyConstrain(e$1.getCameraLngLat(), t.au(r$2 * a$2)).zoom, "wheel" === this._type && (this._startZoom = e$1.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
					}
					const i$1 = "number" != typeof this._targetZoom ? e$1.zoom : this._targetZoom, a$1 = this._startZoom, r$1 = this._easing;
					let o$1, s$1 = !1;
					if ("wheel" === this._type && a$1 && r$1) {
						const e$2 = c() - this._lastWheelEventTime, n$1 = Math.min((e$2 + 5) / 200, 1), l$1 = r$1(n$1);
						o$1 = t.G.number(a$1, i$1, l$1), n$1 < 1 ? this._frameId || (this._frameId = !0) : s$1 = !0;
					} else o$1 = i$1, s$1 = !0;
					return this._active = !0, s$1 && (this._active = !1, this._finishTimeout = setTimeout((() => {
						this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
					}), 200)), this._lastExpectedZoom = o$1, {
						noInertia: !0,
						needsRenderFrame: !s$1,
						zoomDelta: o$1 - e$1.zoom,
						around: this._aroundPoint,
						originalEvent: this._lastWheelEvent
					};
				}
				_smoothOutEasing(e$1) {
					let i$1 = t.cz;
					if (this._prevEase) {
						const e$2 = this._prevEase, a$1 = (c() - e$2.start) / e$2.duration, r$1 = e$2.easing(a$1 + .01) - e$2.easing(a$1), o$1 = .27 / Math.sqrt(r$1 * r$1 + 1e-4) * .01, s$1 = Math.sqrt(.0729 - o$1 * o$1);
						i$1 = t.cx(o$1, s$1, .25, 1);
					}
					return this._prevEase = {
						start: c(),
						duration: e$1,
						easing: i$1
					}, i$1;
				}
				reset() {
					this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
				}
			}
			class Oo$1 {
				constructor(e$1, t$1) {
					this._clickZoom = e$1, this._tapZoom = t$1;
				}
				enable() {
					this._clickZoom.enable(), this._tapZoom.enable();
				}
				disable() {
					this._clickZoom.disable(), this._tapZoom.disable();
				}
				isEnabled() {
					return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
				}
				isActive() {
					return this._clickZoom.isActive() || this._tapZoom.isActive();
				}
			}
			class jo$1 {
				constructor(e$1) {
					this._tr = new lo$1(e$1), this.reset();
				}
				reset() {
					this._active = !1;
				}
				dblclick(e$1, t$1) {
					return e$1.preventDefault(), { cameraAnimation: (i$1) => {
						i$1.easeTo({
							duration: 300,
							zoom: this._tr.zoom + (e$1.shiftKey ? -1 : 1),
							around: this._tr.unproject(t$1)
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class No$1 {
				constructor() {
					this._tap = new _o$1({
						numTouches: 1,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					if (!this._swipePoint) if (this._tapTime) {
						const a$1 = t$1[0], r$1 = e$1.timeStamp - this._tapTime < 500, o$1 = this._tapPoint.dist(a$1) < 30;
						r$1 && o$1 ? i$1.length > 0 && (this._swipePoint = a$1, this._swipeTouch = i$1[0].identifier) : this.reset();
					} else this._tap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._tapTime) {
						if (this._swipePoint) {
							if (i$1[0].identifier !== this._swipeTouch) return;
							const a$1 = t$1[0], r$1 = a$1.y - this._swipePoint.y;
							return this._swipePoint = a$1, e$1.preventDefault(), this._active = !0, { zoomDelta: r$1 / 128 };
						}
					} else this._tap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					if (this._tapTime) this._swipePoint && 0 === i$1.length && this.reset();
					else {
						const a$1 = this._tap.touchend(e$1, t$1, i$1);
						a$1 && (this._tapTime = e$1.timeStamp, this._tapPoint = a$1);
					}
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Zo$1 {
				constructor(e$1, t$1, i$1) {
					this._el = e$1, this._mousePan = t$1, this._touchPan = i$1;
				}
				enable(e$1) {
					this._inertiaOptions = e$1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
				}
				disable() {
					this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
				}
				isEnabled() {
					return this._mousePan.isEnabled() && this._touchPan.isEnabled();
				}
				isActive() {
					return this._mousePan.isActive() || this._touchPan.isActive();
				}
			}
			class Go$1 {
				constructor(e$1, t$1, i$1, a$1) {
					this._pitchWithRotate = e$1.pitchWithRotate, this._rollEnabled = e$1.rollEnabled, this._mouseRotate = t$1, this._mousePitch = i$1, this._mouseRoll = a$1;
				}
				enable() {
					this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
				}
				disable() {
					this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
				}
				isEnabled() {
					return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
				}
				isActive() {
					return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
				}
			}
			class Uo$1 {
				constructor(e$1, t$1, i$1, a$1) {
					this._el = e$1, this._touchZoom = t$1, this._touchRotate = i$1, this._tapDragZoom = a$1, this._rotationDisabled = !1, this._enabled = !0;
				}
				enable(e$1) {
					this._touchZoom.enable(e$1), this._rotationDisabled || this._touchRotate.enable(e$1), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
				}
				disable() {
					this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
				}
				isEnabled() {
					return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
				}
				isActive() {
					return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
				}
				disableRotation() {
					this._rotationDisabled = !0, this._touchRotate.disable();
				}
				enableRotation() {
					this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
				}
			}
			class Vo$1 {
				constructor(e$1, t$1) {
					this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e$1, this._options = t$1, this._enabled = !1;
				}
				isActive() {
					return !1;
				}
				reset() {}
				_setupUI() {
					if (this._container) return;
					const e$1 = this._map.getCanvasContainer();
					e$1.classList.add("maplibregl-cooperative-gestures"), this._container = h.create("div", "maplibregl-cooperative-gesture-screen", e$1);
					let t$1 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
					"metaKey" === this._bypassKey && (t$1 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
					const i$1 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a$1 = document.createElement("div");
					a$1.className = "maplibregl-desktop-message", a$1.textContent = t$1, this._container.appendChild(a$1);
					const r$1 = document.createElement("div");
					r$1.className = "maplibregl-mobile-message", r$1.textContent = i$1, this._container.appendChild(r$1), this._container.setAttribute("aria-hidden", "true");
				}
				_destroyUI() {
					this._container && (h.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
				}
				enable() {
					this._setupUI(), this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this._destroyUI();
				}
				isEnabled() {
					return this._enabled;
				}
				isBypassed(e$1) {
					return e$1[this._bypassKey];
				}
				notifyGestureBlocked(e$1, i$1) {
					this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", {
						gestureType: e$1,
						originalEvent: i$1
					})), this._container.classList.add("maplibregl-show"), setTimeout((() => {
						this._container.classList.remove("maplibregl-show");
					}), 100));
				}
			}
			const qo$1 = (e$1) => e$1.zoom || e$1.drag || e$1.roll || e$1.pitch || e$1.rotate;
			class Wo$1 extends t.l {}
			function $o$1(e$1) {
				return e$1.panDelta && e$1.panDelta.mag() || e$1.zoomDelta || e$1.bearingDelta || e$1.pitchDelta || e$1.rollDelta;
			}
			class Ho$1 {
				constructor(e$1, i$1) {
					this.handleWindowEvent = (e$2) => {
						this.handleEvent(e$2, `${e$2.type}Window`);
					}, this.handleEvent = (e$2, i$2) => {
						if ("blur" === e$2.type) return void this.stop(!0);
						this._updatingCamera = !0;
						const a$2 = "renderFrame" === e$2.type ? void 0 : e$2, r$1 = { needsRenderFrame: !1 }, o$1 = {}, s$1 = {};
						for (const { handlerName: n$2, handler: l$2, allowed: c$1 } of this._handlers) {
							if (!l$2.isEnabled()) continue;
							let u$1;
							if (this._blockedByActive(s$1, c$1, n$2)) l$2.reset();
							else if (l$2[i$2 || e$2.type]) {
								if (t.cA(e$2, i$2 || e$2.type)) {
									const t$1 = h.mousePos(this._map.getCanvas(), e$2);
									u$1 = l$2[i$2 || e$2.type](e$2, t$1);
								} else if (t.cB(e$2, i$2 || e$2.type)) {
									const t$1 = this._getMapTouches(e$2.touches), a$3 = h.touchPos(this._map.getCanvas(), t$1);
									u$1 = l$2[i$2 || e$2.type](e$2, a$3, t$1);
								} else t.cC(i$2 || e$2.type) || (u$1 = l$2[i$2 || e$2.type](e$2));
								this.mergeHandlerResult(r$1, o$1, u$1, n$2, a$2), u$1 && u$1.needsRenderFrame && this._triggerRenderFrame();
							}
							(u$1 || l$2.isActive()) && (s$1[n$2] = l$2);
						}
						const n$1 = {};
						for (const e$3 in this._previousActiveHandlers) s$1[e$3] || (n$1[e$3] = a$2);
						this._previousActiveHandlers = s$1, (Object.keys(n$1).length || $o$1(r$1)) && (this._changes.push([
							r$1,
							o$1,
							n$1
						]), this._triggerRenderFrame()), (Object.keys(s$1).length || $o$1(r$1)) && this._map._stop(!0), this._updatingCamera = !1;
						const { cameraAnimation: l$1 } = r$1;
						l$1 && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], l$1(this._map));
					}, this._map = e$1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new eo$1(e$1), this._bearingSnap = i$1.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i$1);
					const a$1 = this._el;
					this._listeners = [
						[
							a$1,
							"touchstart",
							{ passive: !0 }
						],
						[
							a$1,
							"touchmove",
							{ passive: !1 }
						],
						[
							a$1,
							"touchend",
							void 0
						],
						[
							a$1,
							"touchcancel",
							void 0
						],
						[
							a$1,
							"mousedown",
							void 0
						],
						[
							a$1,
							"mousemove",
							void 0
						],
						[
							a$1,
							"mouseup",
							void 0
						],
						[
							document,
							"mousemove",
							{ capture: !0 }
						],
						[
							document,
							"mouseup",
							void 0
						],
						[
							a$1,
							"mouseover",
							void 0
						],
						[
							a$1,
							"mouseout",
							void 0
						],
						[
							a$1,
							"dblclick",
							void 0
						],
						[
							a$1,
							"click",
							void 0
						],
						[
							a$1,
							"keydown",
							{ capture: !1 }
						],
						[
							a$1,
							"keyup",
							void 0
						],
						[
							a$1,
							"wheel",
							{ passive: !1 }
						],
						[
							a$1,
							"contextmenu",
							void 0
						],
						[
							window,
							"blur",
							void 0
						]
					];
					for (const [e$2, t$1, i$2] of this._listeners) h.addEventListener(e$2, t$1, e$2 === document ? this.handleWindowEvent : this.handleEvent, i$2);
				}
				destroy() {
					for (const [e$1, t$1, i$1] of this._listeners) h.removeEventListener(e$1, t$1, e$1 === document ? this.handleWindowEvent : this.handleEvent, i$1);
				}
				_addDefaultHandlers(e$1) {
					const i$1 = this._map, a$1 = i$1.getCanvasContainer();
					this._add("mapEvent", new so$1(i$1, e$1));
					const r$1 = i$1.boxZoom = new co$1(i$1, e$1);
					this._add("boxZoom", r$1), e$1.interactive && e$1.boxZoom && r$1.enable();
					const o$1 = i$1.cooperativeGestures = new Vo$1(i$1, e$1.cooperativeGestures);
					this._add("cooperativeGestures", o$1), e$1.cooperativeGestures && o$1.enable();
					const s$1 = new po$1(i$1), n$1 = new jo$1(i$1);
					i$1.doubleClickZoom = new Oo$1(n$1, s$1), this._add("tapZoom", s$1), this._add("clickZoom", n$1), e$1.interactive && e$1.doubleClickZoom && i$1.doubleClickZoom.enable();
					const l$1 = new No$1();
					this._add("tapDragZoom", l$1);
					const c$1 = i$1.touchPitch = new zo$1(i$1);
					this._add("touchPitch", c$1), e$1.interactive && e$1.touchPitch && i$1.touchPitch.enable(e$1.touchPitch);
					const u$1 = () => i$1.project(i$1.getCenter()), d$1 = function({ enable: e$2, clickTolerance: i$2, aroundCenter: a$2 = !0, minPixelCenterThreshold: r$2 = 100, rotateDegreesPerPixelMoved: o$2 = .8 }, s$2) {
						return new mo$1({
							clickTolerance: i$2,
							move: (e$3, i$3) => {
								const n$2 = s$2();
								if (a$2 && Math.abs(n$2.y - e$3.y) > r$2) return { bearingDelta: t.cy(new t.P(e$3.x, i$3.y), i$3, n$2) };
								let l$2 = (i$3.x - e$3.x) * o$2;
								return a$2 && i$3.y < n$2.y && (l$2 = -l$2), { bearingDelta: l$2 };
							},
							moveStateManager: new xo$1({ checkCorrectEvent: (e$3) => 0 === h.mouseButton(e$3) && e$3.ctrlKey || 2 === h.mouseButton(e$3) && !e$3.ctrlKey }),
							enable: e$2,
							assignEvents: wo$1
						});
					}(e$1, u$1), _$2 = function({ enable: e$2, clickTolerance: t$1, pitchDegreesPerPixelMoved: i$2 = -.5 }) {
						return new mo$1({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({ pitchDelta: (t$2.y - e$3.y) * i$2 }),
							moveStateManager: new xo$1({ checkCorrectEvent: (e$3) => 0 === h.mouseButton(e$3) && e$3.ctrlKey || 2 === h.mouseButton(e$3) }),
							enable: e$2,
							assignEvents: wo$1
						});
					}(e$1), p$1 = function({ enable: e$2, clickTolerance: t$1, rollDegreesPerPixelMoved: i$2 = .3 }, a$2) {
						return new mo$1({
							clickTolerance: t$1,
							move: (e$3, t$2) => {
								const r$2 = a$2();
								let o$2 = (t$2.x - e$3.x) * i$2;
								return t$2.y < r$2.y && (o$2 = -o$2), { rollDelta: o$2 };
							},
							moveStateManager: new xo$1({ checkCorrectEvent: (e$3) => 2 === h.mouseButton(e$3) && e$3.ctrlKey }),
							enable: e$2,
							assignEvents: wo$1
						});
					}(e$1, u$1);
					i$1.dragRotate = new Go$1(e$1, d$1, _$2, p$1), this._add("mouseRotate", d$1, ["mousePitch"]), this._add("mousePitch", _$2, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p$1, ["mousePitch"]), e$1.interactive && e$1.dragRotate && i$1.dragRotate.enable();
					const m$1 = function({ enable: e$2, clickTolerance: t$1 }) {
						return new mo$1({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({
								around: t$2,
								panDelta: t$2.sub(e$3)
							}),
							activateOnStart: !0,
							moveStateManager: new xo$1({ checkCorrectEvent: (e$3) => 0 === h.mouseButton(e$3) && !e$3.ctrlKey }),
							enable: e$2,
							assignEvents: wo$1
						});
					}(e$1), f$1 = new To$1(e$1, i$1);
					i$1.dragPan = new Zo$1(a$1, m$1, f$1), this._add("mousePan", m$1), this._add("touchPan", f$1, ["touchZoom", "touchRotate"]), e$1.interactive && e$1.dragPan && i$1.dragPan.enable(e$1.dragPan);
					const g$2 = new So$1(), v$1 = new Mo$1();
					i$1.touchZoomRotate = new Uo$1(a$1, v$1, g$2, l$1), this._add("touchRotate", g$2, ["touchPan", "touchZoom"]), this._add("touchZoom", v$1, ["touchPan", "touchRotate"]), e$1.interactive && e$1.touchZoomRotate && i$1.touchZoomRotate.enable(e$1.touchZoomRotate), this._add("blockableMapEvent", new no$1(i$1));
					const x$1 = i$1.scrollZoom = new Bo$1(i$1, (() => this._triggerRenderFrame()));
					this._add("scrollZoom", x$1, ["mousePan"]), e$1.interactive && e$1.scrollZoom && i$1.scrollZoom.enable(e$1.scrollZoom);
					const b$1 = i$1.keyboard = new Ao$1(i$1);
					this._add("keyboard", b$1), e$1.interactive && e$1.keyboard && i$1.keyboard.enable();
				}
				_add(e$1, t$1, i$1) {
					this._handlers.push({
						handlerName: e$1,
						handler: t$1,
						allowed: i$1
					}), this._handlersById[e$1] = t$1;
				}
				stop(e$1) {
					if (!this._updatingCamera) {
						for (const { handler: e$2 } of this._handlers) e$2.reset();
						this._inertia.clear(), this._fireEvents({}, {}, e$1), this._changes = [];
					}
				}
				isActive() {
					for (const { handler: e$1 } of this._handlers) if (e$1.isActive()) return !0;
					return !1;
				}
				isZooming() {
					return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
				}
				isRotating() {
					return !!this._eventsInProgress.rotate;
				}
				isMoving() {
					return Boolean(qo$1(this._eventsInProgress)) || this.isZooming();
				}
				_blockedByActive(e$1, t$1, i$1) {
					for (const a$1 in e$1) if (a$1 !== i$1 && (!t$1 || t$1.indexOf(a$1) < 0)) return !0;
					return !1;
				}
				_getMapTouches(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) this._el.contains(i$1.target) && t$1.push(i$1);
					return t$1;
				}
				mergeHandlerResult(e$1, i$1, a$1, r$1, o$1) {
					if (!a$1) return;
					t.e(e$1, a$1);
					const s$1 = {
						handlerName: r$1,
						originalEvent: a$1.originalEvent || o$1
					};
					void 0 !== a$1.zoomDelta && (i$1.zoom = s$1), void 0 !== a$1.panDelta && (i$1.drag = s$1), void 0 !== a$1.rollDelta && (i$1.roll = s$1), void 0 !== a$1.pitchDelta && (i$1.pitch = s$1), void 0 !== a$1.bearingDelta && (i$1.rotate = s$1);
				}
				_applyChanges() {
					const e$1 = {}, i$1 = {}, a$1 = {};
					for (const [r$1, o$1, s$1] of this._changes) r$1.panDelta && (e$1.panDelta = (e$1.panDelta || new t.P(0, 0))._add(r$1.panDelta)), r$1.zoomDelta && (e$1.zoomDelta = (e$1.zoomDelta || 0) + r$1.zoomDelta), r$1.bearingDelta && (e$1.bearingDelta = (e$1.bearingDelta || 0) + r$1.bearingDelta), r$1.pitchDelta && (e$1.pitchDelta = (e$1.pitchDelta || 0) + r$1.pitchDelta), r$1.rollDelta && (e$1.rollDelta = (e$1.rollDelta || 0) + r$1.rollDelta), void 0 !== r$1.around && (e$1.around = r$1.around), void 0 !== r$1.pinchAround && (e$1.pinchAround = r$1.pinchAround), r$1.noInertia && (e$1.noInertia = r$1.noInertia), t.e(i$1, o$1), t.e(a$1, s$1);
					this._updateMapTransform(e$1, i$1, a$1), this._changes = [];
				}
				_updateMapTransform(e$1, t$1, i$1) {
					const a$1 = this._map, r$1 = a$1._getTransformForUpdate(), o$1 = a$1.terrain;
					if (!($o$1(e$1) || o$1 && this._terrainMovement)) return this._fireEvents(t$1, i$1, !0);
					a$1._stop(!0);
					let { panDelta: s$1, zoomDelta: n$1, bearingDelta: l$1, pitchDelta: c$1, rollDelta: h$1, around: u$1, pinchAround: d$1 } = e$1;
					void 0 !== d$1 && (u$1 = d$1), u$1 = u$1 || a$1.transform.centerPoint, o$1 && !r$1.isPointOnMapSurface(u$1) && (u$1 = r$1.centerPoint);
					const _$2 = {
						panDelta: s$1,
						zoomDelta: n$1,
						rollDelta: h$1,
						pitchDelta: c$1,
						bearingDelta: l$1,
						around: u$1
					};
					this._map.cameraHelper.useGlobeControls && !r$1.isPointOnMapSurface(u$1) && (u$1 = r$1.centerPoint);
					const p$1 = u$1.distSqr(r$1.centerPoint) < .01 ? r$1.center : r$1.screenPointToLocation(s$1 ? u$1.sub(s$1) : u$1);
					this._handleMapControls({
						terrain: o$1,
						tr: r$1,
						deltasForHelper: _$2,
						preZoomAroundLoc: p$1,
						combinedEventsInProgress: t$1,
						panDelta: s$1
					}), a$1._applyUpdatedTransform(r$1), this._map._update(), e$1.noInertia || this._inertia.record(e$1), this._fireEvents(t$1, i$1, !0);
				}
				_handleMapControls({ terrain: e$1, tr: t$1, deltasForHelper: i$1, preZoomAroundLoc: a$1, combinedEventsInProgress: r$1, panDelta: o$1 }) {
					const s$1 = this._map.cameraHelper;
					if (s$1.handleMapControlsRollPitchBearingZoom(i$1, t$1), e$1) return s$1.useGlobeControls ? (this._terrainMovement || !r$1.drag && !r$1.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void s$1.handleMapControlsPan(i$1, t$1, a$1)) : this._terrainMovement || !r$1.drag && !r$1.zoom ? void (r$1.drag && this._terrainMovement && o$1 ? t$1.setCenter(t$1.screenPointToLocation(t$1.centerPoint.sub(o$1))) : s$1.handleMapControlsPan(i$1, t$1, a$1)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void s$1.handleMapControlsPan(i$1, t$1, a$1));
					s$1.handleMapControlsPan(i$1, t$1, a$1);
				}
				_fireEvents(e$1, i$1, a$1) {
					const r$1 = qo$1(this._eventsInProgress), o$1 = qo$1(e$1), s$1 = {};
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._eventsInProgress[t$1] || (s$1[`${t$1}start`] = i$2), this._eventsInProgress[t$1] = e$1[t$1];
					}
					!r$1 && o$1 && this._fireEvent("movestart", o$1.originalEvent);
					for (const e$2 in s$1) this._fireEvent(e$2, s$1[e$2]);
					o$1 && this._fireEvent("move", o$1.originalEvent);
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._fireEvent(t$1, i$2);
					}
					const l$1 = {};
					let c$1;
					for (const e$2 in this._eventsInProgress) {
						const { handlerName: t$1, originalEvent: a$2 } = this._eventsInProgress[e$2];
						this._handlersById[t$1].isActive() || (delete this._eventsInProgress[e$2], c$1 = i$1[t$1] || a$2, l$1[`${e$2}end`] = c$1);
					}
					for (const e$2 in l$1) this._fireEvent(e$2, l$1[e$2]);
					const h$1 = qo$1(this._eventsInProgress), u$1 = (r$1 || o$1) && !h$1;
					if (u$1 && this._terrainMovement) {
						this._map._elevationFreeze = !1, this._terrainMovement = !1;
						const e$2 = this._map._getTransformForUpdate();
						this._map.getCenterClampedToGround() && e$2.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e$2);
					}
					if (a$1 && u$1) {
						this._updatingCamera = !0;
						const e$2 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i$2 = (e$3) => 0 !== e$3 && -this._bearingSnap < e$3 && e$3 < this._bearingSnap;
						!e$2 || !e$2.essential && n.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c$1 })), i$2(this._map.getBearing()) && this._map.resetNorth()) : (i$2(e$2.bearing || this._map.getBearing()) && (e$2.bearing = 0), e$2.freezeElevation = !0, this._map.easeTo(e$2, { originalEvent: c$1 })), this._updatingCamera = !1;
					}
				}
				_fireEvent(e$1, i$1) {
					this._map.fire(new t.l(e$1, i$1 ? { originalEvent: i$1 } : {}));
				}
				_requestFrame() {
					return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e$1) => {
						delete this._frameId, this.handleEvent(new Wo$1("renderFrame", { timeStamp: e$1 })), this._applyChanges();
					}));
				}
				_triggerRenderFrame() {
					void 0 === this._frameId && (this._frameId = this._requestFrame());
				}
			}
			class Xo$1 extends t.E {
				constructor(e$1, t$1, i$1) {
					super(), this._renderFrameCallback = () => {
						const e$2 = Math.min((c() - this._easeStart) / this._easeOptions.duration, 1);
						this._onEaseFrame(this._easeOptions.easing(e$2)), e$2 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
					}, this._moving = !1, this._zooming = !1, this.transform = e$1, this._bearingSnap = i$1.bearingSnap, this.cameraHelper = t$1, this.on("moveend", (() => {
						delete this._requestedCameraState;
					}));
				}
				migrateProjection(e$1, t$1) {
					e$1.apply(this.transform), this.transform = e$1, this.cameraHelper = t$1;
				}
				getCenter() {
					return new t.V(this.transform.center.lng, this.transform.center.lat);
				}
				setCenter(e$1, t$1) {
					return this.jumpTo({ center: e$1 }, t$1);
				}
				getCenterElevation() {
					return this.transform.elevation;
				}
				setCenterElevation(e$1, t$1) {
					return this.jumpTo({ elevation: e$1 }, t$1), this;
				}
				getCenterClampedToGround() {
					return this._centerClampedToGround;
				}
				setCenterClampedToGround(e$1) {
					this._centerClampedToGround = e$1;
				}
				panBy(e$1, i$1, a$1) {
					return e$1 = t.P.convert(e$1).mult(-1), this.panTo(this.transform.center, t.e({ offset: e$1 }, i$1), a$1);
				}
				panTo(e$1, i$1, a$1) {
					return this.easeTo(t.e({ center: e$1 }, i$1), a$1);
				}
				getZoom() {
					return this.transform.zoom;
				}
				setZoom(e$1, t$1) {
					return this.jumpTo({ zoom: e$1 }, t$1), this;
				}
				zoomTo(e$1, i$1, a$1) {
					return this.easeTo(t.e({ zoom: e$1 }, i$1), a$1);
				}
				zoomIn(e$1, t$1) {
					return this.zoomTo(this.getZoom() + 1, e$1, t$1), this;
				}
				zoomOut(e$1, t$1) {
					return this.zoomTo(this.getZoom() - 1, e$1, t$1), this;
				}
				getVerticalFieldOfView() {
					return this.transform.fov;
				}
				setVerticalFieldOfView(e$1, i$1) {
					return e$1 != this.transform.fov && (this.transform.setFov(e$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)).fire(new t.l("moveend", i$1))), this;
				}
				getBearing() {
					return this.transform.bearing;
				}
				setBearing(e$1, t$1) {
					return this.jumpTo({ bearing: e$1 }, t$1), this;
				}
				getPadding() {
					return this.transform.padding;
				}
				setPadding(e$1, t$1) {
					return this.jumpTo({ padding: e$1 }, t$1), this;
				}
				rotateTo(e$1, i$1, a$1) {
					return this.easeTo(t.e({ bearing: e$1 }, i$1), a$1);
				}
				resetNorth(e$1, i$1) {
					return this.rotateTo(0, t.e({ duration: 1e3 }, e$1), i$1), this;
				}
				resetNorthPitch(e$1, i$1) {
					return this.easeTo(t.e({
						bearing: 0,
						pitch: 0,
						roll: 0,
						duration: 1e3
					}, e$1), i$1), this;
				}
				snapToNorth(e$1, t$1) {
					return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e$1, t$1) : this;
				}
				getPitch() {
					return this.transform.pitch;
				}
				setPitch(e$1, t$1) {
					return this.jumpTo({ pitch: e$1 }, t$1), this;
				}
				getRoll() {
					return this.transform.roll;
				}
				setRoll(e$1, t$1) {
					return this.jumpTo({ roll: e$1 }, t$1), this;
				}
				cameraForBounds(e$1, t$1) {
					e$1 = $$1.convert(e$1).adjustAntiMeridian();
					const i$1 = t$1 && t$1.bearing || 0;
					return this._cameraForBoxAndBearing(e$1.getNorthWest(), e$1.getSouthEast(), i$1, t$1);
				}
				_cameraForBoxAndBearing(e$1, i$1, a$1, r$1) {
					const o$1 = {
						top: 0,
						bottom: 0,
						right: 0,
						left: 0
					};
					if ("number" == typeof (r$1 = t.e({
						padding: o$1,
						offset: [0, 0],
						maxZoom: this.transform.maxZoom
					}, r$1)).padding) {
						const e$2 = r$1.padding;
						r$1.padding = {
							top: e$2,
							bottom: e$2,
							right: e$2,
							left: e$2
						};
					}
					const s$1 = t.e(o$1, r$1.padding);
					r$1.padding = s$1;
					const n$1 = this.transform, l$1 = new $$1(e$1, i$1);
					return this.cameraHelper.cameraForBoxAndBearing(r$1, s$1, l$1, a$1, n$1);
				}
				fitBounds(e$1, t$1, i$1) {
					return this._fitInternal(this.cameraForBounds(e$1, t$1), t$1, i$1);
				}
				fitScreenCoordinates(e$1, i$1, a$1, r$1, o$1) {
					return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e$1)), this.transform.screenPointToLocation(t.P.convert(i$1)), a$1, r$1), r$1, o$1);
				}
				_fitInternal(e$1, i$1, a$1) {
					return e$1 ? (delete (i$1 = t.e(e$1, i$1)).padding, i$1.linear ? this.easeTo(i$1, a$1) : this.flyTo(i$1, a$1)) : this;
				}
				jumpTo(e$1, i$1) {
					this.stop();
					const a$1 = this._getTransformForUpdate();
					let r$1 = !1, o$1 = !1, s$1 = !1;
					const n$1 = a$1.zoom;
					this.cameraHelper.handleJumpToCenterZoom(a$1, e$1);
					const l$1 = a$1.zoom !== n$1;
					return "elevation" in e$1 && a$1.elevation !== +e$1.elevation && a$1.setElevation(+e$1.elevation), "bearing" in e$1 && a$1.bearing !== +e$1.bearing && (r$1 = !0, a$1.setBearing(+e$1.bearing)), "pitch" in e$1 && a$1.pitch !== +e$1.pitch && (o$1 = !0, a$1.setPitch(+e$1.pitch)), "roll" in e$1 && a$1.roll !== +e$1.roll && (s$1 = !0, a$1.setRoll(+e$1.roll)), null == e$1.padding || a$1.isPaddingEqual(e$1.padding) || a$1.setPadding(e$1.padding), this._applyUpdatedTransform(a$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)), l$1 && this.fire(new t.l("zoomstart", i$1)).fire(new t.l("zoom", i$1)).fire(new t.l("zoomend", i$1)), r$1 && this.fire(new t.l("rotatestart", i$1)).fire(new t.l("rotate", i$1)).fire(new t.l("rotateend", i$1)), o$1 && this.fire(new t.l("pitchstart", i$1)).fire(new t.l("pitch", i$1)).fire(new t.l("pitchend", i$1)), s$1 && this.fire(new t.l("rollstart", i$1)).fire(new t.l("roll", i$1)).fire(new t.l("rollend", i$1)), this.fire(new t.l("moveend", i$1));
				}
				calculateCameraOptionsFromTo(e$1, i$1, a$1, r$1 = 0) {
					const o$1 = t.ab.fromLngLat(e$1, i$1), s$1 = t.ab.fromLngLat(a$1, r$1), n$1 = s$1.x - o$1.x, l$1 = s$1.y - o$1.y, c$1 = s$1.z - o$1.z, h$1 = Math.hypot(n$1, l$1, c$1);
					if (0 === h$1) throw new Error("Can't calculate camera options with same From and To");
					const u$1 = Math.hypot(n$1, l$1), d$1 = t.au(this.transform.cameraToCenterDistance / h$1 / this.transform.tileSize), _$2 = 180 * Math.atan2(n$1, -l$1) / Math.PI;
					let p$1 = 180 * Math.acos(u$1 / h$1) / Math.PI;
					return p$1 = c$1 < 0 ? 90 - p$1 : 90 + p$1, {
						center: s$1.toLngLat(),
						elevation: r$1,
						zoom: d$1,
						pitch: p$1,
						bearing: _$2
					};
				}
				calculateCameraOptionsFromCameraLngLatAltRotation(e$1, t$1, i$1, a$1, r$1) {
					const o$1 = this.transform.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
					return {
						center: o$1.center,
						elevation: o$1.elevation,
						zoom: o$1.zoom,
						bearing: i$1,
						pitch: a$1,
						roll: r$1
					};
				}
				easeTo(e$1, i$1) {
					this._stop(!1, e$1.easeId), (!1 === (e$1 = t.e({
						offset: [0, 0],
						duration: 500,
						easing: t.cz
					}, e$1)).animate || !e$1.essential && n.prefersReducedMotion) && (e$1.duration = 0);
					const a$1 = this._getTransformForUpdate(), r$1 = this.getBearing(), o$1 = a$1.pitch, s$1 = a$1.roll, l$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, r$1) : r$1, c$1 = "pitch" in e$1 ? +e$1.pitch : o$1, h$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, s$1) : s$1, u$1 = "padding" in e$1 ? e$1.padding : a$1.padding, d$1 = t.P.convert(e$1.offset);
					let _$2, p$1;
					e$1.around && (_$2 = t.V.convert(e$1.around), p$1 = a$1.locationToScreenPoint(_$2));
					const m$1 = {
						moving: this._moving,
						zooming: this._zooming,
						rotating: this._rotating,
						pitching: this._pitching,
						rolling: this._rolling
					}, f$1 = this.cameraHelper.handleEaseTo(a$1, {
						bearing: l$1,
						pitch: c$1,
						roll: h$1,
						padding: u$1,
						around: _$2,
						aroundPoint: p$1,
						offsetAsPoint: d$1,
						offset: e$1.offset,
						zoom: e$1.zoom,
						center: e$1.center
					});
					return this._rotating = this._rotating || r$1 !== l$1, this._pitching = this._pitching || c$1 !== o$1, this._rolling = this._rolling || h$1 !== s$1, this._padding = !a$1.isPaddingEqual(u$1), this._zooming = this._zooming || f$1.isZooming, this._easeId = e$1.easeId, this._prepareEase(i$1, e$1.noMoveStart, m$1), this.terrain && this._prepareElevation(f$1.elevationCenter), this._ease(((t$1) => {
						f$1.easeFunc(t$1), this.terrain && !e$1.freezeElevation && this._updateElevation(t$1), this._applyUpdatedTransform(a$1), this._fireMoveEvents(i$1);
					}), ((t$1) => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1, t$1);
					}), e$1), this;
				}
				_prepareEase(e$1, i$1, a$1 = {}) {
					this._moving = !0, i$1 || a$1.moving || this.fire(new t.l("movestart", e$1)), this._zooming && !a$1.zooming && this.fire(new t.l("zoomstart", e$1)), this._rotating && !a$1.rotating && this.fire(new t.l("rotatestart", e$1)), this._pitching && !a$1.pitching && this.fire(new t.l("pitchstart", e$1)), this._rolling && !a$1.rolling && this.fire(new t.l("rollstart", e$1));
				}
				_prepareElevation(e$1) {
					this._elevationCenter = e$1, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e$1, this.transform.tileZoom), this._elevationFreeze = !0;
				}
				_updateElevation(e$1) {
					void 0 !== this._elevationStart && void 0 !== this._elevationCenter || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
					const i$1 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
					if (e$1 < 1 && i$1 !== this._elevationTarget) {
						const t$1 = this._elevationTarget - this._elevationStart;
						this._elevationStart += e$1 * (t$1 - (i$1 - (t$1 * e$1 + this._elevationStart)) / (1 - e$1)), this._elevationTarget = i$1;
					}
					this.transform.setElevation(t.G.number(this._elevationStart, this._elevationTarget, e$1));
				}
				_finalizeElevation() {
					this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
				}
				_getTransformForUpdate() {
					return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
				}
				_elevateCameraIfInsideTerrain(e$1) {
					if (!this.terrain && e$1.elevation >= 0 && e$1.pitch <= 90) return {};
					const t$1 = e$1.getCameraLngLat(), i$1 = e$1.getCameraAltitude(), a$1 = this.terrain ? this.terrain.getElevationForLngLatZoom(t$1, e$1.zoom) : 0;
					if (i$1 < a$1) {
						const i$2 = this.calculateCameraOptionsFromTo(t$1, a$1, e$1.center, e$1.elevation);
						return {
							pitch: i$2.pitch,
							zoom: i$2.zoom
						};
					}
					return {};
				}
				_applyUpdatedTransform(e$1) {
					const t$1 = [];
					if (t$1.push(((e$2) => this._elevateCameraIfInsideTerrain(e$2))), this.transformCameraUpdate && t$1.push(((e$2) => this.transformCameraUpdate(e$2))), !t$1.length) return;
					const i$1 = e$1.clone();
					for (const e$2 of t$1) {
						const t$2 = i$1.clone(), { center: a$1, zoom: r$1, roll: o$1, pitch: s$1, bearing: n$1, elevation: l$1 } = e$2(t$2);
						a$1 && t$2.setCenter(a$1), void 0 !== l$1 && t$2.setElevation(l$1), void 0 !== r$1 && t$2.setZoom(r$1), void 0 !== o$1 && t$2.setRoll(o$1), void 0 !== s$1 && t$2.setPitch(s$1), void 0 !== n$1 && t$2.setBearing(n$1), i$1.apply(t$2);
					}
					this.transform.apply(i$1);
				}
				_fireMoveEvents(e$1) {
					this.fire(new t.l("move", e$1)), this._zooming && this.fire(new t.l("zoom", e$1)), this._rotating && this.fire(new t.l("rotate", e$1)), this._pitching && this.fire(new t.l("pitch", e$1)), this._rolling && this.fire(new t.l("roll", e$1));
				}
				_afterEase(e$1, i$1) {
					if (this._easeId && i$1 && this._easeId === i$1) return;
					delete this._easeId;
					const a$1 = this._zooming, r$1 = this._rotating, o$1 = this._pitching, s$1 = this._rolling;
					this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, a$1 && this.fire(new t.l("zoomend", e$1)), r$1 && this.fire(new t.l("rotateend", e$1)), o$1 && this.fire(new t.l("pitchend", e$1)), s$1 && this.fire(new t.l("rollend", e$1)), this.fire(new t.l("moveend", e$1));
				}
				flyTo(e$1, i$1) {
					if (!e$1.essential && n.prefersReducedMotion) {
						const a$2 = t.U(e$1, [
							"center",
							"zoom",
							"bearing",
							"pitch",
							"roll",
							"elevation",
							"padding"
						]);
						return this.jumpTo(a$2, i$1);
					}
					this.stop(), e$1 = t.e({
						offset: [0, 0],
						speed: 1.2,
						curve: 1.42,
						easing: t.cz
					}, e$1);
					const a$1 = this._getTransformForUpdate(), r$1 = a$1.bearing, o$1 = a$1.pitch, s$1 = a$1.roll, l$1 = a$1.padding, c$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, r$1) : r$1, h$1 = "pitch" in e$1 ? +e$1.pitch : o$1, u$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, s$1) : s$1, d$1 = "padding" in e$1 ? e$1.padding : a$1.padding, _$2 = t.P.convert(e$1.offset);
					let p$1 = a$1.centerPoint.add(_$2);
					const m$1 = a$1.screenPointToLocation(p$1), f$1 = this.cameraHelper.handleFlyTo(a$1, {
						bearing: c$1,
						pitch: h$1,
						roll: u$1,
						padding: d$1,
						locationAtOffset: m$1,
						offsetAsPoint: _$2,
						center: e$1.center,
						minZoom: e$1.minZoom,
						zoom: e$1.zoom
					});
					let g$2 = e$1.curve;
					const v$1 = Math.max(a$1.width, a$1.height), x$1 = v$1 / f$1.scaleOfZoom, b$1 = f$1.pixelPathLength;
					"number" == typeof f$1.scaleOfMinZoom && (g$2 = Math.sqrt(v$1 / f$1.scaleOfMinZoom / b$1 * 2));
					const y$1 = g$2 * g$2;
					function w$2(e$2) {
						const t$1 = (x$1 * x$1 - v$1 * v$1 + (e$2 ? -1 : 1) * y$1 * y$1 * b$1 * b$1) / (2 * (e$2 ? x$1 : v$1) * y$1 * b$1);
						return Math.log(Math.sqrt(t$1 * t$1 + 1) - t$1);
					}
					function T$1(e$2) {
						return (Math.exp(e$2) - Math.exp(-e$2)) / 2;
					}
					function P$2(e$2) {
						return (Math.exp(e$2) + Math.exp(-e$2)) / 2;
					}
					const I$2 = w$2(!1);
					let C$1 = function(e$2) {
						return P$2(I$2) / P$2(I$2 + g$2 * e$2);
					}, M$2 = function(e$2) {
						return v$1 * ((P$2(I$2) * (T$1(t$1 = I$2 + g$2 * e$2) / P$2(t$1)) - T$1(I$2)) / y$1) / b$1;
						var t$1;
					}, E$1 = (w$2(!0) - I$2) / g$2;
					if (Math.abs(b$1) < 2e-6 || !isFinite(E$1)) {
						if (Math.abs(v$1 - x$1) < 1e-6) return this.easeTo(e$1, i$1);
						const t$1 = x$1 < v$1 ? -1 : 1;
						E$1 = Math.abs(Math.log(x$1 / v$1)) / g$2, M$2 = () => 0, C$1 = (e$2) => Math.exp(t$1 * g$2 * e$2);
					}
					return e$1.duration = "duration" in e$1 ? +e$1.duration : 1e3 * E$1 / ("screenSpeed" in e$1 ? +e$1.screenSpeed / g$2 : +e$1.speed), e$1.maxDuration && e$1.duration > e$1.maxDuration && (e$1.duration = 0), this._zooming = !0, this._rotating = r$1 !== c$1, this._pitching = h$1 !== o$1, this._rolling = u$1 !== s$1, this._padding = !a$1.isPaddingEqual(d$1), this._prepareEase(i$1, !1), this.terrain && this._prepareElevation(f$1.targetCenter), this._ease(((n$1) => {
						const m$2 = n$1 * E$1, g$3 = 1 / C$1(m$2), v$2 = M$2(m$2);
						this._rotating && a$1.setBearing(t.G.number(r$1, c$1, n$1)), this._pitching && a$1.setPitch(t.G.number(o$1, h$1, n$1)), this._rolling && a$1.setRoll(t.G.number(s$1, u$1, n$1)), this._padding && (a$1.interpolatePadding(l$1, d$1, n$1), p$1 = a$1.centerPoint.add(_$2)), f$1.easeFunc(n$1, g$3, v$2, p$1), this.terrain && !e$1.freezeElevation && this._updateElevation(n$1), this._applyUpdatedTransform(a$1), this._fireMoveEvents(i$1);
					}), (() => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1);
					}), e$1), this;
				}
				isEasing() {
					return !!this._easeFrameId;
				}
				stop() {
					return this._stop();
				}
				_stop(e$1, t$1) {
					var i$1;
					if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
						const e$2 = this._onEaseEnd;
						delete this._onEaseEnd, e$2.call(this, t$1);
					}
					return e$1 || null === (i$1 = this.handlers) || void 0 === i$1 || i$1.stop(!1), this;
				}
				_ease(e$1, t$1, i$1) {
					!1 === i$1.animate || 0 === i$1.duration ? (e$1(1), t$1()) : (this._easeStart = c(), this._easeOptions = i$1, this._onEaseFrame = e$1, this._onEaseEnd = t$1, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
				}
				_normalizeBearing(e$1, i$1) {
					e$1 = t.W(e$1, -180, 180);
					const a$1 = Math.abs(e$1 - i$1);
					return Math.abs(e$1 - 360 - i$1) < a$1 && (e$1 -= 360), Math.abs(e$1 + 360 - i$1) < a$1 && (e$1 += 360), e$1;
				}
				queryTerrainElevation(e$1) {
					return this.terrain ? this.terrain.getElevationForLngLat(t.V.convert(e$1)) : null;
				}
			}
			const Ko$1 = {
				compact: !0,
				customAttribution: "<a href=\"https://maplibre.org/\" target=\"_blank\">MapLibre</a>"
			};
			class Yo$1 {
				constructor(e$1 = Ko$1) {
					this._toggleAttribution = () => {
						this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
					}, this._updateData = (e$2) => {
						!e$2 || "metadata" !== e$2.sourceDataType && "visibility" !== e$2.sourceDataType && "style" !== e$2.dataType && "terrain" !== e$2.type || this._updateAttributions();
					}, this._updateCompact = () => {
						this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
					}, this._updateCompactMinimize = () => {
						this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-right";
				}
				onAdd(e$1) {
					return this._map = e$1, this._compact = this.options.compact, this._container = h.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = h.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = h.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
				}
				_setElementTitle(e$1, t$1) {
					const i$1 = this._map._getUIString(`AttributionControl.${t$1}`);
					e$1.title = i$1, e$1.setAttribute("aria-label", i$1);
				}
				_updateAttributions() {
					if (!this._map.style) return;
					let e$1 = [];
					if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e$1 = e$1.concat(this.options.customAttribution.map(((e$2) => "string" != typeof e$2 ? "" : e$2))) : "string" == typeof this.options.customAttribution && e$1.push(this.options.customAttribution)), this._map.style.stylesheet) {
						const e$2 = this._map.style.stylesheet;
						this.styleOwner = e$2.owner, this.styleId = e$2.id;
					}
					const t$1 = this._map.style.tileManagers;
					for (const i$2 in t$1) {
						const a$1 = t$1[i$2];
						if (a$1.used || a$1.usedForTerrain) {
							const t$2 = a$1.getSource();
							t$2.attribution && e$1.indexOf(t$2.attribution) < 0 && e$1.push(t$2.attribution);
						}
					}
					e$1 = e$1.filter(((e$2) => String(e$2).trim())), e$1.sort(((e$2, t$2) => e$2.length - t$2.length)), e$1 = e$1.filter(((t$2, i$2) => {
						for (let a$1 = i$2 + 1; a$1 < e$1.length; a$1++) if (e$1[a$1].indexOf(t$2) >= 0) return !1;
						return !0;
					}));
					const i$1 = e$1.join(" | ");
					i$1 !== this._attribHTML && (this._attribHTML = i$1, e$1.length ? (this._innerContainer.innerHTML = h.sanitize(i$1), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
				}
			}
			class Qo$1 {
				constructor(e$1 = {}) {
					this._updateCompact = () => {
						const e$2 = this._container.children;
						if (e$2.length) {
							const t$1 = e$2[0];
							this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && t$1.classList.add("maplibregl-compact") : t$1.classList.remove("maplibregl-compact");
						}
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					this._map = e$1, this._compact = this.options && this.options.compact, this._container = h.create("div", "maplibregl-ctrl");
					const t$1 = h.create("a", "maplibregl-ctrl-logo");
					return t$1.target = "_blank", t$1.rel = "noopener nofollow", t$1.href = "https://maplibre.org/", t$1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t$1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t$1), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
				}
			}
			class Jo$1 {
				constructor() {
					this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
				}
				add(e$1) {
					const t$1 = ++this._id;
					return this._queue.push({
						callback: e$1,
						id: t$1,
						cancelled: !1
					}), t$1;
				}
				remove(e$1) {
					const t$1 = this._currentlyRunning, i$1 = t$1 ? this._queue.concat(t$1) : this._queue;
					for (const t$2 of i$1) if (t$2.id === e$1) return void (t$2.cancelled = !0);
				}
				run(e$1 = 0) {
					if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
					const t$1 = this._currentlyRunning = this._queue;
					this._queue = [];
					for (const i$1 of t$1) if (!i$1.cancelled && (i$1.callback(e$1), this._cleared)) break;
					this._cleared = !1, this._currentlyRunning = !1;
				}
				clear() {
					this._currentlyRunning && (this._cleared = !0), this._queue = [];
				}
			}
			var es$1 = t.aV([{
				name: "a_pos3d",
				type: "Int16",
				components: 3
			}]);
			class ts$1 extends t.E {
				constructor(e$1) {
					super(), this._lastTilesetChange = c(), this.tileManager = e$1, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e$1._source.tileSize * 2 ** this.deltaZoom, e$1.usedForTerrain = !0, e$1.tileSize = this.tileSize;
				}
				destruct() {
					this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null;
				}
				getSource() {
					return this.tileManager._source;
				}
				update(e$1, i$1) {
					this.tileManager.update(e$1, i$1), this._renderableTilesKeys = [];
					const a$1 = {};
					for (const r$1 of Ce$1(e$1, {
						tileSize: this.tileSize,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						reparseOverscaled: !1,
						terrain: i$1,
						calculateTileZoom: this.tileManager._source.calculateTileZoom
					})) a$1[r$1.key] = !0, this._renderableTilesKeys.push(r$1.key), this._tiles[r$1.key] || (r$1.terrainRttPosMatrix32f = new Float64Array(16), t.c8(r$1.terrainRttPosMatrix32f, 0, t.a5, t.a5, 0, 0, 1), this._tiles[r$1.key] = new de$1(r$1, this.tileSize), this._lastTilesetChange = c());
					for (const e$2 in this._tiles) a$1[e$2] || delete this._tiles[e$2];
				}
				freeRtt(e$1) {
					for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						(!e$1 || i$1.tileID.equals(e$1) || i$1.tileID.isChildOf(e$1) || e$1.isChildOf(i$1.tileID)) && (i$1.rtt = []);
					}
				}
				getRenderableTiles() {
					return this._renderableTilesKeys.map(((e$1) => this.getTileByID(e$1)));
				}
				getTileByID(e$1) {
					return this._tiles[e$1];
				}
				getTerrainCoords(e$1, t$1) {
					return t$1 ? this._getTerrainCoordsForTileRanges(e$1, t$1) : this._getTerrainCoordsForRegularTile(e$1);
				}
				_getTerrainCoordsForRegularTile(e$1) {
					const i$1 = {};
					for (const a$1 of this._renderableTilesKeys) {
						const r$1 = this._tiles[a$1].tileID, o$1 = e$1.clone(), s$1 = t.bl();
						if (r$1.canonical.equals(e$1.canonical)) t.c8(s$1, 0, t.a5, t.a5, 0, 0, 1);
						else if (r$1.canonical.isChildOf(e$1.canonical)) {
							const i$2 = r$1.canonical.z - e$1.canonical.z, a$2 = r$1.canonical.x - (r$1.canonical.x >> i$2 << i$2), o$2 = r$1.canonical.y - (r$1.canonical.y >> i$2 << i$2), n$1 = t.a5 >> i$2;
							t.c8(s$1, 0, n$1, n$1, 0, 0, 1), t.O(s$1, s$1, [
								-a$2 * n$1,
								-o$2 * n$1,
								0
							]);
						} else {
							if (!e$1.canonical.isChildOf(r$1.canonical)) continue;
							{
								const i$2 = e$1.canonical.z - r$1.canonical.z, a$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2), o$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), n$1 = t.a5 >> i$2;
								t.c8(s$1, 0, t.a5, t.a5, 0, 0, 1), t.O(s$1, s$1, [
									a$2 * n$1,
									o$2 * n$1,
									0
								]), t.Q(s$1, s$1, [
									1 / 2 ** i$2,
									1 / 2 ** i$2,
									0
								]);
							}
						}
						o$1.terrainRttPosMatrix32f = new Float32Array(s$1), i$1[a$1] = o$1;
					}
					return i$1;
				}
				_getTerrainCoordsForTileRanges(e$1, i$1) {
					const a$1 = {};
					for (const r$1 of this._renderableTilesKeys) {
						const o$1 = this._tiles[r$1].tileID;
						if (!this._isWithinTileRanges(o$1, i$1)) continue;
						const s$1 = e$1.clone(), n$1 = t.bl();
						if (o$1.canonical.z === e$1.canonical.z) {
							const i$2 = e$1.canonical.x - o$1.canonical.x, a$2 = e$1.canonical.y - o$1.canonical.y;
							t.c8(n$1, 0, t.a5, t.a5, 0, 0, 1), t.O(n$1, n$1, [
								i$2 * t.a5,
								a$2 * t.a5,
								0
							]);
						} else if (o$1.canonical.z > e$1.canonical.z) {
							const i$2 = o$1.canonical.z - e$1.canonical.z, a$2 = o$1.canonical.x - (o$1.canonical.x >> i$2 << i$2), r$2 = o$1.canonical.y - (o$1.canonical.y >> i$2 << i$2), s$2 = e$1.canonical.x - (o$1.canonical.x >> i$2), l$1 = e$1.canonical.y - (o$1.canonical.y >> i$2), c$1 = t.a5 >> i$2;
							t.c8(n$1, 0, c$1, c$1, 0, 0, 1), t.O(n$1, n$1, [
								-a$2 * c$1 + s$2 * t.a5,
								-r$2 * c$1 + l$1 * t.a5,
								0
							]);
						} else {
							const i$2 = e$1.canonical.z - o$1.canonical.z, a$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2), r$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), s$2 = (e$1.canonical.x >> i$2) - o$1.canonical.x, l$1 = (e$1.canonical.y >> i$2) - o$1.canonical.y, c$1 = t.a5 << i$2;
							t.c8(n$1, 0, c$1, c$1, 0, 0, 1), t.O(n$1, n$1, [
								a$2 * t.a5 + s$2 * c$1,
								r$2 * t.a5 + l$1 * c$1,
								0
							]);
						}
						s$1.terrainRttPosMatrix32f = new Float32Array(n$1), a$1[r$1] = s$1;
					}
					return a$1;
				}
				getSourceTile(e$1, t$1) {
					const i$1 = this.tileManager._source;
					let a$1 = e$1.overscaledZ - this.deltaZoom;
					if (a$1 > i$1.maxzoom && (a$1 = i$1.maxzoom), a$1 < i$1.minzoom) return;
					this._sourceTileCache[e$1.key] || (this._sourceTileCache[e$1.key] = e$1.scaledTo(a$1).key);
					let r$1 = this.findTileInCaches(this._sourceTileCache[e$1.key]);
					if (!(null == r$1 ? void 0 : r$1.dem) && t$1) for (; a$1 >= i$1.minzoom && !(null == r$1 ? void 0 : r$1.dem);) r$1 = this.findTileInCaches(e$1.scaledTo(a$1--).key);
					return r$1;
				}
				findTileInCaches(e$1) {
					let t$1 = this.tileManager.getTileByID(e$1);
					return t$1 || (t$1 = this.tileManager._outOfViewCache.getByKey(e$1), t$1);
				}
				anyTilesAfterTime(e$1 = Date.now()) {
					return this._lastTilesetChange >= e$1;
				}
				_isWithinTileRanges(e$1, t$1) {
					return t$1[e$1.canonical.z] && e$1.canonical.x >= t$1[e$1.canonical.z].minTileX && e$1.canonical.x <= t$1[e$1.canonical.z].maxTileX && e$1.canonical.y >= t$1[e$1.canonical.z].minTileY && e$1.canonical.y <= t$1[e$1.canonical.z].maxTileY;
				}
			}
			class is$1 {
				constructor(e$1, t$1, i$1) {
					this._meshCache = {}, this.painter = e$1, this.tileManager = new ts$1(t$1), this.options = i$1, this.exaggeration = "number" == typeof i$1.exaggeration ? i$1.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
				}
				getDEMElevation(e$1, i$1, a$1, r$1 = t.a5) {
					var o$1;
					if (!(i$1 >= 0 && i$1 < r$1 && a$1 >= 0 && a$1 < r$1)) return 0;
					const s$1 = this.getTerrainData(e$1), n$1 = null === (o$1 = s$1.tile) || void 0 === o$1 ? void 0 : o$1.dem;
					if (!n$1) return 0;
					const l$1 = t.cD([], [i$1 / r$1 * t.a5, a$1 / r$1 * t.a5], s$1.u_terrain_matrix), c$1 = [l$1[0] * n$1.dim, l$1[1] * n$1.dim], h$1 = Math.floor(c$1[0]), u$1 = Math.floor(c$1[1]), d$1 = c$1[0] - h$1, _$2 = c$1[1] - u$1;
					return n$1.get(h$1, u$1) * (1 - d$1) * (1 - _$2) + n$1.get(h$1 + 1, u$1) * d$1 * (1 - _$2) + n$1.get(h$1, u$1 + 1) * (1 - d$1) * _$2 + n$1.get(h$1 + 1, u$1 + 1) * d$1 * _$2;
				}
				getElevationForLngLatZoom(e$1, i$1) {
					if (!t.cE(i$1, e$1.wrap())) return 0;
					const { tileID: a$1, mercatorX: r$1, mercatorY: o$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, i$1);
					return this.getElevation(a$1, r$1 % t.a5, o$1 % t.a5, t.a5);
				}
				getElevationForLngLat(e$1) {
					return this.getElevationForLngLatZoom(e$1, this.tileManager.maxzoom);
				}
				getElevation(e$1, i$1, a$1, r$1 = t.a5) {
					return this.getDEMElevation(e$1, i$1, a$1, r$1) * this.exaggeration;
				}
				getTerrainData(e$1) {
					if (!this._emptyDemTexture) {
						const e$2 = this.painter.context, i$2 = new t.R({
							width: 1,
							height: 1
						}, new Uint8Array(4));
						this._emptyDepthTexture = new t.T(e$2, i$2, e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [
							0,
							0,
							0,
							0
						], this._emptyDemTexture = new t.T(e$2, new t.R({
							width: 1,
							height: 1
						}), e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.as([]);
					}
					const i$1 = this.tileManager.getSourceTile(e$1, !0);
					if (i$1 && i$1.dem && (!i$1.demTexture || i$1.needsTerrainPrepare)) {
						const e$2 = this.painter.context;
						i$1.demTexture = this.painter.getTileTexture(i$1.dem.stride), i$1.demTexture ? i$1.demTexture.update(i$1.dem.getPixels(), { premultiply: !1 }) : i$1.demTexture = new t.T(e$2, i$1.dem.getPixels(), e$2.gl.RGBA, { premultiply: !1 }), i$1.demTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), i$1.needsTerrainPrepare = !1;
					}
					const a$1 = i$1 && i$1 + i$1.tileID.key + e$1.key;
					if (a$1 && !this._demMatrixCache[a$1]) {
						const a$2 = this.tileManager.getSource().maxzoom;
						let r$1 = e$1.canonical.z - i$1.tileID.canonical.z;
						e$1.overscaledZ > e$1.canonical.z && (e$1.canonical.z >= a$2 ? r$1 = e$1.canonical.z - a$2 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
						const o$1 = e$1.canonical.x - (e$1.canonical.x >> r$1 << r$1), s$1 = e$1.canonical.y - (e$1.canonical.y >> r$1 << r$1), n$1 = t.cF(new Float64Array(16), [
							1 / (t.a5 << r$1),
							1 / (t.a5 << r$1),
							0
						]);
						t.O(n$1, n$1, [
							o$1 * t.a5,
							s$1 * t.a5,
							0
						]), this._demMatrixCache[e$1.key] = {
							matrix: n$1,
							coord: e$1
						};
					}
					return {
						u_depth: 2,
						u_terrain: 3,
						u_terrain_dim: i$1 && i$1.dem && i$1.dem.dim || 1,
						u_terrain_matrix: a$1 ? this._demMatrixCache[e$1.key].matrix : this._emptyDemMatrix,
						u_terrain_unpack: i$1 && i$1.dem && i$1.dem.getUnpackVector() || this._emptyDemUnpack,
						u_terrain_exaggeration: this.exaggeration,
						texture: (i$1 && i$1.demTexture || this._emptyDemTexture).texture,
						depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
						tile: i$1
					};
				}
				getFramebuffer(e$1) {
					const i$1 = this.painter, a$1 = i$1.width / devicePixelRatio, r$1 = i$1.height / devicePixelRatio;
					return !this._fbo || this._fbo.width === a$1 && this._fbo.height === r$1 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t.T(i$1.context, {
						width: a$1,
						height: r$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t.T(i$1.context, {
						width: a$1,
						height: r$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i$1.context.createFramebuffer(a$1, r$1, !0, !1), this._fbo.depthAttachment.set(i$1.context.createRenderbuffer(i$1.context.gl.DEPTH_COMPONENT16, a$1, r$1))), this._fbo.colorAttachment.set("coords" === e$1 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
				}
				getCoordsTexture() {
					const e$1 = this.painter.context;
					if (this._coordsTexture) return this._coordsTexture;
					const i$1 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
					for (let e$2 = 0, t$1 = 0; e$2 < this._coordsTextureSize; e$2++) for (let a$2 = 0; a$2 < this._coordsTextureSize; a$2++, t$1 += 4) i$1[t$1 + 0] = 255 & a$2, i$1[t$1 + 1] = 255 & e$2, i$1[t$1 + 2] = a$2 >> 8 << 4 | e$2 >> 8, i$1[t$1 + 3] = 0;
					const a$1 = new t.R({
						width: this._coordsTextureSize,
						height: this._coordsTextureSize
					}, new Uint8Array(i$1.buffer)), r$1 = new t.T(e$1, a$1, e$1.gl.RGBA, { premultiply: !1 });
					return r$1.bind(e$1.gl.NEAREST, e$1.gl.CLAMP_TO_EDGE), this._coordsTexture = r$1, r$1;
				}
				pointCoordinate(e$1) {
					this.painter.maybeDrawDepthAndCoords(!0);
					const i$1 = new Uint8Array(4), a$1 = this.painter.context, r$1 = a$1.gl, o$1 = Math.round(e$1.x * this.painter.pixelRatio / devicePixelRatio), s$1 = Math.round(e$1.y * this.painter.pixelRatio / devicePixelRatio), n$1 = Math.round(this.painter.height / devicePixelRatio);
					a$1.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r$1.readPixels(o$1, n$1 - s$1 - 1, 1, 1, r$1.RGBA, r$1.UNSIGNED_BYTE, i$1), a$1.bindFramebuffer.set(null);
					const l$1 = i$1[0] + (i$1[2] >> 4 << 8), c$1 = i$1[1] + ((15 & i$1[2]) << 8), h$1 = this.coordsIndex[255 - i$1[3]], u$1 = h$1 && this.tileManager.getTileByID(h$1);
					if (!u$1) return null;
					const d$1 = this._coordsTextureSize, _$2 = (1 << u$1.tileID.canonical.z) * d$1;
					return new t.ab((u$1.tileID.canonical.x * d$1 + l$1) / _$2 + u$1.tileID.wrap, (u$1.tileID.canonical.y * d$1 + c$1) / _$2, this.getElevation(u$1.tileID, l$1, c$1, d$1));
				}
				depthAtPoint(e$1) {
					const t$1 = new Uint8Array(4), i$1 = this.painter.context, a$1 = i$1.gl;
					return i$1.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a$1.readPixels(e$1.x, this.painter.height / devicePixelRatio - e$1.y - 1, 1, 1, a$1.RGBA, a$1.UNSIGNED_BYTE, t$1), i$1.bindFramebuffer.set(null), (t$1[0] / 16777216 + t$1[1] / 65536 + t$1[2] / 256 + t$1[3]) / 256;
				}
				getTerrainMesh(e$1) {
					var i$1;
					const a$1 = (null === (i$1 = this.painter.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0, r$1 = a$1 && 0 === e$1.canonical.y, o$1 = a$1 && e$1.canonical.y === (1 << e$1.canonical.z) - 1, s$1 = `m_${r$1 ? "n" : ""}_${o$1 ? "s" : ""}`;
					if (this._meshCache[s$1]) return this._meshCache[s$1];
					const n$1 = this.painter.context, l$1 = new t.cG(), c$1 = new t.aZ(), h$1 = this.meshSize, u$1 = t.a5 / h$1, d$1 = h$1 * h$1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) for (let t$1 = 0; t$1 <= h$1; t$1++) l$1.emplaceBack(t$1 * u$1, e$2 * u$1, 0);
					for (let e$2 = 0; e$2 < d$1; e$2 += h$1 + 1) for (let t$1 = 0; t$1 < h$1; t$1++) c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 1, h$1 + t$1 + e$2 + 2), c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 2, t$1 + e$2 + 1);
					const _$2 = l$1.length, p$1 = _$2 + (h$1 + 1), m$1 = (h$1 + 1) * h$1, f$1 = r$1 ? t.bs : 0, g$2 = r$1 ? 0 : 1, v$1 = o$1 ? t.bt : t.a5, x$1 = o$1 ? 0 : 1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, f$1, g$2);
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, v$1, x$1);
					for (let e$2 = 0; e$2 < h$1; e$2++) c$1.emplaceBack(m$1 + e$2, p$1 + e$2, p$1 + e$2 + 1), c$1.emplaceBack(m$1 + e$2, p$1 + e$2 + 1, m$1 + e$2 + 1), c$1.emplaceBack(0 + e$2, _$2 + e$2 + 1, _$2 + e$2), c$1.emplaceBack(0 + e$2, 0 + e$2 + 1, _$2 + e$2 + 1);
					const b$1 = l$1.length, y$1 = b$1 + 2 * (h$1 + 1);
					for (const e$2 of [0, 1]) for (let i$2 = 0; i$2 <= h$1; i$2++) for (const a$2 of [0, 1]) l$1.emplaceBack(e$2 * t.a5, i$2 * u$1, a$2);
					for (let e$2 = 0; e$2 < 2 * h$1; e$2 += 2) c$1.emplaceBack(b$1 + e$2, b$1 + e$2 + 1, b$1 + e$2 + 3), c$1.emplaceBack(b$1 + e$2, b$1 + e$2 + 3, b$1 + e$2 + 2), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 3, y$1 + e$2 + 1), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 2, y$1 + e$2 + 3);
					const w$2 = new kt$1(n$1.createVertexBuffer(l$1, es$1.members), n$1.createIndexBuffer(c$1), t.aY.simpleSegment(0, 0, l$1.length, c$1.length));
					return this._meshCache[s$1] = w$2, w$2;
				}
				getMeshFrameDelta(e$1) {
					return 2 * Math.PI * t.bF / Math.pow(2, Math.max(e$1, 0)) / 5;
				}
				getMinTileElevationForLngLatZoom(e$1, i$1) {
					var a$1;
					if (!t.cE(i$1, e$1.wrap())) return 0;
					const { tileID: r$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, i$1);
					return null !== (a$1 = this.getMinMaxElevation(r$1).minElevation) && void 0 !== a$1 ? a$1 : 0;
				}
				getMinMaxElevation(e$1) {
					const t$1 = this.getTerrainData(e$1).tile, i$1 = {
						minElevation: null,
						maxElevation: null
					};
					return t$1 && t$1.dem && (i$1.minElevation = t$1.dem.min * this.exaggeration, i$1.maxElevation = t$1.dem.max * this.exaggeration), i$1;
				}
				_getOverscaledTileIDFromLngLatZoom(e$1, i$1) {
					const a$1 = t.ab.fromLngLat(e$1.wrap()), r$1 = (1 << i$1) * t.a5, o$1 = a$1.x * r$1, s$1 = a$1.y * r$1, n$1 = Math.floor(o$1 / t.a5), l$1 = Math.floor(s$1 / t.a5);
					return {
						tileID: new t.a2(i$1, 0, i$1, n$1, l$1),
						mercatorX: o$1,
						mercatorY: s$1
					};
				}
			}
			class as$1 {
				constructor(e$1, t$1, i$1) {
					this._context = e$1, this._size = t$1, this._tileSize = i$1, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
				}
				destruct() {
					for (const e$1 of this._objects) e$1.texture.destroy(), e$1.fbo.destroy();
				}
				_createObject(e$1) {
					const i$1 = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), a$1 = new t.T(this._context, {
						width: this._tileSize,
						height: this._tileSize,
						data: null
					}, this._context.gl.RGBA);
					return a$1.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i$1.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i$1.colorAttachment.set(a$1.texture), {
						id: e$1,
						fbo: i$1,
						texture: a$1,
						stamp: -1,
						inUse: !1
					};
				}
				getObjectForId(e$1) {
					return this._objects[e$1];
				}
				useObject(e$1) {
					e$1.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((t$1) => e$1.id !== t$1)), this._recentlyUsed.push(e$1.id);
				}
				stampObject(e$1) {
					e$1.stamp = ++this._stamp;
				}
				getOrCreateFreeObject() {
					for (const e$2 of this._recentlyUsed) if (!this._objects[e$2].inUse) return this._objects[e$2];
					if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
					const e$1 = this._createObject(this._objects.length);
					return this._objects.push(e$1), e$1;
				}
				freeObject(e$1) {
					e$1.inUse = !1;
				}
				freeAllObjects() {
					for (const e$1 of this._objects) this.freeObject(e$1);
				}
				isFull() {
					return !(this._objects.length < this._size) && !1 === this._objects.some(((e$1) => !e$1.inUse));
				}
			}
			const rs$1 = {
				background: !0,
				fill: !0,
				line: !0,
				raster: !0,
				hillshade: !0,
				"color-relief": !0
			};
			class os$1 {
				constructor(e$1, t$1) {
					this.painter = e$1, this.terrain = t$1, this.pool = new as$1(e$1.context, 30, t$1.tileManager.tileSize * t$1.qualityFactor);
				}
				destruct() {
					this.pool.destruct();
				}
				getTexture(e$1) {
					return this.pool.getObjectForId(e$1.rtt[this._stacks.length - 1].id).texture;
				}
				prepareForRender(e$1, t$1) {
					this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e$1._order.filter(((i$1) => !e$1._layers[i$1].isHidden(t$1))), this._coordsAscending = {};
					for (const t$2 in e$1.tileManagers) {
						this._coordsAscending[t$2] = {};
						const i$1 = e$1.tileManagers[t$2].getVisibleCoordinates(), a$1 = e$1.tileManagers[t$2].getSource(), r$1 = a$1 instanceof te$1 ? a$1.terrainTileRanges : null;
						for (const e$2 of i$1) {
							const i$2 = this.terrain.tileManager.getTerrainCoords(e$2, r$1);
							for (const e$3 in i$2) this._coordsAscending[t$2][e$3] || (this._coordsAscending[t$2][e$3] = []), this._coordsAscending[t$2][e$3].push(i$2[e$3]);
						}
					}
					this._coordsAscendingStr = {};
					for (const t$2 of e$1._order) {
						const i$1 = e$1._layers[t$2], a$1 = i$1.source;
						if (rs$1[i$1.type] && !this._coordsAscendingStr[a$1]) {
							this._coordsAscendingStr[a$1] = {};
							for (const e$2 in this._coordsAscending[a$1]) this._coordsAscendingStr[a$1][e$2] = this._coordsAscending[a$1][e$2].map(((e$3) => e$3.key)).sort().join();
						}
					}
					for (const e$2 of this._renderableTiles) for (const t$2 in this._coordsAscendingStr) {
						const i$1 = this._coordsAscendingStr[t$2][e$2.tileID.key];
						i$1 && i$1 !== e$2.rttCoords[t$2] && (e$2.rtt = []);
					}
				}
				renderLayer(e$1, i$1) {
					if (e$1.isHidden(this.painter.transform.zoom)) return !1;
					const a$1 = Object.assign(Object.assign({}, i$1), { isRenderingToTexture: !0 }), r$1 = e$1.type, o$1 = this.painter, s$1 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e$1.id;
					if (rs$1[r$1] && (this._prevType && rs$1[this._prevType] || this._stacks.push([]), this._prevType = r$1, this._stacks[this._stacks.length - 1].push(e$1.id), !s$1)) return !0;
					if (rs$1[this._prevType] || rs$1[r$1] && s$1) {
						this._prevType = r$1;
						const e$2 = this._stacks.length - 1, i$2 = this._stacks[e$2] || [];
						for (const r$2 of this._renderableTiles) {
							if (this.pool.isFull() && (Ur$1(this.painter, this.terrain, this._rttTiles, a$1), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(r$2), r$2.rtt[e$2]) {
								const t$1 = this.pool.getObjectForId(r$2.rtt[e$2].id);
								if (t$1.stamp === r$2.rtt[e$2].stamp) {
									this.pool.useObject(t$1);
									continue;
								}
							}
							const s$2 = this.pool.getOrCreateFreeObject();
							this.pool.useObject(s$2), this.pool.stampObject(s$2), r$2.rtt[e$2] = {
								id: s$2.id,
								stamp: s$2.stamp
							}, o$1.context.bindFramebuffer.set(s$2.fbo.framebuffer), o$1.context.clear({
								color: t.bq.transparent,
								stencil: 0
							}), o$1.currentStencilSource = void 0;
							for (let e$3 = 0; e$3 < i$2.length; e$3++) {
								const t$1 = o$1.style._layers[i$2[e$3]], n$1 = t$1.source ? this._coordsAscending[t$1.source][r$2.tileID.key] : [r$2.tileID];
								o$1.context.viewport.set([
									0,
									0,
									s$2.fbo.width,
									s$2.fbo.height
								]), o$1._renderTileClippingMasks(t$1, n$1, !0), o$1.renderLayer(o$1, o$1.style.tileManagers[t$1.source], t$1, n$1, a$1), t$1.source && (r$2.rttCoords[t$1.source] = this._coordsAscendingStr[t$1.source][r$2.tileID.key]);
							}
						}
						return Ur$1(this.painter, this.terrain, this._rttTiles, a$1), this._rttTiles = [], this.pool.freeAllObjects(), rs$1[r$1];
					}
					return !1;
				}
			}
			const ss$1 = {
				"AttributionControl.ToggleAttribution": "Toggle attribution",
				"AttributionControl.MapFeedback": "Map feedback",
				"FullscreenControl.Enter": "Enter fullscreen",
				"FullscreenControl.Exit": "Exit fullscreen",
				"GeolocateControl.FindMyLocation": "Find my location",
				"GeolocateControl.LocationNotAvailable": "Location not available",
				"LogoControl.Title": "MapLibre logo",
				"Map.Title": "Map",
				"Marker.Title": "Map marker",
				"NavigationControl.ResetBearing": "Reset bearing to north",
				"NavigationControl.ZoomIn": "Zoom in",
				"NavigationControl.ZoomOut": "Zoom out",
				"Popup.Close": "Close popup",
				"ScaleControl.Feet": "ft",
				"ScaleControl.Meters": "m",
				"ScaleControl.Kilometers": "km",
				"ScaleControl.Miles": "mi",
				"ScaleControl.NauticalMiles": "nm",
				"GlobeControl.Enable": "Enable globe",
				"GlobeControl.Disable": "Disable globe",
				"TerrainControl.Enable": "Enable terrain",
				"TerrainControl.Disable": "Disable terrain",
				"CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
				"CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map",
				"CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
			}, ns$1 = i, ls$1 = {
				hash: !1,
				interactive: !0,
				bearingSnap: 7,
				attributionControl: Ko$1,
				maplibreLogo: !1,
				refreshExpiredTiles: !0,
				canvasContextAttributes: {
					antialias: !1,
					preserveDrawingBuffer: !1,
					powerPreference: "high-performance",
					failIfMajorPerformanceCaveat: !1,
					desynchronized: !1,
					contextType: void 0
				},
				scrollZoom: !0,
				minZoom: -2,
				maxZoom: 22,
				minPitch: 0,
				maxPitch: 60,
				boxZoom: !0,
				dragRotate: !0,
				dragPan: !0,
				keyboard: !0,
				doubleClickZoom: !0,
				touchZoomRotate: !0,
				touchPitch: !0,
				cooperativeGestures: !1,
				trackResize: !0,
				center: [0, 0],
				elevation: 0,
				zoom: 0,
				bearing: 0,
				pitch: 0,
				roll: 0,
				renderWorldCopies: !0,
				maxTileCacheSize: null,
				maxTileCacheZoomLevels: t.c.MAX_TILE_CACHE_ZOOM_LEVELS,
				transformRequest: null,
				transformCameraUpdate: null,
				transformConstrain: null,
				fadeDuration: 300,
				crossSourceCollisions: !0,
				clickTolerance: 3,
				localIdeographFontFamily: "sans-serif",
				pitchWithRotate: !0,
				rollEnabled: !1,
				reduceMotion: void 0,
				validateStyle: !0,
				maxCanvasSize: [4096, 4096],
				cancelPendingTileRequestsWhileZooming: !0,
				centerClampedToGround: !0,
				experimentalZoomLevelsToOverscale: void 0
			}, cs$1 = {
				showCompass: !0,
				showZoom: !0,
				visualizePitch: !1,
				visualizeRoll: !0
			};
			class hs$1 {
				constructor(e$1, i$1, a$1 = !1) {
					this.mousedown = (e$2) => {
						this.startMove(e$2, h.mousePos(this.element, e$2)), h.addEventListener(window, "mousemove", this.mousemove), h.addEventListener(window, "mouseup", this.mouseup);
					}, this.mousemove = (e$2) => {
						this.move(e$2, h.mousePos(this.element, e$2));
					}, this.mouseup = (e$2) => {
						this._rotatePitchHandler.dragEnd(e$2), this.offTemp();
					}, this.touchstart = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = h.touchPos(this.element, e$2.targetTouches)[0], this.startMove(e$2, this._startPos), h.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), h.addEventListener(window, "touchend", this.touchend));
					}, this.touchmove = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._lastPos = h.touchPos(this.element, e$2.targetTouches)[0], this.move(e$2, this._lastPos));
					}, this.touchend = (e$2) => {
						0 === e$2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this.reset = () => {
						this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this._clickTolerance = 10, this.element = i$1;
					this._rotatePitchHandler = new mo$1({
						clickTolerance: 3,
						move: (e$2, r$1) => {
							const o$1 = i$1.getBoundingClientRect(), s$1 = new t.P((o$1.bottom - o$1.top) / 2, (o$1.right - o$1.left) / 2);
							return {
								bearingDelta: t.cy(new t.P(e$2.x, r$1.y), r$1, s$1),
								pitchDelta: a$1 ? -.5 * (r$1.y - e$2.y) : void 0
							};
						},
						moveStateManager: new yo$1(),
						enable: !0,
						assignEvents: () => {}
					}), this.map = e$1, h.addEventListener(i$1, "mousedown", this.mousedown), h.addEventListener(i$1, "touchstart", this.touchstart, { passive: !1 }), h.addEventListener(i$1, "touchcancel", this.reset);
				}
				startMove(e$1, t$1) {
					this._rotatePitchHandler.dragStart(e$1, t$1), h.disableDrag();
				}
				move(e$1, t$1) {
					const i$1 = this.map, { bearingDelta: a$1, pitchDelta: r$1 } = this._rotatePitchHandler.dragMove(e$1, t$1) || {};
					a$1 && i$1.setBearing(i$1.getBearing() + a$1), r$1 && i$1.setPitch(i$1.getPitch() + r$1);
				}
				off() {
					const e$1 = this.element;
					h.removeEventListener(e$1, "mousedown", this.mousedown), h.removeEventListener(e$1, "touchstart", this.touchstart, { passive: !1 }), h.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), h.removeEventListener(window, "touchend", this.touchend), h.removeEventListener(e$1, "touchcancel", this.reset), this.offTemp();
				}
				offTemp() {
					h.enableDrag(), h.removeEventListener(window, "mousemove", this.mousemove), h.removeEventListener(window, "mouseup", this.mouseup), h.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), h.removeEventListener(window, "touchend", this.touchend);
				}
			}
			let us$1;
			function ds$1(e$1, i$1, a$1, r$1 = !1) {
				if (r$1 || !a$1.getCoveringTilesDetailsProvider().allowWorldCopies()) return null == e$1 ? void 0 : e$1.wrap();
				const o$1 = new t.V(e$1.lng, e$1.lat);
				if (e$1 = new t.V(e$1.lng, e$1.lat), i$1) {
					const r$2 = new t.V(e$1.lng - 360, e$1.lat), o$2 = new t.V(e$1.lng + 360, e$1.lat), s$1 = a$1.locationToScreenPoint(e$1).distSqr(i$1);
					a$1.locationToScreenPoint(r$2).distSqr(i$1) < s$1 ? e$1 = r$2 : a$1.locationToScreenPoint(o$2).distSqr(i$1) < s$1 && (e$1 = o$2);
				}
				for (; Math.abs(e$1.lng - a$1.center.lng) > 180;) {
					const t$1 = a$1.locationToScreenPoint(e$1);
					if (t$1.x >= 0 && t$1.y >= 0 && t$1.x <= a$1.width && t$1.y <= a$1.height) break;
					e$1.lng > a$1.center.lng ? e$1.lng -= 360 : e$1.lng += 360;
				}
				return e$1.lng !== o$1.lng && a$1.isPointOnMapSurface(a$1.locationToScreenPoint(e$1)) ? e$1 : o$1;
			}
			const _s$1 = {
				center: "translate(-50%,-50%)",
				top: "translate(-50%,0)",
				"top-left": "translate(0,0)",
				"top-right": "translate(-100%,0)",
				bottom: "translate(-50%,-100%)",
				"bottom-left": "translate(0,-100%)",
				"bottom-right": "translate(-100%,-100%)",
				left: "translate(0,-50%)",
				right: "translate(-100%,-50%)"
			};
			function ps$1(e$1, t$1, i$1) {
				const a$1 = e$1.classList;
				for (const e$2 in _s$1) a$1.remove(`maplibregl-${i$1}-anchor-${e$2}`);
				a$1.add(`maplibregl-${i$1}-anchor-${t$1}`);
			}
			class ms$1 extends t.E {
				constructor(e$1) {
					if (super(), this._onKeyPress = (e$2) => {
						const t$1 = e$2.code, i$1 = e$2.charCode || e$2.keyCode;
						"Space" !== t$1 && "Enter" !== t$1 && 32 !== i$1 && 13 !== i$1 || this.togglePopup();
					}, this._onMapClick = (e$2) => {
						const t$1 = e$2.originalEvent.target, i$1 = this._element;
						this._popup && (t$1 === i$1 || i$1.contains(t$1)) && this.togglePopup();
					}, this._update = (e$2) => {
						if (!this._map) return;
						const t$1 = this._map.loaded() && !this._map.isMoving();
						("terrain" === (null == e$2 ? void 0 : e$2.type) || "render" === (null == e$2 ? void 0 : e$2.type) && !t$1) && this._map.once("render", this._update), this._lngLat = ds$1(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
						let i$1 = "";
						"viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? i$1 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (i$1 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
						let a$1 = "";
						"viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a$1 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a$1 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e$2 && "moveend" !== e$2.type || (this._pos = this._pos.round()), h.setTransform(this._element, `${_s$1[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a$1} ${i$1}`), n.frameAsync(new AbortController()).then((() => {
							this._updateOpacity(e$2 && "moveend" === e$2.type);
						})).catch((() => {}));
					}, this._onMove = (e$2) => {
						if (!this._isDragging) {
							const t$1 = this._clickTolerance || this._map._clickTolerance;
							this._isDragging = e$2.point.dist(this._pointerdownPos) >= t$1;
						}
						this._isDragging && (this._pos = e$2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
					}, this._onUp = () => {
						this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.l("dragend")), this._state = "inactive";
					}, this._addDragHandler = (e$2) => {
						this._element.contains(e$2.originalEvent.target) && (e$2.preventDefault(), this._positionDelta = e$2.point.sub(this._pos).add(this._offset), this._pointerdownPos = e$2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
					}, this._anchor = e$1 && e$1.anchor || "center", this._color = e$1 && e$1.color || "#3FB1CE", this._scale = e$1 && e$1.scale || 1, this._draggable = e$1 && e$1.draggable || !1, this._clickTolerance = e$1 && e$1.clickTolerance || 0, this._subpixelPositioning = e$1 && e$1.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e$1 && e$1.rotation || 0, this._rotationAlignment = e$1 && e$1.rotationAlignment || "auto", this._pitchAlignment = e$1 && e$1.pitchAlignment && "auto" !== e$1.pitchAlignment ? e$1.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e$1 ? void 0 : e$1.opacity, null == e$1 ? void 0 : e$1.opacityWhenCovered), e$1 && e$1.element) this._element = e$1.element, this._offset = t.P.convert(e$1 && e$1.offset || [0, 0]);
					else {
						this._defaultMarker = !0, this._element = h.create("div");
						const i$1 = h.createNS("http://www.w3.org/2000/svg", "svg"), a$1 = 41, r$1 = 27;
						i$1.setAttributeNS(null, "display", "block"), i$1.setAttributeNS(null, "height", `${a$1}px`), i$1.setAttributeNS(null, "width", `${r$1}px`), i$1.setAttributeNS(null, "viewBox", `0 0 ${r$1} ${a$1}`);
						const o$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						o$1.setAttributeNS(null, "stroke", "none"), o$1.setAttributeNS(null, "stroke-width", "1"), o$1.setAttributeNS(null, "fill", "none"), o$1.setAttributeNS(null, "fill-rule", "evenodd");
						const s$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						s$1.setAttributeNS(null, "fill-rule", "nonzero");
						const n$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						n$1.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), n$1.setAttributeNS(null, "fill", "#000000");
						for (const e$2 of [
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "9.5",
								ry: "4.77275007"
							},
							{
								rx: "8.5",
								ry: "4.29549936"
							},
							{
								rx: "7.5",
								ry: "3.81822308"
							},
							{
								rx: "6.5",
								ry: "3.34094679"
							},
							{
								rx: "5.5",
								ry: "2.86367051"
							},
							{
								rx: "4.5",
								ry: "2.38636864"
							}
						]) {
							const t$1 = h.createNS("http://www.w3.org/2000/svg", "ellipse");
							t$1.setAttributeNS(null, "opacity", "0.04"), t$1.setAttributeNS(null, "cx", "10.5"), t$1.setAttributeNS(null, "cy", "5.80029008"), t$1.setAttributeNS(null, "rx", e$2.rx), t$1.setAttributeNS(null, "ry", e$2.ry), n$1.appendChild(t$1);
						}
						const c$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						c$1.setAttributeNS(null, "fill", this._color);
						const u$1 = h.createNS("http://www.w3.org/2000/svg", "path");
						u$1.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c$1.appendChild(u$1);
						const d$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						d$1.setAttributeNS(null, "opacity", "0.25"), d$1.setAttributeNS(null, "fill", "#000000");
						const _$2 = h.createNS("http://www.w3.org/2000/svg", "path");
						_$2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d$1.appendChild(_$2);
						const p$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						p$1.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p$1.setAttributeNS(null, "fill", "#FFFFFF");
						const m$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						m$1.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
						const f$1 = h.createNS("http://www.w3.org/2000/svg", "circle");
						f$1.setAttributeNS(null, "fill", "#000000"), f$1.setAttributeNS(null, "opacity", "0.25"), f$1.setAttributeNS(null, "cx", "5.5"), f$1.setAttributeNS(null, "cy", "5.5"), f$1.setAttributeNS(null, "r", "5.4999962");
						const g$2 = h.createNS("http://www.w3.org/2000/svg", "circle");
						g$2.setAttributeNS(null, "fill", "#FFFFFF"), g$2.setAttributeNS(null, "cx", "5.5"), g$2.setAttributeNS(null, "cy", "5.5"), g$2.setAttributeNS(null, "r", "5.4999962"), m$1.appendChild(f$1), m$1.appendChild(g$2), s$1.appendChild(n$1), s$1.appendChild(c$1), s$1.appendChild(d$1), s$1.appendChild(p$1), s$1.appendChild(m$1), i$1.appendChild(s$1), i$1.setAttributeNS(null, "height", a$1 * this._scale + "px"), i$1.setAttributeNS(null, "width", r$1 * this._scale + "px"), this._element.appendChild(i$1), this._offset = t.P.convert(e$1 && e$1.offset || [0, -14]);
					}
					if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((e$2) => {
						e$2.preventDefault();
					})), this._element.addEventListener("mousedown", ((e$2) => {
						e$2.preventDefault();
					})), ps$1(this._element, this._anchor, "marker"), e$1 && e$1.className) for (const t$1 of e$1.className.split(" ")) this._element.classList.add(t$1);
					this._popup = null;
				}
				addTo(e$1) {
					return this.remove(), this._map = e$1, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e$1._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e$1.getCanvasContainer().appendChild(this._element), e$1.on("move", this._update), e$1.on("moveend", this._update), e$1.on("terrain", this._update), e$1.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
				}
				remove() {
					return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), h.remove(this._element), this._popup && this._popup.remove(), this;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.V.convert(e$1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
				}
				getElement() {
					return this._element;
				}
				setPopup(e$1) {
					if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e$1) {
						if (!("offset" in e$1.options)) {
							const t$1 = 38.1, i$1 = 13.5, a$1 = Math.abs(i$1) / Math.SQRT2;
							e$1.options.offset = this._defaultMarker ? {
								top: [0, 0],
								"top-left": [0, 0],
								"top-right": [0, 0],
								bottom: [0, -t$1],
								"bottom-left": [a$1, -1 * (t$1 - i$1 + a$1)],
								"bottom-right": [-a$1, -1 * (t$1 - i$1 + a$1)],
								left: [i$1, -1 * (t$1 - i$1)],
								right: [-i$1, -1 * (t$1 - i$1)]
							} : this._offset;
						}
						this._popup = e$1, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
					}
					return this;
				}
				setSubpixelPositioning(e$1) {
					return this._subpixelPositioning = e$1, this;
				}
				getPopup() {
					return this._popup;
				}
				togglePopup() {
					const e$1 = this._popup;
					return this._element.style.opacity === this._opacityWhenCovered ? this : e$1 ? (e$1.isOpen() ? e$1.remove() : (e$1.setLngLat(this._lngLat), e$1.addTo(this._map)), this) : this;
				}
				_updateOpacity(e$1 = !1) {
					var i$1, a$1;
					const r$1 = null === (i$1 = this._map) || void 0 === i$1 ? void 0 : i$1.terrain, o$1 = this._map.transform.isLocationOccluded(this._lngLat);
					if (!r$1 || o$1) {
						const e$2 = o$1 ? this._opacityWhenCovered : this._opacity;
						this._element.style.opacity !== e$2 && (this._element.style.opacity = e$2);
						return;
					}
					if (e$1) this._opacityTimeout = null;
					else {
						if (this._opacityTimeout) return;
						this._opacityTimeout = setTimeout((() => {
							this._opacityTimeout = null;
						}), 100);
					}
					const s$1 = this._map, n$1 = s$1.terrain.depthAtPoint(this._pos), l$1 = s$1.terrain.getElevationForLngLat(this._lngLat);
					if (s$1.transform.lngLatToCameraDepth(this._lngLat, l$1) - n$1 < .006) return void (this._element.style.opacity = this._opacity);
					const c$1 = -this._offset.y / s$1.transform.pixelsPerMeter, h$1 = Math.sin(s$1.getPitch() * Math.PI / 180) * c$1, u$1 = s$1.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d$1 = s$1.transform.lngLatToCameraDepth(this._lngLat, l$1 + h$1) - u$1 > .006;
					!(null === (a$1 = this._popup) || void 0 === a$1) && a$1.isOpen() && d$1 && this._popup.remove(), this._element.style.opacity = d$1 ? this._opacityWhenCovered : this._opacity;
				}
				getOffset() {
					return this._offset;
				}
				setOffset(e$1) {
					return this._offset = t.P.convert(e$1), this._update(), this;
				}
				addClassName(e$1) {
					this._element.classList.add(e$1);
				}
				removeClassName(e$1) {
					this._element.classList.remove(e$1);
				}
				toggleClassName(e$1) {
					return this._element.classList.toggle(e$1);
				}
				setDraggable(e$1) {
					return this._draggable = !!e$1, this._map && (e$1 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
				}
				isDraggable() {
					return this._draggable;
				}
				setRotation(e$1) {
					return this._rotation = e$1 || 0, this._update(), this;
				}
				getRotation() {
					return this._rotation;
				}
				setRotationAlignment(e$1) {
					return this._rotationAlignment = e$1 || "auto", this._update(), this;
				}
				getRotationAlignment() {
					return this._rotationAlignment;
				}
				setPitchAlignment(e$1) {
					return this._pitchAlignment = e$1 && "auto" !== e$1 ? e$1 : this._rotationAlignment, this._update(), this;
				}
				getPitchAlignment() {
					return this._pitchAlignment;
				}
				setOpacity(e$1, t$1) {
					return (void 0 === this._opacity || void 0 === e$1 && void 0 === t$1) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e$1 && (this._opacity = e$1), void 0 !== t$1 && (this._opacityWhenCovered = t$1), this._map && this._updateOpacity(!0), this;
				}
			}
			const fs$1 = {
				positionOptions: {
					enableHighAccuracy: !1,
					maximumAge: 0,
					timeout: 6e3
				},
				fitBoundsOptions: { maxZoom: 15 },
				trackUserLocation: !1,
				showAccuracyCircle: !0,
				showUserLocation: !0
			};
			let gs$1 = 0, vs$1 = !1;
			const xs$1 = {
				maxWidth: 100,
				unit: "metric"
			};
			function bs$1(e$1, t$1, i$1) {
				const a$1 = i$1 && i$1.maxWidth || 100, r$1 = e$1._container.clientHeight / 2, o$1 = e$1._container.clientWidth / 2, s$1 = e$1.unproject([o$1 - a$1 / 2, r$1]), n$1 = e$1.unproject([o$1 + a$1 / 2, r$1]), l$1 = Math.round(e$1.project(n$1).x - e$1.project(s$1).x), c$1 = Math.min(a$1, l$1, e$1._container.clientWidth), h$1 = s$1.distanceTo(n$1);
				if (i$1 && "imperial" === i$1.unit) {
					const i$2 = 3.2808 * h$1;
					i$2 > 5280 ? ys$1(t$1, c$1, i$2 / 5280, e$1._getUIString("ScaleControl.Miles")) : ys$1(t$1, c$1, i$2, e$1._getUIString("ScaleControl.Feet"));
				} else i$1 && "nautical" === i$1.unit ? ys$1(t$1, c$1, h$1 / 1852, e$1._getUIString("ScaleControl.NauticalMiles")) : h$1 >= 1e3 ? ys$1(t$1, c$1, h$1 / 1e3, e$1._getUIString("ScaleControl.Kilometers")) : ys$1(t$1, c$1, h$1, e$1._getUIString("ScaleControl.Meters"));
			}
			function ys$1(e$1, t$1, i$1, a$1) {
				const r$1 = function(e$2) {
					const t$2 = Math.pow(10, `${Math.floor(e$2)}`.length - 1);
					let i$2 = e$2 / t$2;
					return i$2 = i$2 >= 10 ? 10 : i$2 >= 5 ? 5 : i$2 >= 3 ? 3 : i$2 >= 2 ? 2 : i$2 >= 1 ? 1 : function(e$3) {
						const t$3 = Math.pow(10, Math.ceil(-Math.log(e$3) / Math.LN10));
						return Math.round(e$3 * t$3) / t$3;
					}(i$2), t$2 * i$2;
				}(i$1);
				e$1.style.width = t$1 * (r$1 / i$1) + "px", e$1.innerHTML = `${r$1}&nbsp;${a$1}`;
			}
			const ws$1 = {
				closeButton: !0,
				closeOnClick: !0,
				focusAfterOpen: !0,
				className: "",
				maxWidth: "240px",
				subpixelPositioning: !1,
				locationOccludedOpacity: void 0
			}, Ts$1 = [
				"a[href]",
				"[tabindex]:not([tabindex='-1'])",
				"[contenteditable]:not([contenteditable='false'])",
				"button:not([disabled])",
				"input:not([disabled])",
				"select:not([disabled])",
				"textarea:not([disabled])"
			].join(", ");
			function Ps$1(e$1) {
				if (e$1) {
					if ("number" == typeof e$1) {
						const i$1 = Math.round(Math.abs(e$1) / Math.SQRT2);
						return {
							center: new t.P(0, 0),
							top: new t.P(0, e$1),
							"top-left": new t.P(i$1, i$1),
							"top-right": new t.P(-i$1, i$1),
							bottom: new t.P(0, -e$1),
							"bottom-left": new t.P(i$1, -i$1),
							"bottom-right": new t.P(-i$1, -i$1),
							left: new t.P(e$1, 0),
							right: new t.P(-e$1, 0)
						};
					}
					if (e$1 instanceof t.P || Array.isArray(e$1)) {
						const i$1 = t.P.convert(e$1);
						return {
							center: i$1,
							top: i$1,
							"top-left": i$1,
							"top-right": i$1,
							bottom: i$1,
							"bottom-left": i$1,
							"bottom-right": i$1,
							left: i$1,
							right: i$1
						};
					}
					return {
						center: t.P.convert(e$1.center || [0, 0]),
						top: t.P.convert(e$1.top || [0, 0]),
						"top-left": t.P.convert(e$1["top-left"] || [0, 0]),
						"top-right": t.P.convert(e$1["top-right"] || [0, 0]),
						bottom: t.P.convert(e$1.bottom || [0, 0]),
						"bottom-left": t.P.convert(e$1["bottom-left"] || [0, 0]),
						"bottom-right": t.P.convert(e$1["bottom-right"] || [0, 0]),
						left: t.P.convert(e$1.left || [0, 0]),
						right: t.P.convert(e$1.right || [0, 0])
					};
				}
				return Ps$1(new t.P(0, 0));
			}
			const Is$1 = i;
			e.AJAXError = t.cJ, e.Event = t.l, e.Evented = t.E, e.LngLat = t.V, e.MercatorCoordinate = t.ab, e.Point = t.P, e.addProtocol = t.cK, e.config = t.c, e.removeProtocol = t.cL, e.AttributionControl = Yo$1, e.BoxZoomHandler = co$1, e.CanvasSource = ae$1, e.CooperativeGesturesHandler = Vo$1, e.DoubleClickZoomHandler = Oo$1, e.DragPanHandler = Zo$1, e.DragRotateHandler = Go$1, e.EdgeInsets = Nt$1, e.FullscreenControl = class extends t.E {
				constructor(e$1 = {}) {
					super(), this._onFullscreenChange = () => {
						var e$2;
						let t$1 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
						for (; null === (e$2 = null == t$1 ? void 0 : t$1.shadowRoot) || void 0 === e$2 ? void 0 : e$2.fullscreenElement;) t$1 = t$1.shadowRoot.fullscreenElement;
						t$1 === this._container !== this._fullscreen && this._handleFullscreenChange();
					}, this._onClickFullscreen = () => {
						this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
					}, this._fullscreen = !1, e$1 && e$1.container && (e$1.container instanceof HTMLElement ? this._container = e$1.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
				}
				onAdd(e$1) {
					return this._map = e$1, this._container || (this._container = this._map.getContainer()), this._controlContainer = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
				}
				onRemove() {
					h.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_setupUI() {
					const e$1 = this._fullscreenButton = h.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
					h.create("span", "maplibregl-ctrl-icon", e$1).setAttribute("aria-hidden", "true"), e$1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_updateTitle() {
					const e$1 = this._getTitle();
					this._fullscreenButton.setAttribute("aria-label", e$1), this._fullscreenButton.title = e$1;
				}
				_getTitle() {
					return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
				}
				_isFullscreen() {
					return this._fullscreen;
				}
				_handleFullscreenChange() {
					this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
				}
				_exitFullscreen() {
					window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
				}
				_requestFullscreen() {
					this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
				}
				_togglePseudoFullScreen() {
					this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
				}
			}, e.GeoJSONSource = ee$1, e.GeolocateControl = class extends t.E {
				constructor(e$1) {
					super(), this._onSuccess = (e$2) => {
						if (this._map) {
							if (this._isOutOfMapMaxBounds(e$2)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e$2)), this._updateMarker(), void this._finish();
							if (this.options.trackUserLocation) switch (this._lastKnownPosition = e$2, this._watchState) {
								case "WAITING_ACTIVE":
								case "ACTIVE_LOCK":
								case "ACTIVE_ERROR":
									this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
									break;
								case "BACKGROUND":
								case "BACKGROUND_ERROR":
									this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
									break;
								default: throw new Error(`Unexpected watchState ${this._watchState}`);
							}
							this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e$2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e$2), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e$2)), this._finish();
						}
					}, this._updateCamera = (e$2) => {
						const i$1 = new t.V(e$2.coords.longitude, e$2.coords.latitude), a$1 = e$2.coords.accuracy, r$1 = this._map.getBearing(), o$1 = t.e({ bearing: r$1 }, this.options.fitBoundsOptions), s$1 = $$1.fromLngLat(i$1, a$1);
						this._map.fitBounds(s$1, o$1, { geolocateSource: !0 });
					}, this._updateMarker = (e$2) => {
						if (e$2) {
							const i$1 = new t.V(e$2.coords.longitude, e$2.coords.latitude);
							this._accuracyCircleMarker.setLngLat(i$1).addTo(this._map), this._userLocationDotMarker.setLngLat(i$1).addTo(this._map), this._accuracy = e$2.coords.accuracy, this._updateCircleRadiusIfNeeded();
						} else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
					}, this._onUpdate = () => {
						this._updateCircleRadiusIfNeeded();
					}, this._onError = (e$2) => {
						if (this._map) {
							if (1 === e$2.code) {
								this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3), void 0 !== this._geolocationWatchID && this._clearWatch();
							} else {
								if (3 === e$2.code && vs$1) return;
								this._setErrorState();
							}
							"OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e$2)), this._finish();
						}
					}, this._finish = () => {
						this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
					}, this._setupUI = () => {
						this._map && (this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this._geolocateButton = h.create("button", "maplibregl-ctrl-geolocate", this._container), h.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
					}, this._finishSetupUI = (e$2) => {
						if (this._map) {
							if (!1 === e$2) {
								t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.disabled = !0, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							} else {
								const e$3 = this._map._getUIString("GeolocateControl.FindMyLocation");
								this._geolocateButton.disabled = !1, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							}
							this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = h.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ms$1({ element: this._dotElement }), this._circleElement = h.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ms$1({
								element: this._circleElement,
								pitchAlignment: "map"
							}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((e$3) => {
								const i$1 = (null == e$3 ? void 0 : e$3[0]) instanceof ResizeObserverEntry;
								e$3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || i$1 || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
							}));
						}
					}, this.options = t.e({}, fs$1, e$1);
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
						return t._(this, arguments, void 0, (function* (e$2 = !1) {
							if (void 0 !== us$1 && !e$2) return us$1;
							if (void 0 === window.navigator.permissions) return us$1 = !!window.navigator.geolocation, us$1;
							try {
								us$1 = "denied" !== (yield window.navigator.permissions.query({ name: "geolocation" })).state;
							} catch (e$3) {
								us$1 = !!window.navigator.geolocation;
							}
							return us$1;
						}));
					}().then(((e$2) => this._finishSetupUI(e$2))), this._container;
				}
				onRemove() {
					void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), h.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, gs$1 = 0, vs$1 = !1;
				}
				_isOutOfMapMaxBounds(e$1) {
					const t$1 = this._map.getMaxBounds(), i$1 = e$1.coords;
					return t$1 && (i$1.longitude < t$1.getWest() || i$1.longitude > t$1.getEast() || i$1.latitude < t$1.getSouth() || i$1.latitude > t$1.getNorth());
				}
				_setErrorState() {
					switch (this._watchState) {
						case "WAITING_ACTIVE":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
							break;
						case "ACTIVE_LOCK":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "BACKGROUND":
							this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "ACTIVE_ERROR":
						case "BACKGROUND_ERROR":
						case "OFF":
						case void 0: break;
						default: throw new Error(`Unexpected watchState ${this._watchState}`);
					}
				}
				_updateCircleRadiusIfNeeded() {
					const e$1 = this._userLocationDotMarker.getLngLat();
					if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && e$1)) return;
					const t$1 = this._map.project(e$1), i$1 = this._map.unproject([t$1.x + 100, t$1.y]), a$1 = e$1.distanceTo(i$1) / 100, r$1 = 2 * this._accuracy / a$1;
					this._circleElement.style.width = `${r$1.toFixed(2)}px`, this._circleElement.style.height = `${r$1.toFixed(2)}px`;
				}
				trigger() {
					if (!this._setup) return t.w("Geolocate control triggered before added to a map"), !1;
					if (this.options.trackUserLocation) {
						switch (this._watchState) {
							case "OFF":
								this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
								break;
							case "WAITING_ACTIVE":
							case "ACTIVE_LOCK":
							case "ACTIVE_ERROR":
							case "BACKGROUND_ERROR":
								gs$1--, vs$1 = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
								break;
							case "BACKGROUND":
								this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
								break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						switch (this._watchState) {
							case "WAITING_ACTIVE":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "ACTIVE_LOCK":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "OFF": break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
						else if (void 0 === this._geolocationWatchID) {
							let e$1;
							this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), gs$1++, gs$1 > 1 ? (e$1 = {
								maximumAge: 6e5,
								timeout: 0
							}, vs$1 = !0) : (e$1 = this.options.positionOptions, vs$1 = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e$1);
						}
					} else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
					return !0;
				}
				_clearWatch() {
					window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
				}
			}, e.GlobeControl = class {
				constructor() {
					this._toggleProjection = () => {
						var e$1;
						const t$1 = null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type;
						this._map.setProjection("mercator" !== t$1 && t$1 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
					}, this._updateGlobeIcon = () => {
						var e$1;
						this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
					};
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = h.create("button", "maplibregl-ctrl-globe", this._container), h.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
				}
			}, e.Hash = $r$1, e.ImageSource = te$1, e.KeyboardHandler = Ao$1, e.LngLatBounds = $$1, e.LogoControl = Qo$1, e.Map = class extends Xo$1 {
				constructor(e$1) {
					var i$1, a$1;
					t.cH.mark(t.cI.create);
					const r$1 = Object.assign(Object.assign(Object.assign({}, ls$1), e$1), { canvasContextAttributes: Object.assign(Object.assign({}, ls$1.canvasContextAttributes), e$1.canvasContextAttributes) });
					if (null != r$1.minZoom && null != r$1.maxZoom && r$1.minZoom > r$1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
					if (null != r$1.minPitch && null != r$1.maxPitch && r$1.minPitch > r$1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
					if (null != r$1.minPitch && r$1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (null != r$1.maxPitch && r$1.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
					const o$1 = new $t$1(), s$1 = new Yt$1();
					if (void 0 !== r$1.minZoom && o$1.setMinZoom(r$1.minZoom), void 0 !== r$1.maxZoom && o$1.setMaxZoom(r$1.maxZoom), void 0 !== r$1.minPitch && o$1.setMinPitch(r$1.minPitch), void 0 !== r$1.maxPitch && o$1.setMaxPitch(r$1.maxPitch), void 0 !== r$1.renderWorldCopies && o$1.setRenderWorldCopies(r$1.renderWorldCopies), null !== r$1.transformConstrain && o$1.setConstrainOverride(r$1.transformConstrain), super(o$1, s$1, { bearingSnap: r$1.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Jo$1(), this._controls = [], this._mapId = t.ah(), this._lostContextStyle = {
						style: null,
						images: null
					}, this._contextLost = (e$2) => {
						e$2.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
						for (const e$3 of Object.values(this.style._layers)) if ("custom" === e$3.type && console.warn(`Custom layer with id '${e$3.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), e$3._listeners) for (const [t$1] of Object.entries(e$3._listeners)) console.warn(`Custom layer with id '${e$3.id}' had event listeners for event '${t$1}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
						this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new t.l("webglcontextlost", { originalEvent: e$2 }));
					}, this._contextRestored = (e$2) => {
						this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: !1 }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._setupPainter(), this.resize(), this._update(), this.fire(new t.l("webglcontextrestored", { originalEvent: e$2 }));
					}, this._onMapScroll = (e$2) => {
						if (e$2.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
					}, this._onWindowOnline = () => {
						this._update();
					}, this._interactive = r$1.interactive, this._maxTileCacheSize = r$1.maxTileCacheSize, this._maxTileCacheZoomLevels = r$1.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, r$1.canvasContextAttributes), this._trackResize = !0 === r$1.trackResize, this._bearingSnap = r$1.bearingSnap, this._centerClampedToGround = r$1.centerClampedToGround, this._refreshExpiredTiles = !0 === r$1.refreshExpiredTiles, this._fadeDuration = r$1.fadeDuration, this._crossSourceCollisions = !0 === r$1.crossSourceCollisions, this._collectResourceTiming = !0 === r$1.collectResourceTiming, this._locale = Object.assign(Object.assign({}, ss$1), r$1.locale), this._clickTolerance = r$1.clickTolerance, this._overridePixelRatio = r$1.pixelRatio, this._maxCanvasSize = r$1.maxCanvasSize, this._zoomLevelsToOverscale = r$1.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = r$1.transformCameraUpdate, this.transformConstrain = r$1.transformConstrain, this.cancelPendingTileRequestsWhileZooming = !0 === r$1.cancelPendingTileRequestsWhileZooming, void 0 !== r$1.reduceMotion && (n.prefersReducedMotion = r$1.reduceMotion), this._imageQueueHandle = g$1.addThrottleControl((() => this.isMoving())), this._requestManager = new v(r$1.transformRequest), "string" == typeof r$1.container) {
						if (this._container = document.getElementById(r$1.container), !this._container) throw new Error(`Container '${r$1.container}' not found.`);
					} else {
						if (!(r$1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
						this._container = r$1.container;
					}
					if (r$1.maxBounds && this.setMaxBounds(r$1.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
						this.painter.terrainFacilitator.dirty = !0, this._update(!0);
					})), this.once("idle", (() => {
						this._idleTriggered = !0;
					})), "undefined" != typeof window) {
						addEventListener("online", this._onWindowOnline, !1);
						let e$2 = !1;
						const t$1 = Wr$1(((e$3) => {
							this._trackResize && !this._removed && (this.resize(e$3), this.redraw());
						}), 50);
						this._resizeObserver = new ResizeObserver(((i$2) => {
							e$2 ? t$1(i$2) : e$2 = !0;
						})), this._resizeObserver.observe(this._container);
					}
					this.handlers = new Ho$1(this, r$1), this._hash = r$1.hash && new $r$1("string" == typeof r$1.hash && r$1.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
						center: r$1.center,
						elevation: r$1.elevation,
						zoom: r$1.zoom,
						bearing: r$1.bearing,
						pitch: r$1.pitch,
						roll: r$1.roll
					}), r$1.bounds && (this.resize(), this.fitBounds(r$1.bounds, t.e({}, r$1.fitBoundsOptions, { duration: 0 }))));
					const l$1 = "string" == typeof r$1.style || !("globe" === (null === (a$1 = null === (i$1 = r$1.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === a$1 ? void 0 : a$1.type));
					this.resize(null, l$1), this._localIdeographFontFamily = r$1.localIdeographFontFamily, this._validateStyle = r$1.validateStyle, r$1.style && this.setStyle(r$1.style, { localIdeographFontFamily: r$1.localIdeographFontFamily }), r$1.attributionControl && this.addControl(new Yo$1("boolean" == typeof r$1.attributionControl ? void 0 : r$1.attributionControl)), r$1.maplibreLogo && this.addControl(new Qo$1(), r$1.logoPosition), this.on("style.load", (() => {
						if (l$1 || this._resizeTransform(), this.transform.unmodified) {
							const e$2 = t.U(this.style.stylesheet, [
								"center",
								"zoom",
								"bearing",
								"pitch",
								"roll"
							]);
							this.jumpTo(e$2);
						}
					})), this.on("data", ((e$2) => {
						this._update("style" === e$2.dataType), this.fire(new t.l(`${e$2.dataType}data`, e$2));
					})), this.on("dataloading", ((e$2) => {
						this.fire(new t.l(`${e$2.dataType}dataloading`, e$2));
					})), this.on("dataabort", ((e$2) => {
						this.fire(new t.l("sourcedataabort", e$2));
					}));
				}
				_getMapId() {
					return this._mapId;
				}
				setGlobalStateProperty(e$1, t$1) {
					return this.style.setGlobalStateProperty(e$1, t$1), this._update(!0);
				}
				getGlobalState() {
					return this.style.getGlobalState();
				}
				addControl(e$1, i$1) {
					if (void 0 === i$1 && (i$1 = e$1.getDefaultPosition ? e$1.getDefaultPosition() : "top-right"), !e$1 || !e$1.onAdd) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
					const a$1 = e$1.onAdd(this);
					this._controls.push(e$1);
					const r$1 = this._controlPositions[i$1];
					return -1 !== i$1.indexOf("bottom") ? r$1.insertBefore(a$1, r$1.firstChild) : r$1.appendChild(a$1), this;
				}
				removeControl(e$1) {
					if (!e$1 || !e$1.onRemove) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
					const i$1 = this._controls.indexOf(e$1);
					return i$1 > -1 && this._controls.splice(i$1, 1), e$1.onRemove(this), this;
				}
				hasControl(e$1) {
					return this._controls.indexOf(e$1) > -1;
				}
				coveringTiles(e$1) {
					return Ce$1(this.transform, e$1);
				}
				calculateCameraOptionsFromTo(e$1, t$1, i$1, a$1) {
					return null == a$1 && this.terrain && (a$1 = this.terrain.getElevationForLngLat(i$1)), super.calculateCameraOptionsFromTo(e$1, t$1, i$1, a$1);
				}
				resize(e$1, i$1 = !0) {
					const [a$1, r$1] = this._containerDimensions(), o$1 = this._getClampedPixelRatio(a$1, r$1);
					if (this._resizeCanvas(a$1, r$1, o$1), this.painter.resize(a$1, r$1, o$1), this.painter.overLimit()) {
						const e$2 = this.painter.context.gl;
						this._maxCanvasSize = [e$2.drawingBufferWidth, e$2.drawingBufferHeight];
						const t$1 = this._getClampedPixelRatio(a$1, r$1);
						this._resizeCanvas(a$1, r$1, t$1), this.painter.resize(a$1, r$1, t$1);
					}
					this._resizeTransform(i$1);
					const s$1 = !this._moving;
					return s$1 && (this.stop(), this.fire(new t.l("movestart", e$1)).fire(new t.l("move", e$1))), this.fire(new t.l("resize", e$1)), s$1 && this.fire(new t.l("moveend", e$1)), this;
				}
				_resizeTransform(e$1 = !0) {
					var t$1;
					const [i$1, a$1] = this._containerDimensions();
					this.transform.resize(i$1, a$1, e$1), null === (t$1 = this._requestedCameraState) || void 0 === t$1 || t$1.resize(i$1, a$1, e$1);
				}
				_getClampedPixelRatio(e$1, t$1) {
					const { 0: i$1, 1: a$1 } = this._maxCanvasSize, r$1 = this.getPixelRatio(), o$1 = e$1 * r$1, s$1 = t$1 * r$1;
					return Math.min(o$1 > i$1 ? i$1 / o$1 : 1, s$1 > a$1 ? a$1 / s$1 : 1) * r$1;
				}
				getPixelRatio() {
					var e$1;
					return null !== (e$1 = this._overridePixelRatio) && void 0 !== e$1 ? e$1 : devicePixelRatio;
				}
				setPixelRatio(e$1) {
					this._overridePixelRatio = e$1, this.resize();
				}
				getBounds() {
					return this.transform.getBounds();
				}
				getMaxBounds() {
					return this.transform.getMaxBounds();
				}
				setMaxBounds(e$1) {
					return this.transform.setMaxBounds($$1.convert(e$1)), this._update();
				}
				setMinZoom(e$1) {
					if ((e$1 = null == e$1 ? -2 : e$1) >= -2 && e$1 <= this.transform.maxZoom) return this.transform.setMinZoom(e$1), this._update(), this.getZoom() < e$1 && this.setZoom(e$1), this;
					throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
				}
				getMinZoom() {
					return this.transform.minZoom;
				}
				setMaxZoom(e$1) {
					if ((e$1 = null == e$1 ? 22 : e$1) >= this.transform.minZoom) return this.transform.setMaxZoom(e$1), this._update(), this.getZoom() > e$1 && this.setZoom(e$1), this;
					throw new Error("maxZoom must be greater than the current minZoom");
				}
				getMaxZoom() {
					return this.transform.maxZoom;
				}
				setMinPitch(e$1) {
					if ((e$1 = null == e$1 ? 0 : e$1) < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (e$1 >= 0 && e$1 <= this.transform.maxPitch) return this.transform.setMinPitch(e$1), this._update(), this.getPitch() < e$1 && this.setPitch(e$1), this;
					throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
				}
				getMinPitch() {
					return this.transform.minPitch;
				}
				setMaxPitch(e$1) {
					if ((e$1 = null == e$1 ? 60 : e$1) > 180) throw new Error("maxPitch must be less than or equal to 180");
					if (e$1 >= this.transform.minPitch) return this.transform.setMaxPitch(e$1), this._update(), this.getPitch() > e$1 && this.setPitch(e$1), this;
					throw new Error("maxPitch must be greater than the current minPitch");
				}
				getMaxPitch() {
					return this.transform.maxPitch;
				}
				getRenderWorldCopies() {
					return this.transform.renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					return this.transform.setRenderWorldCopies(e$1), this._update();
				}
				setTransformConstrain(e$1) {
					return this.transform.setConstrainOverride(e$1), this._update();
				}
				project(e$1) {
					return this.transform.locationToScreenPoint(t.V.convert(e$1), this.style && this.terrain);
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this.terrain);
				}
				isMoving() {
					var e$1;
					return this._moving || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isMoving());
				}
				isZooming() {
					var e$1;
					return this._zooming || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isZooming());
				}
				isRotating() {
					var e$1;
					return this._rotating || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isRotating());
				}
				_createDelegatedListener(e$1, t$1, i$1) {
					if ("mouseenter" === e$1 || "mouseover" === e$1) {
						let a$1 = !1;
						const r$1 = (r$2) => {
							const o$1 = t$1.filter(((e$2) => this.getLayer(e$2))), s$1 = 0 !== o$1.length ? this.queryRenderedFeatures(r$2.point, { layers: o$1 }) : [];
							s$1.length ? a$1 || (a$1 = !0, i$1.call(this, new ao$1(e$1, this, r$2.originalEvent, { features: s$1 }))) : a$1 = !1;
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: r$1,
								mouseout: () => {
									a$1 = !1;
								}
							}
						};
					}
					if ("mouseleave" === e$1 || "mouseout" === e$1) {
						let a$1 = !1;
						const r$1 = (r$2) => {
							const o$2 = t$1.filter(((e$2) => this.getLayer(e$2)));
							(0 !== o$2.length ? this.queryRenderedFeatures(r$2.point, { layers: o$2 }) : []).length ? a$1 = !0 : a$1 && (a$1 = !1, i$1.call(this, new ao$1(e$1, this, r$2.originalEvent)));
						}, o$1 = (t$2) => {
							a$1 && (a$1 = !1, i$1.call(this, new ao$1(e$1, this, t$2.originalEvent)));
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: r$1,
								mouseout: o$1
							}
						};
					}
					{
						const a$1 = (e$2) => {
							const a$2 = t$1.filter(((e$3) => this.getLayer(e$3))), r$1 = 0 !== a$2.length ? this.queryRenderedFeatures(e$2.point, { layers: a$2 }) : [];
							r$1.length && (e$2.features = r$1, i$1.call(this, e$2), delete e$2.features);
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: { [e$1]: a$1 }
						};
					}
				}
				_saveDelegatedListener(e$1, t$1) {
					this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e$1] = this._delegatedListeners[e$1] || [], this._delegatedListeners[e$1].push(t$1);
				}
				_removeDelegatedListener(e$1, t$1, i$1) {
					if (!this._delegatedListeners || !this._delegatedListeners[e$1]) return;
					const a$1 = this._delegatedListeners[e$1];
					for (let e$2 = 0; e$2 < a$1.length; e$2++) {
						const r$1 = a$1[e$2];
						if (r$1.listener === i$1 && r$1.layers.length === t$1.length && r$1.layers.every(((e$3) => t$1.includes(e$3)))) {
							for (const e$3 in r$1.delegates) this.off(e$3, r$1.delegates[e$3]);
							a$1.splice(e$2, 1);
							return;
						}
					}
				}
				on(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.on(e$1, t$1);
					const a$1 = "string" == typeof t$1 ? [t$1] : t$1, r$1 = this._createDelegatedListener(e$1, a$1, i$1);
					this._saveDelegatedListener(e$1, r$1);
					for (const e$2 in r$1.delegates) this.on(e$2, r$1.delegates[e$2]);
					return { unsubscribe: () => {
						this._removeDelegatedListener(e$1, a$1, i$1);
					} };
				}
				once(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.once(e$1, t$1);
					const a$1 = "string" == typeof t$1 ? [t$1] : t$1, r$1 = this._createDelegatedListener(e$1, a$1, i$1);
					for (const t$2 in r$1.delegates) {
						const o$1 = r$1.delegates[t$2];
						r$1.delegates[t$2] = (...t$3) => {
							this._removeDelegatedListener(e$1, a$1, i$1), o$1(...t$3);
						};
					}
					this._saveDelegatedListener(e$1, r$1);
					for (const e$2 in r$1.delegates) this.once(e$2, r$1.delegates[e$2]);
					return this;
				}
				off(e$1, t$1, i$1) {
					return void 0 === i$1 ? super.off(e$1, t$1) : (this._removeDelegatedListener(e$1, "string" == typeof t$1 ? [t$1] : t$1, i$1), this);
				}
				queryRenderedFeatures(e$1, i$1) {
					if (!this.style) return [];
					let a$1;
					const r$1 = e$1 instanceof t.P || Array.isArray(e$1), o$1 = r$1 ? e$1 : [[0, 0], [this.transform.width, this.transform.height]];
					if (i$1 = i$1 || (r$1 ? {} : e$1) || {}, o$1 instanceof t.P || "number" == typeof o$1[0]) a$1 = [t.P.convert(o$1)];
					else {
						const e$2 = t.P.convert(o$1[0]), i$2 = t.P.convert(o$1[1]);
						a$1 = [
							e$2,
							new t.P(i$2.x, e$2.y),
							i$2,
							new t.P(e$2.x, i$2.y),
							e$2
						];
					}
					return this.style.queryRenderedFeatures(a$1, i$1, this.transform);
				}
				querySourceFeatures(e$1, t$1) {
					return this.style.querySourceFeatures(e$1, t$1);
				}
				setStyle(e$1, i$1) {
					return !1 !== (i$1 = t.e({}, {
						localIdeographFontFamily: this._localIdeographFontFamily,
						validate: this._validateStyle
					}, i$1)).diff && i$1.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e$1 ? (this._diffStyle(e$1, i$1), this) : (this._localIdeographFontFamily = i$1.localIdeographFontFamily, this._updateStyle(e$1, i$1));
				}
				setTransformRequest(e$1) {
					return this._requestManager.setTransformRequest(e$1), this;
				}
				_getUIString(e$1) {
					const t$1 = this._locale[e$1];
					if (null == t$1) throw new Error(`Missing UI string '${e$1}'`);
					return t$1;
				}
				_updateStyle(e$1, t$1) {
					var i$1, a$1;
					if (t$1.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(e$1, t$1)));
					const r$1 = this.style && t$1.transformStyle ? this.style.serialize() : void 0;
					return this.style && (this.style.setEventedParent(null), this.style._remove(!e$1)), e$1 ? (this.style = new ki(this, t$1 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e$1 ? this.style.loadURL(e$1, t$1, r$1) : this.style.loadJSON(e$1, t$1, r$1), this) : (null === (a$1 = null === (i$1 = this.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === a$1 || a$1.destroy(), delete this.style, this);
				}
				_lazyInitEmptyStyle() {
					this.style || (this.style = new ki(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
				}
				_diffStyle(e$1, i$1) {
					if ("string" == typeof e$1) {
						const a$1 = this._requestManager.transformRequest(e$1, "Style");
						t.j(a$1, new AbortController()).then(((e$2) => {
							this._updateDiff(e$2.data, i$1);
						})).catch(((e$2) => {
							e$2 && this.fire(new t.k(e$2));
						}));
					} else "object" == typeof e$1 && this._updateDiff(e$1, i$1);
				}
				_updateDiff(e$1, i$1) {
					try {
						this.style.setState(e$1, i$1) && this._update(!0);
					} catch (a$1) {
						t.w(`Unable to perform style diff: ${a$1.message || a$1.error || a$1}.  Rebuilding the style from scratch.`), this._updateStyle(e$1, i$1);
					}
				}
				getStyle() {
					if (this.style) return this.style.serialize();
				}
				_getStyleAndImages() {
					return this.style ? {
						style: this.style.serialize(),
						images: this.style.imageManager.cloneImages()
					} : {
						style: null,
						images: {}
					};
				}
				isStyleLoaded() {
					return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
				}
				addSource(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addSource(e$1, t$1), this._update(!0);
				}
				isSourceLoaded(e$1) {
					const i$1 = this.style && this.style.tileManagers[e$1];
					if (void 0 !== i$1) return i$1.loaded();
					this.fire(new t.k(/* @__PURE__ */ new Error(`There is no tile manager with ID '${e$1}'`)));
				}
				setTerrain(e$1) {
					if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e$1) {
						const i$1 = this.style.tileManagers[e$1.source];
						if (!i$1) throw new Error(`cannot load terrain, because there exists no source with ID: ${e$1.source}`);
						null === this.terrain && i$1.reload();
						for (const i$2 in this.style._layers) {
							const a$1 = this.style._layers[i$2];
							"hillshade" === a$1.type && a$1.source === e$1.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), "color-relief" === a$1.type && a$1.source === e$1.source && t.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
						}
						this.terrain = new is$1(this.painter, i$1, e$1), this.painter.renderToTexture = new os$1(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t$1) => {
							var i$2;
							"style" === t$1.dataType ? this.terrain.tileManager.freeRtt() : "source" === t$1.dataType && t$1.tile && (t$1.sourceId !== e$1.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i$2 = t$1.source) || void 0 === i$2 ? void 0 : i$2.type) ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(t$1.tile.tileID));
						}, this.style.on("data", this._terrainDataCallback);
					} else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
					return this.fire(new t.l("terrain", { terrain: e$1 })), this;
				}
				getTerrain() {
					var e$1, t$1;
					return null !== (t$1 = null === (e$1 = this.terrain) || void 0 === e$1 ? void 0 : e$1.options) && void 0 !== t$1 ? t$1 : null;
				}
				areTilesLoaded() {
					const e$1 = this.style && this.style.tileManagers;
					for (const t$1 of Object.values(e$1)) if (!t$1.areTilesLoaded()) return !1;
					return !0;
				}
				removeSource(e$1) {
					return this.style.removeSource(e$1), this._update(!0);
				}
				getSource(e$1) {
					return this.style.getSource(e$1);
				}
				setSourceTileLodParams(e$1, t$1, i$1) {
					if (i$1) {
						const a$1 = this.getSource(i$1);
						if (!a$1) throw new Error(`There is no source with ID "${i$1}", cannot set LOD parameters`);
						a$1.calculateTileZoom = Te$1(Math.max(1, e$1), Math.max(1, t$1));
					} else for (const i$2 in this.style.tileManagers) this.style.tileManagers[i$2].getSource().calculateTileZoom = Te$1(Math.max(1, e$1), Math.max(1, t$1));
					return this._update(!0), this;
				}
				refreshTiles(e$1, i$1) {
					const a$1 = this.style.tileManagers[e$1];
					if (!a$1) throw new Error(`There is no tile manager with ID "${e$1}", cannot refresh tile`);
					void 0 === i$1 ? a$1.reload(!0) : a$1.refreshTiles(i$1.map(((e$2) => new t.ae(e$2.z, e$2.x, e$2.y))));
				}
				addImage(e$1, i$1, a$1 = {}) {
					const { pixelRatio: r$1 = 1, sdf: o$1 = !1, stretchX: s$1, stretchY: l$1, content: c$1, textFitWidth: h$1, textFitHeight: u$1 } = a$1;
					if (this._lazyInitEmptyStyle(), !(i$1 instanceof HTMLImageElement || t.b(i$1))) {
						if (void 0 === i$1.width || void 0 === i$1.height) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
						{
							const { width: a$2, height: n$1, data: d$1 } = i$1, _$2 = i$1;
							return this.style.addImage(e$1, {
								data: new t.R({
									width: a$2,
									height: n$1
								}, new Uint8Array(d$1)),
								pixelRatio: r$1,
								stretchX: s$1,
								stretchY: l$1,
								content: c$1,
								textFitWidth: h$1,
								textFitHeight: u$1,
								sdf: o$1,
								version: 0,
								userImage: _$2
							}), _$2.onAdd && _$2.onAdd(this, e$1), this;
						}
					}
					{
						const { width: a$2, height: d$1, data: _$2 } = n.getImageData(i$1);
						this.style.addImage(e$1, {
							data: new t.R({
								width: a$2,
								height: d$1
							}, _$2),
							pixelRatio: r$1,
							stretchX: s$1,
							stretchY: l$1,
							content: c$1,
							textFitWidth: h$1,
							textFitHeight: u$1,
							sdf: o$1,
							version: 0
						});
					}
				}
				updateImage(e$1, i$1) {
					const a$1 = this.style.getImage(e$1);
					if (!a$1) return this.fire(new t.k(/* @__PURE__ */ new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
					const { width: o$1, height: s$1, data: l$1 } = i$1 instanceof HTMLImageElement || t.b(i$1) ? n.getImageData(i$1) : i$1;
					if (void 0 === o$1 || void 0 === s$1) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
					if (o$1 !== a$1.data.width || s$1 !== a$1.data.height) return this.fire(new t.k(/* @__PURE__ */ new Error("The width and height of the updated image must be that same as the previous version of the image")));
					const c$1 = !(i$1 instanceof HTMLImageElement || t.b(i$1));
					return a$1.data.replace(l$1, c$1), this.style.updateImage(e$1, a$1), this;
				}
				getImage(e$1) {
					return this.style.getImage(e$1);
				}
				hasImage(e$1) {
					return e$1 ? !!this.style.getImage(e$1) : (this.fire(new t.k(/* @__PURE__ */ new Error("Missing required image id"))), !1);
				}
				removeImage(e$1) {
					this.style.removeImage(e$1);
				}
				loadImage(e$1) {
					return g$1.getImage(this._requestManager.transformRequest(e$1, "Image"), new AbortController());
				}
				listImages() {
					return this.style.listImages();
				}
				addLayer(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addLayer(e$1, t$1), this._update(!0);
				}
				moveLayer(e$1, t$1) {
					return this.style.moveLayer(e$1, t$1), this._update(!0);
				}
				removeLayer(e$1) {
					return this.style.removeLayer(e$1), this._update(!0);
				}
				getLayer(e$1) {
					return this.style.getLayer(e$1);
				}
				getLayersOrder() {
					return this.style.getLayersOrder();
				}
				setLayerZoomRange(e$1, t$1, i$1) {
					return this.style.setLayerZoomRange(e$1, t$1, i$1), this._update(!0);
				}
				setFilter(e$1, t$1, i$1 = {}) {
					return this.style.setFilter(e$1, t$1, i$1), this._update(!0);
				}
				getFilter(e$1) {
					return this.style.getFilter(e$1);
				}
				setPaintProperty(e$1, t$1, i$1, a$1 = {}) {
					return this.style.setPaintProperty(e$1, t$1, i$1, a$1), this._update(!0);
				}
				getPaintProperty(e$1, t$1) {
					return this.style.getPaintProperty(e$1, t$1);
				}
				setLayoutProperty(e$1, t$1, i$1, a$1 = {}) {
					return this.style.setLayoutProperty(e$1, t$1, i$1, a$1), this._update(!0);
				}
				getLayoutProperty(e$1, t$1) {
					return this.style.getLayoutProperty(e$1, t$1);
				}
				setGlyphs(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setGlyphs(e$1, t$1), this._update(!0);
				}
				getGlyphs() {
					return this.style.getGlyphsUrl();
				}
				addSprite(e$1, t$1, i$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.addSprite(e$1, t$1, i$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				removeSprite(e$1) {
					return this._lazyInitEmptyStyle(), this.style.removeSprite(e$1), this._update(!0);
				}
				getSprite() {
					return this.style.getSprite();
				}
				setSprite(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSprite(e$1, t$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				setLight(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setLight(e$1, t$1), this._update(!0);
				}
				getLight() {
					return this.style.getLight();
				}
				setSky(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSky(e$1, t$1), this._update(!0);
				}
				getSky() {
					return this.style.getSky();
				}
				setFeatureState(e$1, t$1) {
					return this.style.setFeatureState(e$1, t$1), this._update();
				}
				removeFeatureState(e$1, t$1) {
					return this.style.removeFeatureState(e$1, t$1), this._update();
				}
				getFeatureState(e$1) {
					return this.style.getFeatureState(e$1);
				}
				getContainer() {
					return this._container;
				}
				getCanvasContainer() {
					return this._canvasContainer;
				}
				getCanvas() {
					return this._canvas;
				}
				_containerDimensions() {
					let e$1 = 0, t$1 = 0;
					return this._container && (e$1 = this._container.clientWidth || 400, t$1 = this._container.clientHeight || 300), [e$1, t$1];
				}
				_setupContainer() {
					const e$1 = this._container;
					e$1.classList.add("maplibregl-map");
					const t$1 = this._canvasContainer = h.create("div", "maplibregl-canvas-container", e$1);
					this._interactive && t$1.classList.add("maplibregl-interactive"), this._canvas = h.create("canvas", "maplibregl-canvas", t$1), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
					const i$1 = this._containerDimensions(), a$1 = this._getClampedPixelRatio(i$1[0], i$1[1]);
					this._resizeCanvas(i$1[0], i$1[1], a$1);
					const r$1 = this._controlContainer = h.create("div", "maplibregl-control-container", e$1), o$1 = this._controlPositions = {};
					[
						"top-left",
						"top-right",
						"bottom-left",
						"bottom-right"
					].forEach(((e$2) => {
						o$1[e$2] = h.create("div", `maplibregl-ctrl-${e$2} `, r$1);
					})), this._container.addEventListener("scroll", this._onMapScroll, !1);
				}
				_resizeCanvas(e$1, t$1, i$1) {
					this._canvas.width = Math.floor(i$1 * e$1), this._canvas.height = Math.floor(i$1 * t$1), this._canvas.style.width = `${e$1}px`, this._canvas.style.height = `${t$1}px`;
				}
				_setupPainter() {
					const e$1 = Object.assign(Object.assign({}, this._canvasContextAttributes), {
						alpha: !0,
						depth: !0,
						stencil: !0,
						premultipliedAlpha: !0
					});
					let t$1 = null;
					this._canvas.addEventListener("webglcontextcreationerror", ((i$2) => {
						t$1 = { requestedAttributes: e$1 }, i$2 && (t$1.statusMessage = i$2.statusMessage, t$1.type = i$2.type);
					}), { once: !0 });
					let i$1 = null;
					if (i$1 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e$1) : this._canvas.getContext("webgl2", e$1) || this._canvas.getContext("webgl", e$1), !i$1) {
						const e$2 = "Failed to initialize WebGL";
						throw t$1 ? (t$1.message = e$2, new Error(JSON.stringify(t$1))) : new Error(e$2);
					}
					this.painter = new qr$1(i$1, this.transform), u.testSupport(i$1);
				}
				migrateProjection(e$1, i$1) {
					super.migrateProjection(e$1, i$1), this.painter.transform = e$1, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
				}
				loaded() {
					return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
				}
				_update(e$1) {
					return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e$1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
				}
				_requestRenderFrame(e$1) {
					return this._update(), this._renderTaskQueue.add(e$1);
				}
				_cancelRenderFrame(e$1) {
					this._renderTaskQueue.remove(e$1);
				}
				_render(e$1) {
					var i$1, a$1, r$1, o$1, s$1;
					const n$1 = this._idleTriggered ? this._fadeDuration : 0, l$1 = (null === (i$1 = this.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0;
					if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e$1), this._removed) return;
					let h$1 = !1;
					if (this.style && this._styleDirty) {
						this._styleDirty = !1;
						const e$2 = this.transform.zoom, i$2 = c();
						this.style.zoomHistory.update(e$2, i$2);
						const a$2 = new t.H(e$2, {
							now: i$2,
							fadeDuration: n$1,
							zoomHistory: this.style.zoomHistory,
							transition: this.style.getTransition()
						}), r$2 = a$2.crossFadingFactor();
						1 === r$2 && r$2 === this._crossFadingFactor || (h$1 = !0, this._crossFadingFactor = r$2), this.style.update(a$2);
					}
					const u$1 = (null === (a$1 = this.style.projection) || void 0 === a$1 ? void 0 : a$1.transitionState) > 0 !== l$1;
					null === (r$1 = this.style.projection) || void 0 === r$1 || r$1.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (o$1 = this.style.projection) || void 0 === o$1 ? void 0 : o$1.transitionState, null === (s$1 = this.style.projection) || void 0 === s$1 ? void 0 : s$1.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u$1) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, n$1, this._crossSourceCollisions, u$1), this.painter.render(this.style, {
						showTileBoundaries: this.showTileBoundaries,
						showOverdrawInspector: this._showOverdrawInspector,
						rotating: this.isRotating(),
						zooming: this.isZooming(),
						moving: this.isMoving(),
						fadeDuration: n$1,
						showPadding: this.showPadding
					}), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, t.cH.mark(t.cI.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h$1) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
					const d$1 = this._sourcesDirty || this._styleDirty || this._placementDirty;
					return d$1 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d$1 || (this._fullyLoaded = !0, t.cH.mark(t.cI.fullLoad)), this;
				}
				redraw() {
					return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
				}
				remove() {
					var e$1;
					this._hash && this._hash.remove();
					for (const e$2 of this._controls) e$2.onRemove(this);
					this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, !1), g$1.removeThrottleControl(this._imageQueueHandle), null === (e$1 = this._resizeObserver) || void 0 === e$1 || e$1.disconnect();
					const i$1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
					null != i$1 && i$1.loseContext && i$1.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), h.remove(this._canvasContainer), h.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), t.cH.clearMetrics(), this._removed = !0, this.fire(new t.l("remove"));
				}
				triggerRepaint() {
					this.style && !this._frameRequest && (this._frameRequest = new AbortController(), n.frame(this._frameRequest, ((e$1) => {
						t.cH.frame(e$1), this._frameRequest = null;
						try {
							this._render(e$1);
						} catch (e$2) {
							if (!t.Z(e$2) && !function(e$3) {
								return e$3.message === or$1;
							}(e$2)) throw e$2;
						}
					}), (() => {})));
				}
				get showTileBoundaries() {
					return !!this._showTileBoundaries;
				}
				set showTileBoundaries(e$1) {
					this._showTileBoundaries !== e$1 && (this._showTileBoundaries = e$1, this._update());
				}
				get showPadding() {
					return !!this._showPadding;
				}
				set showPadding(e$1) {
					this._showPadding !== e$1 && (this._showPadding = e$1, this._update());
				}
				get showCollisionBoxes() {
					return !!this._showCollisionBoxes;
				}
				set showCollisionBoxes(e$1) {
					this._showCollisionBoxes !== e$1 && (this._showCollisionBoxes = e$1, e$1 ? this.style._generateCollisionBoxes() : this._update());
				}
				get showOverdrawInspector() {
					return !!this._showOverdrawInspector;
				}
				set showOverdrawInspector(e$1) {
					this._showOverdrawInspector !== e$1 && (this._showOverdrawInspector = e$1, this._update());
				}
				get repaint() {
					return !!this._repaint;
				}
				set repaint(e$1) {
					this._repaint !== e$1 && (this._repaint = e$1, this.triggerRepaint());
				}
				get vertices() {
					return !!this._vertices;
				}
				set vertices(e$1) {
					this._vertices = e$1, this._update();
				}
				get version() {
					return ns$1;
				}
				getCameraTargetElevation() {
					return this.transform.elevation;
				}
				getProjection() {
					return this.style.getProjection();
				}
				setProjection(e$1) {
					return this._lazyInitEmptyStyle(), this.style.setProjection(e$1), this._update(!0);
				}
			}, e.MapMouseEvent = ao$1, e.MapTouchEvent = ro$1, e.MapWheelEvent = oo$1, e.Marker = ms$1, e.NavigationControl = class {
				constructor(e$1) {
					this._updateZoomButtons = () => {
						const e$2 = this._map.getZoom(), t$1 = e$2 === this._map.getMaxZoom(), i$1 = e$2 === this._map.getMinZoom();
						this._zoomInButton.disabled = t$1, this._zoomOutButton.disabled = i$1, this._zoomInButton.setAttribute("aria-disabled", t$1.toString()), this._zoomOutButton.setAttribute("aria-disabled", i$1.toString());
					}, this._rotateCompassArrow = () => {
						this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
					}, this._setButtonTitle = (e$2, t$1) => {
						const i$1 = this._map._getUIString(`NavigationControl.${t$1}`);
						e$2.title = i$1, e$2.setAttribute("aria-label", i$1);
					}, this.options = t.e({}, cs$1, e$1), this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e$2) => this._map.zoomIn({}, { originalEvent: e$2 }))), h.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e$2) => this._map.zoomOut({}, { originalEvent: e$2 }))), h.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e$2) => {
						this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e$2 }) : this._map.resetNorth({}, { originalEvent: e$2 });
					})), this._compassIcon = h.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
				}
				onAdd(e$1) {
					return this._map = e$1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new hs$1(this._map, this._compass, this.options.visualizePitch)), this._container;
				}
				onRemove() {
					h.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
				}
				_createButton(e$1, t$1) {
					const i$1 = h.create("button", e$1, this._container);
					return i$1.type = "button", i$1.addEventListener("click", t$1), i$1;
				}
			}, e.Popup = class extends t.E {
				constructor(e$1) {
					super(), this._updateOpacity = () => {
						void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
					}, this.remove = () => (this._content && h.remove(this._content), this._container && (h.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e$2) => {
						this._update(e$2.point);
					}, this._onMouseMove = (e$2) => {
						this._update(e$2.point);
					}, this._onDrag = (e$2) => {
						this._update(e$2.point);
					}, this._update = (e$2) => {
						if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
						if (!this._container) {
							if (this._container = h.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = h.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e$3 of this.options.className.split(" ")) this._container.classList.add(e$3);
							this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
						}
						if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ds$1(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e$2) return;
						const t$1 = this._flatPos = this._pos = this._trackPointer && e$2 ? e$2 : this._map.project(this._lngLat);
						this._map.terrain && (this._flatPos = this._trackPointer && e$2 ? e$2 : this._map.transform.locationToScreenPoint(this._lngLat));
						let i$1 = this.options.anchor;
						const a$1 = Ps$1(this.options.offset);
						if (!i$1) {
							const e$3 = this._container.offsetWidth, r$2 = this._container.offsetHeight;
							let o$1;
							o$1 = t$1.y + a$1.bottom.y < r$2 ? ["top"] : t$1.y > this._map.transform.height - r$2 ? ["bottom"] : [], t$1.x < e$3 / 2 ? o$1.push("left") : t$1.x > this._map.transform.width - e$3 / 2 && o$1.push("right"), i$1 = 0 === o$1.length ? "bottom" : o$1.join("-");
						}
						let r$1 = t$1.add(a$1[i$1]);
						this.options.subpixelPositioning || (r$1 = r$1.round()), h.setTransform(this._container, `${_s$1[i$1]} translate(${r$1.x}px,${r$1.y}px)`), ps$1(this._container, i$1, "popup"), this._updateOpacity();
					}, this._onClose = () => {
						this.remove();
					}, this.options = t.e(Object.create(ws$1), e$1);
				}
				addTo(e$1) {
					return this._map && this.remove(), this._map = e$1, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
				}
				isOpen() {
					return !!this._map;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.V.convert(e$1), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
				}
				trackPointer() {
					return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
				}
				getElement() {
					return this._container;
				}
				setText(e$1) {
					return this.setDOMContent(document.createTextNode(e$1));
				}
				setHTML(e$1) {
					const t$1 = document.createDocumentFragment(), i$1 = document.createElement("body");
					let a$1;
					for (i$1.innerHTML = e$1; a$1 = i$1.firstChild, a$1;) t$1.appendChild(a$1);
					return this.setDOMContent(t$1);
				}
				getMaxWidth() {
					var e$1;
					return null === (e$1 = this._container) || void 0 === e$1 ? void 0 : e$1.style.maxWidth;
				}
				setMaxWidth(e$1) {
					return this.options.maxWidth = e$1, this._update(), this;
				}
				setDOMContent(e$1) {
					if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
					else this._content = h.create("div", "maplibregl-popup-content", this._container);
					return this._content.appendChild(e$1), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
				}
				addClassName(e$1) {
					return this._container && this._container.classList.add(e$1), this;
				}
				removeClassName(e$1) {
					return this._container && this._container.classList.remove(e$1), this;
				}
				setOffset(e$1) {
					return this.options.offset = e$1, this._update(), this;
				}
				toggleClassName(e$1) {
					if (this._container) return this._container.classList.toggle(e$1);
				}
				setSubpixelPositioning(e$1) {
					this.options.subpixelPositioning = e$1;
				}
				_createCloseButton() {
					this.options.closeButton && (this._closeButton = h.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
				}
				_focusFirstElement() {
					if (!this.options.focusAfterOpen || !this._container) return;
					const e$1 = this._container.querySelector(Ts$1);
					e$1 && e$1.focus();
				}
			}, e.RasterDEMTileSource = Y$1, e.RasterTileSource = K$1, e.ScaleControl = class {
				constructor(e$1) {
					this._onMove = () => {
						bs$1(this._map, this._container, this.options);
					}, this.setUnit = (e$2) => {
						this.options.unit = e$2, bs$1(this._map, this._container, this.options);
					}, this.options = Object.assign(Object.assign({}, xs$1), e$1);
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e$1.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
				}
			}, e.ScrollZoomHandler = Bo$1, e.Style = ki, e.TerrainControl = class {
				constructor(e$1) {
					this._toggleTerrain = () => {
						this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
					}, this._updateTerrainIcon = () => {
						this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
					}, this.options = e$1;
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = h.create("button", "maplibregl-ctrl-terrain", this._container), h.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
				}
			}, e.TwoFingersTouchPitchHandler = zo$1, e.TwoFingersTouchRotateHandler = So$1, e.TwoFingersTouchZoomHandler = Mo$1, e.TwoFingersTouchZoomRotateHandler = Uo$1, e.VectorTileSource = X, e.VideoSource = ie$1, e.addSourceType = (e$1, i$1) => t._(void 0, void 0, void 0, (function* () {
				if (oe$1(e$1)) throw new Error(`A source type called "${e$1}" already exists.`);
				((e$2, t$1) => {
					re$1[e$2] = t$1;
				})(e$1, i$1);
			})), e.clearPrewarmedResources = function() {
				const e$1 = B$1;
				e$1 && (e$1.isPreloaded() && 1 === e$1.numActive() ? (e$1.release(L$1), B$1 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
			}, e.createTileMesh = li, e.getMaxParallelImageRequests = function() {
				return t.c.MAX_PARALLEL_IMAGE_REQUESTS;
			}, e.getRTLTextPluginStatus = function() {
				return ce$1().getRTLTextPluginStatus();
			}, e.getVersion = function() {
				return Is$1;
			}, e.getWorkerCount = function() {
				return k$1.workerCount;
			}, e.getWorkerUrl = function() {
				return t.c.WORKER_URL;
			}, e.importScriptInWorkers = function(e$1) {
				return Z$1().broadcast("IS", e$1);
			}, e.isTimeFrozen = function() {
				return l.isFrozen();
			}, e.now = c, e.prewarm = function() {
				j$1().acquire(L$1);
			}, e.restoreNow = function() {
				l.restoreNow();
			}, e.setMaxParallelImageRequests = function(e$1) {
				t.c.MAX_PARALLEL_IMAGE_REQUESTS = e$1;
			}, e.setNow = function(e$1) {
				l.setNow(e$1);
			}, e.setRTLTextPlugin = function(e$1, t$1) {
				return ce$1().setRTLTextPlugin(e$1, t$1);
			}, e.setWorkerCount = function(e$1) {
				k$1.workerCount = e$1;
			}, e.setWorkerUrl = function(e$1) {
				t.c.WORKER_URL = e$1;
			};
		}));
		return maplibregl;
	}));
}) });

//#endregion
//#region node_modules/js-base64/base64.mjs
var import_maplibre_gl = /* @__PURE__ */ __toESM(require_maplibre_gl(), 1);
/**
*  base64.ts
*
*  Licensed under the BSD 3-Clause License.
*    http://opensource.org/licenses/BSD-3-Clause
*
*  References:
*    http://en.wikipedia.org/wiki/Base64
*
* @author Dan Kogai (https://github.com/dankogai)
*/
var version = "3.7.8";
/**
* @deprecated use lowercase `version`.
*/
var VERSION = version;
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64chs = Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=");
var b64tab = ((a) => {
	let tab = {};
	a.forEach((c, i) => tab[c] = i);
	return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it$1) => new Uint8Array(Array.prototype.slice.call(it$1, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
/**
* polyfill version of `btoa`
*/
var btoaPolyfill = (bin) => {
	let u32, c0, c1, c2, asc = "";
	const pad = bin.length % 3;
	for (let i = 0; i < bin.length;) {
		if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError("invalid character found");
		u32 = c0 << 16 | c1 << 8 | c2;
		asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
	}
	return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
* does what `window.btoa` of web browsers do.
* @param {String} bin binary string
* @returns {string} Base64-encoded string
*/
var _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
	const maxargs = 4096;
	let strs = [];
	for (let i = 0, l = u8a.length; i < l; i += maxargs) strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
	return _btoa(strs.join(""));
};
/**
* converts a Uint8Array to a Base64 string.
* @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 5
* @returns {string} Base64 string
*/
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
	if (c.length < 2) {
		var cc$1 = c.charCodeAt(0);
		return cc$1 < 128 ? c : cc$1 < 2048 ? _fromCC(192 | cc$1 >>> 6) + _fromCC(128 | cc$1 & 63) : _fromCC(224 | cc$1 >>> 12 & 15) + _fromCC(128 | cc$1 >>> 6 & 63) + _fromCC(128 | cc$1 & 63);
	} else {
		var cc$1 = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
		return _fromCC(240 | cc$1 >>> 18 & 7) + _fromCC(128 | cc$1 >>> 12 & 63) + _fromCC(128 | cc$1 >>> 6 & 63) + _fromCC(128 | cc$1 & 63);
	}
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
* @deprecated should have been internal use only.
* @param {string} src UTF-8 string
* @returns {string} UTF-16 string
*/
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
/**
* converts a UTF-8-encoded string to a Base64 string.
* @param {boolean} [urlsafe] if `true` make the result URL-safe
* @returns {string} Base64 string
*/
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
/**
* converts a UTF-8-encoded string to URL-safe Base64 RFC4648 5.
* @returns {string} Base64 string
*/
var encodeURI = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
	switch (cccc.length) {
		case 4:
			var offset = ((7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3)) - 65536;
			return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
		case 3: return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
		default: return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
	}
};
/**
* @deprecated should have been internal use only.
* @param {string} src UTF-16 string
* @returns {string} UTF-8 string
*/
var btou = (b) => b.replace(re_btou, cb_btou);
/**
* polyfill version of `atob`
*/
var atobPolyfill = (asc) => {
	asc = asc.replace(/\s+/g, "");
	if (!b64re.test(asc)) throw new TypeError("malformed base64.");
	asc += "==".slice(2 - (asc.length & 3));
	let u24, r1, r2;
	let binArray = [];
	for (let i = 0; i < asc.length;) {
		u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
		if (r1 === 64) binArray.push(_fromCC(u24 >> 16 & 255));
		else if (r2 === 64) binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
		else binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
	}
	return binArray.join("");
};
/**
* does what `window.atob` of web browsers do.
* @param {String} asc Base64-encoded string
* @returns {string} binary string
*/
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
/**
* converts a Base64 string to a Uint8Array.
*/
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
/**
* converts a Base64 string to a UTF-8 string.
* @param {String} src Base64 string.  Both normal and URL-safe are supported
* @returns {string} UTF-8 string
*/
var decode = (src) => _decode(_unURI(src));
/**
* check if a value is a valid Base64 string
* @param {String} src a value to check
*/
var isValid = (src) => {
	if (typeof src !== "string") return false;
	const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
	return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
	return {
		value: v,
		enumerable: false,
		writable: true,
		configurable: true
	};
};
/**
* extend String.prototype with relevant methods
*/
var extendString = function() {
	const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
	_add("fromBase64", function() {
		return decode(this);
	});
	_add("toBase64", function(urlsafe) {
		return encode(this, urlsafe);
	});
	_add("toBase64URI", function() {
		return encode(this, true);
	});
	_add("toBase64URL", function() {
		return encode(this, true);
	});
	_add("toUint8Array", function() {
		return toUint8Array(this);
	});
};
/**
* extend Uint8Array.prototype with relevant methods
*/
var extendUint8Array = function() {
	const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
	_add("toBase64", function(urlsafe) {
		return fromUint8Array(this, urlsafe);
	});
	_add("toBase64URI", function() {
		return fromUint8Array(this, true);
	});
	_add("toBase64URL", function() {
		return fromUint8Array(this, true);
	});
};
/**
* extend Builtin prototypes with relevant methods
*/
var extendBuiltins = () => {
	extendString();
	extendUint8Array();
};
var gBase64 = {
	version,
	VERSION,
	atob: _atob,
	atobPolyfill,
	btoa: _btoa,
	btoaPolyfill,
	fromBase64: decode,
	toBase64: encode,
	encode,
	encodeURI,
	encodeURL: encodeURI,
	utob,
	btou,
	decode,
	isValid,
	fromUint8Array,
	toUint8Array,
	extendString,
	extendUint8Array,
	extendBuiltins
};

//#endregion
//#region node_modules/events/events.js
var require_events = /* @__PURE__ */ __commonJS({ "node_modules/events/events.js": ((exports, module) => {
	var R$1 = typeof Reflect === "object" ? Reflect : null;
	var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply$1(target, receiver, args) {
		return Function.prototype.apply.call(target, receiver, args);
	};
	var ReflectOwnKeys;
	if (R$1 && typeof R$1.ownKeys === "function") ReflectOwnKeys = R$1.ownKeys;
	else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
	};
	else ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target);
	};
	function ProcessEmitWarning(warning) {
		if (console && console.warn) console.warn(warning);
	}
	var NumberIsNaN = Number.isNaN || function NumberIsNaN$1(value) {
		return value !== value;
	};
	function EventEmitter() {
		EventEmitter.init.call(this);
	}
	module.exports = EventEmitter;
	module.exports.once = once;
	EventEmitter.EventEmitter = EventEmitter;
	EventEmitter.prototype._events = void 0;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = void 0;
	var defaultMaxListeners = 10;
	function checkListener(listener) {
		if (typeof listener !== "function") throw new TypeError("The \"listener\" argument must be of type Function. Received type " + typeof listener);
	}
	Object.defineProperty(EventEmitter, "defaultMaxListeners", {
		enumerable: true,
		get: function() {
			return defaultMaxListeners;
		},
		set: function(arg) {
			if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError("The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received " + arg + ".");
			defaultMaxListeners = arg;
		}
	});
	EventEmitter.init = function() {
		if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
			this._events = Object.create(null);
			this._eventsCount = 0;
		}
		this._maxListeners = this._maxListeners || void 0;
	};
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
		if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError("The value of \"n\" is out of range. It must be a non-negative number. Received " + n + ".");
		this._maxListeners = n;
		return this;
	};
	function _getMaxListeners(that) {
		if (that._maxListeners === void 0) return EventEmitter.defaultMaxListeners;
		return that._maxListeners;
	}
	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
		return _getMaxListeners(this);
	};
	EventEmitter.prototype.emit = function emit(type) {
		var args = [];
		for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
		var doError = type === "error";
		var events = this._events;
		if (events !== void 0) doError = doError && events.error === void 0;
		else if (!doError) return false;
		if (doError) {
			var er$1;
			if (args.length > 0) er$1 = args[0];
			if (er$1 instanceof Error) throw er$1;
			var err = /* @__PURE__ */ new Error("Unhandled error." + (er$1 ? " (" + er$1.message + ")" : ""));
			err.context = er$1;
			throw err;
		}
		var handler = events[type];
		if (handler === void 0) return false;
		if (typeof handler === "function") ReflectApply(handler, this, args);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
		}
		return true;
	};
	function _addListener(target, type, listener, prepend) {
		var m;
		var events;
		var existing;
		checkListener(listener);
		events = target._events;
		if (events === void 0) {
			events = target._events = Object.create(null);
			target._eventsCount = 0;
		} else {
			if (events.newListener !== void 0) {
				target.emit("newListener", type, listener.listener ? listener.listener : listener);
				events = target._events;
			}
			existing = events[type];
		}
		if (existing === void 0) {
			existing = events[type] = listener;
			++target._eventsCount;
		} else {
			if (typeof existing === "function") existing = events[type] = prepend ? [listener, existing] : [existing, listener];
			else if (prepend) existing.unshift(listener);
			else existing.push(listener);
			m = _getMaxListeners(target);
			if (m > 0 && existing.length > m && !existing.warned) {
				existing.warned = true;
				var w$1 = /* @__PURE__ */ new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
				w$1.name = "MaxListenersExceededWarning";
				w$1.emitter = target;
				w$1.type = type;
				w$1.count = existing.length;
				ProcessEmitWarning(w$1);
			}
		}
		return target;
	}
	EventEmitter.prototype.addListener = function addListener(type, listener) {
		return _addListener(this, type, listener, false);
	};
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	EventEmitter.prototype.prependListener = function prependListener(type, listener) {
		return _addListener(this, type, listener, true);
	};
	function onceWrapper() {
		if (!this.fired) {
			this.target.removeListener(this.type, this.wrapFn);
			this.fired = true;
			if (arguments.length === 0) return this.listener.call(this.target);
			return this.listener.apply(this.target, arguments);
		}
	}
	function _onceWrap(target, type, listener) {
		var state = {
			fired: false,
			wrapFn: void 0,
			target,
			type,
			listener
		};
		var wrapped = onceWrapper.bind(state);
		wrapped.listener = listener;
		state.wrapFn = wrapped;
		return wrapped;
	}
	EventEmitter.prototype.once = function once$1(type, listener) {
		checkListener(listener);
		this.on(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
		checkListener(listener);
		this.prependListener(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter.prototype.removeListener = function removeListener(type, listener) {
		var list, events, position, i, originalListener;
		checkListener(listener);
		events = this._events;
		if (events === void 0) return this;
		list = events[type];
		if (list === void 0) return this;
		if (list === listener || list.listener === listener) if (--this._eventsCount === 0) this._events = Object.create(null);
		else {
			delete events[type];
			if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
		}
		else if (typeof list !== "function") {
			position = -1;
			for (i = list.length - 1; i >= 0; i--) if (list[i] === listener || list[i].listener === listener) {
				originalListener = list[i].listener;
				position = i;
				break;
			}
			if (position < 0) return this;
			if (position === 0) list.shift();
			else spliceOne(list, position);
			if (list.length === 1) events[type] = list[0];
			if (events.removeListener !== void 0) this.emit("removeListener", type, originalListener || listener);
		}
		return this;
	};
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
		var listeners, events = this._events, i;
		if (events === void 0) return this;
		if (events.removeListener === void 0) {
			if (arguments.length === 0) {
				this._events = Object.create(null);
				this._eventsCount = 0;
			} else if (events[type] !== void 0) if (--this._eventsCount === 0) this._events = Object.create(null);
			else delete events[type];
			return this;
		}
		if (arguments.length === 0) {
			var keys = Object.keys(events);
			var key;
			for (i = 0; i < keys.length; ++i) {
				key = keys[i];
				if (key === "removeListener") continue;
				this.removeAllListeners(key);
			}
			this.removeAllListeners("removeListener");
			this._events = Object.create(null);
			this._eventsCount = 0;
			return this;
		}
		listeners = events[type];
		if (typeof listeners === "function") this.removeListener(type, listeners);
		else if (listeners !== void 0) for (i = listeners.length - 1; i >= 0; i--) this.removeListener(type, listeners[i]);
		return this;
	};
	function _listeners(target, type, unwrap) {
		var events = target._events;
		if (events === void 0) return [];
		var evlistener = events[type];
		if (evlistener === void 0) return [];
		if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
		return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}
	EventEmitter.prototype.listeners = function listeners(type) {
		return _listeners(this, type, true);
	};
	EventEmitter.prototype.rawListeners = function rawListeners(type) {
		return _listeners(this, type, false);
	};
	EventEmitter.listenerCount = function(emitter, type) {
		if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
		else return listenerCount.call(emitter, type);
	};
	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
		var events = this._events;
		if (events !== void 0) {
			var evlistener = events[type];
			if (typeof evlistener === "function") return 1;
			else if (evlistener !== void 0) return evlistener.length;
		}
		return 0;
	}
	EventEmitter.prototype.eventNames = function eventNames() {
		return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};
	function arrayClone(arr, n) {
		var copy = new Array(n);
		for (var i = 0; i < n; ++i) copy[i] = arr[i];
		return copy;
	}
	function spliceOne(list, index) {
		for (; index + 1 < list.length; index++) list[index] = list[index + 1];
		list.pop();
	}
	function unwrapListeners(arr) {
		var ret = new Array(arr.length);
		for (var i = 0; i < ret.length; ++i) ret[i] = arr[i].listener || arr[i];
		return ret;
	}
	function once(emitter, name) {
		return new Promise(function(resolve, reject) {
			function errorListener(err) {
				emitter.removeListener(name, resolver);
				reject(err);
			}
			function resolver() {
				if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
				resolve([].slice.call(arguments));
			}
			eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
			if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
		});
	}
	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
		if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
	}
	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
		if (typeof emitter.on === "function") if (flags.once) emitter.once(name, listener);
		else emitter.on(name, listener);
		else if (typeof emitter.addEventListener === "function") emitter.addEventListener(name, function wrapListener(arg) {
			if (flags.once) emitter.removeEventListener(name, wrapListener);
			listener(arg);
		});
		else throw new TypeError("The \"emitter\" argument must be of type EventEmitter. Received type " + typeof emitter);
	}
}) });

//#endregion
//#region node_modules/quick-lru/index.js
var import_events = /* @__PURE__ */ __toESM(require_events(), 1);
var QuickLRU = class extends Map {
	#size = 0;
	#cache = /* @__PURE__ */ new Map();
	#oldCache = /* @__PURE__ */ new Map();
	#maxSize;
	#maxAge;
	#onEviction;
	constructor(options = {}) {
		super();
		if (!(options.maxSize && options.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		if (typeof options.maxAge === "number" && options.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
		this.#maxSize = options.maxSize;
		this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
		this.#onEviction = options.onEviction;
	}
	get __oldCache() {
		return this.#oldCache;
	}
	#emitEvictions(cache) {
		if (typeof this.#onEviction !== "function") return;
		for (const [key, item] of cache) this.#onEviction(key, item.value);
	}
	#deleteIfExpired(key, item) {
		if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
			if (typeof this.#onEviction === "function") this.#onEviction(key, item.value);
			return this.delete(key);
		}
		return false;
	}
	#getOrDeleteIfExpired(key, item) {
		if (this.#deleteIfExpired(key, item) === false) return item.value;
	}
	#getItemValue(key, item) {
		return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
	}
	#peek(key, cache) {
		const item = cache.get(key);
		return this.#getItemValue(key, item);
	}
	#set(key, value) {
		this.#cache.set(key, value);
		this.#size++;
		if (this.#size >= this.#maxSize) {
			this.#size = 0;
			this.#emitEvictions(this.#oldCache);
			this.#oldCache = this.#cache;
			this.#cache = /* @__PURE__ */ new Map();
		}
	}
	#moveToRecent(key, item) {
		this.#oldCache.delete(key);
		this.#set(key, item);
	}
	*#entriesAscending() {
		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield item;
			}
		}
		for (const item of this.#cache) {
			const [key, value] = item;
			if (this.#deleteIfExpired(key, value) === false) yield item;
		}
	}
	get(key) {
		if (this.#cache.has(key)) {
			const item = this.#cache.get(key);
			return this.#getItemValue(key, item);
		}
		if (this.#oldCache.has(key)) {
			const item = this.#oldCache.get(key);
			if (this.#deleteIfExpired(key, item) === false) {
				this.#moveToRecent(key, item);
				return item.value;
			}
		}
	}
	set(key, value, { maxAge = this.#maxAge } = {}) {
		const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
		if (this.#cache.has(key)) this.#cache.set(key, {
			value,
			expiry
		});
		else this.#set(key, {
			value,
			expiry
		});
		return this;
	}
	has(key) {
		if (this.#cache.has(key)) return !this.#deleteIfExpired(key, this.#cache.get(key));
		if (this.#oldCache.has(key)) return !this.#deleteIfExpired(key, this.#oldCache.get(key));
		return false;
	}
	peek(key) {
		if (this.#cache.has(key)) return this.#peek(key, this.#cache);
		if (this.#oldCache.has(key)) return this.#peek(key, this.#oldCache);
	}
	expiresIn(key) {
		const item = this.#cache.get(key) ?? this.#oldCache.get(key);
		if (item) return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
	}
	delete(key) {
		const deleted = this.#cache.delete(key);
		if (deleted) this.#size--;
		return this.#oldCache.delete(key) || deleted;
	}
	clear() {
		this.#cache.clear();
		this.#oldCache.clear();
		this.#size = 0;
	}
	resize(newSize) {
		if (!(newSize && newSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		const items = [...this.#entriesAscending()];
		const removeCount = items.length - newSize;
		if (removeCount < 0) {
			this.#cache = new Map(items);
			this.#oldCache = /* @__PURE__ */ new Map();
			this.#size = items.length;
		} else {
			if (removeCount > 0) this.#emitEvictions(items.slice(0, removeCount));
			this.#oldCache = new Map(items.slice(removeCount));
			this.#cache = /* @__PURE__ */ new Map();
			this.#size = 0;
		}
		this.#maxSize = newSize;
	}
	evict(count = 1) {
		const requested = Number(count);
		if (!requested || requested <= 0) return;
		const items = [...this.#entriesAscending()];
		const evictCount = Math.trunc(Math.min(requested, Math.max(items.length - 1, 0)));
		if (evictCount <= 0) return;
		this.#emitEvictions(items.slice(0, evictCount));
		this.#oldCache = new Map(items.slice(evictCount));
		this.#cache = /* @__PURE__ */ new Map();
		this.#size = 0;
	}
	*keys() {
		for (const [key] of this) yield key;
	}
	*values() {
		for (const [, value] of this) yield value;
	}
	*[Symbol.iterator]() {
		for (const item of this.#cache) {
			const [key, value] = item;
			if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesDescending() {
		let items = [...this.#cache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		items = [...this.#oldCache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesAscending() {
		for (const [key, value] of this.#entriesAscending()) yield [key, value.value];
	}
	get size() {
		if (!this.#size) return this.#oldCache.size;
		let oldCacheSize = 0;
		for (const key of this.#oldCache.keys()) if (!this.#cache.has(key)) oldCacheSize++;
		return Math.min(this.#size + oldCacheSize, this.#maxSize);
	}
	get maxSize() {
		return this.#maxSize;
	}
	get maxAge() {
		return this.#maxAge;
	}
	entries() {
		return this.entriesAscending();
	}
	forEach(callbackFunction, thisArgument = this) {
		for (const [key, value] of this.entriesAscending()) callbackFunction.call(thisArgument, value, key, this);
	}
	get [Symbol.toStringTag]() {
		return "QuickLRU";
	}
	toString() {
		return `QuickLRU(${this.size}/${this.maxSize})`;
	}
	[Symbol.for("nodejs.util.inspect.custom")]() {
		return this.toString();
	}
};

//#endregion
//#region node_modules/@maptiler/client/dist/maptiler-client.mjs
function tryGettingFetch() {
	if (typeof self !== "undefined") return fetch.bind(self);
	if (typeof global !== "undefined" && global.fetch) return global.fetch;
	return null;
}
var ClientConfig = class {
	constructor() {
		/**
		* MapTiler Cloud API key
		*/
		this._apiKey = "";
		/**
		* The fetch function. To be set if in Node < 18, otherwise
		* will be automatically resolved.
		*/
		this._fetch = tryGettingFetch();
		/**
		* Number of tiles to keep in cache
		*/
		this.tileCacheSize = 200;
	}
	/**
	* Set the MapTiler Cloud API key
	*/
	set apiKey(k$1) {
		this._apiKey = k$1;
	}
	/**
	* Get the MapTiler Cloud API key
	*/
	get apiKey() {
		return this._apiKey;
	}
	/**
	* Set a the custom fetch function to replace the default one
	*/
	set fetch(f) {
		this._fetch = f;
	}
	/**
	* Get the fetch fucntion
	*/
	get fetch() {
		return this._fetch;
	}
};
var config = new ClientConfig();
var NonISOLanguage = {
	AUTO: {
		code: null,
		flag: "auto",
		name: "Auto",
		latin: false,
		isMode: true,
		geocoding: true
	},
	LATIN: {
		code: "latin",
		flag: "name:latin",
		name: "Latin",
		latin: true,
		isMode: false,
		geocoding: false
	},
	NON_LATIN: {
		code: "nonlatin",
		flag: "name:nonlatin",
		name: "Non Latin",
		latin: false,
		isMode: false,
		geocoding: false
	},
	LOCAL: {
		code: null,
		flag: "name",
		name: "Local",
		latin: true,
		isMode: false,
		geocoding: false
	}
};
var ISOLanguage = {
	ALBANIAN: {
		code: "sq",
		flag: "name:sq",
		name: "Albanian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	AMHARIC: {
		code: "am",
		flag: "name:am",
		name: "Amharic",
		latin: false,
		isMode: false,
		geocoding: true
	},
	ARABIC: {
		code: "ar",
		flag: "name:ar",
		name: "Arabic",
		latin: false,
		isMode: false,
		geocoding: true
	},
	ARMENIAN: {
		code: "hy",
		flag: "name:hy",
		name: "Armenian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	AZERBAIJANI: {
		code: "az",
		flag: "name:az",
		name: "Azerbaijani",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BASQUE: {
		code: "eu",
		flag: "name:eu",
		name: "Basque",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BELARUSIAN: {
		code: "be",
		flag: "name:be",
		name: "Belarusian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	BENGALI: {
		code: "bn",
		flag: "name:bn",
		name: "Bengali",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BOSNIAN: {
		code: "bs",
		flag: "name:bs",
		name: "Bosnian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BRETON: {
		code: "br",
		flag: "name:br",
		name: "Breton",
		latin: true,
		isMode: false,
		geocoding: true
	},
	BULGARIAN: {
		code: "bg",
		flag: "bg",
		name: "Bulgarian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	CATALAN: {
		code: "ca",
		flag: "name:ca",
		name: "Catalan",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CHINESE: {
		code: "zh",
		flag: "name:zh",
		name: "Chinese",
		latin: false,
		isMode: false,
		geocoding: true
	},
	TRADITIONAL_CHINESE: {
		code: "zh-Hant",
		flag: "name:zh-Hant",
		name: "Chinese (traditional)",
		latin: false,
		isMode: false,
		geocoding: false
	},
	SIMPLIFIED_CHINESE: {
		code: "zh-Hans",
		flag: "name:zh-Hans",
		name: "Chinese (simplified)",
		latin: false,
		isMode: false,
		geocoding: false
	},
	CORSICAN: {
		code: "co",
		flag: "name:co",
		name: "Corsican",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CROATIAN: {
		code: "hr",
		flag: "name:hr",
		name: "Croatian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CZECH: {
		code: "cs",
		flag: "name:cs",
		name: "Czech",
		latin: true,
		isMode: false,
		geocoding: true
	},
	DANISH: {
		code: "da",
		flag: "name:da",
		name: "Danish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	DUTCH: {
		code: "nl",
		flag: "name:nl",
		name: "Dutch",
		latin: true,
		isMode: false,
		geocoding: true
	},
	GERMAN: {
		code: "de",
		flag: "name:de",
		name: "German",
		latin: true,
		isMode: false,
		geocoding: true
	},
	GREEK: {
		code: "el",
		flag: "name:el",
		name: "Greek",
		latin: false,
		isMode: false,
		geocoding: true
	},
	ENGLISH: {
		code: "en",
		flag: "name:en",
		name: "English",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ESPERANTO: {
		code: "eo",
		flag: "name:eo",
		name: "Esperanto",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ESTONIAN: {
		code: "et",
		flag: "name:et",
		name: "Estonian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	FINNISH: {
		code: "fi",
		flag: "name:fi",
		name: "Finnish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	FRENCH: {
		code: "fr",
		flag: "name:fr",
		name: "French",
		latin: true,
		isMode: false,
		geocoding: true
	},
	FRISIAN: {
		code: "fy",
		flag: "name:fy",
		name: "Frisian (West)",
		latin: true,
		isMode: false,
		geocoding: true
	},
	GEORGIAN: {
		code: "ka",
		flag: "name:ka",
		name: "Georgian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	HEBREW: {
		code: "he",
		flag: "name:he",
		name: "Hebrew",
		latin: false,
		isMode: false,
		geocoding: true
	},
	HINDI: {
		code: "hi",
		flag: "name:hi",
		name: "Hindi",
		latin: false,
		isMode: false,
		geocoding: true
	},
	HUNGARIAN: {
		code: "hu",
		flag: "name:hu",
		name: "Hungarian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ICELANDIC: {
		code: "is",
		flag: "name:is",
		name: "Icelandic",
		latin: true,
		isMode: false,
		geocoding: true
	},
	INDONESIAN: {
		code: "id",
		flag: "name:id",
		name: "Indonesian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	IRISH: {
		code: "ga",
		flag: "name:ga",
		name: "Irish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ITALIAN: {
		code: "it",
		flag: "name:it",
		name: "Italian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	JAPANESE: {
		code: "ja",
		flag: "name:ja",
		name: "Japanese",
		latin: false,
		isMode: false,
		geocoding: true
	},
	JAPANESE_HIRAGANA: {
		code: "ja-Hira",
		flag: "name:ja-Hira",
		name: "Japanese Hiragana form",
		latin: false,
		isMode: false,
		geocoding: false
	},
	JAPANESE_2018: {
		code: "ja-Latn",
		flag: "name:ja-Latn",
		name: "Japanese (Latin 2018)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	JAPANESE_KANA: {
		code: "ja_kana",
		flag: "name:ja_kana",
		name: "Japanese (Kana)",
		latin: false,
		isMode: false,
		geocoding: false
	},
	JAPANESE_LATIN: {
		code: "ja_rm",
		flag: "name:ja_rm",
		name: "Japanese (Latin script)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	KANNADA: {
		code: "kn",
		flag: "name:kn",
		name: "Kannada",
		latin: true,
		isMode: false,
		geocoding: true
	},
	KAZAKH: {
		code: "kk",
		flag: "name:kk",
		name: "Kazakh",
		latin: false,
		isMode: false,
		geocoding: true
	},
	KOREAN: {
		code: "ko",
		flag: "name:ko",
		name: "Korean",
		latin: false,
		isMode: false,
		geocoding: true
	},
	KOREAN_LATIN: {
		code: "ko-Latn",
		flag: "name:ko-Latn",
		name: "Korean (Latin script)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	KURDISH: {
		code: "ku",
		flag: "name:ku",
		name: "Kurdish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	CLASSICAL_LATIN: {
		code: "la",
		flag: "name:la",
		name: "Latin",
		latin: true,
		isMode: false,
		geocoding: true
	},
	LATVIAN: {
		code: "lv",
		flag: "name:lv",
		name: "Latvian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	LITHUANIAN: {
		code: "lt",
		flag: "name:lt",
		name: "Lithuanian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	LUXEMBOURGISH: {
		code: "lb",
		flag: "name:lb",
		name: "Luxembourgish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	MACEDONIAN: {
		code: "mk",
		flag: "name:mk",
		name: "Macedonian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	MALAYALAM: {
		code: "ml",
		flag: "name:ml",
		name: "Malayalam",
		latin: false,
		isMode: false,
		geocoding: true
	},
	MALTESE: {
		code: "mt",
		flag: "name:mt",
		name: "Maltese",
		latin: true,
		isMode: false,
		geocoding: true
	},
	NORWEGIAN: {
		code: "no",
		flag: "name:no",
		name: "Norwegian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	OCCITAN: {
		code: "oc",
		flag: "name:oc",
		name: "Occitan",
		latin: true,
		isMode: false,
		geocoding: true
	},
	PERSIAN: {
		code: "fa",
		flag: "name:fa",
		name: "Persian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	POLISH: {
		code: "pl",
		flag: "name:pl",
		name: "Polish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	PORTUGUESE: {
		code: "pt",
		flag: "name:pt",
		name: "Portuguese",
		latin: true,
		isMode: false,
		geocoding: true
	},
	PUNJABI: {
		code: "pa",
		flag: "name:pa",
		name: "Punjabi",
		latin: false,
		isMode: false,
		geocoding: true
	},
	WESTERN_PUNJABI: {
		code: "pnb",
		flag: "name:pnb",
		name: "Western Punjabi",
		latin: false,
		isMode: false,
		geocoding: false
	},
	ROMANIAN: {
		code: "ro",
		flag: "name:ro",
		name: "Romanian",
		latin: true,
		isMode: false,
		geocoding: true
	},
	ROMANSH: {
		code: "rm",
		flag: "name:rm",
		name: "Romansh",
		latin: true,
		isMode: false,
		geocoding: true
	},
	RUSSIAN: {
		code: "ru",
		flag: "name:ru",
		name: "Russian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	SERBIAN_CYRILLIC: {
		code: "sr",
		flag: "name:sr",
		name: "Serbian (Cyrillic script)",
		latin: false,
		isMode: false,
		geocoding: true
	},
	SERBIAN_LATIN: {
		code: "sr-Latn",
		flag: "name:sr-Latn",
		name: "Serbian (Latin script)",
		latin: true,
		isMode: false,
		geocoding: false
	},
	SCOTTISH_GAELIC: {
		code: "gd",
		flag: "name:gd",
		name: "Scottish Gaelic",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SLOVAK: {
		code: "sk",
		flag: "name:sk",
		name: "Slovak",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SLOVENE: {
		code: "sl",
		flag: "name:sl",
		name: "Slovene",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SPANISH: {
		code: "es",
		flag: "name:es",
		name: "Spanish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	SWEDISH: {
		code: "sv",
		flag: "name:sv",
		name: "Swedish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	TAMIL: {
		code: "ta",
		flag: "name:ta",
		name: "Tamil",
		latin: false,
		isMode: false,
		geocoding: true
	},
	TELUGU: {
		code: "te",
		flag: "name:te",
		name: "Telugu",
		latin: false,
		isMode: false,
		geocoding: true
	},
	THAI: {
		code: "th",
		flag: "name:th",
		name: "Thai",
		latin: false,
		isMode: false,
		geocoding: true
	},
	TURKISH: {
		code: "tr",
		flag: "name:tr",
		name: "Turkish",
		latin: true,
		isMode: false,
		geocoding: true
	},
	UKRAINIAN: {
		code: "uk",
		flag: "name:uk",
		name: "Ukrainian",
		latin: false,
		isMode: false,
		geocoding: true
	},
	VIETNAMESE: {
		code: "vi",
		flag: "name:vi",
		name: "Vietnamese (Latin script)",
		latin: true,
		isMode: false,
		geocoding: true
	},
	WELSH: {
		code: "cy",
		flag: "name:cy",
		name: "Welsh",
		latin: true,
		isMode: false,
		geocoding: true
	}
};
var Language = {
	...NonISOLanguage,
	...ISOLanguage
};
function getLanguageInfoFromKey(languageKey, languageDictionary = Language) {
	if (languageKey in languageDictionary) return languageKey[languageKey];
	return null;
}
function getLanguageInfoFromCode(languageCode, languageDictionary = Language) {
	for (const lang of Object.values(languageDictionary)) if (lang.code === languageCode) return lang;
	return null;
}
function getLanguageInfoFromFlag(languageFlag, languageDictionary = Language) {
	for (const lang of Object.values(languageDictionary)) if (lang.flag === languageFlag) return lang;
	return null;
}
function getAutoLanguage() {
	if (typeof navigator === "undefined") {
		const code = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
		return getLanguageInfoFromCode(code) ?? Language.ENGLISH;
	}
	return Array.from(new Set(navigator.languages.map((l) => l.split("-")[0]))).map((code) => getLanguageInfoFromCode(code)).filter((li) => li)[0] ?? Language.ENGLISH;
}
function isLanguageInfo(obj) {
	return obj !== null && typeof obj === "object" && "code" in obj && "flag" in obj && "name" in obj && "latin" in obj && "isMode" in obj && "geocoding" in obj && (typeof obj.code === "string" || obj.code === null) && typeof obj.flag === "string" && typeof obj.name === "string" && typeof obj.latin === "boolean" && typeof obj.isMode === "boolean" && typeof obj.geocoding === "boolean";
}
function toLanguageInfo(lang, languageDictionary = Language) {
	if (isLanguageInfo(lang)) return getLanguageInfoFromFlag(lang.flag, languageDictionary);
	if (typeof lang !== "string") return null;
	return getLanguageInfoFromKey(lang, languageDictionary) || getLanguageInfoFromCode(lang, languageDictionary) || getLanguageInfoFromFlag(lang, languageDictionary) || null;
}
function areSameLanguages(langA, langB, languageDictionary = Language) {
	const langAObj = toLanguageInfo(langA, languageDictionary);
	const langBObj = toLanguageInfo(langB, languageDictionary);
	return langAObj && langBObj && langAObj.flag === langBObj.flag;
}
async function callFetch(resource, options = {}) {
	if (config.fetch === null) throw new Error("The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch");
	if (new URL(resource).searchParams.get("key").trim() === "") throw new Error("The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com");
	return config.fetch(resource, options);
}
var defaults = {
	maptilerApiURL: "https://api.maptiler.com/",
	mapStyle: "streets-v2"
};
Object.freeze(defaults);
var ServiceError = class extends Error {
	constructor(res, customMessage = "") {
		super(`Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`);
		this.res = res;
	}
};
var customMessages$4 = {
	400: "Query too long / Invalid parameters",
	403: "Key is missing, invalid or restricted"
};
function addLanguageGeocodingOptions(searchParams, options) {
	const { language } = options;
	if (language === void 0) return;
	const languageCodes = (Array.isArray(language) ? language : [language]).map((elem) => toValidGeocodingLanguageCode(elem)).filter((elem) => elem);
	const languages = Array.from(new Set(languageCodes)).join(",");
	searchParams.set("language", languages);
}
function toValidGeocodingLanguageCode(lang) {
	const langInfo = lang === Language.AUTO.flag ? getAutoLanguage() : typeof lang === "string" ? getLanguageInfoFromCode(lang) : isLanguageInfo(lang) ? lang.flag === Language.AUTO.flag ? getAutoLanguage() : getLanguageInfoFromFlag(lang.flag) : null;
	return langInfo?.geocoding ? langInfo.code : null;
}
function addCommonForwardAndReverseGeocodingOptions(searchParams, options) {
	const { apiKey, limit, types, excludeTypes } = options;
	searchParams.set("key", apiKey ?? config.apiKey);
	if (limit !== void 0) searchParams.set("limit", String(limit));
	if (types !== void 0) searchParams.set("types", types.join(","));
	if (excludeTypes !== void 0) searchParams.set("excludeTypes", String(excludeTypes));
	addLanguageGeocodingOptions(searchParams, options);
}
function addForwardGeocodingOptions(searchParams, options) {
	addCommonForwardAndReverseGeocodingOptions(searchParams, options);
	const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;
	if (bbox !== void 0) searchParams.set("bbox", bbox.join(","));
	if (proximity !== void 0) searchParams.set("proximity", proximity === "ip" ? proximity : proximity.join(","));
	if (country !== void 0) searchParams.set("country", country.join(","));
	if (fuzzyMatch !== void 0) searchParams.set("fuzzyMatch", fuzzyMatch ? "true" : "false");
	if (autocomplete !== void 0) searchParams.set("autocomplete", autocomplete ? "true" : "false");
}
async function forward(query, options = {}) {
	if (typeof query !== "string" || query.trim().length === 0) throw new Error("The query must be a non-empty string");
	const endpoint = new URL(`geocoding/${encodeURIComponent(query)}.json`, defaults.maptilerApiURL);
	addForwardGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	return await res.json();
}
async function reverse(position, options = {}) {
	if (!Array.isArray(position) || position.length < 2) throw new Error("The position must be an array of form [lng, lat].");
	const endpoint = new URL(`geocoding/${position[0]},${position[1]}.json`, defaults.maptilerApiURL);
	addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	return await res.json();
}
async function byId(id, options = {}) {
	const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	addLanguageGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	return await res.json();
}
async function batch$1(queries, options = {}) {
	if (!queries.length) return [];
	const joinedQuery = queries.map((query) => encodeURIComponent(query)).join(";");
	const endpoint = new URL(`geocoding/${joinedQuery}.json`, defaults.maptilerApiURL);
	addForwardGeocodingOptions(endpoint.searchParams, options);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, customMessages$4[res.status] ?? "");
	const obj = await res.json();
	return queries.length === 1 ? [obj] : obj;
}
var geocoding = {
	forward,
	reverse,
	byId,
	batch: batch$1
};
var customMessages$3 = { 403: "Key is missing, invalid or restricted" };
async function info(options = {}) {
	const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	if ("elevation" in options) endpoint.searchParams.set("elevation", options.elevation ? "true" : "false");
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$3 ? customMessages$3[res.status] : "");
	return await res.json();
}
var geolocation = { info };
var customMessages$2 = { 403: "Key is missing, invalid or restricted" };
async function search(query, options = {}) {
	if (typeof query !== "string" || query.trim().length === 0) throw new Error("The query must be a non-empty string");
	const endpoint = new URL(`coordinates/search/${query}.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	if ("limit" in options) endpoint.searchParams.set("limit", options.limit.toString());
	if ("transformations" in options) endpoint.searchParams.set("transformations", options.transformations.toString());
	if ("exports" in options) endpoint.searchParams.set("exports", options.exports.toString());
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : "");
	return await res.json();
}
async function transform(positions, options = {}) {
	const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map((coord) => `${coord[0]},${coord[1]}`).join(";");
	const endpoint = new URL(`coordinates/transform/${coordinatesStr}.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	if ("sourceCrs" in options) endpoint.searchParams.set("s_srs", options.sourceCrs.toString());
	if ("targetCrs" in options) endpoint.searchParams.set("t_srs", options.targetCrs.toString());
	if ("operations" in options) endpoint.searchParams.set("ops", (Array.isArray(options.operations) ? options.operations : [options.operations]).join("|"));
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : "");
	return await res.json();
}
var coordinates = {
	search,
	transform
};
var customMessages$1 = { 403: "Key is missing, invalid or restricted" };
async function get(dataId, options = {}) {
	if (typeof dataId !== "string" || dataId.trim().length === 0) throw new Error("The data ID must be a non-empty string");
	const endpoint = new URL(`data/${encodeURIComponent(dataId)}/features.json`, defaults.maptilerApiURL);
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	const res = await callFetch(endpoint.toString());
	if (!res.ok) throw new ServiceError(res, res.status in customMessages$1 ? customMessages$1[res.status] : "");
	return await res.json();
}
var data = { get };
function expandMapStyle(style) {
	const maptilerDomainRegex = /^maptiler:\/\/(.*)/;
	let match;
	const trimmed = style.trim();
	let expandedStyle;
	if (trimmed.startsWith("http://") || trimmed.startsWith("https://")) expandedStyle = trimmed;
	else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;
	else expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;
	return expandedStyle;
}
var MapStyleVariant = class {
	constructor(name, variantType, id, referenceStyle, description, imageURL, deprecated = false, deprecationMessage) {
		this.name = name;
		this.variantType = variantType;
		this.id = id;
		this.referenceStyle = referenceStyle;
		this.description = description;
		this.imageURL = imageURL;
		this.deprecated = deprecated;
		this.deprecationMessage = deprecationMessage;
	}
	/**
	* Get the human-friendly name
	* @returns
	*/
	getName() {
		return this.name;
	}
	getFullName() {
		return `${this.referenceStyle.getName()} ${this.name}`;
	}
	/**
	* Get the variant type (eg. "DEFAULT", "DARK", "PASTEL", etc.)
	* @returns
	*/
	getType() {
		return this.variantType;
	}
	/**
	* Get the MapTiler Cloud id
	* @returns
	*/
	getId() {
		return this.id;
	}
	/**
	* Get the human-friendly description
	*/
	getDescription() {
		return this.description;
	}
	/**
	* Get the reference style this variant belongs to
	* @returns
	*/
	getReferenceStyle() {
		return this.referenceStyle;
	}
	/**
	* Check if a variant of a given type exists for _this_ variants
	* (eg. if this is a "DARK", then we can check if there is a "LIGHT" variant of it)
	* @param variantType
	* @returns
	*/
	hasVariant(variantType) {
		return this.referenceStyle.hasVariant(variantType);
	}
	/**
	* Retrieve the variant of a given type. If not found, will return the "DEFAULT" variant.
	* (eg. _this_ "DARK" variant does not have any "PASTEL" variant, then the "DEFAULT" is returned)
	* @param variantType
	* @returns
	*/
	getVariant(variantType) {
		const variant = this.referenceStyle.getVariant(variantType);
		this.warnIfDeprecated(variant);
		return variant;
	}
	/**
	* Get all the variants for _this_ variants, except _this_ current one
	* @returns
	*/
	getVariants() {
		return this.referenceStyle.getVariants().filter((v) => v !== this).map((v) => {
			this.warnIfDeprecated(v);
			return v;
		});
	}
	/**
	* Get the image URL that represent _this_ variant
	* @returns
	*/
	getImageURL() {
		return this.imageURL;
	}
	/**
	* Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)
	* @returns
	*/
	getExpandedStyleURL() {
		return expandMapStyle(this.getId());
	}
	warnIfDeprecated(variant = this) {
		if (!variant.deprecated) return variant;
		if (variant.deprecationMessage) console.warn(variant.deprecationMessage);
		else {
			const name = variant.getFullName();
			console.warn(`Style "${name}" is deprecated and will be removed in a future version.`);
		}
		return variant;
	}
};
var ReferenceMapStyle = class {
	constructor(name, id) {
		this.name = name;
		this.id = id;
		/**
		* Variants that belong to this reference style, key being the reference type
		*/
		this.variants = {};
		/**
		* Variants that belong to this reference style, ordered by relevance
		*/
		this.orderedVariants = [];
	}
	/**
	* Get the human-friendly name of this reference style
	* @returns
	*/
	getName() {
		return this.name;
	}
	/**
	* Get the id of _this_ reference style
	* @returns
	*/
	getId() {
		return this.id;
	}
	/**
	* Add a variant to _this_ reference style
	* @param v
	*/
	addVariant(v) {
		this.variants[v.getType()] = v;
		this.orderedVariants.push(v);
	}
	/**
	* Check if a given variant type exists for this reference style
	* @param variantType
	* @returns
	*/
	hasVariant(variantType) {
		return variantType in this.variants;
	}
	/**
	* Get a given variant. If the given type of variant does not exist for this reference style,
	* then the most relevant default variant is returned instead
	* @param variantType
	* @returns
	*/
	getVariant(variantType) {
		return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];
	}
	/**
	* Get the list of variants for this reference style
	* @returns
	*/
	getVariants() {
		return Object.values(this.variants);
	}
	/**
	* Get the defualt variant for this reference style
	* @returns
	*/
	getDefaultVariant() {
		return this.orderedVariants[0].warnIfDeprecated();
	}
};
var mapStylePresetList = [
	{
		referenceStyleID: "STREETS_V2",
		name: "Streets",
		description: "",
		variants: [
			{
				id: "streets-v2",
				name: "Default v2",
				variantType: "DEFAULT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2" is deprecated, use "streets-v4" instead`
			},
			{
				id: "streets-v2-dark",
				name: "Dark v2",
				variantType: "DARK",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-dark" is deprecated, use "streets-v4-dark" instead`
			},
			{
				id: "streets-v2-light",
				name: "Light v2",
				variantType: "LIGHT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-light" is deprecated, use "streets-v4-light" instead`
			},
			{
				id: "streets-v2-night",
				name: "Night v2",
				variantType: "NIGHT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-night" is deprecated, use "streets-v4-night" instead`
			},
			{
				id: "streets-v2-pastel",
				name: "Pastel v2",
				variantType: "PASTEL",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"streets-v2-pastel" is deprecated, use "streets-v4-pastel" instead`
			}
		]
	},
	{
		referenceStyleID: "STREETS_V4",
		name: "Streets",
		description: "",
		variants: [
			{
				id: "streets-v4",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "streets-v4-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "streets-v4-pastel",
				name: "Pastel",
				variantType: "PASTEL",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "BASE_V4",
		name: "Base",
		description: "",
		variants: [
			{
				id: "base-v4",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "base-v4-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "base-v4-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			},
			{
				id: "base-v4-ai",
				name: "Base AI",
				variantType: "NIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "OUTDOOR",
		name: "Outdoor",
		description: "",
		variants: [{
			id: "outdoor-v2",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}, {
			id: "outdoor-v2-dark",
			name: "Dark",
			variantType: "DARK",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "WINTER",
		name: "Winter",
		description: "",
		variants: [{
			id: "winter-v2",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}, {
			id: "winter-v2-dark",
			name: "Dark",
			variantType: "DARK",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "SATELLITE",
		name: "Satellite",
		description: "",
		variants: [{
			id: "satellite",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "HYBRID",
		name: "Hybrid",
		description: "",
		variants: [{
			id: "hybrid",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "BASIC_V2",
		name: "Basic",
		description: "",
		variants: [
			{
				id: "basic-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"basic-v2" is deprecated, use "basic-v4" instead`
			},
			{
				id: "basic-v2-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "basic-v2-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "BRIGHT",
		name: "Bright",
		description: "",
		variants: [
			{
				id: "bright-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "bright-v2-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "bright-v2-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			},
			{
				id: "bright-v2-pastel",
				name: "Pastel",
				variantType: "PASTEL",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "OPENSTREETMAP",
		name: "OpenStreetMap",
		description: "",
		variants: [{
			id: "openstreetmap",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "TOPO",
		name: "Topo",
		description: "",
		variants: [
			{
				id: "topo-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-shiny",
				name: "Shiny",
				deprecated: true,
				variantType: "SHINY",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-pastel",
				name: "Pastel",
				variantType: "PASTEL",
				description: "",
				imageURL: ""
			},
			{
				id: "topo-v2-topographique",
				name: "Topographique",
				variantType: "TOPOGRAPHIQUE",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "VOYAGER",
		name: "Voyager",
		description: "",
		variants: [
			{
				id: "voyager-v2",
				name: "Default",
				deprecated: true,
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "voyager-v2-darkmatter",
				name: "Darkmatter",
				deprecated: true,
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "voyager-v2-positron",
				name: "Positron",
				deprecated: true,
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			},
			{
				id: "voyager-v2-vintage",
				name: "Vintage",
				deprecated: true,
				variantType: "VINTAGE",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "TONER",
		name: "Toner",
		description: "",
		variants: [
			{
				id: "toner-v2",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "toner-v2-background",
				name: "Background",
				variantType: "BACKGROUND",
				deprecated: true,
				description: "",
				imageURL: ""
			},
			{
				id: "toner-v2-lite",
				name: "Lite",
				variantType: "LITE",
				description: "",
				imageURL: ""
			},
			{
				id: "toner-v2-lines",
				name: "Lines",
				variantType: "LINES",
				deprecated: true,
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "DATAVIZ",
		name: "Dataviz",
		description: "",
		variants: [
			{
				id: "dataviz",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "dataviz-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "dataviz-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "BACKDROP",
		name: "Backdrop",
		description: "",
		variants: [
			{
				id: "backdrop",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "backdrop-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "backdrop-light",
				name: "Light",
				variantType: "LIGHT",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "OCEAN",
		name: "Ocean",
		description: "",
		variants: [{
			id: "ocean",
			name: "Default",
			variantType: "DEFAULT",
			description: "",
			imageURL: ""
		}]
	},
	{
		referenceStyleID: "AQUARELLE",
		name: "Aquarelle",
		description: "Watercolor map for creative use",
		variants: [
			{
				id: "aquarelle",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "aquarelle-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "aquarelle-vivid",
				name: "Vivid",
				variantType: "VIVID",
				description: "",
				imageURL: ""
			}
		]
	},
	{
		referenceStyleID: "LANDSCAPE_V2",
		name: "Landscape",
		description: "Terrain map for data overlays and visualisations",
		variants: [
			{
				id: "landscape",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"landscape" is deprecated, use "landscape-v4" instead`
			},
			{
				id: "landscape-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"landscape-dark" is deprecated, use "landscape-v4-dark" instead`
			},
			{
				id: "landscape-vivid",
				name: "Vivid",
				variantType: "VIVID",
				description: "",
				imageURL: "",
				deprecated: true,
				deprecationMessage: `"landscape-vivid" is deprecated, use "landscape-v4-vivid" instead`
			}
		]
	},
	{
		referenceStyleID: "LANDSCAPE_V4",
		name: "Landscape",
		description: "Terrain map for data overlays and visualisations",
		variants: [
			{
				id: "landscape-v4",
				name: "Default",
				variantType: "DEFAULT",
				description: "",
				imageURL: ""
			},
			{
				id: "landscape-v4-dark",
				name: "Dark",
				variantType: "DARK",
				description: "",
				imageURL: ""
			},
			{
				id: "landscape-v4-vivid",
				name: "Vivid",
				variantType: "VIVID",
				description: "",
				imageURL: ""
			}
		]
	}
];
var defaultReferenceStyleMap = {
	STREETS: "STREETS_V2",
	BASIC: "BASIC_V2",
	LANDSCAPE: "LANDSCAPE_V2"
};
function applyVersionToDefaultReferenceStyle(defaultKey, referenceKey) {
	if (mapStylePresetList.find((style) => style.referenceStyleID === defaultKey)) console.warn(`Default reference style ${defaultKey} already exists, it will be overwritten...`);
	const versionedMapStyle = mapStylePresetList.find((style) => style.referenceStyleID === referenceKey);
	if (!versionedMapStyle) throw new Error(`Versioned map style not found for reference style: ${referenceKey}`);
	const defaultStyle = {
		...versionedMapStyle,
		referenceStyleID: defaultKey
	};
	mapStylePresetList.push(defaultStyle);
}
Object.entries(defaultReferenceStyleMap).forEach(([defaultKey, referenceKey]) => {
	applyVersionToDefaultReferenceStyle(defaultKey, referenceKey);
});
function makeReferenceStyleProxy(referenceStyle) {
	return new Proxy(referenceStyle, { get(target, prop, receiver) {
		if (target.hasVariant(prop)) return target.getVariant(prop);
		if (prop.toString().toUpperCase() === prop) return referenceStyle.getDefaultVariant();
		return Reflect.get(target, prop, receiver);
	} });
}
function buildMapStyles() {
	const mapStyle = {};
	for (let i = 0; i < mapStylePresetList.length; i += 1) {
		const refStyleInfo = mapStylePresetList[i];
		const refStyle = makeReferenceStyleProxy(new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID));
		for (let j$1 = 0; j$1 < refStyleInfo.variants.length; j$1 += 1) {
			const variantInfo = refStyleInfo.variants[j$1];
			const variant = new MapStyleVariant(variantInfo.name, variantInfo.variantType, variantInfo.id, refStyle, variantInfo.description, variantInfo.imageURL, variantInfo.deprecated);
			refStyle.addVariant(variant);
		}
		mapStyle[refStyleInfo.referenceStyleID] = refStyle;
	}
	return mapStyle;
}
function styleToStyle(style) {
	if (!style) return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();
	if (typeof style === "string" || style instanceof String) return style.trim().toLowerCase();
	if (style instanceof MapStyleVariant) return style.getId();
	if (style instanceof ReferenceMapStyle) return style.getDefaultVariant().getId();
}
var MapStyle = buildMapStyles();
function extractLineStrings(geoJson) {
	const lineStrings = [];
	function extractFromGeometry(geometry) {
		if (geometry.type === "LineString" || geometry.type === "MultiLineString") lineStrings.push(geometry);
	}
	function extractFromFeature(feature) {
		if (feature.geometry) extractFromGeometry(feature.geometry);
	}
	function extractFromFeatureCollection(collection) {
		for (const feature of collection.features) if (feature.type === "Feature") extractFromFeature(feature);
		else if (feature.type === "FeatureCollection") extractFromFeatureCollection(feature);
	}
	if (geoJson.type === "Feature") extractFromFeature(geoJson);
	else if (geoJson.type === "FeatureCollection") extractFromFeatureCollection(geoJson);
	else extractFromGeometry(geoJson);
	return lineStrings;
}
function getSqSegDist(p, p1, p2) {
	let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
	if (dx !== 0 || dy !== 0) {
		const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
		if (t > 1) {
			x = p2[0];
			y = p2[1];
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}
	dx = p[0] - x;
	dy = p[1] - y;
	return dx * dx + dy * dy;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
	let maxSqDist = sqTolerance, index;
	for (let i = first + 1; i < last; i++) {
		const sqDist = getSqSegDist(points[i], points[first], points[last]);
		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}
	if (maxSqDist > sqTolerance) {
		if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
		simplified.push(points[index]);
		if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
	}
}
function simplifyDouglasPeucker(points, sqTolerance) {
	const last = points.length - 1;
	const simplified = [points[0]];
	simplifyDPStep(points, 0, last, sqTolerance, simplified);
	simplified.push(points[last]);
	return simplified;
}
function simplify(points, tolerance) {
	if (points.length <= 2) return points;
	return simplifyDouglasPeucker(points, tolerance !== void 0 ? tolerance * tolerance : 1);
}
var misc = {
	extractLineStrings,
	simplify
};
function staticMapMarkerToString(marker, includeColor = true) {
	let str = `${marker[0]},${marker[1]}`;
	if (marker.length === 3 && includeColor) str += `,${marker[2]}`;
	return str;
}
function simplifyAndStringify(path, maxNbChar = 3e3) {
	let str = path.map((point) => point.join(",")).join("|");
	let tolerance = 5e-6;
	const toleranceStep = 1e-5;
	while (str.length > maxNbChar) {
		str = misc.simplify(path, tolerance).map((point) => `${point[0]},${point[1]}`).join("|");
		tolerance += toleranceStep;
	}
	return str;
}
function centered(center, zoom, options = {}) {
	const style = styleToStyle(options.style);
	const scale = options.hiDPI ? "@2x" : "";
	const format = options.format ?? "png";
	let width = ~~(options.width ?? 1024);
	let height = ~~(options.height ?? 1024);
	if (options.hiDPI) {
		width = ~~(width / 2);
		height = ~~(height / 2);
	}
	const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
	if ("attribution" in options) endpoint.searchParams.set("attribution", options.attribution.toString());
	if ("markers" in options) {
		let markerStr = "";
		const hasIcon = "markerIcon" in options;
		if (hasIcon) markerStr += `icon:${options.markerIcon}|`;
		if (hasIcon && "markerAnchor" in options) markerStr += `anchor:${options.markerAnchor}|`;
		if (hasIcon && options.hiDPI) markerStr += `scale:2|`;
		const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
		markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
		endpoint.searchParams.set("markers", markerStr);
	}
	if ("path" in options) {
		let pathStr = "";
		pathStr += `fill:${options.pathFillColor ?? "none"}|`;
		if ("pathStrokeColor" in options) pathStr += `stroke:${options.pathStrokeColor}|`;
		if ("pathWidth" in options) {
			const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
			pathStr += `width:${pathWidth.toString()}|`;
		}
		pathStr += simplifyAndStringify(options.path);
		endpoint.searchParams.set("path", pathStr);
	}
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	return endpoint.toString();
}
function bounded(boundingBox, options = {}) {
	const style = styleToStyle(options.style);
	const scale = options.hiDPI ? "@2x" : "";
	const format = options.format ?? "png";
	let width = ~~(options.width ?? 1024);
	let height = ~~(options.height ?? 1024);
	if (options.hiDPI) {
		width = ~~(width / 2);
		height = ~~(height / 2);
	}
	const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
	if ("attribution" in options) endpoint.searchParams.set("attribution", options.attribution.toString());
	if ("padding" in options) endpoint.searchParams.set("padding", options.padding.toString());
	if ("markers" in options) {
		let markerStr = "";
		const hasIcon = "markerIcon" in options;
		if (hasIcon) markerStr += `icon:${options.markerIcon}|`;
		if (hasIcon && "markerAnchor" in options) markerStr += `anchor:${options.markerAnchor}|`;
		if (hasIcon && options.hiDPI) markerStr += `scale:2|`;
		const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
		markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
		endpoint.searchParams.set("markers", markerStr);
	}
	if ("path" in options) {
		let pathStr = "";
		pathStr += `fill:${options.pathFillColor ?? "none"}|`;
		if ("pathStrokeColor" in options) pathStr += `stroke:${options.pathStrokeColor}|`;
		if ("pathWidth" in options) {
			const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
			pathStr += `width:${pathWidth.toString()}|`;
		}
		pathStr += simplifyAndStringify(options.path);
		endpoint.searchParams.set("path", pathStr);
	}
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	return endpoint.toString();
}
function automatic(options = {}) {
	if (!("markers" in options) && !("path" in options)) throw new Error("Automatic static maps require markers and/or path to be created.");
	const style = styleToStyle(options.style);
	const scale = options.hiDPI ? "@2x" : "";
	const format = options.format ?? "png";
	let width = ~~(options.width ?? 1024);
	let height = ~~(options.height ?? 1024);
	if (options.hiDPI) {
		width = ~~(width / 2);
		height = ~~(height / 2);
	}
	const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/auto/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
	if ("attribution" in options) endpoint.searchParams.set("attribution", options.attribution.toString());
	if ("padding" in options) endpoint.searchParams.set("padding", options.padding.toString());
	if ("markers" in options) {
		let markerStr = "";
		const hasIcon = "markerIcon" in options;
		if (hasIcon) markerStr += `icon:${options.markerIcon}|`;
		if (hasIcon && "markerAnchor" in options) markerStr += `anchor:${options.markerAnchor}|`;
		if (hasIcon && options.hiDPI) markerStr += `scale:2|`;
		const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
		markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
		endpoint.searchParams.set("markers", markerStr);
	}
	if ("path" in options) {
		let pathStr = "";
		pathStr += `fill:${options.pathFillColor ?? "none"}|`;
		if ("pathStrokeColor" in options) pathStr += `stroke:${options.pathStrokeColor}|`;
		if ("pathWidth" in options) {
			const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
			pathStr += `width:${pathWidth.toString()}|`;
		}
		pathStr += simplifyAndStringify(options.path);
		endpoint.searchParams.set("path", pathStr);
	}
	endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
	return endpoint.toString();
}
var staticMaps = {
	centered,
	bounded,
	automatic
};
var EARTH_RADIUS = 6371008.8;
var EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
function longitudeToMercatorX(lng) {
	return (180 + lng) / 360;
}
function latitudeToMercatorY(lat) {
	return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function wgs84ToMercator(position) {
	const wrappedPos = wrapWgs84(position);
	return [longitudeToMercatorX(wrappedPos[0]), latitudeToMercatorY(wrappedPos[1])];
}
function mercatorXToLongitude(x) {
	return x * 360 - 180;
}
function mercatorYToLatitude(y) {
	const y2 = 180 - y * 360;
	return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
}
function mercatorToWgs84(position) {
	return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];
}
function haversineDistanceWgs84(from, to$1) {
	const rad = Math.PI / 180;
	const lat1 = from[1] * rad;
	const lat2 = to$1[1] * rad;
	const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to$1[0] - from[0]) * rad);
	return EARTH_RADIUS * Math.acos(Math.min(a, 1));
}
function haversineCumulatedDistanceWgs84(positions) {
	const cumulatedDistance = Array(positions.length);
	cumulatedDistance[0] = 0;
	const l = cumulatedDistance.length;
	for (let i = 1; i < l; i++) cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];
	return cumulatedDistance;
}
function wrapWgs84(position) {
	const lng = position[0];
	const lat = position[1];
	const d = 360;
	const w$1 = ((lng + 180) % d + d) % d - 180;
	return [w$1 === -180 ? 180 : w$1, lat];
}
function circumferenceAtLatitude(latitude) {
	return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);
}
function mercatorToTileIndex(position, zoom, strict = true) {
	const numberOfTilePerAxis = 2 ** zoom;
	const fIndex = [position[0] * numberOfTilePerAxis, position[1] * numberOfTilePerAxis];
	return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;
}
function wgs84ToTileIndex(position, zoom, strict = true) {
	return mercatorToTileIndex(wgs84ToMercator(position), zoom, strict);
}
function toRadians(degrees) {
	return degrees * Math.PI / 180;
}
function toDegrees(radians) {
	return radians * 180 / Math.PI;
}
function haversineIntermediateWgs84(pos1, pos2, ratio) {
	const d = haversineDistanceWgs84(pos1, pos2);
	const 1 = toRadians(pos1[0]);
	const 1 = toRadians(pos1[1]);
	const 2 = toRadians(pos2[0]);
	const 2 = toRadians(pos2[1]);
	const  = d / EARTH_RADIUS;
	const a = Math.sin((1 - ratio) * ) / Math.sin();
	const b = Math.sin(ratio * ) / Math.sin();
	const x = a * Math.cos(1) * Math.cos(1) + b * Math.cos(2) * Math.cos(2);
	const y = a * Math.cos(1) * Math.sin(1) + b * Math.cos(2) * Math.sin(2);
	const z$1 = a * Math.sin(1) + b * Math.sin(2);
	const 3 = Math.atan2(z$1, Math.sqrt(x * x + y * y));
	return [toDegrees(Math.atan2(y, x)), toDegrees(3)];
}
var math = {
	EARTH_RADIUS,
	EARTH_CIRCUMFERENCE,
	longitudeToMercatorX,
	latitudeToMercatorY,
	wgs84ToMercator,
	mercatorXToLongitude,
	mercatorYToLatitude,
	mercatorToWgs84,
	haversineDistanceWgs84,
	wrapWgs84,
	circumferenceAtLatitude,
	mercatorToTileIndex,
	wgs84ToTileIndex,
	toRadians,
	toDegrees,
	haversineIntermediateWgs84,
	haversineCumulatedDistanceWgs84
};
var tileCache = null;
function getTileCache() {
	if (!tileCache) tileCache = new QuickLRU({ maxSize: config.tileCacheSize });
	return tileCache;
}
async function bufferToPixelDataBrowser(buff) {
	const blob = new Blob([buff]);
	const imageBitmap = await createImageBitmap(blob);
	const canvas = document.createElement("canvas");
	const ctx = canvas.getContext("2d");
	canvas.width = imageBitmap.width;
	canvas.height = imageBitmap.height;
	ctx.drawImage(imageBitmap, 0, 0);
	const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
	return {
		pixels: imageData.data,
		width: canvas.width,
		height: canvas.height,
		components: imageData.data.length / (canvas.width * canvas.height)
	};
}
function getBufferToPixelDataParser() {
	if (config.bufferToPixelData) return config.bufferToPixelData;
	if (typeof window !== "undefined") return bufferToPixelDataBrowser;
	throw new Error("An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`");
}
function canParsePixelData() {
	return !!config.bufferToPixelData || typeof window !== "undefined";
}
var TERRAIN_TILESET = "terrain-rgb-v2";
var API_BATCH_SIZE = 50;
var API_WARN_SIZE = 1e3;
var terrainTileJson = null;
var customMessages = { 403: "Key is missing, invalid or restricted" };
async function computeOnServer(positions, apiKey) {
	if (positions.length > API_WARN_SIZE) console.warn("Computing elevation for complex geometries is discouraged - simplify the geometry before proceeding");
	const parts = Math.ceil(positions.length / API_BATCH_SIZE);
	const respPromises = Array.from({ length: parts }, () => null).map((_$1, part) => {
		const startPos = part * API_BATCH_SIZE;
		const batchEncoded = positions.slice(startPos, startPos + API_BATCH_SIZE).map((pos) => pos.join(",")).join(";");
		const endpoint = new URL(`elevation/${batchEncoded}.json`, defaults.maptilerApiURL);
		endpoint.searchParams.set("key", apiKey);
		return callFetch(endpoint.toString());
	});
	const resps = await Promise.allSettled(respPromises);
	return (await Promise.all(resps.map(async (resp) => {
		if (resp.status === "rejected") throw new Error(`Some segments could not be fetched, error: ${resp.reason}`);
		if (!resp.value.ok) throw new Error(`Some segments could not be fetched, response: ${resp.value.status} ${await resp.value.text()}, url: ${resp.value.url}`);
		return resp.value.json();
	}))).flat();
}
async function computeOnClient(positions, apiKey, zoom) {
	if (!terrainTileJson) {
		const endpoint = new URL(`tiles/${TERRAIN_TILESET}/tiles.json`, defaults.maptilerApiURL);
		endpoint.searchParams.set("key", apiKey);
		const res = await callFetch(endpoint.toString());
		if (res.ok) terrainTileJson = await res.json();
		else throw new ServiceError(res, customMessages[res.status] ?? "");
	}
	const tileParser = getBufferToPixelDataParser();
	const tileURLSchema = terrainTileJson.tiles[0];
	const cache = getTileCache();
	const maxZoom = terrainTileJson.maxzoom;
	let usedZoom = ~~(zoom ?? maxZoom);
	if (usedZoom > maxZoom || usedZoom < 0) usedZoom = maxZoom;
	const tileIndicesFloats = positions.map((position) => math.wgs84ToTileIndex(position, usedZoom, false));
	const tileIDs = tileIndicesFloats.map((index) => [~~index[0], ~~index[1]]).map((index) => `terrain_${usedZoom.toString()}_${index[0].toString()}_${index[1].toString()}`);
	const uniqueTilesToFetch = Array.from(new Set(tileIDs.filter((tileID) => !cache.has(tileID)))).map((tileID) => tileID.split("_").slice(1));
	const promisesFetchTiles = uniqueTilesToFetch.map((zxy) => tileURLSchema.replace("{x}", zxy[1].toString()).replace("{y}", zxy[2].toString()).replace("{z}", zxy[0].toString())).map((url) => callFetch(url));
	const fulfilledRes = (await Promise.allSettled(promisesFetchTiles)).map((el$1) => el$1.status === "fulfilled" ? el$1.value : null).filter((res) => res);
	const fulfilledRButNotOkRes = fulfilledRes.filter((res) => !res.ok);
	if (fulfilledRes.length !== promisesFetchTiles.length) throw new Error("Some tiles could not be fetched.");
	if (fulfilledRButNotOkRes.length) throw new ServiceError(fulfilledRButNotOkRes[0], customMessages[fulfilledRButNotOkRes[0].status] ?? "");
	const tileArrayBuffers = await Promise.all(fulfilledRes.map((res) => res.arrayBuffer()));
	if (!tileArrayBuffers.every((buff) => buff.byteLength > 0)) throw new Error("Some tiles are not available.");
	(await Promise.all(tileArrayBuffers.map((buff) => tileParser(buff)))).forEach((tilePixelData, i) => {
		const zxy = uniqueTilesToFetch[i];
		const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;
		cache.set(tileID, tilePixelData);
	});
	return positions.map((position, i) => {
		const tileID = tileIDs[i];
		const tileIndexFloat = tileIndicesFloats[i];
		const tilePixelData = cache.get(tileID);
		const pixelX = Math.min(Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)), tilePixelData.width - 1);
		const pixelDataIndex = (Math.min(Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)), tilePixelData.height - 1) * tilePixelData.width + pixelX) * tilePixelData.components;
		const R$2 = tilePixelData.pixels[pixelDataIndex];
		const G$1 = tilePixelData.pixels[pixelDataIndex + 1];
		const B$1 = tilePixelData.pixels[pixelDataIndex + 2];
		const elevation2 = -1e4 + (R$2 * 256 * 256 + G$1 * 256 + B$1) * .1;
		return [
			position[0],
			position[1],
			~~(elevation2 * 1e3) / 1e3
		];
	});
}
async function at$1(position, options = {}) {
	return (await batch([position], options))[0];
}
async function batch(positions, options = {}) {
	if (positions.length === 0) return [];
	const apiKey = options.apiKey ?? config.apiKey;
	const elevatedPositions = options.computeOn === "client" ? await computeOnClient(positions, apiKey, options.zoom) : await computeOnServer(positions, apiKey);
	if (options.smoothingKernelSize) {
		const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;
		const elevations = elevatedPositions.map((pos) => pos[2]);
		const kernelSpan = ~~(kernelSize / 2);
		for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {
			let sum = 0;
			for (let j$1 = 0; j$1 < kernelSize; j$1 += 1) {
				const elev = elevations[i - kernelSpan + j$1];
				sum += elev;
			}
			sum /= kernelSize;
			elevatedPositions[i][2] = sum;
		}
	}
	return elevatedPositions;
}
async function fromLineString(ls$1, options = {}) {
	if (ls$1.type !== "LineString") throw new Error("The provided object is not a GeoJSON LineString");
	options.computeOn ?? (options.computeOn = canParsePixelData() ? "client" : "server");
	const clone = structuredClone(ls$1);
	clone.coordinates = await batch(clone.coordinates, options);
	return clone;
}
async function fromMultiLineString(ls$1, options = {}) {
	if (ls$1.type !== "MultiLineString") throw new Error("The provided object is not a GeoJSON MultiLineString");
	options.computeOn ?? (options.computeOn = canParsePixelData() ? "client" : "server");
	const clone = structuredClone(ls$1);
	const multiLengths = clone.coordinates.map((poss) => poss.length);
	const flattenPositionsElevated = await batch(clone.coordinates.flat(), options);
	const result = [];
	let index = 0;
	for (const length of multiLengths) {
		result.push(flattenPositionsElevated.slice(index, index + length));
		index += length;
	}
	clone.coordinates = result;
	return clone;
}
var elevation = {
	at: at$1,
	batch,
	fromLineString,
	fromMultiLineString
};

//#endregion
//#region node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
	return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

//#endregion
//#region node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
	if (!getRandomValues) {
		if (typeof crypto === "undefined" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
		getRandomValues = crypto.getRandomValues.bind(crypto);
	}
	return getRandomValues(rnds8);
}

//#endregion
//#region node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

//#endregion
//#region node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
	if (native_default.randomUUID && !buf && !options) return native_default.randomUUID();
	options = options || {};
	const rnds = options.random ?? options.rng?.() ?? rng();
	if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
	rnds[6] = rnds[6] & 15 | 64;
	rnds[8] = rnds[8] & 63 | 128;
	if (buf) {
		offset = offset || 0;
		if (offset < 0 || offset + 16 > buf.length) throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
		for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
		return buf;
	}
	return unsafeStringify(rnds);
}
var v4_default = v4;

//#endregion
//#region node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs
var mi = Object.defineProperty;
var Pn = (r) => {
	throw TypeError(r);
};
var yi = (r, e, t) => e in r ? mi(r, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : r[e] = t;
var g = (r, e, t) => yi(r, typeof e != "symbol" ? e + "" : e, t), gr = (r, e, t) => e.has(r) || Pn("Cannot " + t);
var L = (r, e, t) => (gr(r, e, "read from private field"), t ? t.call(r) : e.get(r)), Y = (r, e, t) => e.has(r) ? Pn("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), J = (r, e, t, n) => (gr(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t), Q = (r, e, t) => (gr(r, e, "access private method"), t);
var Ci = class extends import_maplibre_gl.default.Marker {
	addTo(e) {
		return super.addTo(e);
	}
};
var Jc = class extends import_maplibre_gl.default.Popup {
	addTo(e) {
		return super.addTo(e);
	}
};
var Qc = class extends import_maplibre_gl.default.Style {
	constructor(e, t = {}) {
		super(e, t);
	}
};
var ep = class extends import_maplibre_gl.default.CanvasSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var tp = class extends import_maplibre_gl.default.GeoJSONSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var rp = class extends import_maplibre_gl.default.ImageSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var np = class extends import_maplibre_gl.default.RasterTileSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var ap = class extends import_maplibre_gl.default.RasterDEMTileSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var op = class extends import_maplibre_gl.default.VectorTileSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var ip = class extends import_maplibre_gl.default.VideoSource {
	onAdd(e) {
		super.onAdd(e);
	}
};
var Na = class extends import_maplibre_gl.default.NavigationControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var Ei = class extends import_maplibre_gl.default.GeolocateControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var sp = class extends import_maplibre_gl.default.AttributionControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var Ai = class extends import_maplibre_gl.default.LogoControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var Ti = class extends import_maplibre_gl.default.ScaleControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var _i = class extends import_maplibre_gl.default.FullscreenControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var lp = class extends import_maplibre_gl.default.TerrainControl {
	onAdd(e) {
		return super.onAdd(e);
	}
};
var up = class extends import_maplibre_gl.default.BoxZoomHandler {
	constructor(e, t) {
		super(e, t);
	}
};
var cp = class extends import_maplibre_gl.default.ScrollZoomHandler {
	constructor(e, t) {
		super(e, t);
	}
};
var pp = class extends import_maplibre_gl.default.CooperativeGesturesHandler {
	constructor(e, t) {
		super(e, t);
	}
};
var fp = class extends import_maplibre_gl.default.KeyboardHandler {
	constructor(e) {
		super(e);
	}
};
var dp = class extends import_maplibre_gl.default.TwoFingersTouchPitchHandler {
	constructor(e) {
		super(e);
	}
};
var hp = class extends import_maplibre_gl.default.MapWheelEvent {
	constructor(e, t, n) {
		super(e, t, n);
	}
};
var mp = class extends import_maplibre_gl.default.MapTouchEvent {
	constructor(e, t, n) {
		super(e, t, n);
	}
};
var yp = class extends import_maplibre_gl.default.MapMouseEvent {
	constructor(e, t, n, a = {}) {
		super(e, t, n, a);
	}
};
var z = {
	VISITOR: {
		code: null,
		flag: "visitor",
		name: "Visitor",
		latin: !0,
		isMode: !0,
		geocoding: !1
	},
	VISITOR_ENGLISH: {
		code: null,
		flag: "visitor_en",
		name: "Visitor English",
		latin: !0,
		isMode: !0,
		geocoding: !1
	},
	STYLE: {
		code: null,
		flag: "style",
		name: "Style",
		latin: !1,
		isMode: !0,
		geocoding: !1
	},
	STYLE_LOCK: {
		code: null,
		flag: "style_lock",
		name: "Style Lock",
		latin: !1,
		isMode: !0,
		geocoding: !1
	},
	...Language
};
function Fn() {
	if (typeof navigator > "u") {
		const e = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
		return getLanguageInfoFromCode(e) || z.ENGLISH;
	}
	return Array.from(new Set(navigator.languages.map((e) => e.split("-")[0]))).map((e) => getLanguageInfoFromCode(e)).filter((e) => e)[0] ?? z.LOCAL;
}
var W = {
	maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
	maptilerURL: "https://www.maptiler.com/",
	maptilerApiHost: "api.maptiler.com",
	telemetryURL: "https://api.maptiler.com/metrics",
	rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
	primaryLanguage: z.STYLE,
	secondaryLanguage: z.LOCAL,
	terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
	terrainSourceId: "maptiler-terrain"
};
Object.freeze(W);
var on = v4_default();
var Ii = class extends import_events.default {
	constructor() {
		super(...arguments);
		/**
		* The primary language. By default, the language of the web browser is used.
		*/
		g(this, "primaryLanguage", W.primaryLanguage);
		/**
		* The secondary language, to overwrite the default language defined in the map style.
		* This settings is highly dependant on the style compatibility and may not work in most cases.
		*/
		g(this, "secondaryLanguage");
		/**
		* Setting on whether of not the SDK runs with a session logic.
		* A "session" is started at the initialization of the SDK and finished when the browser
		* page is being refreshed.
		* When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries
		* on the MapTiler Cloud API. This allows MapTiler to enable "session based billing".
		*/
		g(this, "session", !0);
		/**
		* Enables client-side caching of requests for tiles and fonts.
		* The cached requests persist multiple browser sessions and will be reused when possible.
		* Works only for requests to the MapTiler Cloud API when sessions are enabled.
		*/
		g(this, "caching", !0);
		/**
		* Telemetry is enabled by default but can be opted-out by setting this value to `false`.
		* The telemetry is very valuable to the team at MapTiler because it shares information
		* about where to add the extra effort. It also helps spotting some incompatibility issues
		* that may arise between the SDK and a specific version of a module.
		*
		* It consists in sending metrics about usage of the following features:
		* - SDK version [string]
		* - API key [string]
		* - MapTiler sesion ID (if opted-in) [string]
		* - if tile caching is enabled [boolean]
		* - if language specified at initialization [boolean]
		* - if terrain is activated at initialization [boolean]
		* - if globe projection is activated at initialization [boolean]
		*
		* In addition, each official module will be added to a list, alongside its version number.
		*/
		g(this, "telemetry", !0);
		/**
		* Unit to be used
		*/
		g(this, "_unit", "metric");
		/**
		* MapTiler Cloud API key
		*/
		g(this, "_apiKey", "");
	}
	/**
	* Set the unit system
	*/
	set unit(t) {
		this._unit = t, this.emit("unit", t);
	}
	/**
	* Get the unit system
	*/
	get unit() {
		return this._unit;
	}
	/**
	* Set the MapTiler Cloud API key
	*/
	set apiKey(t) {
		this._apiKey = t, config.apiKey = t, this.emit("apiKey", t);
	}
	/**
	* Get the MapTiler Cloud API key
	*/
	get apiKey() {
		return this._apiKey;
	}
	/**
	* Set a the custom fetch function to replace the default one
	*/
	set fetch(t) {
		config.fetch = t;
	}
	/**
	* Get the fetch fucntion
	*/
	get fetch() {
		return config.fetch;
	}
};
var j = new Ii();
var $n = class extends Ai {
	constructor(t = {}) {
		super(t);
		g(this, "logoURL", "");
		g(this, "linkURL", "");
		this.logoURL = t.logoURL ?? W.maptilerLogoURL, this.linkURL = t.linkURL ?? W.maptilerURL;
	}
	onAdd(t) {
		this._map = t, this._compact = this.options.compact ?? !1, this._container = window.document.createElement("div"), this._container.className = "maplibregl-ctrl";
		const n = window.document.createElement("a");
		return n.style.backgroundRepeat = "no-repeat", n.style.cursor = "pointer", n.style.display = "block", n.style.height = "23px", n.style.margin = "0 0 -4px -4px", n.style.overflow = "hidden", n.style.width = "88px", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = "100px 30px", n.style.width = "100px", n.style.height = "30px", n.target = "_blank", n.rel = "noopener", n.href = this.linkURL, n.setAttribute("aria-label", "MapTiler logo"), n.setAttribute("rel", "noopener"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
	}
};
var $r = "localcache_source", Nr = "localcache", Mi = "maptiler_sdk", Pi = 1e3, Ri = 100, jr = typeof caches < "u", { addProtocol: Nn } = import_maplibre_gl.default;
function zi(r, e) {
	if (jr && j.caching && j.session && r.host === W.maptilerApiHost) {
		if (e === "Source" && r.href.includes("tiles.json")) return r.href.replace("https://", `${$r}://`);
		if (e === "Tile" || e === "Glyphs") return r.href.replace("https://", `${Nr}://`);
	}
	return r.href;
}
var wr;
async function ja() {
	return wr || (wr = await caches.open(Mi)), wr;
}
var jn = 0;
async function Oi() {
	const r = await ja(), e = await r.keys(), t = e.slice(0, Math.max(e.length - Pi, 0));
	for (const n of t) r.delete(n);
}
function Fi() {
	Nn($r, async (r, e) => {
		if (!r.url) throw new Error("");
		r.url = r.url.replace(`${$r}://`, "https://");
		const t = r;
		t.signal = e.signal;
		const n = await fetch(r.url, t), a = await n.json();
		return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get("Last-Modified")}`), {
			data: a,
			cacheControl: n.headers.get("Cache-Control"),
			expires: n.headers.get("Expires")
		};
	}), Nn(Nr, async (r, e) => {
		if (!r.url) throw new Error("");
		r.url = r.url.replace(`${Nr}://`, "https://");
		const t = new URL(r.url), n = new URL(t);
		n.searchParams.delete("mtsid"), n.searchParams.delete("key");
		const a = n.toString(), o = new URL(t);
		o.searchParams.delete("last-modified");
		const i = o.toString(), s = async (d) => ({
			data: await d.arrayBuffer(),
			cacheControl: d.headers.get("Cache-Control"),
			expires: d.headers.get("Expires")
		}), l = await ja(), u = await l.match(a);
		if (u) return s(u);
		const c = r;
		c.signal = e.signal;
		const p = await fetch(i, c);
		return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {}), ++jn > Ri && (Oi(), jn = 0)), s(p);
	});
}
async function $i(r) {
	if (typeof window > "u") return;
	const e = import_maplibre_gl.default.getRTLTextPluginStatus();
	if (e === "unavailable" || e === "requested") try {
		await import_maplibre_gl.default.setRTLTextPlugin(r ?? W.rtlPluginURL, !0);
	} catch (t) {
		console.error("Error enabling RTL plugin. It is enabled by default and cannot be unset after. Are you attempting to enable it twice?", t);
	}
}
function Ni(r, e) {
	for (const t of r) typeof e[t] == "function" && (e[t] = e[t].bind(e));
}
function Dn(r, e) {
	let t = null;
	try {
		t = new URL(r);
	} catch {
		return { url: r };
	}
	return t.host === W.maptilerApiHost && (t.searchParams.has("key") || t.searchParams.append("key", j.apiKey), j.session && t.searchParams.append("mtsid", on)), { url: zi(t, e) };
}
function Un(r) {
	return (e, t) => {
		if (r != null) {
			const n = r(e, t), a = Dn((n == null ? void 0 : n.url) ?? "", t);
			return {
				...n,
				...a
			};
		}
		return Dn(e, t);
	};
}
function Da() {
	return Math.random().toString(36).substring(2);
}
function Qt(r) {
	return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi.test(r);
}
function ji(r) {
	try {
		return JSON.parse(r);
	} catch {}
	return null;
}
function Di() {
	return document.createElement("canvas").getContext("webgl2") ? null : typeof WebGL2RenderingContext < "u" ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
}
function Ui(r) {
	const e = Di();
	if (!e) return;
	let t = null;
	if (typeof r == "string" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t) throw new Error("The Map container must be provided.");
	const n = document.createElement("div");
	throw n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n), new Error(e);
}
function gp(r) {
	const e = "The WebGL context was lost.", t = r.getContainer(), n = document.createElement("div");
	n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n);
}
function Bn(r, e) {
	return !(!Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" || e && !r[1].startsWith("name:") || !e && r[1] !== "name");
}
function Bi(r, e, t) {
	const n = structuredClone(r), a = (o) => {
		if (typeof o != "string") for (let i = 0; i < o.length; i += 1) Bn(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);
	};
	return Bn(n, t) ? e : (a(n), n);
}
function qi(r, e) {
	const t = e ? /\{name:\S+\}/ : /\{name\}/;
	return {
		contains: t.test(r),
		exactMatch: (/* @__PURE__ */ new RegExp(`^${t.source}$`)).test(r)
	};
}
function Vi(r, e, t) {
	const n = t ? /\{name:\S+\}/ : /\{name\}/, a = r.split(n);
	return ["concat", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];
}
function Gi(r) {
	var n;
	const e = /\{name(?::(?<language>\S+))?\}/g, t = [];
	for (;;) {
		const a = e.exec(r);
		if (!a) break;
		const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;
		t.push(o);
	}
	return t;
}
function Hi(r) {
	return !Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" ? null : r[1].trim() === "name" ? {
		isLanguage: !0,
		localization: null
	} : r[1].trim().startsWith("name:") ? {
		isLanguage: !0,
		localization: r[1].trim().split(":").pop()
	} : null;
}
function Zi(r) {
	const e = [], t = structuredClone(r), n = (a) => {
		if (typeof a != "string") for (let o = 0; o < a.length; o += 1) {
			const i = Hi(a[o]);
			i ? e.push(i.localization) : n(a[o]);
		}
	};
	return n([t]), e;
}
function Ki(r, e) {
	const t = [];
	for (const o of r) {
		if (o.type !== "symbol") continue;
		const { id: s, layout: l } = o;
		if (!l || !("text-field" in l)) continue;
		const u = e.getLayoutProperty(s, "text-field");
		if (u) if (typeof u == "string") {
			const c = Gi(u);
			t.push(c);
		} else {
			const c = Zi(u);
			t.push(c);
		}
	}
	const n = t.flat(), a = {
		unlocalized: 0,
		localized: {}
	};
	for (const o of n) o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);
	return a;
}
var Xi = 8, Yi = {
	version: {
		required: !0,
		type: "enum",
		values: [8]
	},
	name: { type: "string" },
	metadata: { type: "*" },
	center: {
		type: "array",
		value: "number"
	},
	centerAltitude: { type: "number" },
	zoom: { type: "number" },
	bearing: {
		type: "number",
		default: 0,
		period: 360,
		units: "degrees"
	},
	pitch: {
		type: "number",
		default: 0,
		units: "degrees"
	},
	roll: {
		type: "number",
		default: 0,
		units: "degrees"
	},
	state: {
		type: "state",
		default: {}
	},
	light: { type: "light" },
	sky: { type: "sky" },
	projection: { type: "projection" },
	terrain: { type: "terrain" },
	sources: {
		required: !0,
		type: "sources"
	},
	sprite: { type: "sprite" },
	glyphs: { type: "string" },
	"font-faces": {
		type: "array",
		value: "fontFaces"
	},
	transition: { type: "transition" },
	layers: {
		required: !0,
		type: "array",
		value: "layer"
	}
}, Wi = { "*": { type: "source" } }, Ji = [
	"source_vector",
	"source_raster",
	"source_raster_dem",
	"source_geojson",
	"source_video",
	"source_image"
], Qi = {
	type: {
		required: !0,
		type: "enum",
		values: { vector: {} }
	},
	url: { type: "string" },
	tiles: {
		type: "array",
		value: "string"
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		default: [
			-180,
			-85.051129,
			180,
			85.051129
		]
	},
	scheme: {
		type: "enum",
		values: {
			xyz: {},
			tms: {}
		},
		default: "xyz"
	},
	minzoom: {
		type: "number",
		default: 0
	},
	maxzoom: {
		type: "number",
		default: 22
	},
	attribution: { type: "string" },
	promoteId: { type: "promoteId" },
	volatile: {
		type: "boolean",
		default: !1
	},
	encoding: {
		type: "enum",
		values: {
			mvt: {},
			mlt: {}
		},
		default: "mvt"
	},
	"*": { type: "*" }
}, es = {
	type: {
		required: !0,
		type: "enum",
		values: { raster: {} }
	},
	url: { type: "string" },
	tiles: {
		type: "array",
		value: "string"
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		default: [
			-180,
			-85.051129,
			180,
			85.051129
		]
	},
	minzoom: {
		type: "number",
		default: 0
	},
	maxzoom: {
		type: "number",
		default: 22
	},
	tileSize: {
		type: "number",
		default: 512,
		units: "pixels"
	},
	scheme: {
		type: "enum",
		values: {
			xyz: {},
			tms: {}
		},
		default: "xyz"
	},
	attribution: { type: "string" },
	volatile: {
		type: "boolean",
		default: !1
	},
	"*": { type: "*" }
}, ts = {
	type: {
		required: !0,
		type: "enum",
		values: { "raster-dem": {} }
	},
	url: { type: "string" },
	tiles: {
		type: "array",
		value: "string"
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		default: [
			-180,
			-85.051129,
			180,
			85.051129
		]
	},
	minzoom: {
		type: "number",
		default: 0
	},
	maxzoom: {
		type: "number",
		default: 22
	},
	tileSize: {
		type: "number",
		default: 512,
		units: "pixels"
	},
	attribution: { type: "string" },
	encoding: {
		type: "enum",
		values: {
			terrarium: {},
			mapbox: {},
			custom: {}
		},
		default: "mapbox"
	},
	redFactor: {
		type: "number",
		default: 1
	},
	blueFactor: {
		type: "number",
		default: 1
	},
	greenFactor: {
		type: "number",
		default: 1
	},
	baseShift: {
		type: "number",
		default: 0
	},
	volatile: {
		type: "boolean",
		default: !1
	},
	"*": { type: "*" }
}, rs = {
	type: {
		required: !0,
		type: "enum",
		values: { geojson: {} }
	},
	data: {
		required: !0,
		type: "*"
	},
	maxzoom: {
		type: "number",
		default: 18
	},
	attribution: { type: "string" },
	buffer: {
		type: "number",
		default: 128,
		maximum: 512,
		minimum: 0
	},
	filter: { type: "*" },
	tolerance: {
		type: "number",
		default: .375
	},
	cluster: {
		type: "boolean",
		default: !1
	},
	clusterRadius: {
		type: "number",
		default: 50,
		minimum: 0
	},
	clusterMaxZoom: { type: "number" },
	clusterMinPoints: { type: "number" },
	clusterProperties: { type: "*" },
	lineMetrics: {
		type: "boolean",
		default: !1
	},
	generateId: {
		type: "boolean",
		default: !1
	},
	promoteId: { type: "promoteId" }
}, ns = {
	type: {
		required: !0,
		type: "enum",
		values: { video: {} }
	},
	urls: {
		required: !0,
		type: "array",
		value: "string"
	},
	coordinates: {
		required: !0,
		type: "array",
		length: 4,
		value: {
			type: "array",
			length: 2,
			value: "number"
		}
	}
}, as = {
	type: {
		required: !0,
		type: "enum",
		values: { image: {} }
	},
	url: {
		required: !0,
		type: "string"
	},
	coordinates: {
		required: !0,
		type: "array",
		length: 4,
		value: {
			type: "array",
			length: 2,
			value: "number"
		}
	}
}, os = {
	id: {
		type: "string",
		required: !0
	},
	type: {
		type: "enum",
		values: {
			fill: {},
			line: {},
			symbol: {},
			circle: {},
			heatmap: {},
			"fill-extrusion": {},
			raster: {},
			hillshade: {},
			"color-relief": {},
			background: {}
		},
		required: !0
	},
	metadata: { type: "*" },
	source: { type: "string" },
	"source-layer": { type: "string" },
	minzoom: {
		type: "number",
		minimum: 0,
		maximum: 24
	},
	maxzoom: {
		type: "number",
		minimum: 0,
		maximum: 24
	},
	filter: { type: "filter" },
	layout: { type: "layout" },
	paint: { type: "paint" }
}, is = [
	"layout_fill",
	"layout_line",
	"layout_circle",
	"layout_heatmap",
	"layout_fill-extrusion",
	"layout_symbol",
	"layout_raster",
	"layout_hillshade",
	"layout_color-relief",
	"layout_background"
], ss = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, ls = {
	"fill-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, us = {
	"circle-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, cs = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, ps = {
	"line-cap": {
		type: "enum",
		values: {
			butt: {},
			round: {},
			square: {}
		},
		default: "butt",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-join": {
		type: "enum",
		values: {
			bevel: {},
			round: {},
			miter: {}
		},
		default: "miter",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"line-miter-limit": {
		type: "number",
		default: 2,
		requires: [{ "line-join": "miter" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-round-limit": {
		type: "number",
		default: 1.05,
		requires: [{ "line-join": "round" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, fs = {
	"symbol-placement": {
		type: "enum",
		values: {
			point: {},
			line: {},
			"line-center": {}
		},
		default: "point",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"symbol-spacing": {
		type: "number",
		default: 250,
		minimum: 1,
		units: "pixels",
		requires: [{ "symbol-placement": "line" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"symbol-avoid-edges": {
		type: "boolean",
		default: !1,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"symbol-sort-key": {
		type: "number",
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"symbol-z-order": {
		type: "enum",
		values: {
			auto: {},
			"viewport-y": {},
			source: {}
		},
		default: "auto",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-allow-overlap": {
		type: "boolean",
		default: !1,
		requires: ["icon-image", { "!": "icon-overlap" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-overlap": {
		type: "enum",
		values: {
			never: {},
			always: {},
			cooperative: {}
		},
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-ignore-placement": {
		type: "boolean",
		default: !1,
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-optional": {
		type: "boolean",
		default: !1,
		requires: ["icon-image", "text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-rotation-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			auto: {}
		},
		default: "auto",
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-size": {
		type: "number",
		default: 1,
		minimum: 0,
		units: "factor of the original icon size",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-text-fit": {
		type: "enum",
		values: {
			none: {},
			width: {},
			height: {},
			both: {}
		},
		default: "none",
		requires: ["icon-image", "text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-text-fit-padding": {
		type: "array",
		value: "number",
		length: 4,
		default: [
			0,
			0,
			0,
			0
		],
		units: "pixels",
		requires: [
			"icon-image",
			"text-field",
			{ "icon-text-fit": [
				"both",
				"width",
				"height"
			] }
		],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-image": {
		type: "resolvedImage",
		tokens: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-rotate": {
		type: "number",
		default: 0,
		period: 360,
		units: "degrees",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-padding": {
		type: "padding",
		default: [2],
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-keep-upright": {
		type: "boolean",
		default: !1,
		requires: [
			"icon-image",
			{ "icon-rotation-alignment": "map" },
			{ "symbol-placement": ["line", "line-center"] }
		],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-offset": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-anchor": {
		type: "enum",
		values: {
			center: {},
			left: {},
			right: {},
			top: {},
			bottom: {},
			"top-left": {},
			"top-right": {},
			"bottom-left": {},
			"bottom-right": {}
		},
		default: "center",
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"icon-pitch-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			auto: {}
		},
		default: "auto",
		requires: ["icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-pitch-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			auto: {}
		},
		default: "auto",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-rotation-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {},
			"viewport-glyph": {},
			auto: {}
		},
		default: "auto",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-field": {
		type: "formatted",
		default: "",
		tokens: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-font": {
		type: "array",
		value: "string",
		default: ["Open Sans Regular", "Arial Unicode MS Regular"],
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-size": {
		type: "number",
		default: 16,
		minimum: 0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-max-width": {
		type: "number",
		default: 10,
		minimum: 0,
		units: "ems",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-line-height": {
		type: "number",
		default: 1.2,
		units: "ems",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-letter-spacing": {
		type: "number",
		default: 0,
		units: "ems",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-justify": {
		type: "enum",
		values: {
			auto: {},
			left: {},
			center: {},
			right: {}
		},
		default: "center",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-radial-offset": {
		type: "number",
		units: "ems",
		default: 0,
		requires: ["text-field"],
		"property-type": "data-driven",
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		}
	},
	"text-variable-anchor": {
		type: "array",
		value: "enum",
		values: {
			center: {},
			left: {},
			right: {},
			top: {},
			bottom: {},
			"top-left": {},
			"top-right": {},
			"bottom-left": {},
			"bottom-right": {}
		},
		requires: ["text-field", { "symbol-placement": ["point"] }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-variable-anchor-offset": {
		type: "variableAnchorOffsetCollection",
		requires: ["text-field", { "symbol-placement": ["point"] }],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-anchor": {
		type: "enum",
		values: {
			center: {},
			left: {},
			right: {},
			top: {},
			bottom: {},
			"top-left": {},
			"top-right": {},
			"bottom-left": {},
			"bottom-right": {}
		},
		default: "center",
		requires: ["text-field", { "!": "text-variable-anchor" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-max-angle": {
		type: "number",
		default: 45,
		units: "degrees",
		requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-writing-mode": {
		type: "array",
		value: "enum",
		values: {
			horizontal: {},
			vertical: {}
		},
		requires: ["text-field", { "symbol-placement": ["point"] }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-rotate": {
		type: "number",
		default: 0,
		period: 360,
		units: "degrees",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-padding": {
		type: "number",
		default: 2,
		minimum: 0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-keep-upright": {
		type: "boolean",
		default: !0,
		requires: [
			"text-field",
			{ "text-rotation-alignment": "map" },
			{ "symbol-placement": ["line", "line-center"] }
		],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-transform": {
		type: "enum",
		values: {
			none: {},
			uppercase: {},
			lowercase: {}
		},
		default: "none",
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-offset": {
		type: "array",
		value: "number",
		units: "ems",
		length: 2,
		default: [0, 0],
		requires: ["text-field", { "!": "text-radial-offset" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom", "feature"]
		},
		"property-type": "data-driven"
	},
	"text-allow-overlap": {
		type: "boolean",
		default: !1,
		requires: ["text-field", { "!": "text-overlap" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-overlap": {
		type: "enum",
		values: {
			never: {},
			always: {},
			cooperative: {}
		},
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-ignore-placement": {
		type: "boolean",
		default: !1,
		requires: ["text-field"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-optional": {
		type: "boolean",
		default: !1,
		requires: ["text-field", "icon-image"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	}
}, ds = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, hs = { visibility: {
	type: "enum",
	values: {
		visible: {},
		none: {}
	},
	default: "visible",
	"property-type": "constant"
} }, ms = {
	type: "array",
	value: "*"
}, ys = {
	type: "enum",
	values: {
		"==": {},
		"!=": {},
		">": {},
		">=": {},
		"<": {},
		"<=": {},
		in: {},
		"!in": {},
		all: {},
		any: {},
		none: {},
		has: {},
		"!has": {}
	}
}, gs = {
	type: "enum",
	values: {
		Point: {},
		LineString: {},
		Polygon: {}
	}
}, vs = {
	type: "array",
	minimum: 0,
	maximum: 24,
	value: ["number", "color"],
	length: 2
}, bs = {
	type: "array",
	value: "*",
	minimum: 1
}, ws = {
	anchor: {
		type: "enum",
		default: "viewport",
		values: {
			map: {},
			viewport: {}
		},
		"property-type": "data-constant",
		transition: !1,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		}
	},
	position: {
		type: "array",
		default: [
			1.15,
			210,
			30
		],
		length: 3,
		value: "number",
		"property-type": "data-constant",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		}
	},
	color: {
		type: "color",
		"property-type": "data-constant",
		default: "#ffffff",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	intensity: {
		type: "number",
		"property-type": "data-constant",
		default: .5,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	}
}, Ss = {
	"sky-color": {
		type: "color",
		"property-type": "data-constant",
		default: "#88C6FC",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"horizon-color": {
		type: "color",
		"property-type": "data-constant",
		default: "#ffffff",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"fog-color": {
		type: "color",
		"property-type": "data-constant",
		default: "#ffffff",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"fog-ground-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .5,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"horizon-fog-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .8,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"sky-horizon-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .8,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	},
	"atmosphere-blend": {
		type: "number",
		"property-type": "data-constant",
		default: .8,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		transition: !0
	}
}, xs = {
	source: {
		type: "string",
		required: !0
	},
	exaggeration: {
		type: "number",
		minimum: 0,
		default: 1
	}
}, ks = { type: {
	type: "projectionDefinition",
	default: "mercator",
	"property-type": "data-constant",
	transition: !1,
	expression: {
		interpolated: !0,
		parameters: ["zoom"]
	}
} }, Ls = [
	"paint_fill",
	"paint_line",
	"paint_circle",
	"paint_heatmap",
	"paint_fill-extrusion",
	"paint_symbol",
	"paint_raster",
	"paint_hillshade",
	"paint_color-relief",
	"paint_background"
], Cs = {
	"fill-antialias": {
		type: "boolean",
		default: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"fill-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: [{ "!": "fill-pattern" }],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-outline-color": {
		type: "color",
		transition: !0,
		requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"fill-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["fill-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"fill-pattern": {
		type: "resolvedImage",
		transition: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "cross-faded-data-driven"
	}
}, Es = {
	"line-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: [{ "!": "line-pattern" }],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["line-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"line-width": {
		type: "number",
		default: 1,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-gap-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-offset": {
		type: "number",
		default: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-blur": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-dasharray": {
		type: "array",
		value: "number",
		minimum: 0,
		transition: !0,
		units: "line widths",
		requires: [{ "!": "line-pattern" }],
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "cross-faded-data-driven"
	},
	"line-pattern": {
		type: "resolvedImage",
		transition: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom", "feature"]
		},
		"property-type": "cross-faded-data-driven"
	},
	"line-gradient": {
		type: "color",
		transition: !1,
		requires: [
			{ "!": "line-dasharray" },
			{ "!": "line-pattern" },
			{
				source: "geojson",
				has: { lineMetrics: !0 }
			}
		],
		expression: {
			interpolated: !0,
			parameters: ["line-progress"]
		},
		"property-type": "color-ramp"
	}
}, As = {
	"circle-radius": {
		type: "number",
		default: 5,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-blur": {
		type: "number",
		default: 0,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["circle-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-pitch-scale": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-pitch-alignment": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "viewport",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"circle-stroke-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-stroke-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-stroke-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	}
}, Ts = {
	"heatmap-radius": {
		type: "number",
		default: 30,
		minimum: 1,
		transition: !0,
		units: "pixels",
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"heatmap-weight": {
		type: "number",
		default: 1,
		minimum: 0,
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"heatmap-intensity": {
		type: "number",
		default: 1,
		minimum: 0,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"heatmap-color": {
		type: "color",
		default: [
			"interpolate",
			["linear"],
			["heatmap-density"],
			0,
			"rgba(0, 0, 255, 0)",
			.1,
			"royalblue",
			.3,
			"cyan",
			.5,
			"lime",
			.7,
			"yellow",
			1,
			"red"
		],
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: ["heatmap-density"]
		},
		"property-type": "color-ramp"
	},
	"heatmap-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, _s = {
	"icon-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-color": {
		type: "color",
		default: "rgba(0, 0, 0, 0)",
		transition: !0,
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-blur": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		requires: ["icon-image"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"icon-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["icon-image", "icon-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		overridable: !0,
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-color": {
		type: "color",
		default: "rgba(0, 0, 0, 0)",
		transition: !0,
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-width": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-blur": {
		type: "number",
		default: 0,
		minimum: 0,
		transition: !0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-translate": {
		type: "array",
		value: "number",
		length: 2,
		default: [0, 0],
		transition: !0,
		units: "pixels",
		requires: ["text-field"],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"text-translate-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "map",
		requires: ["text-field", "text-translate"],
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, Is = {
	"raster-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-hue-rotate": {
		type: "number",
		default: 0,
		period: 360,
		transition: !0,
		units: "degrees",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-brightness-min": {
		type: "number",
		default: 0,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-brightness-max": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-saturation": {
		type: "number",
		default: 0,
		minimum: -1,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-contrast": {
		type: "number",
		default: 0,
		minimum: -1,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-resampling": {
		type: "enum",
		values: {
			linear: {},
			nearest: {}
		},
		default: "linear",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"raster-fade-duration": {
		type: "number",
		default: 300,
		minimum: 0,
		transition: !1,
		units: "milliseconds",
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, Ms = {
	"hillshade-illumination-direction": {
		type: "numberArray",
		default: 335,
		minimum: 0,
		maximum: 359,
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-illumination-altitude": {
		type: "numberArray",
		default: 45,
		minimum: 0,
		maximum: 90,
		transition: !1,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-illumination-anchor": {
		type: "enum",
		values: {
			map: {},
			viewport: {}
		},
		default: "viewport",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-exaggeration": {
		type: "number",
		default: .5,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-shadow-color": {
		type: "colorArray",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-highlight-color": {
		type: "colorArray",
		default: "#FFFFFF",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-accent-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"hillshade-method": {
		type: "enum",
		values: {
			standard: {},
			basic: {},
			combined: {},
			igor: {},
			multidirectional: {}
		},
		default: "standard",
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, Ps = {
	"background-color": {
		type: "color",
		default: "#000000",
		transition: !0,
		requires: [{ "!": "background-pattern" }],
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	},
	"background-pattern": {
		type: "resolvedImage",
		transition: !0,
		expression: {
			interpolated: !1,
			parameters: ["zoom"]
		},
		"property-type": "cross-faded"
	},
	"background-opacity": {
		type: "number",
		default: 1,
		minimum: 0,
		maximum: 1,
		transition: !0,
		expression: {
			interpolated: !0,
			parameters: ["zoom"]
		},
		"property-type": "data-constant"
	}
}, Rs = {
	duration: {
		type: "number",
		default: 300,
		minimum: 0,
		units: "milliseconds"
	},
	delay: {
		type: "number",
		default: 0,
		minimum: 0,
		units: "milliseconds"
	}
}, zs = { "*": { type: "string" } }, Os = {
	$version: Xi,
	$root: Yi,
	sources: Wi,
	source: Ji,
	source_vector: Qi,
	source_raster: es,
	source_raster_dem: ts,
	source_geojson: rs,
	source_video: ns,
	source_image: as,
	layer: os,
	layout: is,
	layout_background: ss,
	layout_fill: ls,
	layout_circle: us,
	layout_heatmap: cs,
	"layout_fill-extrusion": { visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	} },
	layout_line: ps,
	layout_symbol: fs,
	layout_raster: ds,
	layout_hillshade: hs,
	"layout_color-relief": { visibility: {
		type: "enum",
		values: {
			visible: {},
			none: {}
		},
		default: "visible",
		"property-type": "constant"
	} },
	filter: ms,
	filter_operator: ys,
	geometry_type: gs,
	function: {
		expression: { type: "expression" },
		stops: {
			type: "array",
			value: "function_stop"
		},
		base: {
			type: "number",
			default: 1,
			minimum: 0
		},
		property: {
			type: "string",
			default: "$zoom"
		},
		type: {
			type: "enum",
			values: {
				identity: {},
				exponential: {},
				interval: {},
				categorical: {}
			},
			default: "exponential"
		},
		colorSpace: {
			type: "enum",
			values: {
				rgb: {},
				lab: {},
				hcl: {}
			},
			default: "rgb"
		},
		default: {
			type: "*",
			required: !1
		}
	},
	function_stop: vs,
	expression: bs,
	light: ws,
	sky: Ss,
	terrain: xs,
	projection: ks,
	paint: Ls,
	paint_fill: Cs,
	"paint_fill-extrusion": {
		"fill-extrusion-opacity": {
			type: "number",
			default: 1,
			minimum: 0,
			maximum: 1,
			transition: !0,
			expression: {
				interpolated: !0,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-color": {
			type: "color",
			default: "#000000",
			transition: !0,
			requires: [{ "!": "fill-extrusion-pattern" }],
			expression: {
				interpolated: !0,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-translate": {
			type: "array",
			value: "number",
			length: 2,
			default: [0, 0],
			transition: !0,
			units: "pixels",
			expression: {
				interpolated: !0,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-translate-anchor": {
			type: "enum",
			values: {
				map: {},
				viewport: {}
			},
			default: "map",
			requires: ["fill-extrusion-translate"],
			expression: {
				interpolated: !1,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"fill-extrusion-pattern": {
			type: "resolvedImage",
			transition: !0,
			expression: {
				interpolated: !1,
				parameters: ["zoom", "feature"]
			},
			"property-type": "cross-faded-data-driven"
		},
		"fill-extrusion-height": {
			type: "number",
			default: 0,
			minimum: 0,
			units: "meters",
			transition: !0,
			expression: {
				interpolated: !0,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-base": {
			type: "number",
			default: 0,
			minimum: 0,
			units: "meters",
			transition: !0,
			requires: ["fill-extrusion-height"],
			expression: {
				interpolated: !0,
				parameters: [
					"zoom",
					"feature",
					"feature-state"
				]
			},
			"property-type": "data-driven"
		},
		"fill-extrusion-vertical-gradient": {
			type: "boolean",
			default: !0,
			transition: !1,
			expression: {
				interpolated: !1,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		}
	},
	paint_line: Es,
	paint_circle: As,
	paint_heatmap: Ts,
	paint_symbol: _s,
	paint_raster: Is,
	paint_hillshade: Ms,
	"paint_color-relief": {
		"color-relief-opacity": {
			type: "number",
			default: 1,
			minimum: 0,
			maximum: 1,
			transition: !0,
			expression: {
				interpolated: !0,
				parameters: ["zoom"]
			},
			"property-type": "data-constant"
		},
		"color-relief-color": {
			type: "color",
			transition: !1,
			expression: {
				interpolated: !0,
				parameters: ["elevation"]
			},
			"property-type": "color-ramp"
		}
	},
	paint_background: Ps,
	transition: Rs,
	"property-type": {
		"data-driven": { type: "property-type" },
		"cross-faded": { type: "property-type" },
		"cross-faded-data-driven": { type: "property-type" },
		"color-ramp": { type: "property-type" },
		"data-constant": { type: "property-type" },
		constant: { type: "property-type" }
	},
	promoteId: zs
};
var w = class {
	constructor(e, t, n, a) {
		this.message = (e ? `${e}: ` : "") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);
	}
};
function qt(r, ...e) {
	for (const t of e) for (const n in t) r[n] = t[n];
	return r;
}
var ve = class extends Error {
	constructor(e, t) {
		super(t), this.message = t, this.key = e;
	}
};
var sn = class sn {
	constructor(e, t = []) {
		this.parent = e, this.bindings = {};
		for (const [n, a] of t) this.bindings[n] = a;
	}
	concat(e) {
		return new sn(this, e);
	}
	get(e) {
		if (this.bindings[e]) return this.bindings[e];
		if (this.parent) return this.parent.get(e);
		throw new Error(`${e} not found in scope.`);
	}
	has(e) {
		return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;
	}
};
var er = { kind: "null" }, S = { kind: "number" }, P = { kind: "string" }, M = { kind: "boolean" }, be = { kind: "color" }, tr = { kind: "projectionDefinition" }, De = { kind: "object" }, I = { kind: "value" }, Fs = { kind: "error" }, rr = { kind: "collator" }, nr = { kind: "formatted" }, ar = { kind: "padding" }, yt = { kind: "colorArray" }, or = { kind: "numberArray" }, Tt = { kind: "resolvedImage" }, ir = { kind: "variableAnchorOffsetCollection" };
function ae(r, e) {
	return {
		kind: "array",
		itemType: r,
		N: e
	};
}
function D(r) {
	if (r.kind === "array") {
		const e = D(r.itemType);
		return typeof r.N == "number" ? `array<${e}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${e}>`;
	} else return r.kind;
}
var $s = [
	er,
	S,
	P,
	M,
	be,
	tr,
	nr,
	De,
	ae(I),
	ar,
	or,
	yt,
	Tt,
	ir
];
function gt(r, e) {
	if (e.kind === "error") return null;
	if (r.kind === "array") {
		if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !gt(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N)) return null;
	} else {
		if (r.kind === e.kind) return null;
		if (r.kind === "value") {
			for (const t of $s) if (!gt(t, e)) return null;
		}
	}
	return `Expected ${D(r)} but found ${D(e)} instead.`;
}
function ln(r, e) {
	return e.some((t) => t.kind === r.kind);
}
function Ue(r, e) {
	return e.some((t) => t === "null" ? r === null : t === "array" ? Array.isArray(r) : t === "object" ? r && !Array.isArray(r) && typeof r == "object" : t === typeof r);
}
function Ae(r, e) {
	return r.kind === "array" && e.kind === "array" ? r.itemType.kind === e.itemType.kind && typeof r.N == "number" : r.kind === e.kind;
}
var Ua = .96422, Ba = 1, qa = .82521, Va = 4 / 29, rt = 6 / 29, Ga = 3 * rt * rt, Ns = rt * rt * rt, js = Math.PI / 180, Ds = 180 / Math.PI;
function Ha(r) {
	return r = r % 360, r < 0 && (r += 360), r;
}
function Za([r, e, t, n]) {
	r = Sr(r), e = Sr(e), t = Sr(t);
	let a, o;
	const i = xr((.2225045 * r + .7168786 * e + .0606169 * t) / Ba);
	r === e && e === t ? a = o = i : (a = xr((.4360747 * r + .3850649 * e + .1430804 * t) / Ua), o = xr((.0139322 * r + .0971045 * e + .7141733 * t) / qa));
	const s = 116 * i - 16;
	return [
		s < 0 ? 0 : s,
		500 * (a - i),
		200 * (i - o),
		n
	];
}
function Sr(r) {
	return r <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
}
function xr(r) {
	return r > Ns ? Math.pow(r, 1 / 3) : r / Ga + Va;
}
function Ka([r, e, t, n]) {
	let a = (r + 16) / 116, o = isNaN(e) ? a : a + e / 500, i = isNaN(t) ? a : a - t / 200;
	return a = Ba * Lr(a), o = Ua * Lr(o), i = qa * Lr(i), [
		kr(3.1338561 * o - 1.6168667 * a - .4906146 * i),
		kr(-.9787684 * o + 1.9161415 * a + .033454 * i),
		kr(.0719453 * o - .2289914 * a + 1.4052427 * i),
		n
	];
}
function kr(r) {
	return r = r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055, r < 0 ? 0 : r > 1 ? 1 : r;
}
function Lr(r) {
	return r > rt ? r * r * r : Ga * (r - Va);
}
function Us(r) {
	const [e, t, n, a] = Za(r), o = Math.sqrt(t * t + n * n);
	return [
		Math.round(o * 1e4) ? Ha(Math.atan2(n, t) * Ds) : NaN,
		o,
		e,
		a
	];
}
function Bs([r, e, t, n]) {
	return r = isNaN(r) ? 0 : r * js, Ka([
		t,
		Math.cos(r) * e,
		Math.sin(r) * e,
		n
	]);
}
function qs([r, e, t, n]) {
	r = Ha(r), e /= 100, t /= 100;
	function a(o) {
		const i = (o + r / 30) % 12, s = e * Math.min(t, 1 - t);
		return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));
	}
	return [
		a(0),
		a(8),
		a(4),
		n
	];
}
var Vs = Object.hasOwn || function(e, t) {
	return Object.prototype.hasOwnProperty.call(e, t);
};
function dt(r, e) {
	return Vs(r, e) ? r[e] : void 0;
}
function Gs(r) {
	if (r = r.toLowerCase().trim(), r === "transparent") return [
		0,
		0,
		0,
		0
	];
	const e = dt(Hs, r);
	if (e) {
		const [a, o, i] = e;
		return [
			a / 255,
			o / 255,
			i / 255,
			1
		];
	}
	if (r.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {
		const o = r.length < 6 ? 1 : 2;
		let i = 1;
		return [
			Rt(r.slice(i, i += o)),
			Rt(r.slice(i, i += o)),
			Rt(r.slice(i, i += o)),
			Rt(r.slice(i, i + o) || "ff")
		];
	}
	if (r.startsWith("rgb")) {
		const o = r.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
		if (o) {
			const [i, s, l, u, c, p, d, f, h, m, y, b] = o, v = [
				u || " ",
				d || " ",
				m
			].join("");
			if (v === "  " || v === "  /" || v === ",," || v === ",,,") {
				const x = [
					l,
					p,
					h
				].join(""), E = x === "%%%" ? 100 : x === "" ? 255 : 0;
				if (E) {
					const C = [
						Qe(+s / E, 0, 1),
						Qe(+c / E, 0, 1),
						Qe(+f / E, 0, 1),
						y ? qn(+y, b) : 1
					];
					if (Vn(C)) return C;
				}
			}
			return;
		}
	}
	const n = r.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
	if (n) {
		const [a, o, i, s, l, u, c, p, d] = n, f = [
			i || " ",
			l || " ",
			c
		].join("");
		if (f === "  " || f === "  /" || f === ",," || f === ",,,") {
			const h = [
				+o,
				Qe(+s, 0, 100),
				Qe(+u, 0, 100),
				p ? qn(+p, d) : 1
			];
			if (Vn(h)) return qs(h);
		}
	}
}
function Rt(r) {
	return parseInt(r.padEnd(2, r), 16) / 255;
}
function qn(r, e) {
	return Qe(e ? r / 100 : r, 0, 1);
}
function Qe(r, e, t) {
	return Math.min(Math.max(e, r), t);
}
function Vn(r) {
	return !r.some(Number.isNaN);
}
var Hs = {
	aliceblue: [
		240,
		248,
		255
	],
	antiquewhite: [
		250,
		235,
		215
	],
	aqua: [
		0,
		255,
		255
	],
	aquamarine: [
		127,
		255,
		212
	],
	azure: [
		240,
		255,
		255
	],
	beige: [
		245,
		245,
		220
	],
	bisque: [
		255,
		228,
		196
	],
	black: [
		0,
		0,
		0
	],
	blanchedalmond: [
		255,
		235,
		205
	],
	blue: [
		0,
		0,
		255
	],
	blueviolet: [
		138,
		43,
		226
	],
	brown: [
		165,
		42,
		42
	],
	burlywood: [
		222,
		184,
		135
	],
	cadetblue: [
		95,
		158,
		160
	],
	chartreuse: [
		127,
		255,
		0
	],
	chocolate: [
		210,
		105,
		30
	],
	coral: [
		255,
		127,
		80
	],
	cornflowerblue: [
		100,
		149,
		237
	],
	cornsilk: [
		255,
		248,
		220
	],
	crimson: [
		220,
		20,
		60
	],
	cyan: [
		0,
		255,
		255
	],
	darkblue: [
		0,
		0,
		139
	],
	darkcyan: [
		0,
		139,
		139
	],
	darkgoldenrod: [
		184,
		134,
		11
	],
	darkgray: [
		169,
		169,
		169
	],
	darkgreen: [
		0,
		100,
		0
	],
	darkgrey: [
		169,
		169,
		169
	],
	darkkhaki: [
		189,
		183,
		107
	],
	darkmagenta: [
		139,
		0,
		139
	],
	darkolivegreen: [
		85,
		107,
		47
	],
	darkorange: [
		255,
		140,
		0
	],
	darkorchid: [
		153,
		50,
		204
	],
	darkred: [
		139,
		0,
		0
	],
	darksalmon: [
		233,
		150,
		122
	],
	darkseagreen: [
		143,
		188,
		143
	],
	darkslateblue: [
		72,
		61,
		139
	],
	darkslategray: [
		47,
		79,
		79
	],
	darkslategrey: [
		47,
		79,
		79
	],
	darkturquoise: [
		0,
		206,
		209
	],
	darkviolet: [
		148,
		0,
		211
	],
	deeppink: [
		255,
		20,
		147
	],
	deepskyblue: [
		0,
		191,
		255
	],
	dimgray: [
		105,
		105,
		105
	],
	dimgrey: [
		105,
		105,
		105
	],
	dodgerblue: [
		30,
		144,
		255
	],
	firebrick: [
		178,
		34,
		34
	],
	floralwhite: [
		255,
		250,
		240
	],
	forestgreen: [
		34,
		139,
		34
	],
	fuchsia: [
		255,
		0,
		255
	],
	gainsboro: [
		220,
		220,
		220
	],
	ghostwhite: [
		248,
		248,
		255
	],
	gold: [
		255,
		215,
		0
	],
	goldenrod: [
		218,
		165,
		32
	],
	gray: [
		128,
		128,
		128
	],
	green: [
		0,
		128,
		0
	],
	greenyellow: [
		173,
		255,
		47
	],
	grey: [
		128,
		128,
		128
	],
	honeydew: [
		240,
		255,
		240
	],
	hotpink: [
		255,
		105,
		180
	],
	indianred: [
		205,
		92,
		92
	],
	indigo: [
		75,
		0,
		130
	],
	ivory: [
		255,
		255,
		240
	],
	khaki: [
		240,
		230,
		140
	],
	lavender: [
		230,
		230,
		250
	],
	lavenderblush: [
		255,
		240,
		245
	],
	lawngreen: [
		124,
		252,
		0
	],
	lemonchiffon: [
		255,
		250,
		205
	],
	lightblue: [
		173,
		216,
		230
	],
	lightcoral: [
		240,
		128,
		128
	],
	lightcyan: [
		224,
		255,
		255
	],
	lightgoldenrodyellow: [
		250,
		250,
		210
	],
	lightgray: [
		211,
		211,
		211
	],
	lightgreen: [
		144,
		238,
		144
	],
	lightgrey: [
		211,
		211,
		211
	],
	lightpink: [
		255,
		182,
		193
	],
	lightsalmon: [
		255,
		160,
		122
	],
	lightseagreen: [
		32,
		178,
		170
	],
	lightskyblue: [
		135,
		206,
		250
	],
	lightslategray: [
		119,
		136,
		153
	],
	lightslategrey: [
		119,
		136,
		153
	],
	lightsteelblue: [
		176,
		196,
		222
	],
	lightyellow: [
		255,
		255,
		224
	],
	lime: [
		0,
		255,
		0
	],
	limegreen: [
		50,
		205,
		50
	],
	linen: [
		250,
		240,
		230
	],
	magenta: [
		255,
		0,
		255
	],
	maroon: [
		128,
		0,
		0
	],
	mediumaquamarine: [
		102,
		205,
		170
	],
	mediumblue: [
		0,
		0,
		205
	],
	mediumorchid: [
		186,
		85,
		211
	],
	mediumpurple: [
		147,
		112,
		219
	],
	mediumseagreen: [
		60,
		179,
		113
	],
	mediumslateblue: [
		123,
		104,
		238
	],
	mediumspringgreen: [
		0,
		250,
		154
	],
	mediumturquoise: [
		72,
		209,
		204
	],
	mediumvioletred: [
		199,
		21,
		133
	],
	midnightblue: [
		25,
		25,
		112
	],
	mintcream: [
		245,
		255,
		250
	],
	mistyrose: [
		255,
		228,
		225
	],
	moccasin: [
		255,
		228,
		181
	],
	navajowhite: [
		255,
		222,
		173
	],
	navy: [
		0,
		0,
		128
	],
	oldlace: [
		253,
		245,
		230
	],
	olive: [
		128,
		128,
		0
	],
	olivedrab: [
		107,
		142,
		35
	],
	orange: [
		255,
		165,
		0
	],
	orangered: [
		255,
		69,
		0
	],
	orchid: [
		218,
		112,
		214
	],
	palegoldenrod: [
		238,
		232,
		170
	],
	palegreen: [
		152,
		251,
		152
	],
	paleturquoise: [
		175,
		238,
		238
	],
	palevioletred: [
		219,
		112,
		147
	],
	papayawhip: [
		255,
		239,
		213
	],
	peachpuff: [
		255,
		218,
		185
	],
	peru: [
		205,
		133,
		63
	],
	pink: [
		255,
		192,
		203
	],
	plum: [
		221,
		160,
		221
	],
	powderblue: [
		176,
		224,
		230
	],
	purple: [
		128,
		0,
		128
	],
	rebeccapurple: [
		102,
		51,
		153
	],
	red: [
		255,
		0,
		0
	],
	rosybrown: [
		188,
		143,
		143
	],
	royalblue: [
		65,
		105,
		225
	],
	saddlebrown: [
		139,
		69,
		19
	],
	salmon: [
		250,
		128,
		114
	],
	sandybrown: [
		244,
		164,
		96
	],
	seagreen: [
		46,
		139,
		87
	],
	seashell: [
		255,
		245,
		238
	],
	sienna: [
		160,
		82,
		45
	],
	silver: [
		192,
		192,
		192
	],
	skyblue: [
		135,
		206,
		235
	],
	slateblue: [
		106,
		90,
		205
	],
	slategray: [
		112,
		128,
		144
	],
	slategrey: [
		112,
		128,
		144
	],
	snow: [
		255,
		250,
		250
	],
	springgreen: [
		0,
		255,
		127
	],
	steelblue: [
		70,
		130,
		180
	],
	tan: [
		210,
		180,
		140
	],
	teal: [
		0,
		128,
		128
	],
	thistle: [
		216,
		191,
		216
	],
	tomato: [
		255,
		99,
		71
	],
	turquoise: [
		64,
		224,
		208
	],
	violet: [
		238,
		130,
		238
	],
	wheat: [
		245,
		222,
		179
	],
	white: [
		255,
		255,
		255
	],
	whitesmoke: [
		245,
		245,
		245
	],
	yellow: [
		255,
		255,
		0
	],
	yellowgreen: [
		154,
		205,
		50
	]
};
function Be(r, e, t) {
	return r + t * (e - r);
}
function vt(r, e, t) {
	return r.map((n, a) => Be(n, e[a], t));
}
var $ = class $ {
	/**
	* @param r Red component premultiplied by `alpha` 0..1
	* @param g Green component premultiplied by `alpha` 0..1
	* @param b Blue component premultiplied by `alpha` 0..1
	* @param [alpha=1] Alpha component 0..1
	* @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
	* been multiplied by alpha. If `true` nothing happens if `false` then they will
	* be multiplied automatically.
	*/
	constructor(e, t, n, a = 1, o = !0) {
		this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter("rgb", [
			e,
			t,
			n,
			a
		]));
	}
	/**
	* Parses CSS color strings and converts colors to sRGB color space if needed.
	* Officially supported color formats:
	* - keyword, e.g. 'aquamarine' or 'steelblue'
	* - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
	* - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
	* - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
	*
	* @param input CSS color string to parse.
	* @returns A `Color` instance, or `undefined` if the input is not a valid color string.
	*/
	static parse(e) {
		if (e instanceof $) return e;
		if (typeof e != "string") return;
		const t = Gs(e);
		if (t) return new $(...t, !1);
	}
	/**
	* Used in color interpolation and by 'to-rgba' expression.
	*
	* @returns Gien color, with reversed alpha blending, in sRGB color space.
	*/
	get rgb() {
		const { r: e, g: t, b: n, a } = this, o = a || Infinity;
		return this.overwriteGetter("rgb", [
			e / o,
			t / o,
			n / o,
			a
		]);
	}
	/**
	* Used in color interpolation.
	*
	* @returns Gien color, with reversed alpha blending, in HCL color space.
	*/
	get hcl() {
		return this.overwriteGetter("hcl", Us(this.rgb));
	}
	/**
	* Used in color interpolation.
	*
	* @returns Gien color, with reversed alpha blending, in LAB color space.
	*/
	get lab() {
		return this.overwriteGetter("lab", Za(this.rgb));
	}
	/**
	* Lazy getter pattern. When getter is called for the first time lazy value
	* is calculated and then overwrites getter function in given object instance.
	*
	* @example:
	* const redColor = Color.parse('red');
	* let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
	* // the value of red in HCL space and invoke this `overwriteGetter` function
	* // which in turn will set a field with a key 'hcl' in the `redColor` object.
	* // In other words it will override `get hcl()` from its `Color` prototype
	* // with its own property: hcl = [calculated red value in hcl].
	* let y = redColor.hcl; // next call will no longer invoke getter but simply
	* // return the previously calculated value
	* x === y; // true - `x` is exactly the same object as `y`
	*
	* @param getterKey Getter key
	* @param lazyValue Lazily calculated value to be memoized by current instance
	* @private
	*/
	overwriteGetter(e, t) {
		return Object.defineProperty(this, e, { value: t }), t;
	}
	/**
	* Used by 'to-string' expression.
	*
	* @returns Serialized color in format `rgba(r,g,b,a)`
	* where r,g,b are numbers within 0..255 and alpha is number within 1..0
	*
	* @example
	* var purple = new Color.parse('purple');
	* purple.toString; // = "rgba(128,0,128,1)"
	* var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
	* translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
	*/
	toString() {
		const [e, t, n, a] = this.rgb;
		return `rgba(${[
			e,
			t,
			n
		].map((o) => Math.round(o * 255)).join(",")},${a})`;
	}
	static interpolate(e, t, n, a = "rgb") {
		switch (a) {
			case "rgb": {
				const [o, i, s, l] = vt(e.rgb, t.rgb, n);
				return new $(o, i, s, l, !1);
			}
			case "hcl": {
				const [o, i, s, l] = e.hcl, [u, c, p, d] = t.hcl;
				let f, h;
				if (!isNaN(o) && !isNaN(u)) {
					let x = u - o;
					u > o && x > 180 ? x -= 360 : u < o && o - u > 180 && (x += 360), f = o + n * x;
				} else isNaN(o) ? isNaN(u) ? f = NaN : (f = u, (s === 1 || s === 0) && (h = c)) : (f = o, (p === 1 || p === 0) && (h = i));
				const [m, y, b, v] = Bs([
					f,
					h ?? Be(i, c, n),
					Be(s, p, n),
					Be(l, d, n)
				]);
				return new $(m, y, b, v, !1);
			}
			case "lab": {
				const [o, i, s, l] = Ka(vt(e.lab, t.lab, n));
				return new $(o, i, s, l, !1);
			}
		}
	}
};
$.black = new $(0, 0, 0, 1);
$.white = new $(1, 1, 1, 1);
$.transparent = new $(0, 0, 0, 0);
$.red = new $(1, 0, 0, 1);
var un = class {
	constructor(e, t, n) {
		e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
			sensitivity: this.sensitivity,
			usage: "search"
		});
	}
	compare(e, t) {
		return this.collator.compare(e, t);
	}
	resolvedLocale() {
		return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
	}
};
var Zs = [
	"bottom",
	"center",
	"top"
];
var Dr = class {
	constructor(e, t, n, a, o, i) {
		this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o, this.verticalAlign = i;
	}
};
var Le = class Le {
	constructor(e) {
		this.sections = e;
	}
	static fromString(e) {
		return new Le([new Dr(e, null, null, null, null, null)]);
	}
	isEmpty() {
		return this.sections.length === 0 ? !0 : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
	}
	static factory(e) {
		return e instanceof Le ? e : Le.fromString(e);
	}
	toString() {
		return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
	}
};
var fe = class fe {
	constructor(e) {
		this.values = e.slice();
	}
	/**
	* Numeric padding values
	* @param input A padding value
	* @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
	*/
	static parse(e) {
		if (e instanceof fe) return e;
		if (typeof e == "number") return new fe([
			e,
			e,
			e,
			e
		]);
		if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
			for (const t of e) if (typeof t != "number") return;
			switch (e.length) {
				case 1:
					e = [
						e[0],
						e[0],
						e[0],
						e[0]
					];
					break;
				case 2:
					e = [
						e[0],
						e[1],
						e[0],
						e[1]
					];
					break;
				case 3:
					e = [
						e[0],
						e[1],
						e[2],
						e[1]
					];
					break;
			}
			return new fe(e);
		}
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n) {
		return new fe(vt(e.values, t.values, n));
	}
};
var de = class de {
	constructor(e) {
		this.values = e.slice();
	}
	/**
	* Numeric NumberArray values
	* @param input A NumberArray value
	* @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.
	*/
	static parse(e) {
		if (e instanceof de) return e;
		if (typeof e == "number") return new de([e]);
		if (Array.isArray(e)) {
			for (const t of e) if (typeof t != "number") return;
			return new de(e);
		}
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n) {
		return new de(vt(e.values, t.values, n));
	}
};
var oe = class oe {
	constructor(e) {
		this.values = e.slice();
	}
	/**
	* ColorArray values
	* @param input A ColorArray value
	* @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.
	*/
	static parse(e) {
		if (e instanceof oe) return e;
		if (typeof e == "string") {
			const n = $.parse(e);
			return n ? new oe([n]) : void 0;
		}
		if (!Array.isArray(e)) return;
		const t = [];
		for (const n of e) {
			if (typeof n != "string") return;
			const a = $.parse(n);
			if (!a) return;
			t.push(a);
		}
		return new oe(t);
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n, a = "rgb") {
		const o = [];
		if (e.values.length != t.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);
		for (let i = 0; i < e.values.length; i++) o.push($.interpolate(e.values[i], t.values[i], n, a));
		return new oe(o);
	}
};
var V = class extends Error {
	constructor(e) {
		super(e), this.name = "RuntimeError";
	}
	toJSON() {
		return this.message;
	}
};
var Ks = /* @__PURE__ */ new Set([
	"center",
	"left",
	"right",
	"top",
	"bottom",
	"top-left",
	"top-right",
	"bottom-left",
	"bottom-right"
]);
var we = class we {
	constructor(e) {
		this.values = e.slice();
	}
	static parse(e) {
		if (e instanceof we) return e;
		if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
			for (let t = 0; t < e.length; t += 2) {
				const n = e[t], a = e[t + 1];
				if (typeof n != "string" || !Ks.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != "number" || typeof a[1] != "number") return;
			}
			return new we(e);
		}
	}
	toString() {
		return JSON.stringify(this.values);
	}
	static interpolate(e, t, n) {
		const a = e.values, o = t.values;
		if (a.length !== o.length) throw new V(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
		const i = [];
		for (let s = 0; s < a.length; s += 2) {
			if (a[s] !== o[s]) throw new V(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);
			i.push(a[s]);
			const [l, u] = a[s + 1], [c, p] = o[s + 1];
			i.push([Be(l, c, n), Be(u, p, n)]);
		}
		return new we(i);
	}
};
var Fe = class Fe {
	constructor(e) {
		this.name = e.name, this.available = e.available;
	}
	toString() {
		return this.name;
	}
	static fromString(e) {
		return e ? new Fe({
			name: e,
			available: !1
		}) : null;
	}
};
var ce = class ce {
	constructor(e, t, n) {
		this.from = e, this.to = t, this.transition = n;
	}
	static interpolate(e, t, n) {
		return new ce(e, t, n);
	}
	static parse(e) {
		if (e instanceof ce) return e;
		if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number") return new ce(e[0], e[1], e[2]);
		if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number") return new ce(e.from, e.to, e.transition);
		if (typeof e == "string") return new ce(e, e, 1);
	}
};
function Xa(r, e, t, n) {
	return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
		r,
		e,
		t,
		n
	].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [
		r,
		e,
		t,
		n
	] : [
		r,
		e,
		t
	]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function bt(r) {
	if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof ce || r instanceof $ || r instanceof un || r instanceof Le || r instanceof fe || r instanceof de || r instanceof oe || r instanceof we || r instanceof Fe) return !0;
	if (Array.isArray(r)) {
		for (const e of r) if (!bt(e)) return !1;
		return !0;
	} else if (typeof r == "object") {
		for (const e in r) if (!bt(r[e])) return !1;
		return !0;
	} else return !1;
}
function H(r) {
	if (r === null) return er;
	if (typeof r == "string") return P;
	if (typeof r == "boolean") return M;
	if (typeof r == "number") return S;
	if (r instanceof $) return be;
	if (r instanceof ce) return tr;
	if (r instanceof un) return rr;
	if (r instanceof Le) return nr;
	if (r instanceof fe) return ar;
	if (r instanceof de) return or;
	if (r instanceof oe) return yt;
	if (r instanceof we) return ir;
	if (r instanceof Fe) return Tt;
	if (Array.isArray(r)) {
		const e = r.length;
		let t;
		for (const n of r) {
			const a = H(n);
			if (!t) t = a;
			else {
				if (t === a) continue;
				t = I;
				break;
			}
		}
		return ae(t || I, e);
	} else return De;
}
function ht(r) {
	const e = typeof r;
	return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof $ || r instanceof ce || r instanceof Le || r instanceof fe || r instanceof de || r instanceof oe || r instanceof we || r instanceof Fe ? r.toString() : JSON.stringify(r);
}
var ot = class ot {
	constructor(e, t) {
		this.type = e, this.value = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
		if (!bt(e[1])) return t.error("invalid value");
		const n = e[1];
		let a = H(n);
		const o = t.expectedType;
		return a.kind === "array" && a.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (a = o), new ot(a, n);
	}
	evaluate() {
		return this.value;
	}
	eachChild() {}
	outputDefined() {
		return !0;
	}
};
var zt = {
	string: P,
	number: S,
	boolean: M,
	object: De
};
var pe = class pe {
	constructor(e, t) {
		this.type = e, this.args = t;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		let n = 1, a;
		const o = e[0];
		if (o === "array") {
			let s;
			if (e.length > 2) {
				const u = e[1];
				if (typeof u != "string" || !(u in zt) || u === "object") return t.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
				s = zt[u], n++;
			} else s = I;
			let l;
			if (e.length > 3) {
				if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error("The length argument to \"array\" must be a positive integer literal", 2);
				l = e[2], n++;
			}
			a = ae(s, l);
		} else {
			if (!zt[o]) throw new Error(`Types doesn't contain name = ${o}`);
			a = zt[o];
		}
		const i = [];
		for (; n < e.length; n++) {
			const s = t.parse(e[n], n, I);
			if (!s) return null;
			i.push(s);
		}
		return new pe(a, i);
	}
	evaluate(e) {
		for (let t = 0; t < this.args.length; t++) {
			const n = this.args[t].evaluate(e);
			if (gt(this.type, H(n))) {
				if (t === this.args.length - 1) throw new V(`Expected value to be of type ${D(this.type)}, but found ${D(H(n))} instead.`);
			} else return n;
		}
		throw new Error();
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return this.args.every((e) => e.outputDefined());
	}
};
var Gn = {
	"to-boolean": M,
	"to-color": be,
	"to-number": S,
	"to-string": P
};
var Re = class Re {
	constructor(e, t) {
		this.type = e, this.args = t;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		const n = e[0];
		if (!Gn[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);
		if ((n === "to-boolean" || n === "to-string") && e.length !== 2) return t.error("Expected one argument.");
		const a = Gn[n], o = [];
		for (let i = 1; i < e.length; i++) {
			const s = t.parse(e[i], i, I);
			if (!s) return null;
			o.push(s);
		}
		return new Re(a, o);
	}
	evaluate(e) {
		switch (this.type.kind) {
			case "boolean": return !!this.args[0].evaluate(e);
			case "color": {
				let t, n;
				for (const a of this.args) {
					if (t = a.evaluate(e), n = null, t instanceof $) return t;
					if (typeof t == "string") {
						const o = e.parseColor(t);
						if (o) return o;
					} else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = Xa(t[0], t[1], t[2], t[3]), !n)) return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
				}
				throw new V(n || `Could not parse color from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "padding": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = fe.parse(t);
					if (a) return a;
				}
				throw new V(`Could not parse padding from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "numberArray": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = de.parse(t);
					if (a) return a;
				}
				throw new V(`Could not parse numberArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "colorArray": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = oe.parse(t);
					if (a) return a;
				}
				throw new V(`Could not parse colorArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "variableAnchorOffsetCollection": {
				let t;
				for (const n of this.args) {
					t = n.evaluate(e);
					const a = we.parse(t);
					if (a) return a;
				}
				throw new V(`Could not parse variableAnchorOffsetCollection from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
			}
			case "number": {
				let t = null;
				for (const n of this.args) {
					if (t = n.evaluate(e), t === null) return 0;
					const a = Number(t);
					if (!isNaN(a)) return a;
				}
				throw new V(`Could not convert ${JSON.stringify(t)} to number.`);
			}
			case "formatted": return Le.fromString(ht(this.args[0].evaluate(e)));
			case "resolvedImage": return Fe.fromString(ht(this.args[0].evaluate(e)));
			case "projectionDefinition": return this.args[0].evaluate(e);
			default: return ht(this.args[0].evaluate(e));
		}
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return this.args.every((e) => e.outputDefined());
	}
};
var Xs = [
	"Unknown",
	"Point",
	"LineString",
	"Polygon"
];
var Ya = class {
	constructor() {
		this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
	}
	id() {
		return this.feature && "id" in this.feature ? this.feature.id : null;
	}
	geometryType() {
		return this.feature ? typeof this.feature.type == "number" ? Xs[this.feature.type] : this.feature.type : null;
	}
	geometry() {
		return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
	}
	canonicalID() {
		return this.canonical;
	}
	properties() {
		return this.feature && this.feature.properties || {};
	}
	parseColor(e) {
		let t = this._parseColorCache.get(e);
		return t || (t = $.parse(e), this._parseColorCache.set(e, t)), t;
	}
};
var sr = class sr {
	constructor(e, t, n = [], a, o = new sn(), i = []) {
		this.registry = e, this.path = n, this.key = n.map((s) => `[${s}]`).join(""), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;
	}
	/**
	* @param expr the JSON expression to parse
	* @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
	* @param options
	* @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
	* @private
	*/
	parse(e, t, n, a, o = {}) {
		return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);
	}
	_parse(e, t) {
		(e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
		function n(a, o, i) {
			return i === "assert" ? new pe(o, [a]) : i === "coerce" ? new Re(o, [a]) : a;
		}
		if (Array.isArray(e)) {
			if (e.length === 0) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
			const a = e[0];
			if (typeof a != "string") return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
			const o = this.registry[a];
			if (o) {
				let i = o.parse(e, this);
				if (!i) return null;
				if (this.expectedType) {
					const s = this.expectedType, l = i.type;
					if ((s.kind === "string" || s.kind === "number" || s.kind === "boolean" || s.kind === "object" || s.kind === "array") && l.kind === "value") i = n(i, s, t.typeAnnotation || "assert");
					else if (s.kind === "projectionDefinition" && ["string", "array"].includes(l.kind) || [
						"color",
						"formatted",
						"resolvedImage"
					].includes(s.kind) && ["value", "string"].includes(l.kind) || ["padding", "numberArray"].includes(s.kind) && [
						"value",
						"number",
						"array"
					].includes(l.kind) || s.kind === "colorArray" && [
						"value",
						"string",
						"array"
					].includes(l.kind) || s.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(l.kind)) i = n(i, s, t.typeAnnotation || "coerce");
					else if (this.checkSubtype(s, l)) return null;
				}
				if (!(i instanceof ot) && i.type.kind !== "resolvedImage" && this._isConstant(i)) {
					const s = new Ya();
					try {
						i = new ot(i.type, i.evaluate(s));
					} catch (l) {
						return this.error(l.message), null;
					}
				}
				return i;
			}
			return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
		} else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error("Bare objects invalid. Use [\"literal\", {...}] instead.") : this.error(`Expected an array, but found ${typeof e} instead.`);
	}
	/**
	* Returns a copy of this context suitable for parsing the subexpression at
	* index `index`, optionally appending to 'let' binding map.
	*
	* Note that `errors` property, intended for collecting errors while
	* parsing, is copied by reference rather than cloned.
	* @private
	*/
	concat(e, t, n) {
		const a = typeof e == "number" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;
		return new sr(this.registry, this._isConstant, a, t || null, o, this.errors);
	}
	/**
	* Push a parsing (or type checking) error into the `this.errors`
	* @param error The message
	* @param keys Optionally specify the source of the error at a child
	* of the current expression at `this.key`.
	* @private
	*/
	error(e, ...t) {
		const n = `${this.key}${t.map((a) => `[${a}]`).join("")}`;
		this.errors.push(new ve(n, e));
	}
	/**
	* Returns null if `t` is a subtype of `expected`; otherwise returns an
	* error message and also pushes it to `this.errors`.
	* @param expected The expected type
	* @param t The actual type
	* @returns null if `t` is a subtype of `expected`; otherwise returns an error message
	*/
	checkSubtype(e, t) {
		const n = gt(e, t);
		return n && this.error(n), n;
	}
};
var lr = class lr {
	constructor(e, t) {
		this.type = t.type, this.bindings = [].concat(e), this.result = t;
	}
	evaluate(e) {
		return this.result.evaluate(e);
	}
	eachChild(e) {
		for (const t of this.bindings) e(t[1]);
		e(this.result);
	}
	static parse(e, t) {
		if (e.length < 4) return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
		const n = [];
		for (let o = 1; o < e.length - 1; o += 2) {
			const i = e[o];
			if (typeof i != "string") return t.error(`Expected string, but found ${typeof i} instead.`, o);
			if (/[^a-zA-Z0-9_]/.test(i)) return t.error("Variable names must contain only alphanumeric characters or '_'.", o);
			const s = t.parse(e[o + 1], o + 1);
			if (!s) return null;
			n.push([i, s]);
		}
		const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
		return a ? new lr(n, a) : null;
	}
	outputDefined() {
		return this.result.outputDefined();
	}
};
var ur = class ur {
	constructor(e, t) {
		this.type = t.type, this.name = e, this.boundExpression = t;
	}
	static parse(e, t) {
		if (e.length !== 2 || typeof e[1] != "string") return t.error("'var' expression requires exactly one string literal argument.");
		const n = e[1];
		return t.scope.has(n) ? new ur(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
	}
	evaluate(e) {
		return this.boundExpression.evaluate(e);
	}
	eachChild() {}
	outputDefined() {
		return !1;
	}
};
var cn = class cn {
	constructor(e, t, n) {
		this.type = e, this.index = t, this.input = n;
	}
	static parse(e, t) {
		if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, S), a = t.parse(e[2], 2, ae(t.expectedType || I));
		if (!n || !a) return null;
		const o = a.type;
		return new cn(o.itemType, n, a);
	}
	evaluate(e) {
		const t = this.index.evaluate(e), n = this.input.evaluate(e);
		if (t < 0) throw new V(`Array index out of bounds: ${t} < 0.`);
		if (t >= n.length) throw new V(`Array index out of bounds: ${t} > ${n.length - 1}.`);
		if (t !== Math.floor(t)) throw new V(`Array index must be an integer, but found ${t} instead.`);
		return n[t];
	}
	eachChild(e) {
		e(this.index), e(this.input);
	}
	outputDefined() {
		return !1;
	}
};
var pn = class pn {
	constructor(e, t) {
		this.type = M, this.needle = e, this.haystack = t;
	}
	static parse(e, t) {
		if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);
		return !n || !a ? null : ln(n.type, [
			M,
			P,
			S,
			er,
			I
		]) ? new pn(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
	}
	evaluate(e) {
		const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
		if (!n) return !1;
		if (!Ue(t, [
			"boolean",
			"string",
			"number",
			"null"
		])) throw new V(`Expected first argument to be of type boolean, string, number or null, but found ${D(H(t))} instead.`);
		if (!Ue(n, ["string", "array"])) throw new V(`Expected second argument to be of type array or string, but found ${D(H(n))} instead.`);
		return n.indexOf(t) >= 0;
	}
	eachChild(e) {
		e(this.needle), e(this.haystack);
	}
	outputDefined() {
		return !0;
	}
};
var Vt = class Vt {
	constructor(e, t, n) {
		this.type = S, this.needle = e, this.haystack = t, this.fromIndex = n;
	}
	static parse(e, t) {
		if (e.length <= 2 || e.length >= 5) return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);
		if (!n || !a) return null;
		if (!ln(n.type, [
			M,
			P,
			S,
			er,
			I
		])) return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
		if (e.length === 4) {
			const o = t.parse(e[3], 3, S);
			return o ? new Vt(n, a, o) : null;
		} else return new Vt(n, a);
	}
	evaluate(e) {
		const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
		if (!Ue(t, [
			"boolean",
			"string",
			"number",
			"null"
		])) throw new V(`Expected first argument to be of type boolean, string, number or null, but found ${D(H(t))} instead.`);
		let a;
		if (this.fromIndex && (a = this.fromIndex.evaluate(e)), Ue(n, ["string"])) {
			const o = n.indexOf(t, a);
			return o === -1 ? -1 : [...n.slice(0, o)].length;
		} else {
			if (Ue(n, ["array"])) return n.indexOf(t, a);
			throw new V(`Expected second argument to be of type array or string, but found ${D(H(n))} instead.`);
		}
	}
	eachChild(e) {
		e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
	}
	outputDefined() {
		return !1;
	}
};
var fn = class fn {
	constructor(e, t, n, a, o, i) {
		this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;
	}
	static parse(e, t) {
		if (e.length < 5) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
		if (e.length % 2 !== 1) return t.error("Expected an even number of arguments.");
		let n, a;
		t.expectedType && t.expectedType.kind !== "value" && (a = t.expectedType);
		const o = {}, i = [];
		for (let u = 2; u < e.length - 1; u += 2) {
			let c = e[u];
			const p = e[u + 1];
			Array.isArray(c) || (c = [c]);
			const d = t.concat(u);
			if (c.length === 0) return d.error("Expected at least one branch label.");
			for (const h of c) {
				if (typeof h != "number" && typeof h != "string") return d.error("Branch labels must be numbers or strings.");
				if (typeof h == "number" && Math.abs(h) > Number.MAX_SAFE_INTEGER) return d.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
				if (typeof h == "number" && Math.floor(h) !== h) return d.error("Numeric branch labels must be integer values.");
				if (!n) n = H(h);
				else if (d.checkSubtype(n, H(h))) return null;
				if (typeof o[String(h)] < "u") return d.error("Branch labels must be unique.");
				o[String(h)] = i.length;
			}
			const f = t.parse(p, u, a);
			if (!f) return null;
			a = a || f.type, i.push(f);
		}
		const s = t.parse(e[1], 1, I);
		if (!s) return null;
		const l = t.parse(e[e.length - 1], e.length - 1, a);
		return !l || s.type.kind !== "value" && t.concat(1).checkSubtype(n, s.type) ? null : new fn(n, a, s, o, i, l);
	}
	evaluate(e) {
		const t = this.input.evaluate(e);
		return (H(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
	}
	eachChild(e) {
		e(this.input), this.outputs.forEach(e), e(this.otherwise);
	}
	outputDefined() {
		return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
	}
};
var dn = class dn {
	constructor(e, t, n) {
		this.type = e, this.branches = t, this.otherwise = n;
	}
	static parse(e, t) {
		if (e.length < 4) return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
		if (e.length % 2 !== 0) return t.error("Expected an odd number of arguments.");
		let n;
		t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
		const a = [];
		for (let i = 1; i < e.length - 1; i += 2) {
			const s = t.parse(e[i], i, M);
			if (!s) return null;
			const l = t.parse(e[i + 1], i + 1, n);
			if (!l) return null;
			a.push([s, l]), n = n || l.type;
		}
		const o = t.parse(e[e.length - 1], e.length - 1, n);
		if (!o) return null;
		if (!n) throw new Error("Can't infer output type");
		return new dn(n, a, o);
	}
	evaluate(e) {
		for (const [t, n] of this.branches) if (t.evaluate(e)) return n.evaluate(e);
		return this.otherwise.evaluate(e);
	}
	eachChild(e) {
		for (const [t, n] of this.branches) e(t), e(n);
		e(this.otherwise);
	}
	outputDefined() {
		return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
	}
};
var Gt = class Gt {
	constructor(e, t, n, a) {
		this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;
	}
	static parse(e, t) {
		if (e.length <= 2 || e.length >= 5) return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, S);
		if (!n || !a) return null;
		if (!ln(n.type, [
			ae(I),
			P,
			I
		])) return t.error(`Expected first argument to be of type array or string, but found ${D(n.type)} instead`);
		if (e.length === 4) {
			const o = t.parse(e[3], 3, S);
			return o ? new Gt(n.type, n, a, o) : null;
		} else return new Gt(n.type, n, a);
	}
	evaluate(e) {
		const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
		let a;
		if (this.endIndex && (a = this.endIndex.evaluate(e)), Ue(t, ["string"])) return [...t].slice(n, a).join("");
		if (Ue(t, ["array"])) return t.slice(n, a);
		throw new V(`Expected first argument to be of type array or string, but found ${D(H(t))} instead.`);
	}
	eachChild(e) {
		e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
	}
	outputDefined() {
		return !1;
	}
};
function Wa(r, e) {
	const t = r.length - 1;
	let n = 0, a = t, o = 0, i, s;
	for (; n <= a;) if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {
		if (o === t || e < s) return o;
		n = o + 1;
	} else if (i > e) a = o - 1;
	else throw new V("Input is not a number.");
	return 0;
}
var cr = class cr {
	constructor(e, t, n) {
		this.type = e, this.input = t, this.labels = [], this.outputs = [];
		for (const [a, o] of n) this.labels.push(a), this.outputs.push(o);
	}
	static parse(e, t) {
		if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
		if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
		const n = t.parse(e[1], 1, S);
		if (!n) return null;
		const a = [];
		let o = null;
		t.expectedType && t.expectedType.kind !== "value" && (o = t.expectedType);
		for (let i = 1; i < e.length; i += 2) {
			const s = i === 1 ? -Infinity : e[i], l = e[i + 1], u = i, c = i + 1;
			if (typeof s != "number") return t.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", u);
			if (a.length && a[a.length - 1][0] >= s) return t.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", u);
			const p = t.parse(l, c, o);
			if (!p) return null;
			o = o || p.type, a.push([s, p]);
		}
		return new cr(o, n, a);
	}
	evaluate(e) {
		const t = this.labels, n = this.outputs;
		if (t.length === 1) return n[0].evaluate(e);
		const a = this.input.evaluate(e);
		if (a <= t[0]) return n[0].evaluate(e);
		const o = t.length;
		if (a >= t[o - 1]) return n[o - 1].evaluate(e);
		return n[Wa(t, a)].evaluate(e);
	}
	eachChild(e) {
		e(this.input);
		for (const t of this.outputs) e(t);
	}
	outputDefined() {
		return this.outputs.every((e) => e.outputDefined());
	}
};
function Ys(r) {
	return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Cr, Hn;
function Ws() {
	if (Hn) return Cr;
	Hn = 1, Cr = r;
	function r(e, t, n, a) {
		this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;
	}
	return r.prototype = {
		sampleCurveX: function(e) {
			return ((this.ax * e + this.bx) * e + this.cx) * e;
		},
		sampleCurveY: function(e) {
			return ((this.ay * e + this.by) * e + this.cy) * e;
		},
		sampleCurveDerivativeX: function(e) {
			return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
		},
		solveCurveX: function(e, t) {
			if (t === void 0 && (t = 1e-6), e < 0) return 0;
			if (e > 1) return 1;
			for (var n = e, a = 0; a < 8; a++) {
				var o = this.sampleCurveX(n) - e;
				if (Math.abs(o) < t) return n;
				var i = this.sampleCurveDerivativeX(n);
				if (Math.abs(i) < 1e-6) break;
				n = n - o / i;
			}
			var s = 0, l = 1;
			for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++) e > o ? s = n : l = n, n = (l - s) * .5 + s;
			return n;
		},
		solve: function(e, t) {
			return this.sampleCurveY(this.solveCurveX(e, t));
		}
	}, Cr;
}
var Qs = /* @__PURE__ */ Ys(Ws());
var Se = class Se {
	constructor(e, t, n, a, o) {
		this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];
		for (const [i, s] of o) this.labels.push(i), this.outputs.push(s);
	}
	static interpolationFactor(e, t, n, a) {
		let o = 0;
		if (e.name === "exponential") o = Er(t, e.base, n, a);
		else if (e.name === "linear") o = Er(t, 1, n, a);
		else if (e.name === "cubic-bezier") {
			const i = e.controlPoints;
			o = new Qs(i[0], i[1], i[2], i[3]).solve(Er(t, 1, n, a));
		}
		return o;
	}
	static parse(e, t) {
		let [n, a, o, ...i] = e;
		if (!Array.isArray(a) || a.length === 0) return t.error("Expected an interpolation type expression.", 1);
		if (a[0] === "linear") a = { name: "linear" };
		else if (a[0] === "exponential") {
			const u = a[1];
			if (typeof u != "number") return t.error("Exponential interpolation requires a numeric base.", 1, 1);
			a = {
				name: "exponential",
				base: u
			};
		} else if (a[0] === "cubic-bezier") {
			const u = a.slice(1);
			if (u.length !== 4 || u.some((c) => typeof c != "number" || c < 0 || c > 1)) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
			a = {
				name: "cubic-bezier",
				controlPoints: u
			};
		} else return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
		if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
		if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
		if (o = t.parse(o, 2, S), !o) return null;
		const s = [];
		let l = null;
		(n === "interpolate-hcl" || n === "interpolate-lab") && t.expectedType != yt ? l = be : t.expectedType && t.expectedType.kind !== "value" && (l = t.expectedType);
		for (let u = 0; u < i.length; u += 2) {
			const c = i[u], p = i[u + 1], d = u + 3, f = u + 4;
			if (typeof c != "number") return t.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", d);
			if (s.length && s[s.length - 1][0] >= c) return t.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", d);
			const h = t.parse(p, f, l);
			if (!h) return null;
			l = l || h.type, s.push([c, h]);
		}
		return !Ae(l, S) && !Ae(l, tr) && !Ae(l, be) && !Ae(l, ar) && !Ae(l, or) && !Ae(l, yt) && !Ae(l, ir) && !Ae(l, ae(S)) ? t.error(`Type ${D(l)} is not interpolatable.`) : new Se(l, n, a, o, s);
	}
	evaluate(e) {
		const t = this.labels, n = this.outputs;
		if (t.length === 1) return n[0].evaluate(e);
		const a = this.input.evaluate(e);
		if (a <= t[0]) return n[0].evaluate(e);
		const o = t.length;
		if (a >= t[o - 1]) return n[o - 1].evaluate(e);
		const i = Wa(t, a), s = t[i], l = t[i + 1], u = Se.interpolationFactor(this.interpolation, a, s, l), c = n[i].evaluate(e), p = n[i + 1].evaluate(e);
		switch (this.operator) {
			case "interpolate": switch (this.type.kind) {
				case "number": return Be(c, p, u);
				case "color": return $.interpolate(c, p, u);
				case "padding": return fe.interpolate(c, p, u);
				case "colorArray": return oe.interpolate(c, p, u);
				case "numberArray": return de.interpolate(c, p, u);
				case "variableAnchorOffsetCollection": return we.interpolate(c, p, u);
				case "array": return vt(c, p, u);
				case "projectionDefinition": return ce.interpolate(c, p, u);
			}
			case "interpolate-hcl": switch (this.type.kind) {
				case "color": return $.interpolate(c, p, u, "hcl");
				case "colorArray": return oe.interpolate(c, p, u, "hcl");
			}
			case "interpolate-lab": switch (this.type.kind) {
				case "color": return $.interpolate(c, p, u, "lab");
				case "colorArray": return oe.interpolate(c, p, u, "lab");
			}
		}
	}
	eachChild(e) {
		e(this.input);
		for (const t of this.outputs) e(t);
	}
	outputDefined() {
		return this.outputs.every((e) => e.outputDefined());
	}
};
function Er(r, e, t, n) {
	const a = n - t, o = r - t;
	return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);
}
var wt = class wt {
	constructor(e, t) {
		this.type = e, this.args = t;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		let n = null;
		const a = t.expectedType;
		a && a.kind !== "value" && (n = a);
		const o = [];
		for (const s of e.slice(1)) {
			const l = t.parse(s, 1 + o.length, n, void 0, { typeAnnotation: "omit" });
			if (!l) return null;
			n = n || l.type, o.push(l);
		}
		if (!n) throw new Error("No output type");
		return a && o.some((s) => gt(a, s.type)) ? new wt(I, o) : new wt(n, o);
	}
	evaluate(e) {
		let t = null, n = 0, a;
		for (const o of this.args) if (n++, t = o.evaluate(e), t && t instanceof Fe && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null) break;
		return t;
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return this.args.every((e) => e.outputDefined());
	}
};
function Zn(r, e) {
	return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function el(r, e, t) {
	return e === t;
}
function tl(r, e, t) {
	return e !== t;
}
function rl(r, e, t) {
	return e < t;
}
function nl(r, e, t) {
	return e > t;
}
function al(r, e, t) {
	return e <= t;
}
function ol(r, e, t) {
	return e >= t;
}
function Ja(r, e, t, n) {
	return n.compare(e, t) === 0;
}
function il(r, e, t, n) {
	return !Ja(r, e, t, n);
}
function sl(r, e, t, n) {
	return n.compare(e, t) < 0;
}
function ll(r, e, t, n) {
	return n.compare(e, t) > 0;
}
function ul(r, e, t, n) {
	return n.compare(e, t) <= 0;
}
function cl(r, e, t, n) {
	return n.compare(e, t) >= 0;
}
function lt(r, e, t) {
	const n = r !== "==" && r !== "!=";
	return class Qa {
		constructor(o, i, s) {
			this.type = M, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === "value" || i.type.kind === "value";
		}
		static parse(o, i) {
			if (o.length !== 3 && o.length !== 4) return i.error("Expected two or three arguments.");
			const s = o[0];
			let l = i.parse(o[1], 1, I);
			if (!l) return null;
			if (!Zn(s, l.type)) return i.concat(1).error(`"${s}" comparisons are not supported for type '${D(l.type)}'.`);
			let u = i.parse(o[2], 2, I);
			if (!u) return null;
			if (!Zn(s, u.type)) return i.concat(2).error(`"${s}" comparisons are not supported for type '${D(u.type)}'.`);
			if (l.type.kind !== u.type.kind && l.type.kind !== "value" && u.type.kind !== "value") return i.error(`Cannot compare types '${D(l.type)}' and '${D(u.type)}'.`);
			n && (l.type.kind === "value" && u.type.kind !== "value" ? l = new pe(u.type, [l]) : l.type.kind !== "value" && u.type.kind === "value" && (u = new pe(l.type, [u])));
			let c = null;
			if (o.length === 4) {
				if (l.type.kind !== "string" && u.type.kind !== "string" && l.type.kind !== "value" && u.type.kind !== "value") return i.error("Cannot use collator to compare non-string types.");
				if (c = i.parse(o[3], 3, rr), !c) return null;
			}
			return new Qa(l, u, c);
		}
		evaluate(o) {
			const i = this.lhs.evaluate(o), s = this.rhs.evaluate(o);
			if (n && this.hasUntypedArgument) {
				const l = H(i), u = H(s);
				if (l.kind !== u.kind || !(l.kind === "string" || l.kind === "number")) throw new V(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);
			}
			if (this.collator && !n && this.hasUntypedArgument) {
				const l = H(i), u = H(s);
				if (l.kind !== "string" || u.kind !== "string") return e(o, i, s);
			}
			return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);
		}
		eachChild(o) {
			o(this.lhs), o(this.rhs), this.collator && o(this.collator);
		}
		outputDefined() {
			return !0;
		}
	};
}
var pl = lt("==", el, Ja), fl = lt("!=", tl, il), dl = lt("<", rl, sl), hl = lt(">", nl, ll), ml = lt("<=", al, ul), yl = lt(">=", ol, cl);
var pr = class pr {
	constructor(e, t, n) {
		this.type = rr, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error("Expected one argument.");
		const n = e[1];
		if (typeof n != "object" || Array.isArray(n)) return t.error("Collator options argument must be an object.");
		const a = t.parse(n["case-sensitive"] === void 0 ? !1 : n["case-sensitive"], 1, M);
		if (!a) return null;
		const o = t.parse(n["diacritic-sensitive"] === void 0 ? !1 : n["diacritic-sensitive"], 1, M);
		if (!o) return null;
		let i = null;
		return n.locale && (i = t.parse(n.locale, 1, P), !i) ? null : new pr(a, o, i);
	}
	evaluate(e) {
		return new un(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
	}
	eachChild(e) {
		e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
	}
	outputDefined() {
		return !1;
	}
};
var hn = class hn {
	constructor(e, t, n, a, o) {
		this.type = P, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;
	}
	static parse(e, t) {
		if (e.length !== 3) return t.error("Expected two arguments.");
		const n = t.parse(e[1], 1, S);
		if (!n) return null;
		const a = e[2];
		if (typeof a != "object" || Array.isArray(a)) return t.error("NumberFormat options argument must be an object.");
		let o = null;
		if (a.locale && (o = t.parse(a.locale, 1, P), !o)) return null;
		let i = null;
		if (a.currency && (i = t.parse(a.currency, 1, P), !i)) return null;
		let s = null;
		if (a["min-fraction-digits"] && (s = t.parse(a["min-fraction-digits"], 1, S), !s)) return null;
		let l = null;
		return a["max-fraction-digits"] && (l = t.parse(a["max-fraction-digits"], 1, S), !l) ? null : new hn(n, o, i, s, l);
	}
	evaluate(e) {
		return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
			style: this.currency ? "currency" : "decimal",
			currency: this.currency ? this.currency.evaluate(e) : void 0,
			minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
			maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
		}).format(this.number.evaluate(e));
	}
	eachChild(e) {
		e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
	}
	outputDefined() {
		return !1;
	}
};
var mn = class mn {
	constructor(e) {
		this.type = nr, this.sections = e;
	}
	static parse(e, t) {
		if (e.length < 2) return t.error("Expected at least one argument.");
		const n = e[1];
		if (!Array.isArray(n) && typeof n == "object") return t.error("First argument must be an image or text section.");
		const a = [];
		let o = !1;
		for (let i = 1; i <= e.length - 1; ++i) {
			const s = e[i];
			if (o && typeof s == "object" && !Array.isArray(s)) {
				o = !1;
				let l = null;
				if (s["font-scale"] && (l = t.parse(s["font-scale"], 1, S), !l)) return null;
				let u = null;
				if (s["text-font"] && (u = t.parse(s["text-font"], 1, ae(P)), !u)) return null;
				let c = null;
				if (s["text-color"] && (c = t.parse(s["text-color"], 1, be), !c)) return null;
				let p = null;
				if (s["vertical-align"]) {
					if (typeof s["vertical-align"] == "string" && !Zs.includes(s["vertical-align"])) return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s["vertical-align"]}' instead.`);
					if (p = t.parse(s["vertical-align"], 1, P), !p) return null;
				}
				const d = a[a.length - 1];
				d.scale = l, d.font = u, d.textColor = c, d.verticalAlign = p;
			} else {
				const l = t.parse(e[i], 1, I);
				if (!l) return null;
				const u = l.type.kind;
				if (u !== "string" && u !== "value" && u !== "null" && u !== "resolvedImage") return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
				o = !0, a.push({
					content: l,
					scale: null,
					font: null,
					textColor: null,
					verticalAlign: null
				});
			}
		}
		return new mn(a);
	}
	evaluate(e) {
		const t = (n) => {
			const a = n.content.evaluate(e);
			return H(a) === Tt ? new Dr("", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new Dr(ht(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);
		};
		return new Le(this.sections.map(t));
	}
	eachChild(e) {
		for (const t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);
	}
	outputDefined() {
		return !1;
	}
};
var yn = class yn {
	constructor(e) {
		this.type = Tt, this.input = e;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error("Expected two arguments.");
		const n = t.parse(e[1], 1, P);
		return n ? new yn(n) : t.error("No image name provided.");
	}
	evaluate(e) {
		const t = this.input.evaluate(e), n = Fe.fromString(t);
		return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
	}
	eachChild(e) {
		e(this.input);
	}
	outputDefined() {
		return !1;
	}
};
var gn = class gn {
	constructor(e) {
		this.type = S, this.input = e;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
		const n = t.parse(e[1], 1);
		return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error(`Expected argument of type string or array, but found ${D(n.type)} instead.`) : new gn(n) : null;
	}
	evaluate(e) {
		const t = this.input.evaluate(e);
		if (typeof t == "string") return [...t].length;
		if (Array.isArray(t)) return t.length;
		throw new V(`Expected value to be of type string or array, but found ${D(H(t))} instead.`);
	}
	eachChild(e) {
		e(this.input);
	}
	outputDefined() {
		return !1;
	}
};
var xe = 8192;
function gl(r, e) {
	const t = vl(r[0]), n = wl(r[1]), a = Math.pow(2, e.z);
	return [Math.round(t * a * xe), Math.round(n * a * xe)];
}
function vn(r, e) {
	const t = Math.pow(2, e.z), n = (r[0] / xe + e.x) / t, a = (r[1] / xe + e.y) / t;
	return [bl(n), Sl(a)];
}
function vl(r) {
	return (180 + r) / 360;
}
function bl(r) {
	return r * 360 - 180;
}
function wl(r) {
	return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function Sl(r) {
	return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;
}
function _t(r, e) {
	r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
}
function St(r, e) {
	return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
}
function xl(r, e, t) {
	return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];
}
function kl(r, e, t) {
	const n = r[0] - e[0], a = r[1] - e[1], o = r[0] - t[0], i = r[1] - t[1];
	return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;
}
function fr(r, e, t, n) {
	const a = [e[0] - r[0], e[1] - r[1]];
	return Al([n[0] - t[0], n[1] - t[1]], a) === 0 ? !1 : !!(Kn(r, e, t, n) && Kn(t, n, r, e));
}
function Ll(r, e, t) {
	for (const n of t) for (let a = 0; a < n.length - 1; ++a) if (fr(r, e, n[a], n[a + 1])) return !0;
	return !1;
}
function ut(r, e, t = !1) {
	let n = !1;
	for (const a of e) for (let o = 0; o < a.length - 1; o++) {
		if (kl(r, a[o], a[o + 1])) return t;
		xl(r, a[o], a[o + 1]) && (n = !n);
	}
	return n;
}
function Cl(r, e) {
	for (const t of e) if (ut(r, t)) return !0;
	return !1;
}
function eo(r, e) {
	for (const t of r) if (!ut(t, e)) return !1;
	for (let t = 0; t < r.length - 1; ++t) if (Ll(r[t], r[t + 1], e)) return !1;
	return !0;
}
function El(r, e) {
	for (const t of e) if (eo(r, t)) return !0;
	return !1;
}
function Al(r, e) {
	return r[0] * e[1] - r[1] * e[0];
}
function Kn(r, e, t, n) {
	const a = r[0] - t[0], o = r[1] - t[1], i = e[0] - t[0], s = e[1] - t[1], l = n[0] - t[0], u = n[1] - t[1], c = a * u - l * o, p = i * u - l * s;
	return c > 0 && p < 0 || c < 0 && p > 0;
}
function bn(r, e, t) {
	const n = [];
	for (let a = 0; a < r.length; a++) {
		const o = [];
		for (let i = 0; i < r[a].length; i++) {
			const s = gl(r[a][i], t);
			_t(e, s), o.push(s);
		}
		n.push(o);
	}
	return n;
}
function to(r, e, t) {
	const n = [];
	for (let a = 0; a < r.length; a++) {
		const o = bn(r[a], e, t);
		n.push(o);
	}
	return n;
}
function ro(r, e, t, n) {
	if (r[0] < t[0] || r[0] > t[2]) {
		const a = n * .5;
		let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;
		o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;
	}
	_t(e, r);
}
function Tl(r) {
	r[0] = r[1] = Infinity, r[2] = r[3] = -Infinity;
}
function Xn(r, e, t, n) {
	const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];
	for (const s of r) for (const l of s) {
		const u = [l.x + o[0], l.y + o[1]];
		ro(u, e, t, a), i.push(u);
	}
	return i;
}
function Yn(r, e, t, n) {
	const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];
	for (const s of r) {
		const l = [];
		for (const u of s) {
			const c = [u.x + o[0], u.y + o[1]];
			_t(e, c), l.push(c);
		}
		i.push(l);
	}
	if (e[2] - e[0] <= a / 2) {
		Tl(e);
		for (const s of i) for (const l of s) ro(l, e, t, a);
	}
	return i;
}
function _l(r, e) {
	const t = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], n = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], a = r.canonicalID();
	if (e.type === "Polygon") {
		const o = bn(e.coordinates, n, a), i = Xn(r.geometry(), t, n, a);
		if (!St(t, n)) return !1;
		for (const s of i) if (!ut(s, o)) return !1;
	}
	if (e.type === "MultiPolygon") {
		const o = to(e.coordinates, n, a), i = Xn(r.geometry(), t, n, a);
		if (!St(t, n)) return !1;
		for (const s of i) if (!Cl(s, o)) return !1;
	}
	return !0;
}
function Il(r, e) {
	const t = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], n = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	], a = r.canonicalID();
	if (e.type === "Polygon") {
		const o = bn(e.coordinates, n, a), i = Yn(r.geometry(), t, n, a);
		if (!St(t, n)) return !1;
		for (const s of i) if (!eo(s, o)) return !1;
	}
	if (e.type === "MultiPolygon") {
		const o = to(e.coordinates, n, a), i = Yn(r.geometry(), t, n, a);
		if (!St(t, n)) return !1;
		for (const s of i) if (!El(s, o)) return !1;
	}
	return !0;
}
var qe = class qe {
	constructor(e, t) {
		this.type = M, this.geojson = e, this.geometries = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
		if (bt(e[1])) {
			const n = e[1];
			if (n.type === "FeatureCollection") {
				const a = [];
				for (const o of n.features) {
					const { type: i, coordinates: s } = o.geometry;
					i === "Polygon" && a.push(s), i === "MultiPolygon" && a.push(...s);
				}
				if (a.length) return new qe(n, {
					type: "MultiPolygon",
					coordinates: a
				});
			} else if (n.type === "Feature") {
				const a = n.geometry.type;
				if (a === "Polygon" || a === "MultiPolygon") return new qe(n, n.geometry);
			} else if (n.type === "Polygon" || n.type === "MultiPolygon") return new qe(n, n);
		}
		return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
	}
	evaluate(e) {
		if (e.geometry() != null && e.canonicalID() != null) {
			if (e.geometryType() === "Point") return _l(e, this.geometries);
			if (e.geometryType() === "LineString") return Il(e, this.geometries);
		}
		return !1;
	}
	eachChild() {}
	outputDefined() {
		return !0;
	}
};
var no = class {
	constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
		if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
	}
	push(e) {
		this.data.push(e), this._up(this.length++);
	}
	pop() {
		if (this.length === 0) return;
		const e = this.data[0], t = this.data.pop();
		return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
	}
	peek() {
		return this.data[0];
	}
	_up(e) {
		const { data: t, compare: n } = this, a = t[e];
		for (; e > 0;) {
			const o = e - 1 >> 1, i = t[o];
			if (n(a, i) >= 0) break;
			t[e] = i, e = o;
		}
		t[e] = a;
	}
	_down(e) {
		const { data: t, compare: n } = this, a = this.length >> 1, o = t[e];
		for (; e < a;) {
			let i = (e << 1) + 1;
			const s = i + 1;
			if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;
			t[e] = t[i], e = i;
		}
		t[e] = o;
	}
};
function Ml(r, e) {
	if (r.length <= 1) return [r];
	const n = [];
	let a, o;
	for (const i of r) {
		const s = Pl(i);
		s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));
	}
	return a && n.push(a), n;
}
function Pl(r) {
	let e = 0;
	for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++) o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);
	return e;
}
var Rl = 6378.137, Wn = 1 / 298.257223563, Jn = Wn * (2 - Wn), Qn = Math.PI / 180;
var wn = class {
	constructor(e) {
		const t = Qn * Rl * 1e3, n = Math.cos(e * Qn), a = 1 / (1 - Jn * (1 - n * n)), o = Math.sqrt(a);
		this.kx = t * o * n, this.ky = t * o * a * (1 - Jn);
	}
	/**
	* Given two points of the form [longitude, latitude], returns the distance.
	*
	* @param a - point [longitude, latitude]
	* @param b - point [longitude, latitude]
	* @returns distance
	* @example
	* const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
	* //=distance
	*/
	distance(e, t) {
		const n = this.wrap(e[0] - t[0]) * this.kx, a = (e[1] - t[1]) * this.ky;
		return Math.sqrt(n * n + a * a);
	}
	/**
	* Returns an object of the form {point, index, t}, where point is closest point on the line
	* from the given point, index is the start index of the segment with the closest point,
	* and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
	*
	* @param line - an array of points that form the line
	* @param p - point [longitude, latitude]
	* @returns the nearest point, its index in the array and the proportion along the line
	* @example
	* const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
	* //=point
	*/
	pointOnLine(e, t) {
		let n = Infinity, a, o, i, s;
		for (let l = 0; l < e.length - 1; l++) {
			let u = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, d = (e[l + 1][1] - c) * this.ky, f = 0;
			(p !== 0 || d !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * d) / (p * p + d * d), f > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c += d / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, d = (t[1] - c) * this.ky;
			const h = p * p + d * d;
			h < n && (n = h, a = u, o = c, i = l, s = f);
		}
		return {
			point: [a, o],
			index: i,
			t: Math.max(0, Math.min(1, s))
		};
	}
	wrap(e) {
		for (; e < -180;) e += 360;
		for (; e > 180;) e -= 360;
		return e;
	}
};
var Ur = 100, Br = 50;
function ao(r, e) {
	return e[0] - r[0];
}
function Ht(r) {
	return r[1] - r[0] + 1;
}
function Ee(r, e) {
	return r[1] >= r[0] && r[1] < e;
}
function qr(r, e) {
	if (r[0] > r[1]) return [null, null];
	const t = Ht(r);
	if (e) {
		if (t === 2) return [r, null];
		const a = Math.floor(t / 2);
		return [[r[0], r[0] + a], [r[0] + a, r[1]]];
	}
	if (t === 1) return [r, null];
	const n = Math.floor(t / 2) - 1;
	return [[r[0], r[0] + n], [r[0] + n + 1, r[1]]];
}
function Vr(r, e) {
	if (!Ee(e, r.length)) return [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	];
	const t = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	];
	for (let n = e[0]; n <= e[1]; ++n) _t(t, r[n]);
	return t;
}
function Gr(r) {
	const e = [
		Infinity,
		Infinity,
		-Infinity,
		-Infinity
	];
	for (const t of r) for (const n of t) _t(e, n);
	return e;
}
function ea(r) {
	return r[0] !== -Infinity && r[1] !== -Infinity && r[2] !== Infinity && r[3] !== Infinity;
}
function Sn(r, e, t) {
	if (!ea(r) || !ea(e)) return NaN;
	let n = 0, a = 0;
	return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);
}
function je(r, e, t) {
	const n = t.pointOnLine(e, r);
	return t.distance(r, n.point);
}
function xn(r, e, t, n, a) {
	const o = Math.min(je(r, [t, n], a), je(e, [t, n], a)), i = Math.min(je(t, [r, e], a), je(n, [r, e], a));
	return Math.min(o, i);
}
function zl(r, e, t, n, a) {
	if (!(Ee(e, r.length) && Ee(n, t.length))) return Infinity;
	let i = Infinity;
	for (let s = e[0]; s < e[1]; ++s) {
		const l = r[s], u = r[s + 1];
		for (let c = n[0]; c < n[1]; ++c) {
			const p = t[c], d = t[c + 1];
			if (fr(l, u, p, d)) return 0;
			i = Math.min(i, xn(l, u, p, d, a));
		}
	}
	return i;
}
function Ol(r, e, t, n, a) {
	if (!(Ee(e, r.length) && Ee(n, t.length))) return NaN;
	let i = Infinity;
	for (let s = e[0]; s <= e[1]; ++s) for (let l = n[0]; l <= n[1]; ++l) if (i = Math.min(i, a.distance(r[s], t[l])), i === 0) return i;
	return i;
}
function Fl(r, e, t) {
	if (ut(r, e, !0)) return 0;
	let n = Infinity;
	for (const a of e) {
		const o = a[0], i = a[a.length - 1];
		if (o !== i && (n = Math.min(n, je(r, [i, o], t)), n === 0)) return n;
		const s = t.pointOnLine(a, r);
		if (n = Math.min(n, t.distance(r, s.point)), n === 0) return n;
	}
	return n;
}
function $l(r, e, t, n) {
	if (!Ee(e, r.length)) return NaN;
	for (let o = e[0]; o <= e[1]; ++o) if (ut(r[o], t, !0)) return 0;
	let a = Infinity;
	for (let o = e[0]; o < e[1]; ++o) {
		const i = r[o], s = r[o + 1];
		for (const l of t) for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {
			const d = l[p], f = l[u];
			if (fr(i, s, d, f)) return 0;
			a = Math.min(a, xn(i, s, d, f, n));
		}
	}
	return a;
}
function ta(r, e) {
	for (const t of r) for (const n of t) if (ut(n, e, !0)) return !0;
	return !1;
}
function Nl(r, e, t, n = Infinity) {
	const a = Gr(r), o = Gr(e);
	if (n !== Infinity && Sn(a, o, t) >= n) return n;
	if (St(a, o)) {
		if (ta(r, e)) return 0;
	} else if (ta(e, r)) return 0;
	let i = Infinity;
	for (const s of r) for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {
		const p = s[c], d = s[l];
		for (const f of e) for (let h = 0, m = f.length, y = m - 1; h < m; y = h++) {
			const b = f[y], v = f[h];
			if (fr(p, d, b, v)) return 0;
			i = Math.min(i, xn(p, d, b, v, t));
		}
	}
	return i;
}
function ra(r, e, t, n, a, o) {
	if (!o) return;
	const i = Sn(Vr(n, o), a, t);
	i < e && r.push([
		i,
		o,
		[0, 0]
	]);
}
function Ot(r, e, t, n, a, o, i) {
	if (!o || !i) return;
	const s = Sn(Vr(n, o), Vr(a, i), t);
	s < e && r.push([
		s,
		o,
		i
	]);
}
function Zt(r, e, t, n, a = Infinity) {
	let o = Math.min(n.distance(r[0], t[0][0]), a);
	if (o === 0) return o;
	const i = new no([[
		0,
		[0, r.length - 1],
		[0, 0]
	]], ao), s = Gr(t);
	for (; i.length > 0;) {
		const l = i.pop();
		if (l[0] >= o) continue;
		const u = l[1], c = e ? Br : Ur;
		if (Ht(u) <= c) {
			if (!Ee(u, r.length)) return NaN;
			if (e) {
				const p = $l(r, u, t, n);
				if (isNaN(p) || p === 0) return p;
				o = Math.min(o, p);
			} else for (let p = u[0]; p <= u[1]; ++p) {
				const d = Fl(r[p], t, n);
				if (o = Math.min(o, d), o === 0) return 0;
			}
		} else {
			const p = qr(u, e);
			ra(i, o, n, r, s, p[0]), ra(i, o, n, r, s, p[1]);
		}
	}
	return o;
}
function Kt(r, e, t, n, a, o = Infinity) {
	let i = Math.min(o, a.distance(r[0], t[0]));
	if (i === 0) return i;
	const s = new no([[
		0,
		[0, r.length - 1],
		[0, t.length - 1]
	]], ao);
	for (; s.length > 0;) {
		const l = s.pop();
		if (l[0] >= i) continue;
		const u = l[1], c = l[2], p = e ? Br : Ur, d = n ? Br : Ur;
		if (Ht(u) <= p && Ht(c) <= d) {
			if (!Ee(u, r.length) && Ee(c, t.length)) return NaN;
			let f;
			if (e && n) f = zl(r, u, t, c, a), i = Math.min(i, f);
			else if (e && !n) {
				const h = r.slice(u[0], u[1] + 1);
				for (let m = c[0]; m <= c[1]; ++m) if (f = je(t[m], h, a), i = Math.min(i, f), i === 0) return i;
			} else if (!e && n) {
				const h = t.slice(c[0], c[1] + 1);
				for (let m = u[0]; m <= u[1]; ++m) if (f = je(r[m], h, a), i = Math.min(i, f), i === 0) return i;
			} else f = Ol(r, u, t, c, a), i = Math.min(i, f);
		} else {
			const f = qr(u, e), h = qr(c, n);
			Ot(s, i, a, r, t, f[0], h[0]), Ot(s, i, a, r, t, f[0], h[1]), Ot(s, i, a, r, t, f[1], h[0]), Ot(s, i, a, r, t, f[1], h[1]);
		}
	}
	return i;
}
function jl(r, e) {
	const t = r.geometry(), n = t.flat().map((i) => vn([i.x, i.y], r.canonical));
	if (t.length === 0) return NaN;
	const a = new wn(n[0][1]);
	let o = Infinity;
	for (const i of e) {
		switch (i.type) {
			case "Point":
				o = Math.min(o, Kt(n, !1, [i.coordinates], !1, a, o));
				break;
			case "LineString":
				o = Math.min(o, Kt(n, !1, i.coordinates, !0, a, o));
				break;
			case "Polygon":
				o = Math.min(o, Zt(n, !1, i.coordinates, a, o));
				break;
		}
		if (o === 0) return o;
	}
	return o;
}
function Dl(r, e) {
	const t = r.geometry(), n = t.flat().map((i) => vn([i.x, i.y], r.canonical));
	if (t.length === 0) return NaN;
	const a = new wn(n[0][1]);
	let o = Infinity;
	for (const i of e) {
		switch (i.type) {
			case "Point":
				o = Math.min(o, Kt(n, !0, [i.coordinates], !1, a, o));
				break;
			case "LineString":
				o = Math.min(o, Kt(n, !0, i.coordinates, !0, a, o));
				break;
			case "Polygon":
				o = Math.min(o, Zt(n, !0, i.coordinates, a, o));
				break;
		}
		if (o === 0) return o;
	}
	return o;
}
function Ul(r, e) {
	const t = r.geometry();
	if (t.length === 0 || t[0].length === 0) return NaN;
	const n = Ml(t).map((i) => i.map((s) => s.map((l) => vn([l.x, l.y], r.canonical)))), a = new wn(n[0][0][0][1]);
	let o = Infinity;
	for (const i of e) for (const s of n) {
		switch (i.type) {
			case "Point":
				o = Math.min(o, Zt([i.coordinates], !1, s, a, o));
				break;
			case "LineString":
				o = Math.min(o, Zt(i.coordinates, !0, s, a, o));
				break;
			case "Polygon":
				o = Math.min(o, Nl(s, i.coordinates, a, o));
				break;
		}
		if (o === 0) return o;
	}
	return o;
}
function Ar(r) {
	return r.type === "MultiPolygon" ? r.coordinates.map((e) => ({
		type: "Polygon",
		coordinates: e
	})) : r.type === "MultiLineString" ? r.coordinates.map((e) => ({
		type: "LineString",
		coordinates: e
	})) : r.type === "MultiPoint" ? r.coordinates.map((e) => ({
		type: "Point",
		coordinates: e
	})) : [r];
}
var Ve = class Ve {
	constructor(e, t) {
		this.type = S, this.geojson = e, this.geometries = t;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
		if (bt(e[1])) {
			const n = e[1];
			if (n.type === "FeatureCollection") return new Ve(n, n.features.map((a) => Ar(a.geometry)).flat());
			if (n.type === "Feature") return new Ve(n, Ar(n.geometry));
			if ("type" in n && "coordinates" in n) return new Ve(n, Ar(n));
		}
		return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
	}
	evaluate(e) {
		if (e.geometry() != null && e.canonicalID() != null) {
			if (e.geometryType() === "Point") return jl(e, this.geometries);
			if (e.geometryType() === "LineString") return Dl(e, this.geometries);
			if (e.geometryType() === "Polygon") return Ul(e, this.geometries);
		}
		return NaN;
	}
	eachChild() {}
	outputDefined() {
		return !0;
	}
};
var It = class It {
	constructor(e) {
		this.type = I, this.key = e;
	}
	static parse(e, t) {
		if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
		const n = e[1];
		return n == null ? t.error("Global state property must be defined.") : typeof n != "string" ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new It(n);
	}
	evaluate(e) {
		var t;
		const n = (t = e.globals) === null || t === void 0 ? void 0 : t.globalState;
		return !n || Object.keys(n).length === 0 ? null : dt(n, this.key);
	}
	eachChild() {}
	outputDefined() {
		return !1;
	}
};
var kn = {
	"==": pl,
	"!=": fl,
	">": hl,
	"<": dl,
	">=": yl,
	"<=": ml,
	array: pe,
	at: cn,
	boolean: pe,
	case: dn,
	coalesce: wt,
	collator: pr,
	format: mn,
	image: yn,
	in: pn,
	"index-of": Vt,
	interpolate: Se,
	"interpolate-hcl": Se,
	"interpolate-lab": Se,
	length: gn,
	let: lr,
	literal: ot,
	match: fn,
	number: pe,
	"number-format": hn,
	object: pe,
	slice: Gt,
	step: cr,
	string: pe,
	"to-boolean": Re,
	"to-color": Re,
	"to-number": Re,
	"to-string": Re,
	var: ur,
	within: qe,
	distance: Ve,
	"global-state": It
};
var he = class he {
	constructor(e, t, n, a) {
		this.name = e, this.type = t, this._evaluate = n, this.args = a;
	}
	evaluate(e) {
		return this._evaluate(e, this.args);
	}
	eachChild(e) {
		this.args.forEach(e);
	}
	outputDefined() {
		return !1;
	}
	static parse(e, t) {
		const n = e[0], a = he.definitions[n];
		if (!a) return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
		const o = Array.isArray(a) ? a[0] : a.type, i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, s = i.filter(([u]) => !Array.isArray(u) || u.length === e.length - 1);
		let l = null;
		for (const [u, c] of s) {
			l = new sr(t.registry, Xt, t.path, null, t.scope);
			const p = [];
			let d = !1;
			for (let f = 1; f < e.length; f++) {
				const h = e[f], m = Array.isArray(u) ? u[f - 1] : u.type, y = l.parse(h, 1 + p.length, m);
				if (!y) {
					d = !0;
					break;
				}
				p.push(y);
			}
			if (!d) {
				if (Array.isArray(u) && u.length !== p.length) {
					l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);
					continue;
				}
				for (let f = 0; f < p.length; f++) {
					const h = Array.isArray(u) ? u[f] : u.type, m = p[f];
					l.concat(f + 1).checkSubtype(h, m.type);
				}
				if (l.errors.length === 0) return new he(n, o, c, p);
			}
		}
		if (s.length === 1) t.errors.push(...l.errors);
		else {
			const c = (s.length ? s : i).map(([d]) => ql(d)).join(" | "), p = [];
			for (let d = 1; d < e.length; d++) {
				const f = t.parse(e[d], 1 + p.length);
				if (!f) return null;
				p.push(D(f.type));
			}
			t.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`);
		}
		return null;
	}
	static register(e, t) {
		he.definitions = t;
		for (const n in t) e[n] = he;
	}
};
function na(r, [e, t, n, a]) {
	e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);
	const o = a ? a.evaluate(r) : 1, i = Xa(e, t, n, o);
	if (i) throw new V(i);
	return new $(e / 255, t / 255, n / 255, o, !1);
}
function aa(r, e) {
	return r in e;
}
function Tr(r, e) {
	const t = e[r];
	return typeof t > "u" ? null : t;
}
function Bl(r, e, t, n) {
	for (; t <= n;) {
		const a = t + n >> 1;
		if (e[a] === r) return !0;
		e[a] > r ? n = a - 1 : t = a + 1;
	}
	return !1;
}
function $e(r) {
	return { type: r };
}
he.register(kn, {
	error: [
		Fs,
		[P],
		(r, [e]) => {
			throw new V(e.evaluate(r));
		}
	],
	typeof: [
		P,
		[I],
		(r, [e]) => D(H(e.evaluate(r)))
	],
	"to-rgba": [
		ae(S, 4),
		[be],
		(r, [e]) => {
			const [t, n, a, o] = e.evaluate(r).rgb;
			return [
				t * 255,
				n * 255,
				a * 255,
				o
			];
		}
	],
	rgb: [
		be,
		[
			S,
			S,
			S
		],
		na
	],
	rgba: [
		be,
		[
			S,
			S,
			S,
			S
		],
		na
	],
	has: {
		type: M,
		overloads: [[[P], (r, [e]) => aa(e.evaluate(r), r.properties())], [[P, De], (r, [e, t]) => aa(e.evaluate(r), t.evaluate(r))]]
	},
	get: {
		type: I,
		overloads: [[[P], (r, [e]) => Tr(e.evaluate(r), r.properties())], [[P, De], (r, [e, t]) => Tr(e.evaluate(r), t.evaluate(r))]]
	},
	"feature-state": [
		I,
		[P],
		(r, [e]) => Tr(e.evaluate(r), r.featureState || {})
	],
	properties: [
		De,
		[],
		(r) => r.properties()
	],
	"geometry-type": [
		P,
		[],
		(r) => r.geometryType()
	],
	id: [
		I,
		[],
		(r) => r.id()
	],
	zoom: [
		S,
		[],
		(r) => r.globals.zoom
	],
	"heatmap-density": [
		S,
		[],
		(r) => r.globals.heatmapDensity || 0
	],
	elevation: [
		S,
		[],
		(r) => r.globals.elevation || 0
	],
	"line-progress": [
		S,
		[],
		(r) => r.globals.lineProgress || 0
	],
	accumulated: [
		I,
		[],
		(r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated
	],
	"+": [
		S,
		$e(S),
		(r, e) => {
			let t = 0;
			for (const n of e) t += n.evaluate(r);
			return t;
		}
	],
	"*": [
		S,
		$e(S),
		(r, e) => {
			let t = 1;
			for (const n of e) t *= n.evaluate(r);
			return t;
		}
	],
	"-": {
		type: S,
		overloads: [[[S, S], (r, [e, t]) => e.evaluate(r) - t.evaluate(r)], [[S], (r, [e]) => -e.evaluate(r)]]
	},
	"/": [
		S,
		[S, S],
		(r, [e, t]) => e.evaluate(r) / t.evaluate(r)
	],
	"%": [
		S,
		[S, S],
		(r, [e, t]) => e.evaluate(r) % t.evaluate(r)
	],
	ln2: [
		S,
		[],
		() => Math.LN2
	],
	pi: [
		S,
		[],
		() => Math.PI
	],
	e: [
		S,
		[],
		() => Math.E
	],
	"^": [
		S,
		[S, S],
		(r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))
	],
	sqrt: [
		S,
		[S],
		(r, [e]) => Math.sqrt(e.evaluate(r))
	],
	log10: [
		S,
		[S],
		(r, [e]) => Math.log(e.evaluate(r)) / Math.LN10
	],
	ln: [
		S,
		[S],
		(r, [e]) => Math.log(e.evaluate(r))
	],
	log2: [
		S,
		[S],
		(r, [e]) => Math.log(e.evaluate(r)) / Math.LN2
	],
	sin: [
		S,
		[S],
		(r, [e]) => Math.sin(e.evaluate(r))
	],
	cos: [
		S,
		[S],
		(r, [e]) => Math.cos(e.evaluate(r))
	],
	tan: [
		S,
		[S],
		(r, [e]) => Math.tan(e.evaluate(r))
	],
	asin: [
		S,
		[S],
		(r, [e]) => Math.asin(e.evaluate(r))
	],
	acos: [
		S,
		[S],
		(r, [e]) => Math.acos(e.evaluate(r))
	],
	atan: [
		S,
		[S],
		(r, [e]) => Math.atan(e.evaluate(r))
	],
	min: [
		S,
		$e(S),
		(r, e) => Math.min(...e.map((t) => t.evaluate(r)))
	],
	max: [
		S,
		$e(S),
		(r, e) => Math.max(...e.map((t) => t.evaluate(r)))
	],
	abs: [
		S,
		[S],
		(r, [e]) => Math.abs(e.evaluate(r))
	],
	round: [
		S,
		[S],
		(r, [e]) => {
			const t = e.evaluate(r);
			return t < 0 ? -Math.round(-t) : Math.round(t);
		}
	],
	floor: [
		S,
		[S],
		(r, [e]) => Math.floor(e.evaluate(r))
	],
	ceil: [
		S,
		[S],
		(r, [e]) => Math.ceil(e.evaluate(r))
	],
	"filter-==": [
		M,
		[P, I],
		(r, [e, t]) => r.properties()[e.value] === t.value
	],
	"filter-id-==": [
		M,
		[I],
		(r, [e]) => r.id() === e.value
	],
	"filter-type-==": [
		M,
		[P],
		(r, [e]) => r.geometryType() === e.value
	],
	"filter-<": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n < a;
		}
	],
	"filter-id-<": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t < n;
		}
	],
	"filter->": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n > a;
		}
	],
	"filter-id->": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t > n;
		}
	],
	"filter-<=": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n <= a;
		}
	],
	"filter-id-<=": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t <= n;
		}
	],
	"filter->=": [
		M,
		[P, I],
		(r, [e, t]) => {
			const n = r.properties()[e.value], a = t.value;
			return typeof n == typeof a && n >= a;
		}
	],
	"filter-id->=": [
		M,
		[I],
		(r, [e]) => {
			const t = r.id(), n = e.value;
			return typeof t == typeof n && t >= n;
		}
	],
	"filter-has": [
		M,
		[I],
		(r, [e]) => e.value in r.properties()
	],
	"filter-has-id": [
		M,
		[],
		(r) => r.id() !== null && r.id() !== void 0
	],
	"filter-type-in": [
		M,
		[ae(P)],
		(r, [e]) => e.value.indexOf(r.geometryType()) >= 0
	],
	"filter-id-in": [
		M,
		[ae(I)],
		(r, [e]) => e.value.indexOf(r.id()) >= 0
	],
	"filter-in-small": [
		M,
		[P, ae(I)],
		(r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0
	],
	"filter-in-large": [
		M,
		[P, ae(I)],
		(r, [e, t]) => Bl(r.properties()[e.value], t.value, 0, t.value.length - 1)
	],
	all: {
		type: M,
		overloads: [[[M, M], (r, [e, t]) => e.evaluate(r) && t.evaluate(r)], [$e(M), (r, e) => {
			for (const t of e) if (!t.evaluate(r)) return !1;
			return !0;
		}]]
	},
	any: {
		type: M,
		overloads: [[[M, M], (r, [e, t]) => e.evaluate(r) || t.evaluate(r)], [$e(M), (r, e) => {
			for (const t of e) if (t.evaluate(r)) return !0;
			return !1;
		}]]
	},
	"!": [
		M,
		[M],
		(r, [e]) => !e.evaluate(r)
	],
	"is-supported-script": [
		M,
		[P],
		(r, [e]) => {
			const t = r.globals && r.globals.isSupportedScript;
			return t ? t(e.evaluate(r)) : !0;
		}
	],
	upcase: [
		P,
		[P],
		(r, [e]) => e.evaluate(r).toUpperCase()
	],
	downcase: [
		P,
		[P],
		(r, [e]) => e.evaluate(r).toLowerCase()
	],
	concat: [
		P,
		$e(I),
		(r, e) => e.map((t) => ht(t.evaluate(r))).join("")
	],
	"resolved-locale": [
		P,
		[rr],
		(r, [e]) => e.evaluate(r).resolvedLocale()
	]
});
function ql(r) {
	return Array.isArray(r) ? `(${r.map(D).join(", ")})` : `(${D(r.type)}...)`;
}
function Xt(r) {
	if (r instanceof ur) return Xt(r.boundExpression);
	if (r instanceof he && r.name === "error") return !1;
	if (r instanceof pr) return !1;
	if (r instanceof qe) return !1;
	if (r instanceof Ve) return !1;
	if (r instanceof It) return !1;
	const e = r instanceof Re || r instanceof pe;
	let t = !0;
	return r.eachChild((n) => {
		e ? t = t && Xt(n) : t = t && n instanceof ot;
	}), t ? dr(r) && hr(r, [
		"zoom",
		"heatmap-density",
		"elevation",
		"line-progress",
		"accumulated",
		"is-supported-script"
	]) : !1;
}
function dr(r) {
	if (r instanceof he) {
		if (r.name === "get" && r.args.length === 1) return !1;
		if (r.name === "feature-state") return !1;
		if (r.name === "has" && r.args.length === 1) return !1;
		if (r.name === "properties" || r.name === "geometry-type" || r.name === "id") return !1;
		if (/^filter-/.test(r.name)) return !1;
	}
	if (r instanceof qe || r instanceof Ve) return !1;
	let e = !0;
	return r.eachChild((t) => {
		e && !dr(t) && (e = !1);
	}), e;
}
function xt(r) {
	if (r instanceof he && r.name === "feature-state") return !1;
	let e = !0;
	return r.eachChild((t) => {
		e && !xt(t) && (e = !1);
	}), e;
}
function hr(r, e) {
	if (r instanceof he && e.indexOf(r.name) >= 0) return !1;
	let t = !0;
	return r.eachChild((n) => {
		t && !hr(n, e) && (t = !1);
	}), t;
}
function Hr(r) {
	return {
		result: "success",
		value: r
	};
}
function et(r) {
	return {
		result: "error",
		value: r
	};
}
function Yt(r) {
	return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
}
function oo(r) {
	return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
}
function io(r) {
	return !!r.expression && r.expression.interpolated;
}
function R(r) {
	return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
}
function Ln(r) {
	return typeof r == "object" && r !== null && !Array.isArray(r) && H(r) === De;
}
var Vl = class {
	constructor(e, t, n) {
		this.expression = e, this._warningHistory = {}, this._evaluator = new Ya(), this._defaultValue = t ? Zl(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null, this._globalState = n;
	}
	evaluateWithoutErrorHandling(e, t, n, a, o, i) {
		return this._globalState && (e = it(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);
	}
	evaluate(e, t, n, a, o, i) {
		this._globalState && (e = it(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;
		try {
			const s = this.expression.evaluate(this._evaluator);
			if (s == null || typeof s == "number" && s !== s) return this._defaultValue;
			if (this._enumValues && !(s in this._enumValues)) throw new V(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s)} instead.`);
			return s;
		} catch (s) {
			return this._warningHistory[s.message] || (this._warningHistory[s.message] = !0, typeof console < "u" && console.warn(s.message)), this._defaultValue;
		}
	}
};
function so(r) {
	return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in kn;
}
function lo(r, e, t) {
	const n = new sr(kn, Xt, [], e ? Hl(e) : void 0), a = n.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
	return a ? Hr(new Vl(a, e, t)) : et(n.errors);
}
var oa = class {
	constructor(e, t, n) {
		this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !xt(t.expression), this.globalStateRefs = Cn(t.expression), this._globalState = n;
	}
	evaluateWithoutErrorHandling(e, t, n, a, o, i) {
		return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
	}
	evaluate(e, t, n, a, o, i) {
		return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluate(e, t, n, a, o, i);
	}
};
var ia = class {
	constructor(e, t, n, a, o) {
		this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !xt(t.expression), this.globalStateRefs = Cn(t.expression), this.interpolationType = a, this._globalState = o;
	}
	evaluateWithoutErrorHandling(e, t, n, a, o, i) {
		return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
	}
	evaluate(e, t, n, a, o, i) {
		return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluate(e, t, n, a, o, i);
	}
	interpolationFactor(e, t, n) {
		return this.interpolationType ? Se.interpolationFactor(this.interpolationType, e, t, n) : 0;
	}
};
function Gl(r, e, t) {
	const n = lo(r, e, t);
	if (n.result === "error") return n;
	const a = n.value.expression, o = dr(a);
	if (!o && !Yt(e)) return et([new ve("", "data expressions not supported")]);
	const i = hr(a, ["zoom"]);
	if (!i && !oo(e)) return et([new ve("", "zoom expressions not supported")]);
	const s = jt(a);
	if (!s && !i) return et([new ve("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.")]);
	if (s instanceof ve) return et([s]);
	if (s instanceof Se && !io(e)) return et([new ve("", "\"interpolate\" expressions cannot be used with this property")]);
	if (!s) return Hr(o ? new oa("constant", n.value, t) : new oa("source", n.value, t));
	const l = s instanceof Se ? s.interpolation : void 0;
	return Hr(o ? new ia("camera", n.value, s.labels, l, t) : new ia("composite", n.value, s.labels, l, t));
}
function jt(r) {
	let e = null;
	if (r instanceof lr) e = jt(r.result);
	else if (r instanceof wt) {
		for (const t of r.args) if (e = jt(t), e) break;
	} else (r instanceof cr || r instanceof Se) && r.input instanceof he && r.input.name === "zoom" && (e = r);
	return e instanceof ve || r.eachChild((t) => {
		const n = jt(t);
		n instanceof ve ? e = n : !e && n ? e = new ve("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.") : e && n && e !== n && (e = new ve("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
	}), e;
}
function Cn(r, e = /* @__PURE__ */ new Set()) {
	return r instanceof It && e.add(r.key), r.eachChild((t) => {
		Cn(t, e);
	}), e;
}
function Hl(r) {
	const e = {
		color: be,
		string: P,
		number: S,
		enum: P,
		boolean: M,
		formatted: nr,
		padding: ar,
		numberArray: or,
		colorArray: yt,
		projectionDefinition: tr,
		resolvedImage: Tt,
		variableAnchorOffsetCollection: ir
	};
	return r.type === "array" ? ae(e[r.value] || I, r.length) : e[r.type];
}
function Zl(r) {
	if (r.type === "color" && Ln(r.default)) return new $(0, 0, 0, 0);
	switch (r.type) {
		case "color": return $.parse(r.default) || null;
		case "padding": return fe.parse(r.default) || null;
		case "numberArray": return de.parse(r.default) || null;
		case "colorArray": return oe.parse(r.default) || null;
		case "variableAnchorOffsetCollection": return we.parse(r.default) || null;
		case "projectionDefinition": return ce.parse(r.default) || null;
		default: return r.default === void 0 ? null : r.default;
	}
}
function it(r, e) {
	const { zoom: t, heatmapDensity: n, elevation: a, lineProgress: o, isSupportedScript: i, accumulated: s } = r ?? {};
	return {
		zoom: t,
		heatmapDensity: n,
		elevation: a,
		lineProgress: o,
		isSupportedScript: i,
		accumulated: s,
		globalState: e
	};
}
function uo(r) {
	if (r === !0 || r === !1) return !0;
	if (!Array.isArray(r) || r.length === 0) return !1;
	switch (r[0]) {
		case "has": return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
		case "in": return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
		case "!in":
		case "!has":
		case "none": return !1;
		case "==":
		case "!=":
		case ">":
		case ">=":
		case "<":
		case "<=": return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
		case "any":
		case "all":
			for (const e of r.slice(1)) if (!uo(e) && typeof e != "boolean") return !1;
			return !0;
		default: return !0;
	}
}
function co(r) {
	const e = r.key, t = r.value;
	return t ? [new w(e, t, "constants have been deprecated as of v8")] : [];
}
function G(r) {
	return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
}
function Ze(r) {
	if (Array.isArray(r)) return r.map(Ze);
	if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
		const e = {};
		for (const t in r) e[t] = Ze(r[t]);
		return e;
	}
	return G(r);
}
function le(r) {
	const e = r.key, t = r.value, n = r.valueSpec || {}, a = r.objectElementValidators || {}, o = r.style, i = r.styleSpec, s = r.validateSpec;
	let l = [];
	const u = R(t);
	if (u !== "object") return [new w(e, t, `object expected, ${u} found`)];
	for (const c in t) {
		const p = c.split(".")[0], d = dt(n, p) || n["*"];
		let f;
		if (dt(a, p)) f = a[p];
		else if (dt(n, p)) f = s;
		else if (a["*"]) f = a["*"];
		else if (n["*"]) f = s;
		else {
			l.push(new w(e, t[c], `unknown property "${c}"`));
			continue;
		}
		l = l.concat(f({
			key: (e && `${e}.`) + c,
			value: t[c],
			valueSpec: d,
			style: o,
			styleSpec: i,
			object: t,
			objectKey: c,
			validateSpec: s
		}, t));
	}
	for (const c in n) a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new w(e, t, `missing required property "${c}"`));
	return l;
}
function En(r) {
	const e = r.value, t = r.valueSpec, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.key, s = r.arrayElementValidator || n;
	if (R(e) !== "array") return [new w(i, e, `array expected, ${R(e)} found`)];
	if (t.length && e.length !== t.length) return [new w(i, e, `array length ${t.length} expected, length ${e.length} found`)];
	if (t["min-length"] && e.length < t["min-length"]) return [new w(i, e, `array length at least ${t["min-length"]} expected, length ${e.length} found`)];
	let l = {
		type: t.value,
		values: t.values
	};
	o.$version < 7 && (l.function = t.function), R(t.value) === "object" && (l = t.value);
	let u = [];
	for (let c = 0; c < e.length; c++) u = u.concat(s({
		array: e,
		arrayIndex: c,
		value: e[c],
		valueSpec: l,
		validateSpec: r.validateSpec,
		style: a,
		styleSpec: o,
		key: `${i}[${c}]`
	}));
	return u;
}
function mr(r) {
	const e = r.key, t = r.value, n = r.valueSpec;
	let a = R(t);
	return a === "number" && t !== t && (a = "NaN"), a !== "number" ? [new w(e, t, `number expected, ${a} found`)] : "minimum" in n && t < n.minimum ? [new w(e, t, `${t} is less than the minimum value ${n.minimum}`)] : "maximum" in n && t > n.maximum ? [new w(e, t, `${t} is greater than the maximum value ${n.maximum}`)] : [];
}
function po(r) {
	const e = r.valueSpec, t = G(r.value.type);
	let n, a = {}, o, i;
	const s = t !== "categorical" && r.value.property === void 0, l = !s, u = R(r.value.stops) === "array" && R(r.value.stops[0]) === "array" && R(r.value.stops[0][0]) === "object", c = le({
		key: r.key,
		value: r.value,
		valueSpec: r.styleSpec.function,
		validateSpec: r.validateSpec,
		style: r.style,
		styleSpec: r.styleSpec,
		objectElementValidators: {
			stops: p,
			default: h
		}
	});
	return t === "identity" && s && c.push(new w(r.key, r.value, "missing required property \"property\"")), t !== "identity" && !r.value.stops && c.push(new w(r.key, r.value, "missing required property \"stops\"")), t === "exponential" && r.valueSpec.expression && !io(r.valueSpec) && c.push(new w(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (l && !Yt(r.valueSpec) ? c.push(new w(r.key, r.value, "property functions not supported")) : s && !oo(r.valueSpec) && c.push(new w(r.key, r.value, "zoom functions not supported"))), (t === "categorical" || u) && r.value.property === void 0 && c.push(new w(r.key, r.value, "\"property\" property is required")), c;
	function p(m) {
		if (t === "identity") return [new w(m.key, m.value, "identity function may not have a \"stops\" property")];
		let y = [];
		const b = m.value;
		return y = y.concat(En({
			key: m.key,
			value: b,
			valueSpec: m.valueSpec,
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec,
			arrayElementValidator: d
		})), R(b) === "array" && b.length === 0 && y.push(new w(m.key, b, "array must have at least one stop")), y;
	}
	function d(m) {
		let y = [];
		const b = m.value, v = m.key;
		if (R(b) !== "array") return [new w(v, b, `array expected, ${R(b)} found`)];
		if (b.length !== 2) return [new w(v, b, `array length 2 expected, length ${b.length} found`)];
		if (u) {
			if (R(b[0]) !== "object") return [new w(v, b, `object expected, ${R(b[0])} found`)];
			if (b[0].zoom === void 0) return [new w(v, b, "object stop key must have zoom")];
			if (b[0].value === void 0) return [new w(v, b, "object stop key must have value")];
			if (i && i > G(b[0].zoom)) return [new w(v, b[0].zoom, "stop zoom values must appear in ascending order")];
			G(b[0].zoom) !== i && (i = G(b[0].zoom), o = void 0, a = {}), y = y.concat(le({
				key: `${v}[0]`,
				value: b[0],
				valueSpec: { zoom: {} },
				validateSpec: m.validateSpec,
				style: m.style,
				styleSpec: m.styleSpec,
				objectElementValidators: {
					zoom: mr,
					value: f
				}
			}));
		} else y = y.concat(f({
			key: `${v}[0]`,
			value: b[0],
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec
		}, b));
		return so(Ze(b[1])) ? y.concat([new w(`${v}[1]`, b[1], "expressions are not allowed in function stops.")]) : y.concat(m.validateSpec({
			key: `${v}[1]`,
			value: b[1],
			valueSpec: e,
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec
		}));
	}
	function f(m, y) {
		const b = R(m.value), v = G(m.value), x = m.value !== null ? m.value : y;
		if (!n) n = b;
		else if (b !== n) return [new w(m.key, x, `${b} stop domain type must match previous stop domain type ${n}`)];
		if (b !== "number" && b !== "string" && b !== "boolean") return [new w(m.key, x, "stop domain value must be a number, string, or boolean")];
		if (b !== "number" && t !== "categorical") {
			let E = `number expected, ${b} found`;
			return Yt(e) && t === void 0 && (E += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new w(m.key, x, E)];
		}
		return t === "categorical" && b === "number" && (!isFinite(v) || Math.floor(v) !== v) ? [new w(m.key, x, `integer expected, found ${v}`)] : t !== "categorical" && b === "number" && o !== void 0 && v < o ? [new w(m.key, x, "stop domain values must appear in ascending order")] : (o = v, t === "categorical" && v in a ? [new w(m.key, x, "stop domain values must be unique")] : (a[v] = !0, []));
	}
	function h(m) {
		return m.validateSpec({
			key: m.key,
			value: m.value,
			valueSpec: e,
			validateSpec: m.validateSpec,
			style: m.style,
			styleSpec: m.styleSpec
		});
	}
}
function st(r) {
	const e = (r.expressionContext === "property" ? Gl : lo)(Ze(r.value), r.valueSpec);
	if (e.result === "error") return e.value.map((n) => new w(`${r.key}${n.key}`, r.value, n.message));
	const t = e.value.expression || e.value._styleExpression.expression;
	if (r.expressionContext === "property" && r.propertyKey === "text-font" && !t.outputDefined()) return [new w(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)];
	if (r.expressionContext === "property" && r.propertyType === "layout" && !xt(t)) return [new w(r.key, r.value, "\"feature-state\" data expressions are not supported with layout properties.")];
	if (r.expressionContext === "filter" && !xt(t)) return [new w(r.key, r.value, "\"feature-state\" data expressions are not supported with filters.")];
	if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
		if (!hr(t, ["zoom", "feature-state"])) return [new w(r.key, r.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
		if (r.expressionContext === "cluster-initial" && !dr(t)) return [new w(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
	}
	return [];
}
function Kl(r) {
	const e = r.value, t = r.key, n = R(e);
	return n !== "boolean" ? [new w(t, e, `boolean expected, ${n} found`)] : [];
}
function Zr(r) {
	const e = r.key, t = r.value, n = R(t);
	return n !== "string" ? [new w(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new w(e, t, `color expected, "${t}" found`)];
}
function kt(r) {
	const e = r.key, t = r.value, n = r.valueSpec, a = [];
	return Array.isArray(n.values) ? n.values.indexOf(G(t)) === -1 && a.push(new w(e, t, `expected one of [${n.values.join(", ")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(G(t)) === -1 && a.push(new w(e, t, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(t)} found`)), a;
}
function An(r) {
	return uo(Ze(r.value)) ? st(qt({}, r, {
		expressionContext: "filter",
		valueSpec: { value: "boolean" }
	})) : fo(r);
}
function fo(r) {
	const e = r.value, t = r.key;
	if (R(e) !== "array") return [new w(t, e, `array expected, ${R(e)} found`)];
	const n = r.styleSpec;
	let a, o = [];
	if (e.length < 1) return [new w(t, e, "filter array must have at least 1 element")];
	switch (o = o.concat(kt({
		key: `${t}[0]`,
		value: e[0],
		valueSpec: n.filter_operator,
		style: r.style,
		styleSpec: r.styleSpec
	})), G(e[0])) {
		case "<":
		case "<=":
		case ">":
		case ">=": e.length >= 2 && G(e[1]) === "$type" && o.push(new w(t, e, `"$type" cannot be use with operator "${e[0]}"`));
		case "==":
		case "!=": e.length !== 3 && o.push(new w(t, e, `filter array for operator "${e[0]}" must have 3 elements`));
		case "in":
		case "!in":
			e.length >= 2 && (a = R(e[1]), a !== "string" && o.push(new w(`${t}[1]`, e[1], `string expected, ${a} found`)));
			for (let i = 2; i < e.length; i++) a = R(e[i]), G(e[1]) === "$type" ? o = o.concat(kt({
				key: `${t}[${i}]`,
				value: e[i],
				valueSpec: n.geometry_type,
				style: r.style,
				styleSpec: r.styleSpec
			})) : a !== "string" && a !== "number" && a !== "boolean" && o.push(new w(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));
			break;
		case "any":
		case "all":
		case "none":
			for (let i = 1; i < e.length; i++) o = o.concat(fo({
				key: `${t}[${i}]`,
				value: e[i],
				style: r.style,
				styleSpec: r.styleSpec
			}));
			break;
		case "has":
		case "!has":
			a = R(e[1]), e.length !== 2 ? o.push(new w(t, e, `filter array for "${e[0]}" operator must have 2 elements`)) : a !== "string" && o.push(new w(`${t}[1]`, e[1], `string expected, ${a} found`));
			break;
	}
	return o;
}
function ho(r, e) {
	const t = r.key, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.value, s = r.objectKey, l = o[`${e}_${r.layerType}`];
	if (!l) return [];
	const u = s.match(/^(.*)-transition$/);
	if (e === "paint" && u && l[u[1]] && l[u[1]].transition) return n({
		key: t,
		value: i,
		valueSpec: o.transition,
		style: a,
		styleSpec: o
	});
	const c = r.valueSpec || l[s];
	if (!c) return [new w(t, i, `unknown property "${s}"`)];
	let p;
	if (R(i) === "string" && Yt(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i))) return [new w(t, i, `"${s}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\`.`)];
	const d = [];
	return r.layerType === "symbol" && s === "text-font" && Ln(Ze(i)) && G(i.type) === "identity" && d.push(new w(t, i, "\"text-font\" does not support identity functions")), d.concat(n({
		key: r.key,
		value: i,
		valueSpec: c,
		style: a,
		styleSpec: o,
		expressionContext: "property",
		propertyType: e,
		propertyKey: s
	}));
}
function mo(r) {
	return ho(r, "paint");
}
function yo(r) {
	return ho(r, "layout");
}
function go(r) {
	let e = [];
	const t = r.value, n = r.key, a = r.style, o = r.styleSpec;
	if (R(t) !== "object") return [new w(n, t, `object expected, ${R(t)} found`)];
	!t.type && !t.ref && e.push(new w(n, t, "either \"type\" or \"ref\" is required"));
	let i = G(t.type);
	const s = G(t.ref);
	if (t.id) {
		const l = G(t.id);
		for (let u = 0; u < r.arrayIndex; u++) {
			const c = a.layers[u];
			G(c.id) === l && e.push(new w(n, t.id, `duplicate layer id "${t.id}", previously used at line ${c.id.__line__}`));
		}
	}
	if ("ref" in t) {
		[
			"type",
			"source",
			"source-layer",
			"filter",
			"layout"
		].forEach((u) => {
			u in t && e.push(new w(n, t[u], `"${u}" is prohibited for ref layers`));
		});
		let l;
		a.layers.forEach((u) => {
			G(u.id) === s && (l = u);
		}), l ? l.ref ? e.push(new w(n, t.ref, "ref cannot reference another ref layer")) : i = G(l.type) : e.push(new w(n, t.ref, `ref layer "${s}" not found`));
	} else if (i !== "background") if (!t.source) e.push(new w(n, t, "missing required property \"source\""));
	else {
		const l = a.sources && a.sources[t.source], u = l && G(l.type);
		l ? u === "vector" && i === "raster" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster source`)) : u !== "raster-dem" && i === "hillshade" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u !== "raster-dem" && i === "color-relief" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u === "raster" && i !== "raster" ? e.push(new w(n, t.source, `layer "${t.id}" requires a vector source`)) : u === "vector" && !t["source-layer"] ? e.push(new w(n, t, `layer "${t.id}" must specify a "source-layer"`)) : u === "raster-dem" && i !== "hillshade" && i !== "color-relief" ? e.push(new w(n, t.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : i === "line" && t.paint && t.paint["line-gradient"] && (u !== "geojson" || !l.lineMetrics) && e.push(new w(n, t, `layer "${t.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new w(n, t.source, `source "${t.source}" not found`));
	}
	return e = e.concat(le({
		key: n,
		value: t,
		valueSpec: o.layer,
		style: r.style,
		styleSpec: r.styleSpec,
		validateSpec: r.validateSpec,
		objectElementValidators: {
			"*"() {
				return [];
			},
			type() {
				return r.validateSpec({
					key: `${n}.type`,
					value: t.type,
					valueSpec: o.layer.type,
					style: r.style,
					styleSpec: r.styleSpec,
					validateSpec: r.validateSpec,
					object: t,
					objectKey: "type"
				});
			},
			filter: An,
			layout(l) {
				return le({
					layer: t,
					key: l.key,
					value: l.value,
					style: l.style,
					styleSpec: l.styleSpec,
					validateSpec: l.validateSpec,
					objectElementValidators: { "*"(u) {
						return yo(qt({ layerType: i }, u));
					} }
				});
			},
			paint(l) {
				return le({
					layer: t,
					key: l.key,
					value: l.value,
					style: l.style,
					styleSpec: l.styleSpec,
					validateSpec: l.validateSpec,
					objectElementValidators: { "*"(u) {
						return mo(qt({ layerType: i }, u));
					} }
				});
			}
		}
	})), e;
}
function Ke(r) {
	const e = r.value, t = r.key, n = R(e);
	return n !== "string" ? [new w(t, e, `string expected, ${n} found`)] : [];
}
function Xl(r) {
	var e;
	const t = (e = r.sourceName) !== null && e !== void 0 ? e : "", n = r.value, a = r.styleSpec, o = a.source_raster_dem, i = r.style;
	let s = [];
	const l = R(n);
	if (n === void 0) return s;
	if (l !== "object") return s.push(new w("source_raster_dem", n, `object expected, ${l} found`)), s;
	const c = G(n.encoding) === "custom", p = [
		"redFactor",
		"greenFactor",
		"blueFactor",
		"baseShift"
	], d = r.value.encoding ? `"${r.value.encoding}"` : "Default";
	for (const f in n) !c && p.includes(f) ? s.push(new w(f, n[f], `In "${t}": "${f}" is only valid when "encoding" is set to "custom". ${d} encoding found`)) : o[f] ? s = s.concat(r.validateSpec({
		key: f,
		value: n[f],
		valueSpec: o[f],
		validateSpec: r.validateSpec,
		style: i,
		styleSpec: a
	})) : s.push(new w(f, n[f], `unknown property "${f}"`));
	return s;
}
var sa = { promoteId: Yl };
function vo(r) {
	const e = r.value, t = r.key, n = r.styleSpec, a = r.style, o = r.validateSpec;
	if (!e.type) return [new w(t, e, "\"type\" is required")];
	const i = G(e.type);
	let s;
	switch (i) {
		case "vector":
		case "raster": return s = le({
			key: t,
			value: e,
			valueSpec: n[`source_${i.replace("-", "_")}`],
			style: r.style,
			styleSpec: n,
			objectElementValidators: sa,
			validateSpec: o
		}), s;
		case "raster-dem": return s = Xl({
			sourceName: t,
			value: e,
			style: r.style,
			styleSpec: n,
			validateSpec: o
		}), s;
		case "geojson":
			if (s = le({
				key: t,
				value: e,
				valueSpec: n.source_geojson,
				style: a,
				styleSpec: n,
				validateSpec: o,
				objectElementValidators: sa
			}), e.cluster) for (const l in e.clusterProperties) {
				const [u, c] = e.clusterProperties[l], p = typeof u == "string" ? [
					u,
					["accumulated"],
					["get", l]
				] : u;
				s.push(...st({
					key: `${t}.${l}.map`,
					value: c,
					expressionContext: "cluster-map"
				})), s.push(...st({
					key: `${t}.${l}.reduce`,
					value: p,
					expressionContext: "cluster-reduce"
				}));
			}
			return s;
		case "video": return le({
			key: t,
			value: e,
			valueSpec: n.source_video,
			style: a,
			validateSpec: o,
			styleSpec: n
		});
		case "image": return le({
			key: t,
			value: e,
			valueSpec: n.source_image,
			style: a,
			validateSpec: o,
			styleSpec: n
		});
		case "canvas": return [new w(t, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
		default: return kt({
			key: `${t}.type`,
			value: e.type,
			valueSpec: { values: [
				"vector",
				"raster",
				"raster-dem",
				"geojson",
				"video",
				"image"
			] }
		});
	}
}
function Yl({ key: r, value: e }) {
	if (R(e) === "string") return Ke({
		key: r,
		value: e
	});
	{
		const t = [];
		for (const n in e) t.push(...Ke({
			key: `${r}.${n}`,
			value: e[n]
		}));
		return t;
	}
}
function bo(r) {
	const e = r.value, t = r.styleSpec, n = t.light, a = r.style;
	let o = [];
	const i = R(e);
	if (e === void 0) return o;
	if (i !== "object") return o = o.concat([new w("light", e, `object expected, ${i} found`)]), o;
	for (const s in e) {
		const l = s.match(/^(.*)-transition$/);
		l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({
			key: s,
			value: e[s],
			valueSpec: t.transition,
			validateSpec: r.validateSpec,
			style: a,
			styleSpec: t
		})) : n[s] ? o = o.concat(r.validateSpec({
			key: s,
			value: e[s],
			valueSpec: n[s],
			validateSpec: r.validateSpec,
			style: a,
			styleSpec: t
		})) : o = o.concat([new w(s, e[s], `unknown property "${s}"`)]);
	}
	return o;
}
function wo(r) {
	const e = r.value, t = r.styleSpec, n = t.sky, a = r.style, o = R(e);
	if (e === void 0) return [];
	if (o !== "object") return [new w("sky", e, `object expected, ${o} found`)];
	let i = [];
	for (const s in e) n[s] ? i = i.concat(r.validateSpec({
		key: s,
		value: e[s],
		valueSpec: n[s],
		style: a,
		styleSpec: t
	})) : i = i.concat([new w(s, e[s], `unknown property "${s}"`)]);
	return i;
}
function So(r) {
	const e = r.value, t = r.styleSpec, n = t.terrain, a = r.style;
	let o = [];
	const i = R(e);
	if (e === void 0) return o;
	if (i !== "object") return o = o.concat([new w("terrain", e, `object expected, ${i} found`)]), o;
	for (const s in e) n[s] ? o = o.concat(r.validateSpec({
		key: s,
		value: e[s],
		valueSpec: n[s],
		validateSpec: r.validateSpec,
		style: a,
		styleSpec: t
	})) : o = o.concat([new w(s, e[s], `unknown property "${s}"`)]);
	return o;
}
function Wl(r) {
	return Ke(r).length === 0 ? [] : st(r);
}
function Jl(r) {
	return Ke(r).length === 0 ? [] : st(r);
}
function Ql(r) {
	const e = r.key, t = r.value;
	if (R(t) === "array") {
		if (t.length < 1 || t.length > 4) return [new w(e, t, `padding requires 1 to 4 values; ${t.length} values found`)];
		const a = { type: "number" };
		let o = [];
		for (let i = 0; i < t.length; i++) o = o.concat(r.validateSpec({
			key: `${e}[${i}]`,
			value: t[i],
			validateSpec: r.validateSpec,
			valueSpec: a
		}));
		return o;
	} else return mr({
		key: e,
		value: t,
		valueSpec: {}
	});
}
function eu(r) {
	const e = r.key, t = r.value;
	if (R(t) === "array") {
		const a = { type: "number" };
		if (t.length < 1) return [new w(e, t, "array length at least 1 expected, length 0 found")];
		let o = [];
		for (let i = 0; i < t.length; i++) o = o.concat(r.validateSpec({
			key: `${e}[${i}]`,
			value: t[i],
			validateSpec: r.validateSpec,
			valueSpec: a
		}));
		return o;
	} else return mr({
		key: e,
		value: t,
		valueSpec: {}
	});
}
function tu(r) {
	const e = r.key, t = r.value;
	if (R(t) === "array") {
		if (t.length < 1) return [new w(e, t, "array length at least 1 expected, length 0 found")];
		let a = [];
		for (let o = 0; o < t.length; o++) a = a.concat(Zr({
			key: `${e}[${o}]`,
			value: t[o]
		}));
		return a;
	} else return Zr({
		key: e,
		value: t
	});
}
function ru(r) {
	const e = r.key, t = r.value, n = R(t), a = r.styleSpec;
	if (n !== "array" || t.length < 1 || t.length % 2 !== 0) return [new w(e, t, "variableAnchorOffsetCollection requires a non-empty array of even length")];
	let o = [];
	for (let i = 0; i < t.length; i += 2) o = o.concat(kt({
		key: `${e}[${i}]`,
		value: t[i],
		valueSpec: a.layout_symbol["text-anchor"]
	})), o = o.concat(En({
		key: `${e}[${i + 1}]`,
		value: t[i + 1],
		valueSpec: {
			length: 2,
			value: "number"
		},
		validateSpec: r.validateSpec,
		style: r.style,
		styleSpec: a
	}));
	return o;
}
function xo(r) {
	let e = [];
	const t = r.value, n = r.key;
	if (Array.isArray(t)) {
		const a = [], o = [];
		for (const i in t) {
			t[i].id && a.includes(t[i].id) && e.push(new w(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new w(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);
			e = e.concat(le({
				key: `${n}[${i}]`,
				value: t[i],
				valueSpec: {
					id: {
						type: "string",
						required: !0
					},
					url: {
						type: "string",
						required: !0
					}
				},
				validateSpec: r.validateSpec
			}));
		}
		return e;
	} else return Ke({
		key: n,
		value: t
	});
}
function nu(r) {
	const e = r.value, t = r.styleSpec, n = t.projection, a = r.style, o = R(e);
	if (e === void 0) return [];
	if (o !== "object") return [new w("projection", e, `object expected, ${o} found`)];
	let i = [];
	for (const s in e) n[s] ? i = i.concat(r.validateSpec({
		key: s,
		value: e[s],
		valueSpec: n[s],
		style: a,
		styleSpec: t
	})) : i = i.concat([new w(s, e[s], `unknown property "${s}"`)]);
	return i;
}
function au(r) {
	const e = r.key;
	let t = r.value;
	t = t instanceof String ? t.valueOf() : t;
	const n = R(t);
	return n === "array" && !iu(t) && !ou(t) ? [new w(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)] : ["array", "string"].includes(n) ? [] : [new w(e, t, `projection expected, invalid type "${n}" found`)];
}
function ou(r) {
	return !![
		"interpolate",
		"step",
		"literal"
	].includes(r[0]);
}
function iu(r) {
	return Array.isArray(r) && r.length === 3 && typeof r[0] == "string" && typeof r[1] == "string" && typeof r[2] == "number";
}
function su(r) {
	return !!r && r.constructor === Object;
}
function ko(r) {
	return su(r.value) ? [] : [new w(r.key, r.value, `object expected, ${R(r.value)} found`)];
}
var la = {
	"*"() {
		return [];
	},
	array: En,
	boolean: Kl,
	number: mr,
	color: Zr,
	constants: co,
	enum: kt,
	filter: An,
	function: po,
	layer: go,
	object: le,
	source: vo,
	light: bo,
	sky: wo,
	terrain: So,
	projection: nu,
	projectionDefinition: au,
	string: Ke,
	formatted: Wl,
	resolvedImage: Jl,
	padding: Ql,
	numberArray: eu,
	colorArray: tu,
	variableAnchorOffsetCollection: ru,
	sprite: xo,
	state: ko
};
function Wt(r) {
	const e = r.value, t = r.valueSpec, n = r.styleSpec;
	return r.validateSpec = Wt, t.expression && Ln(G(e)) ? po(r) : t.expression && so(Ze(e)) ? st(r) : t.type && la[t.type] ? la[t.type](r) : le(qt({}, r, { valueSpec: t.type ? n[t.type] : t }));
}
function Lo(r) {
	const e = r.value, t = r.key, n = Ke(r);
	return n.length || (e.indexOf("{fontstack}") === -1 && n.push(new w(t, e, "\"glyphs\" url must include a \"{fontstack}\" token")), e.indexOf("{range}") === -1 && n.push(new w(t, e, "\"glyphs\" url must include a \"{range}\" token"))), n;
}
function ie(r, e = Os) {
	let t = [];
	return t = t.concat(Wt({
		key: "",
		value: r,
		valueSpec: e.$root,
		styleSpec: e,
		style: r,
		validateSpec: Wt,
		objectElementValidators: {
			glyphs: Lo,
			"*"() {
				return [];
			}
		}
	})), r.constants && (t = t.concat(co({
		key: "constants",
		value: r.constants
	}))), Co(t);
}
ie.source = ye(me(vo));
ie.sprite = ye(me(xo));
ie.glyphs = ye(me(Lo));
ie.light = ye(me(bo));
ie.sky = ye(me(wo));
ie.terrain = ye(me(So));
ie.state = ye(me(ko));
ie.layer = ye(me(go));
ie.filter = ye(me(An));
ie.paintProperty = ye(me(mo));
ie.layoutProperty = ye(me(yo));
function me(r) {
	return function(e) {
		return r(Object.assign({}, e, { validateSpec: Wt }));
	};
}
function Co(r) {
	return [].concat(r).sort((e, t) => e.line - t.line);
}
function ye(r) {
	return function(...e) {
		return Co(r.apply(this, e));
	};
}
function ua(r) {
	if (!r) return {
		style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !0
	};
	if (typeof r == "string") {
		const t = uu(r);
		return t.isValidStyle ? {
			style: t.styleObject,
			requiresUrlMonitoring: !1,
			isFallback: !1
		} : t.isValidJSON ? {
			style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
			requiresUrlMonitoring: !1,
			isFallback: !0
		} : r.startsWith("http") ? {
			style: r,
			requiresUrlMonitoring: !0,
			isFallback: !1
		} : r.toLowerCase().includes(".json") ? {
			style: lu(r),
			requiresUrlMonitoring: !0,
			isFallback: !1
		} : {
			style: expandMapStyle(r),
			requiresUrlMonitoring: !0,
			isFallback: !1
		};
	}
	return r instanceof MapStyleVariant ? {
		style: r.getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !1
	} : r instanceof ReferenceMapStyle ? {
		style: r.getDefaultVariant().getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !1
	} : ie(r).length === 0 ? {
		style: r,
		requiresUrlMonitoring: !1,
		isFallback: !1,
		isJSON: !0
	} : {
		style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
		requiresUrlMonitoring: !1,
		isFallback: !0
	};
}
function lu(r) {
	try {
		return new URL(r).href;
	} catch {}
	return new URL(r, location.origin).href;
}
function uu(r) {
	try {
		const e = JSON.parse(r), t = ie(e);
		return {
			isValidJSON: !0,
			isValidStyle: t.length === 0,
			styleObject: t.length === 0 ? e : null
		};
	} catch {
		return {
			isValidJSON: !1,
			isValidStyle: !1,
			styleObject: null
		};
	}
}
function Ce(r, e, t) {
	const n = window.document.createElement(r);
	return e !== void 0 && (n.className = e), t && t.appendChild(n), n;
}
function Lt(r) {
	r.parentNode && r.parentNode.removeChild(r);
}
var cu = class {
	constructor() {
		g(this, "_map");
		g(this, "_container");
		g(this, "_terrainButton");
		Ni(["_toggleTerrain", "_updateTerrainIcon"], this);
	}
	onAdd(e) {
		return this._map = e, this._container = Ce("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Ce("button", "maplibregl-ctrl-terrain", this._container), Ce("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
	}
	onRemove() {
		Lt(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
	}
	_toggleTerrain() {
		Eo(this._map), this._updateTerrainIcon();
	}
	_updateTerrainIcon() {
		this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
	}
};
function Eo(r) {
	r.hasTerrain() ? r.disableTerrain() : r.enableTerrain();
}
var pu = class extends Na {
	constructor(t = {}) {
		super({
			showCompass: t.showCompass ?? !0,
			showZoom: t.showZoom ?? !0,
			visualizePitch: t.visualizePitch ?? !0
		});
		/**
		* Overloading: Limit how flat the compass icon can get
		*/
		g(this, "_rotateCompassArrow", () => {
			const t$1 = this._map.getBearing(), n = this._map.getPitch(), a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** .5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t$1}deg)` : `rotate(${-t$1}deg)`;
			this._compassIcon.style.transform = a;
		});
		this._compass && (this._compass.removeEventListener("click", this._compass.clickFunction), this._compass.addEventListener("click", (n) => {
			this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: n }) : this._map.resetNorth({}, { originalEvent: n });
		}));
	}
	/**
	* Overloading: the button now stores its click callback so that we can later on delete it and replace it
	*/
	_createButton(t, n) {
		const a = super._createButton(t, n);
		return a.clickFunction = n, a;
	}
};
var ca = import_maplibre_gl.default.Marker, pa = import_maplibre_gl.default.LngLat, fu = import_maplibre_gl.default.LngLatBounds;
var du = class extends Ei {
	constructor() {
		super(...arguments);
		g(this, "lastUpdatedCenter", new pa(0, 0));
		/**
		* Update the camera location to center on the current position
		*
		* @param {Position} position the Geolocation API Position
		* @private
		*/
		g(this, "_updateCamera", (t) => {
			var c;
			const n = new pa(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, i = {
				bearing: this._map.getBearing(),
				...this.options.fitBoundsOptions,
				linear: !0
			}, s = this._map.getZoom();
			s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(fu.fromLngLat(n, a), i, { geolocateSource: !0 });
			let l = !1;
			const u = () => {
				l = !0;
			};
			this._map.once("click", u), this._map.once("dblclick", u), this._map.once("dragstart", u), this._map.once("mousedown", u), this._map.once("touchstart", u), this._map.once("wheel", u), this._map.once("moveend", () => {
				this._map.off("click", u), this._map.off("dblclick", u), this._map.off("dragstart", u), this._map.off("mousedown", u), this._map.off("touchstart", u), this._map.off("wheel", u), !l && (this.lastUpdatedCenter = this._map.getCenter());
			});
		});
		g(this, "_finishSetupUI", (t) => {
			if (this._map) {
				if (t === !1) {
					const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
					this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
				} else {
					const n = this._map._getUIString("GeolocateControl.FindMyLocation");
					this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
				}
				this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Ce("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ca({ element: this._dotElement }), this._circleElement = Ce("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ca({
					element: this._circleElement,
					pitchAlignment: "map"
				}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("move", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("moveend", (n) => {
					const a = n.originalEvent && n.originalEvent.type === "resize", o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
					!n.geolocateSource && this._watchState === "ACTIVE_LOCK" && !a && o > 1 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
				});
			}
		});
		g(this, "_onZoom", () => {
			this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
		});
	}
	_updateCircleRadius() {
		if (this._watchState !== "BACKGROUND" && this._watchState !== "ACTIVE_LOCK") return;
		const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], n = this._map.project(t), a = this._map.unproject([n.x, n.y]), o = this._map.unproject([n.x + 20, n.y]), i = a.distanceTo(o) / 20, s = Math.ceil(2 * this._accuracy / i);
		this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;
	}
	_setErrorState() {
		switch (this._watchState) {
			case "WAITING_ACTIVE":
				this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
				break;
			case "ACTIVE_LOCK":
				this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
				break;
			case "BACKGROUND":
				this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
				break;
			case "ACTIVE_ERROR": break;
			case "BACKGROUND_ERROR": break;
			default: throw new Error(`Unexpected watchState ${this._watchState}`);
		}
	}
};
var Te, ee, _e, Ie, nt;
var hu = class {
	/**
	* @param selectorOrElement Element to be used as control, specified as either reference to element itself or a CSS selector to find the element in DOM
	* @param onClick Function called when the element is clicked
	* @param onRender Function called every time the underlying map renders a new state
	*/
	constructor(e, t, n) {
		Y(this, Te);
		Y(this, ee);
		Y(this, _e);
		Y(this, Ie);
		Y(this, nt);
		if (typeof e == "string") {
			const a = document.querySelector(e);
			if (!a) throw new Error(`No element has been found with selector "${e}" when creating an external control.`);
			J(this, ee, a);
		} else J(this, ee, e);
		t && J(this, _e, (a) => {
			t(L(this, Te), L(this, ee), a);
		}), n && J(this, Ie, (a) => {
			n(L(this, Te), L(this, ee), a);
		}), J(this, nt, L(this, ee).parentElement);
	}
	onAdd(e) {
		return J(this, Te, e), L(this, _e) && L(this, ee).addEventListener("click", L(this, _e)), L(this, Ie) && L(this, Te).on("render", L(this, Ie)), Lt(L(this, ee)), L(this, ee);
	}
	onRemove() {
		L(this, _e) && L(this, ee).removeEventListener("click", L(this, _e)), L(this, Ie) && L(this, Te).off("render", L(this, Ie)), L(this, nt) ? L(this, nt).appendChild(L(this, ee)) : Lt(L(this, ee));
	}
};
Te = /* @__PURE__ */ new WeakMap(), ee = /* @__PURE__ */ new WeakMap(), _e = /* @__PURE__ */ new WeakMap(), Ie = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap();
var mu = class {
	constructor() {
		g(this, "map");
		g(this, "container");
		g(this, "projectionButton");
	}
	onAdd(e) {
		return this.map = e, this.container = Ce("div", "maplibregl-ctrl maplibregl-ctrl-group"), this.projectionButton = Ce("button", "maplibregl-ctrl-projection", this.container), Ce("span", "maplibregl-ctrl-icon", this.projectionButton).setAttribute("aria-hidden", "true"), this.projectionButton.type = "button", this.projectionButton.addEventListener("click", this.toggleProjection.bind(this)), e.on("projectiontransition", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;
	}
	onRemove() {
		Lt(this.container), this.map.off("projectiontransition", this.updateProjectionIcon), this.map = void 0;
	}
	toggleProjection() {
		Ao(this.map), this.updateProjectionIcon();
	}
	updateProjectionIcon() {
		this.projectionButton.classList.remove("maplibregl-ctrl-projection-globe"), this.projectionButton.classList.remove("maplibregl-ctrl-projection-mercator"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add("maplibregl-ctrl-projection-mercator"), this.projectionButton.title = "Enable Mercator projection") : (this.projectionButton.classList.add("maplibregl-ctrl-projection-globe"), this.projectionButton.title = "Enable Globe projection");
	}
};
function Ao(r) {
	r.getProjection() === void 0 && r.setProjection({ type: "mercator" }), r.isGlobeProjection() ? r.enableMercatorProjection() : r.enableGlobeProjection();
}
var ct = {
	"zoom-in": (r) => r.zoomIn(),
	"zoom-out": (r) => r.zoomOut(),
	"toggle-projection": Ao,
	"toggle-terrain": Eo,
	"reset-view": (r) => {
		r.getPitch() === 0 ? r.easeTo({ pitch: Math.min(r.getMaxPitch(), 80) }) : r.resetNorthPitch();
	},
	"reset-bearing": (r) => {
		r.rotateTo(0);
	},
	"reset-pitch": (r) => {
		r.setPitch(0);
	},
	"reset-roll": (r) => {
		r.setRoll(0);
	}
};
var Et, at;
var Kr = class extends hu {
	/**
	* Constructs an instance of External Control to have a predefined functionality
	* @param controlElement Element to be used as control, specified as reference to element itself
	* @param controlType One of the predefined types of functionality
	*/
	constructor(t, n) {
		if (n && !(n in ct)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
		super(t, n && ct[n]);
		Y(this, Et);
		Y(this, at, /* @__PURE__ */ new Map());
	}
	onAdd(t) {
		return J(this, Et, t), super.onAdd(t);
	}
	onRemove() {
		for (const [t, n] of L(this, at)) {
			const a = t.deref();
			a && a.removeEventListener("click", n);
		}
		L(this, at).clear(), super.onRemove();
	}
	/**
	* Configure a child element to be part of this control and to have a predefined functionality added
	* @param controlElement Element that is a descendant of the control element and that optionally should have some functionality
	* @param controlType One of the predefined types of functionality
	*/
	configureGroupItem(t, n) {
		if (!n) return;
		if (!(n in ct)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
		const a = (o) => {
			ct[n](L(this, Et), t, o);
		};
		t.addEventListener("click", a), L(this, at).set(new WeakRef(t), a);
	}
};
Et = /* @__PURE__ */ new WeakMap(), at = /* @__PURE__ */ new WeakMap(), g(Kr, "controlCallbacks", ct);
var te, ue, Me, Pe, re, At, Z, To, se, _o;
var _r = class {
	constructor(e, t) {
		Y(this, Z);
		Y(this, te);
		g(this, "map");
		Y(this, ue);
		Y(this, Me);
		Y(this, Pe);
		Y(this, re, !1);
		Y(this, At);
		e.style !== void 0 && J(this, re, !0), J(this, te, {
			zoomAdjust: -4,
			position: "top-right",
			...t,
			forceNoAttributionControl: !0,
			attributionControl: !1,
			navigationControl: !1,
			geolocateControl: !1,
			maptilerLogo: !1,
			minimap: !1,
			hash: !1,
			pitchAdjust: !1,
			...e,
			containerStyle: {
				border: "1px solid #000",
				width: "400px",
				height: "300px",
				...e.containerStyle ?? {}
			}
		}), e.lockZoom !== void 0 && (L(this, te).minZoom = e.lockZoom, L(this, te).maxZoom = e.lockZoom);
	}
	setStyle(e, t) {
		L(this, re) || this.map.setStyle(e, t), Q(this, Z, se).call(this);
	}
	addLayer(e, t) {
		return L(this, re) || this.map.addLayer(e, t), Q(this, Z, se).call(this), this.map;
	}
	moveLayer(e, t) {
		return L(this, re) || this.map.moveLayer(e, t), Q(this, Z, se).call(this), this.map;
	}
	removeLayer(e) {
		return L(this, re) || this.map.removeLayer(e), Q(this, Z, se).call(this), this;
	}
	setLayerZoomRange(e, t, n) {
		return L(this, re) || this.map.setLayerZoomRange(e, t, n), Q(this, Z, se).call(this), this;
	}
	setFilter(e, t, n) {
		return L(this, re) || this.map.setFilter(e, t, n), Q(this, Z, se).call(this), this;
	}
	setPaintProperty(e, t, n, a) {
		return L(this, re) || this.map.setPaintProperty(e, t, n, a), Q(this, Z, se).call(this), this;
	}
	setLayoutProperty(e, t, n, a) {
		return L(this, re) || this.map.setLayoutProperty(e, t, n, a), Q(this, Z, se).call(this), this;
	}
	setGlyphs(e, t) {
		return L(this, re) || this.map.setGlyphs(e, t), Q(this, Z, se).call(this), this;
	}
	onAdd(e) {
		J(this, ue, e), J(this, Me, Ce("div", "maplibregl-ctrl maplibregl-ctrl-group"));
		for (const [t, n] of Object.entries(L(this, te).containerStyle)) L(this, Me).style.setProperty(t, n);
		return L(this, te).container = L(this, Me), L(this, te).zoom = e.getZoom() + L(this, te).zoomAdjust, this.map = new Po(L(this, te)), this.map.once("style.load", () => {
			this.map.resize();
		}), this.map.once("load", () => {
			Q(this, Z, To).call(this, L(this, te).parentRect), J(this, At, Q(this, Z, _o).call(this));
		}), L(this, Me);
	}
	onRemove() {
		var e;
		(e = L(this, At)) == null || e.call(this), Lt(L(this, Me));
	}
};
te = /* @__PURE__ */ new WeakMap(), ue = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakMap(), Pe = /* @__PURE__ */ new WeakMap(), re = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap(), Z = /* @__PURE__ */ new WeakSet(), To = function(e) {
	e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (J(this, Pe, {
		type: "Feature",
		properties: { name: "parentRect" },
		geometry: {
			type: "Polygon",
			coordinates: [[
				[],
				[],
				[],
				[],
				[]
			]]
		}
	}), this.map.addSource("parentRect", {
		type: "geojson",
		data: L(this, Pe)
	}), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({
		id: "parentRectOutline",
		type: "line",
		source: "parentRect",
		layout: { ...e.lineLayout },
		paint: {
			"line-color": "#FFF",
			"line-width": 1,
			"line-opacity": .85,
			...e.linePaint
		}
	}), e.fillPaint !== void 0 && this.map.addLayer({
		id: "parentRectFill",
		type: "fill",
		source: "parentRect",
		layout: {},
		paint: {
			"fill-color": "#08F",
			"fill-opacity": .135,
			...e.fillPaint
		}
	}), Q(this, Z, se).call(this));
}, se = function() {
	if (L(this, Pe) === void 0) return;
	const { devicePixelRatio: e } = window, t = L(this, ue).getCanvas(), n = t.width / e, a = t.height / e, o = L(this, ue).unproject.bind(L(this, ue)), i = o([0, 0]), s = o([n, 0]), l = o([0, a]), u = o([n, a]);
	L(this, Pe).geometry.coordinates = [[
		l.toArray(),
		u.toArray(),
		s.toArray(),
		i.toArray(),
		l.toArray()
	]];
	const c = this.map.getSource("parentRect");
	c !== void 0 && c.setData(L(this, Pe));
}, _o = function() {
	const { pitchAdjust: e } = L(this, te), t = () => {
		i("parent");
	}, n = () => {
		i("minimap");
	}, a = () => {
		L(this, ue).on("move", t), this.map.on("move", n);
	}, o = () => {
		L(this, ue).off("move", t), this.map.off("move", n);
	}, i = (s) => {
		o();
		const l = s === "parent" ? L(this, ue) : this.map, u = s === "parent" ? this.map : L(this, ue), c = l.getCenter(), p = l.getZoom() + L(this, te).zoomAdjust * (s === "parent" ? 1 : -1), d = l.getBearing(), f = l.getPitch();
		u.jumpTo({
			center: c,
			zoom: p,
			bearing: d,
			pitch: e ? f : 0
		}), Q(this, Z, se).call(this), a();
	};
	return a(), () => {
		o();
	};
};
var yu = class {
	/**
	*
	* @param map : a Map instance
	* @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)
	*/
	constructor(e, t = 2e3) {
		g(this, "map");
		g(this, "registeredModules", /* @__PURE__ */ new Set());
		g(this, "viewerType");
		this.map = e, this.viewerType = "Map", setTimeout(async () => {
			if (!j.telemetry) return;
			const n = this.preparePayload();
			try {
				(await fetch(n, { method: "POST" })).ok || console.warn("The metrics could not be sent to MapTiler Cloud");
			} catch (a) {
				console.warn("The metrics could not be sent to MapTiler Cloud", a);
			}
		}, Math.max(1e3, t));
	}
	/**
	* Register a module to the telemetry system of the SDK.
	* The arguments `name` and `version` likely come from the package.json
	* of each module.
	*/
	registerModule(e, t) {
		this.registeredModules.add(`${e}:${t}`);
	}
	registerViewerType(e = "Map") {
		this.viewerType = e;
	}
	preparePayload() {
		const e = new URL(W.telemetryURL);
		return e.searchParams.append("sdk", oi()), e.searchParams.append("key", j.apiKey), e.searchParams.append("mtsid", on), e.searchParams.append("session", j.session ? "1" : "0"), e.searchParams.append("caching", j.caching ? "1" : "0"), e.searchParams.append("lang-updated", this.map.isLanguageUpdated() ? "1" : "0"), e.searchParams.append("terrain", this.map.getTerrain() ? "1" : "0"), e.searchParams.append("globe", this.map.isGlobeProjection() ? "1" : "0"), e.searchParams.append("viewerType", this.viewerType), this.registeredModules.size > 0 && e.searchParams.append("modules", Array.from(this.registeredModules).join("|")), e.href;
	}
};
var Ct = typeof Float32Array < "u" ? Float32Array : Array;
function mt() {
	var r = new Ct(16);
	return Ct != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
}
function gu(r, e, t, n, a, o, i, s, l, u, c, p, d, f, h, m, y) {
	return r[0] = e, r[1] = t, r[2] = n, r[3] = a, r[4] = o, r[5] = i, r[6] = s, r[7] = l, r[8] = u, r[9] = c, r[10] = p, r[11] = d, r[12] = f, r[13] = h, r[14] = m, r[15] = y, r;
}
function vu(r, e, t) {
	var n = e[0], a = e[1], o = e[2], i = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], d = e[9], f = e[10], h = e[11], m = e[12], y = e[13], b = e[14], v = e[15], x = t[0], E = t[1], C = t[2], T = t[3];
	return r[0] = x * n + E * s + C * p + T * m, r[1] = x * a + E * l + C * d + T * y, r[2] = x * o + E * u + C * f + T * b, r[3] = x * i + E * c + C * h + T * v, x = t[4], E = t[5], C = t[6], T = t[7], r[4] = x * n + E * s + C * p + T * m, r[5] = x * a + E * l + C * d + T * y, r[6] = x * o + E * u + C * f + T * b, r[7] = x * i + E * c + C * h + T * v, x = t[8], E = t[9], C = t[10], T = t[11], r[8] = x * n + E * s + C * p + T * m, r[9] = x * a + E * l + C * d + T * y, r[10] = x * o + E * u + C * f + T * b, r[11] = x * i + E * c + C * h + T * v, x = t[12], E = t[13], C = t[14], T = t[15], r[12] = x * n + E * s + C * p + T * m, r[13] = x * a + E * l + C * d + T * y, r[14] = x * o + E * u + C * f + T * b, r[15] = x * i + E * c + C * h + T * v, r;
}
function bu(r, e, t) {
	var n = t[0], a = t[1], o = t[2];
	return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * a, r[5] = e[5] * a, r[6] = e[6] * a, r[7] = e[7] * a, r[8] = e[8] * o, r[9] = e[9] * o, r[10] = e[10] * o, r[11] = e[11] * o, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function fa(r, e, t) {
	var n = Math.sin(t), a = Math.cos(t), o = e[4], i = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], d = e[11];
	return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = o * a + u * n, r[5] = i * a + c * n, r[6] = s * a + p * n, r[7] = l * a + d * n, r[8] = u * a - o * n, r[9] = c * a - i * n, r[10] = p * a - s * n, r[11] = d * a - l * n, r;
}
function wu(r, e, t) {
	var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[8], c = e[9], p = e[10], d = e[11];
	return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a - u * n, r[1] = i * a - c * n, r[2] = s * a - p * n, r[3] = l * a - d * n, r[8] = o * n + u * a, r[9] = i * n + c * a, r[10] = s * n + p * a, r[11] = l * n + d * a, r;
}
function da(r, e, t) {
	var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], d = e[7];
	return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a + u * n, r[1] = i * a + c * n, r[2] = s * a + p * n, r[3] = l * a + d * n, r[4] = u * a - o * n, r[5] = c * a - i * n, r[6] = p * a - s * n, r[7] = d * a - l * n, r;
}
function Su(r, e, t, n, a) {
	var o = 1 / Math.tan(e / 2);
	if (r[0] = o / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, a != null && a !== Infinity) {
		var i = 1 / (n - a);
		r[10] = (a + n) * i, r[14] = 2 * a * n * i;
	} else r[10] = -1, r[14] = -2 * n;
	return r;
}
var xu = Su;
function Dt() {
	var r = new Ct(3);
	return Ct != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function ku(r, e, t) {
	var n = new Ct(3);
	return n[0] = r, n[1] = e, n[2] = t, n;
}
function Ir(r, e) {
	var t = e[0], n = e[1], a = e[2], o = t * t + n * n + a * a;
	return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = e[0] * o, r[1] = e[1] * o, r[2] = e[2] * o, r;
}
function ha(r, e, t) {
	var n = e[0], a = e[1], o = e[2], i = t[0], s = t[1], l = t[2];
	return r[0] = a * l - o * s, r[1] = o * i - n * l, r[2] = n * s - a * i, r;
}
(function() {
	var r = Dt();
	return function(e, t, n, a, o, i) {
		var s, l;
		for (t || (t = 3), n || (n = 0), a ? l = Math.min(a * t + n, e.length) : l = e.length, s = n; s < l; s += t) r[0] = e[s], r[1] = e[s + 1], r[2] = e[s + 2], o(r, r, i), e[s] = r[0], e[s + 1] = r[1], e[s + 2] = r[2];
		return e;
	};
})();
function Lu(r) {
	return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Mr, ma;
function Cu() {
	return ma || (ma = 1, Mr = {
		aliceblue: [
			240,
			248,
			255
		],
		antiquewhite: [
			250,
			235,
			215
		],
		aqua: [
			0,
			255,
			255
		],
		aquamarine: [
			127,
			255,
			212
		],
		azure: [
			240,
			255,
			255
		],
		beige: [
			245,
			245,
			220
		],
		bisque: [
			255,
			228,
			196
		],
		black: [
			0,
			0,
			0
		],
		blanchedalmond: [
			255,
			235,
			205
		],
		blue: [
			0,
			0,
			255
		],
		blueviolet: [
			138,
			43,
			226
		],
		brown: [
			165,
			42,
			42
		],
		burlywood: [
			222,
			184,
			135
		],
		cadetblue: [
			95,
			158,
			160
		],
		chartreuse: [
			127,
			255,
			0
		],
		chocolate: [
			210,
			105,
			30
		],
		coral: [
			255,
			127,
			80
		],
		cornflowerblue: [
			100,
			149,
			237
		],
		cornsilk: [
			255,
			248,
			220
		],
		crimson: [
			220,
			20,
			60
		],
		cyan: [
			0,
			255,
			255
		],
		darkblue: [
			0,
			0,
			139
		],
		darkcyan: [
			0,
			139,
			139
		],
		darkgoldenrod: [
			184,
			134,
			11
		],
		darkgray: [
			169,
			169,
			169
		],
		darkgreen: [
			0,
			100,
			0
		],
		darkgrey: [
			169,
			169,
			169
		],
		darkkhaki: [
			189,
			183,
			107
		],
		darkmagenta: [
			139,
			0,
			139
		],
		darkolivegreen: [
			85,
			107,
			47
		],
		darkorange: [
			255,
			140,
			0
		],
		darkorchid: [
			153,
			50,
			204
		],
		darkred: [
			139,
			0,
			0
		],
		darksalmon: [
			233,
			150,
			122
		],
		darkseagreen: [
			143,
			188,
			143
		],
		darkslateblue: [
			72,
			61,
			139
		],
		darkslategray: [
			47,
			79,
			79
		],
		darkslategrey: [
			47,
			79,
			79
		],
		darkturquoise: [
			0,
			206,
			209
		],
		darkviolet: [
			148,
			0,
			211
		],
		deeppink: [
			255,
			20,
			147
		],
		deepskyblue: [
			0,
			191,
			255
		],
		dimgray: [
			105,
			105,
			105
		],
		dimgrey: [
			105,
			105,
			105
		],
		dodgerblue: [
			30,
			144,
			255
		],
		firebrick: [
			178,
			34,
			34
		],
		floralwhite: [
			255,
			250,
			240
		],
		forestgreen: [
			34,
			139,
			34
		],
		fuchsia: [
			255,
			0,
			255
		],
		gainsboro: [
			220,
			220,
			220
		],
		ghostwhite: [
			248,
			248,
			255
		],
		gold: [
			255,
			215,
			0
		],
		goldenrod: [
			218,
			165,
			32
		],
		gray: [
			128,
			128,
			128
		],
		green: [
			0,
			128,
			0
		],
		greenyellow: [
			173,
			255,
			47
		],
		grey: [
			128,
			128,
			128
		],
		honeydew: [
			240,
			255,
			240
		],
		hotpink: [
			255,
			105,
			180
		],
		indianred: [
			205,
			92,
			92
		],
		indigo: [
			75,
			0,
			130
		],
		ivory: [
			255,
			255,
			240
		],
		khaki: [
			240,
			230,
			140
		],
		lavender: [
			230,
			230,
			250
		],
		lavenderblush: [
			255,
			240,
			245
		],
		lawngreen: [
			124,
			252,
			0
		],
		lemonchiffon: [
			255,
			250,
			205
		],
		lightblue: [
			173,
			216,
			230
		],
		lightcoral: [
			240,
			128,
			128
		],
		lightcyan: [
			224,
			255,
			255
		],
		lightgoldenrodyellow: [
			250,
			250,
			210
		],
		lightgray: [
			211,
			211,
			211
		],
		lightgreen: [
			144,
			238,
			144
		],
		lightgrey: [
			211,
			211,
			211
		],
		lightpink: [
			255,
			182,
			193
		],
		lightsalmon: [
			255,
			160,
			122
		],
		lightseagreen: [
			32,
			178,
			170
		],
		lightskyblue: [
			135,
			206,
			250
		],
		lightslategray: [
			119,
			136,
			153
		],
		lightslategrey: [
			119,
			136,
			153
		],
		lightsteelblue: [
			176,
			196,
			222
		],
		lightyellow: [
			255,
			255,
			224
		],
		lime: [
			0,
			255,
			0
		],
		limegreen: [
			50,
			205,
			50
		],
		linen: [
			250,
			240,
			230
		],
		magenta: [
			255,
			0,
			255
		],
		maroon: [
			128,
			0,
			0
		],
		mediumaquamarine: [
			102,
			205,
			170
		],
		mediumblue: [
			0,
			0,
			205
		],
		mediumorchid: [
			186,
			85,
			211
		],
		mediumpurple: [
			147,
			112,
			219
		],
		mediumseagreen: [
			60,
			179,
			113
		],
		mediumslateblue: [
			123,
			104,
			238
		],
		mediumspringgreen: [
			0,
			250,
			154
		],
		mediumturquoise: [
			72,
			209,
			204
		],
		mediumvioletred: [
			199,
			21,
			133
		],
		midnightblue: [
			25,
			25,
			112
		],
		mintcream: [
			245,
			255,
			250
		],
		mistyrose: [
			255,
			228,
			225
		],
		moccasin: [
			255,
			228,
			181
		],
		navajowhite: [
			255,
			222,
			173
		],
		navy: [
			0,
			0,
			128
		],
		oldlace: [
			253,
			245,
			230
		],
		olive: [
			128,
			128,
			0
		],
		olivedrab: [
			107,
			142,
			35
		],
		orange: [
			255,
			165,
			0
		],
		orangered: [
			255,
			69,
			0
		],
		orchid: [
			218,
			112,
			214
		],
		palegoldenrod: [
			238,
			232,
			170
		],
		palegreen: [
			152,
			251,
			152
		],
		paleturquoise: [
			175,
			238,
			238
		],
		palevioletred: [
			219,
			112,
			147
		],
		papayawhip: [
			255,
			239,
			213
		],
		peachpuff: [
			255,
			218,
			185
		],
		peru: [
			205,
			133,
			63
		],
		pink: [
			255,
			192,
			203
		],
		plum: [
			221,
			160,
			221
		],
		powderblue: [
			176,
			224,
			230
		],
		purple: [
			128,
			0,
			128
		],
		rebeccapurple: [
			102,
			51,
			153
		],
		red: [
			255,
			0,
			0
		],
		rosybrown: [
			188,
			143,
			143
		],
		royalblue: [
			65,
			105,
			225
		],
		saddlebrown: [
			139,
			69,
			19
		],
		salmon: [
			250,
			128,
			114
		],
		sandybrown: [
			244,
			164,
			96
		],
		seagreen: [
			46,
			139,
			87
		],
		seashell: [
			255,
			245,
			238
		],
		sienna: [
			160,
			82,
			45
		],
		silver: [
			192,
			192,
			192
		],
		skyblue: [
			135,
			206,
			235
		],
		slateblue: [
			106,
			90,
			205
		],
		slategray: [
			112,
			128,
			144
		],
		slategrey: [
			112,
			128,
			144
		],
		snow: [
			255,
			250,
			250
		],
		springgreen: [
			0,
			255,
			127
		],
		steelblue: [
			70,
			130,
			180
		],
		tan: [
			210,
			180,
			140
		],
		teal: [
			0,
			128,
			128
		],
		thistle: [
			216,
			191,
			216
		],
		tomato: [
			255,
			99,
			71
		],
		turquoise: [
			64,
			224,
			208
		],
		violet: [
			238,
			130,
			238
		],
		wheat: [
			245,
			222,
			179
		],
		white: [
			255,
			255,
			255
		],
		whitesmoke: [
			245,
			245,
			245
		],
		yellow: [
			255,
			255,
			0
		],
		yellowgreen: [
			154,
			205,
			50
		]
	}), Mr;
}
var Pr, ya;
function Io() {
	if (ya) return Pr;
	ya = 1;
	const r = Cu(), e = {};
	for (const a of Object.keys(r)) e[r[a]] = a;
	const t = {
		rgb: {
			channels: 3,
			labels: "rgb"
		},
		hsl: {
			channels: 3,
			labels: "hsl"
		},
		hsv: {
			channels: 3,
			labels: "hsv"
		},
		hwb: {
			channels: 3,
			labels: "hwb"
		},
		cmyk: {
			channels: 4,
			labels: "cmyk"
		},
		xyz: {
			channels: 3,
			labels: "xyz"
		},
		lab: {
			channels: 3,
			labels: "lab"
		},
		lch: {
			channels: 3,
			labels: "lch"
		},
		hex: {
			channels: 1,
			labels: ["hex"]
		},
		keyword: {
			channels: 1,
			labels: ["keyword"]
		},
		ansi16: {
			channels: 1,
			labels: ["ansi16"]
		},
		ansi256: {
			channels: 1,
			labels: ["ansi256"]
		},
		hcg: {
			channels: 3,
			labels: [
				"h",
				"c",
				"g"
			]
		},
		apple: {
			channels: 3,
			labels: [
				"r16",
				"g16",
				"b16"
			]
		},
		gray: {
			channels: 1,
			labels: ["gray"]
		}
	};
	Pr = t;
	for (const a of Object.keys(t)) {
		if (!("channels" in t[a])) throw new Error("missing channels property: " + a);
		if (!("labels" in t[a])) throw new Error("missing channel labels property: " + a);
		if (t[a].labels.length !== t[a].channels) throw new Error("channel and label counts mismatch: " + a);
		const { channels: o, labels: i } = t[a];
		delete t[a].channels, delete t[a].labels, Object.defineProperty(t[a], "channels", { value: o }), Object.defineProperty(t[a], "labels", { value: i });
	}
	t.rgb.hsl = function(a) {
		const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(o, i, s), u = Math.max(o, i, s), c = u - l;
		let p, d;
		u === l ? p = 0 : o === u ? p = (i - s) / c : i === u ? p = 2 + (s - o) / c : s === u && (p = 4 + (o - i) / c), p = Math.min(p * 60, 360), p < 0 && (p += 360);
		const f = (l + u) / 2;
		return u === l ? d = 0 : f <= .5 ? d = c / (u + l) : d = c / (2 - u - l), [
			p,
			d * 100,
			f * 100
		];
	}, t.rgb.hsv = function(a) {
		let o, i, s, l, u;
		const c = a[0] / 255, p = a[1] / 255, d = a[2] / 255, f = Math.max(c, p, d), h = f - Math.min(c, p, d), m = function(y) {
			return (f - y) / 6 / h + 1 / 2;
		};
		return h === 0 ? (l = 0, u = 0) : (u = h / f, o = m(c), i = m(p), s = m(d), c === f ? l = s - i : p === f ? l = 1 / 3 + o - s : d === f && (l = 2 / 3 + i - o), l < 0 ? l += 1 : l > 1 && (l -= 1)), [
			l * 360,
			u * 100,
			f * 100
		];
	}, t.rgb.hwb = function(a) {
		const o = a[0], i = a[1];
		let s = a[2];
		const l = t.rgb.hsl(a)[0], u = 1 / 255 * Math.min(o, Math.min(i, s));
		return s = 1 - 1 / 255 * Math.max(o, Math.max(i, s)), [
			l,
			u * 100,
			s * 100
		];
	}, t.rgb.cmyk = function(a) {
		const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(1 - o, 1 - i, 1 - s), u = (1 - o - l) / (1 - l) || 0, c = (1 - i - l) / (1 - l) || 0, p = (1 - s - l) / (1 - l) || 0;
		return [
			u * 100,
			c * 100,
			p * 100,
			l * 100
		];
	};
	function n(a, o) {
		return (a[0] - o[0]) ** 2 + (a[1] - o[1]) ** 2 + (a[2] - o[2]) ** 2;
	}
	return t.rgb.keyword = function(a) {
		const o = e[a];
		if (o) return o;
		let i = Infinity, s;
		for (const l of Object.keys(r)) {
			const u = r[l], c = n(a, u);
			c < i && (i = c, s = l);
		}
		return s;
	}, t.keyword.rgb = function(a) {
		return r[a];
	}, t.rgb.xyz = function(a) {
		let o = a[0] / 255, i = a[1] / 255, s = a[2] / 255;
		o = o > .04045 ? ((o + .055) / 1.055) ** 2.4 : o / 12.92, i = i > .04045 ? ((i + .055) / 1.055) ** 2.4 : i / 12.92, s = s > .04045 ? ((s + .055) / 1.055) ** 2.4 : s / 12.92;
		const l = o * .4124 + i * .3576 + s * .1805, u = o * .2126 + i * .7152 + s * .0722, c = o * .0193 + i * .1192 + s * .9505;
		return [
			l * 100,
			u * 100,
			c * 100
		];
	}, t.rgb.lab = function(a) {
		const o = t.rgb.xyz(a);
		let i = o[0], s = o[1], l = o[2];
		i /= 95.047, s /= 100, l /= 108.883, i = i > .008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > .008856 ? s ** (1 / 3) : 7.787 * s + 16 / 116, l = l > .008856 ? l ** (1 / 3) : 7.787 * l + 16 / 116;
		return [
			116 * s - 16,
			500 * (i - s),
			200 * (s - l)
		];
	}, t.hsl.rgb = function(a) {
		const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
		let l, u, c;
		if (i === 0) return c = s * 255, [
			c,
			c,
			c
		];
		s < .5 ? l = s * (1 + i) : l = s + i - s * i;
		const p = 2 * s - l, d = [
			0,
			0,
			0
		];
		for (let f = 0; f < 3; f++) u = o + 1 / 3 * -(f - 1), u < 0 && u++, u > 1 && u--, 6 * u < 1 ? c = p + (l - p) * 6 * u : 2 * u < 1 ? c = l : 3 * u < 2 ? c = p + (l - p) * (2 / 3 - u) * 6 : c = p, d[f] = c * 255;
		return d;
	}, t.hsl.hsv = function(a) {
		const o = a[0];
		let i = a[1] / 100, s = a[2] / 100, l = i;
		const u = Math.max(s, .01);
		s *= 2, i *= s <= 1 ? s : 2 - s, l *= u <= 1 ? u : 2 - u;
		const c = (s + i) / 2;
		return [
			o,
			(s === 0 ? 2 * l / (u + l) : 2 * i / (s + i)) * 100,
			c * 100
		];
	}, t.hsv.rgb = function(a) {
		const o = a[0] / 60, i = a[1] / 100;
		let s = a[2] / 100;
		const l = Math.floor(o) % 6, u = o - Math.floor(o), c = 255 * s * (1 - i), p = 255 * s * (1 - i * u), d = 255 * s * (1 - i * (1 - u));
		switch (s *= 255, l) {
			case 0: return [
				s,
				d,
				c
			];
			case 1: return [
				p,
				s,
				c
			];
			case 2: return [
				c,
				s,
				d
			];
			case 3: return [
				c,
				p,
				s
			];
			case 4: return [
				d,
				c,
				s
			];
			case 5: return [
				s,
				c,
				p
			];
		}
	}, t.hsv.hsl = function(a) {
		const o = a[0], i = a[1] / 100, s = a[2] / 100, l = Math.max(s, .01);
		let u, c;
		c = (2 - i) * s;
		const p = (2 - i) * l;
		return u = i * l, u /= p <= 1 ? p : 2 - p, u = u || 0, c /= 2, [
			o,
			u * 100,
			c * 100
		];
	}, t.hwb.rgb = function(a) {
		const o = a[0] / 360;
		let i = a[1] / 100, s = a[2] / 100;
		const l = i + s;
		let u;
		l > 1 && (i /= l, s /= l);
		const c = Math.floor(6 * o), p = 1 - s;
		u = 6 * o - c, c & 1 && (u = 1 - u);
		const d = i + u * (p - i);
		let f, h, m;
		switch (c) {
			default:
			case 6:
			case 0:
				f = p, h = d, m = i;
				break;
			case 1:
				f = d, h = p, m = i;
				break;
			case 2:
				f = i, h = p, m = d;
				break;
			case 3:
				f = i, h = d, m = p;
				break;
			case 4:
				f = d, h = i, m = p;
				break;
			case 5:
				f = p, h = i, m = d;
				break;
		}
		return [
			f * 255,
			h * 255,
			m * 255
		];
	}, t.cmyk.rgb = function(a) {
		const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100, l = a[3] / 100, u = 1 - Math.min(1, o * (1 - l) + l), c = 1 - Math.min(1, i * (1 - l) + l), p = 1 - Math.min(1, s * (1 - l) + l);
		return [
			u * 255,
			c * 255,
			p * 255
		];
	}, t.xyz.rgb = function(a) {
		const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100;
		let l, u, c;
		return l = o * 3.2406 + i * -1.5372 + s * -.4986, u = o * -.9689 + i * 1.8758 + s * .0415, c = o * .0557 + i * -.204 + s * 1.057, l = l > .0031308 ? 1.055 * l ** (1 / 2.4) - .055 : l * 12.92, u = u > .0031308 ? 1.055 * u ** (1 / 2.4) - .055 : u * 12.92, c = c > .0031308 ? 1.055 * c ** (1 / 2.4) - .055 : c * 12.92, l = Math.min(Math.max(0, l), 1), u = Math.min(Math.max(0, u), 1), c = Math.min(Math.max(0, c), 1), [
			l * 255,
			u * 255,
			c * 255
		];
	}, t.xyz.lab = function(a) {
		let o = a[0], i = a[1], s = a[2];
		o /= 95.047, i /= 100, s /= 108.883, o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116, i = i > .008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > .008856 ? s ** (1 / 3) : 7.787 * s + 16 / 116;
		return [
			116 * i - 16,
			500 * (o - i),
			200 * (i - s)
		];
	}, t.lab.xyz = function(a) {
		const o = a[0], i = a[1], s = a[2];
		let l, u, c;
		u = (o + 16) / 116, l = i / 500 + u, c = u - s / 200;
		const p = u ** 3, d = l ** 3, f = c ** 3;
		return u = p > .008856 ? p : (u - 16 / 116) / 7.787, l = d > .008856 ? d : (l - 16 / 116) / 7.787, c = f > .008856 ? f : (c - 16 / 116) / 7.787, l *= 95.047, u *= 100, c *= 108.883, [
			l,
			u,
			c
		];
	}, t.lab.lch = function(a) {
		const o = a[0], i = a[1], s = a[2];
		let l;
		l = Math.atan2(s, i) * 360 / 2 / Math.PI, l < 0 && (l += 360);
		return [
			o,
			Math.sqrt(i * i + s * s),
			l
		];
	}, t.lch.lab = function(a) {
		const o = a[0], i = a[1], l = a[2] / 360 * 2 * Math.PI;
		return [
			o,
			i * Math.cos(l),
			i * Math.sin(l)
		];
	}, t.rgb.ansi16 = function(a, o = null) {
		const [i, s, l] = a;
		let u = o === null ? t.rgb.hsv(a)[2] : o;
		if (u = Math.round(u / 50), u === 0) return 30;
		let c = 30 + (Math.round(l / 255) << 2 | Math.round(s / 255) << 1 | Math.round(i / 255));
		return u === 2 && (c += 60), c;
	}, t.hsv.ansi16 = function(a) {
		return t.rgb.ansi16(t.hsv.rgb(a), a[2]);
	}, t.rgb.ansi256 = function(a) {
		const o = a[0], i = a[1], s = a[2];
		return o === i && i === s ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(s / 255 * 5);
	}, t.ansi16.rgb = function(a) {
		let o = a % 10;
		if (o === 0 || o === 7) return a > 50 && (o += 3.5), o = o / 10.5 * 255, [
			o,
			o,
			o
		];
		const i = (~~(a > 50) + 1) * .5;
		return [
			(o & 1) * i * 255,
			(o >> 1 & 1) * i * 255,
			(o >> 2 & 1) * i * 255
		];
	}, t.ansi256.rgb = function(a) {
		if (a >= 232) {
			const u = (a - 232) * 10 + 8;
			return [
				u,
				u,
				u
			];
		}
		a -= 16;
		let o;
		return [
			Math.floor(a / 36) / 5 * 255,
			Math.floor((o = a % 36) / 6) / 5 * 255,
			o % 6 / 5 * 255
		];
	}, t.rgb.hex = function(a) {
		const i = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16).toUpperCase();
		return "000000".substring(i.length) + i;
	}, t.hex.rgb = function(a) {
		const o = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
		if (!o) return [
			0,
			0,
			0
		];
		let i = o[0];
		o[0].length === 3 && (i = i.split("").map((p) => p + p).join(""));
		const s = parseInt(i, 16);
		return [
			s >> 16 & 255,
			s >> 8 & 255,
			s & 255
		];
	}, t.rgb.hcg = function(a) {
		const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.max(Math.max(o, i), s), u = Math.min(Math.min(o, i), s), c = l - u;
		let p, d;
		return c < 1 ? p = u / (1 - c) : p = 0, c <= 0 ? d = 0 : l === o ? d = (i - s) / c % 6 : l === i ? d = 2 + (s - o) / c : d = 4 + (o - i) / c, d /= 6, d %= 1, [
			d * 360,
			c * 100,
			p * 100
		];
	}, t.hsl.hcg = function(a) {
		const o = a[1] / 100, i = a[2] / 100, s = i < .5 ? 2 * o * i : 2 * o * (1 - i);
		let l = 0;
		return s < 1 && (l = (i - .5 * s) / (1 - s)), [
			a[0],
			s * 100,
			l * 100
		];
	}, t.hsv.hcg = function(a) {
		const o = a[1] / 100, i = a[2] / 100, s = o * i;
		let l = 0;
		return s < 1 && (l = (i - s) / (1 - s)), [
			a[0],
			s * 100,
			l * 100
		];
	}, t.hcg.rgb = function(a) {
		const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
		if (i === 0) return [
			s * 255,
			s * 255,
			s * 255
		];
		const l = [
			0,
			0,
			0
		], u = o % 1 * 6, c = u % 1, p = 1 - c;
		let d = 0;
		switch (Math.floor(u)) {
			case 0:
				l[0] = 1, l[1] = c, l[2] = 0;
				break;
			case 1:
				l[0] = p, l[1] = 1, l[2] = 0;
				break;
			case 2:
				l[0] = 0, l[1] = 1, l[2] = c;
				break;
			case 3:
				l[0] = 0, l[1] = p, l[2] = 1;
				break;
			case 4:
				l[0] = c, l[1] = 0, l[2] = 1;
				break;
			default: l[0] = 1, l[1] = 0, l[2] = p;
		}
		return d = (1 - i) * s, [
			(i * l[0] + d) * 255,
			(i * l[1] + d) * 255,
			(i * l[2] + d) * 255
		];
	}, t.hcg.hsv = function(a) {
		const o = a[1] / 100, s = o + a[2] / 100 * (1 - o);
		let l = 0;
		return s > 0 && (l = o / s), [
			a[0],
			l * 100,
			s * 100
		];
	}, t.hcg.hsl = function(a) {
		const o = a[1] / 100, s = a[2] / 100 * (1 - o) + .5 * o;
		let l = 0;
		return s > 0 && s < .5 ? l = o / (2 * s) : s >= .5 && s < 1 && (l = o / (2 * (1 - s))), [
			a[0],
			l * 100,
			s * 100
		];
	}, t.hcg.hwb = function(a) {
		const o = a[1] / 100, s = o + a[2] / 100 * (1 - o);
		return [
			a[0],
			(s - o) * 100,
			(1 - s) * 100
		];
	}, t.hwb.hcg = function(a) {
		const o = a[1] / 100, s = 1 - a[2] / 100, l = s - o;
		let u = 0;
		return l < 1 && (u = (s - l) / (1 - l)), [
			a[0],
			l * 100,
			u * 100
		];
	}, t.apple.rgb = function(a) {
		return [
			a[0] / 65535 * 255,
			a[1] / 65535 * 255,
			a[2] / 65535 * 255
		];
	}, t.rgb.apple = function(a) {
		return [
			a[0] / 255 * 65535,
			a[1] / 255 * 65535,
			a[2] / 255 * 65535
		];
	}, t.gray.rgb = function(a) {
		return [
			a[0] / 100 * 255,
			a[0] / 100 * 255,
			a[0] / 100 * 255
		];
	}, t.gray.hsl = function(a) {
		return [
			0,
			0,
			a[0]
		];
	}, t.gray.hsv = t.gray.hsl, t.gray.hwb = function(a) {
		return [
			0,
			100,
			a[0]
		];
	}, t.gray.cmyk = function(a) {
		return [
			0,
			0,
			0,
			a[0]
		];
	}, t.gray.lab = function(a) {
		return [
			a[0],
			0,
			0
		];
	}, t.gray.hex = function(a) {
		const o = Math.round(a[0] / 100 * 255) & 255, s = ((o << 16) + (o << 8) + o).toString(16).toUpperCase();
		return "000000".substring(s.length) + s;
	}, t.rgb.gray = function(a) {
		return [(a[0] + a[1] + a[2]) / 3 / 255 * 100];
	}, Pr;
}
var Rr, ga;
function Eu() {
	if (ga) return Rr;
	ga = 1;
	const r = Io();
	function e() {
		const o = {}, i = Object.keys(r);
		for (let s = i.length, l = 0; l < s; l++) o[i[l]] = {
			distance: -1,
			parent: null
		};
		return o;
	}
	function t(o) {
		const i = e(), s = [o];
		for (i[o].distance = 0; s.length;) {
			const l = s.pop(), u = Object.keys(r[l]);
			for (let c = u.length, p = 0; p < c; p++) {
				const d = u[p], f = i[d];
				f.distance === -1 && (f.distance = i[l].distance + 1, f.parent = l, s.unshift(d));
			}
		}
		return i;
	}
	function n(o, i) {
		return function(s) {
			return i(o(s));
		};
	}
	function a(o, i) {
		const s = [i[o].parent, o];
		let l = r[i[o].parent][o], u = i[o].parent;
		for (; i[u].parent;) s.unshift(i[u].parent), l = n(r[i[u].parent][u], l), u = i[u].parent;
		return l.conversion = s, l;
	}
	return Rr = function(o) {
		const i = t(o), s = {}, l = Object.keys(i);
		for (let u = l.length, c = 0; c < u; c++) {
			const p = l[c];
			i[p].parent !== null && (s[p] = a(p, i));
		}
		return s;
	}, Rr;
}
var zr, va;
function Au() {
	if (va) return zr;
	va = 1;
	const r = Io(), e = Eu(), t = {}, n = Object.keys(r);
	function a(i) {
		const s = function(...l) {
			const u = l[0];
			return u == null ? u : (u.length > 1 && (l = u), i(l));
		};
		return "conversion" in i && (s.conversion = i.conversion), s;
	}
	function o(i) {
		const s = function(...l) {
			const u = l[0];
			if (u == null) return u;
			u.length > 1 && (l = u);
			const c = i(l);
			if (typeof c == "object") for (let p = c.length, d = 0; d < p; d++) c[d] = Math.round(c[d]);
			return c;
		};
		return "conversion" in i && (s.conversion = i.conversion), s;
	}
	return n.forEach((i) => {
		t[i] = {}, Object.defineProperty(t[i], "channels", { value: r[i].channels }), Object.defineProperty(t[i], "labels", { value: r[i].labels });
		const s = e(i);
		Object.keys(s).forEach((u) => {
			const c = s[u];
			t[i][u] = o(c), t[i][u].raw = a(c);
		});
	}), zr = t, zr;
}
var _u = /* @__PURE__ */ Lu(Au());
function ba({ gl: r, type: e, source: t }) {
	const n = r.createShader(e);
	if (n === null) throw new Error("Cannot create shader");
	if (r.shaderSource(n, t), r.compileShader(n), !r.getShaderParameter(n, r.COMPILE_STATUS)) throw console.error("Shader compilation error:", r.getShaderInfoLog(n)), r.deleteShader(n), /* @__PURE__ */ new Error("Cannot compile shader");
	return n;
}
function Iu({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }) {
	const n = ba({
		gl: r,
		type: r.VERTEX_SHADER,
		source: e
	}), a = ba({
		gl: r,
		type: r.FRAGMENT_SHADER,
		source: t
	}), o = r.createProgram();
	if (r.attachShader(o, n), r.attachShader(o, a), r.linkProgram(o), !r.getProgramParameter(o, r.LINK_STATUS)) throw console.error("Error: ", r.getProgramInfoLog(o)), /* @__PURE__ */ new Error("Cannot link shader program");
	return o;
}
function Mu(r, e, t) {
	const n = r.getUniformLocation(e, t);
	if (n === null) throw new Error(`Cannot get uniform location for ${t}`);
	return n;
}
function Mo({ gl: r, vertexShaderSource: e, fragmentShaderSource: t, attributesKeys: n, uniformsKeys: a, vertices: o, indices: i }) {
	const s = Iu({
		gl: r,
		vertexShaderSource: e,
		fragmentShaderSource: t
	}), l = n.reduce((f, h) => (f[h] = r.getAttribLocation(s, `a_${h}`), f), {}), u = a.reduce((f, h) => (f[h] = Mu(r, s, `u_${h}`), f), {}), c = r.createBuffer();
	r.bindBuffer(r.ARRAY_BUFFER, c), r.bufferData(r.ARRAY_BUFFER, new Float32Array(o), r.STATIC_DRAW);
	let p, d;
	return i !== void 0 && (p = r.createBuffer(), d = i.length, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, p), r.bufferData(r.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), r.STATIC_DRAW)), {
		shaderProgram: s,
		programInfo: {
			attributesLocations: l,
			uniformsLocations: u
		},
		positionBuffer: c,
		indexBuffer: p,
		indexBufferLength: d
	};
}
function Ut(r) {
	if (!r) return [
		1,
		1,
		1,
		0
	];
	if (r === "transparent") return [
		1,
		1,
		1,
		0
	];
	try {
		const e = Pu(r), t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(e);
		if (t != null && t.length) {
			const a = !!t[4];
			return [..._u.hex.rgb(e).map((o) => o / 255), a ? parseInt(t[4], 16) / 255 : 1];
		}
		const n = e.match(/(\d\.\d(\d+)?|\d{3}|\d{2}|\d{1})/gi) ?? [
			"0",
			"0",
			"0"
		];
		if (e.includes("rgb")) {
			const a = e.includes("rgba"), o = [...n.map((i) => parseFloat(i)).map((i, s) => s < 3 ? i / 255 : i)];
			return a || o.push(1), o;
		}
	} catch {}
	return console.warn([`[parseColorStringToVec4]: Color ${r} is either not a valid color or its type is not supported, defaulting to black`]), [
		0,
		0,
		0,
		1
	];
}
var pt;
function Pu(r) {
	return pt = pt ?? document.createElement("canvas").getContext("2d"), pt ? (pt.fillStyle = r, pt.fillStyle) : "#000000";
}
var Tn = 1, U = Tn / 2, B = Tn / 2, q = Tn / 2, Ru = [
	-U,
	-B,
	q,
	U,
	-B,
	q,
	U,
	B,
	q,
	-U,
	B,
	q
], zu = [
	-U,
	-B,
	-q,
	-U,
	B,
	-q,
	U,
	B,
	-q,
	U,
	-B,
	-q
], Ou = [
	-U,
	B,
	-q,
	-U,
	B,
	q,
	U,
	B,
	q,
	U,
	B,
	-q
], Fu = [
	-U,
	-B,
	-q,
	U,
	-B,
	-q,
	U,
	-B,
	q,
	-U,
	-B,
	q
], $u = [
	U,
	-B,
	-q,
	U,
	B,
	-q,
	U,
	B,
	q,
	U,
	-B,
	q
], Nu = [
	-U,
	-B,
	-q,
	-U,
	-B,
	q,
	-U,
	B,
	q,
	-U,
	B,
	-q
], ju = [
	...Ru,
	...zu,
	...Ou,
	...Fu,
	...$u,
	...Nu
], Du = [
	0,
	1,
	2,
	0,
	2,
	3,
	4,
	5,
	6,
	4,
	6,
	7,
	8,
	9,
	10,
	8,
	10,
	11,
	12,
	13,
	14,
	12,
	14,
	15,
	16,
	17,
	18,
	16,
	18,
	19,
	20,
	21,
	22,
	20,
	22,
	23
], Uu = `attribute vec3 a_vertexPosition;
varying vec3 vTextureCoord;

uniform mat4 u_projectionMatrix;
uniform mat4 u_modelViewMatrix;
  
void main(void) {
  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);
  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);
}
`, wa = `precision mediump float;

varying vec3 vTextureCoord;

%USE_TEXTURE_MACRO_MARKER%

# ifdef USE_TEXTURE
uniform samplerCube u_cubeSampler;
uniform float u_fadeOpacity;
# endif

uniform vec4 u_bgColor;

void main(void) {
  #ifdef USE_TEXTURE
  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);

    gl_FragColor = mix(
      u_bgColor,
      texColor,
      min(texColor.a, u_fadeOpacity)
    );

    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);

  #else
  gl_FragColor = u_bgColor;
  #endif
}
`;
var Bu = /* @__PURE__ */ ((r) => (r.UNIVERSE_DARK = "universe-dark", r))(Bu || {});
var Ge = {
	stars: {
		color: "hsl(233,100%,92%)",
		preset: "stars"
	},
	space: {
		color: "hsl(210, 100%, 4%)",
		preset: "space"
	},
	milkyway: {
		color: "hsl(233,100%,92%)",
		preset: "milkyway"
	},
	"milkyway-subtle": {
		color: "hsl(233,100%,92%)",
		preset: "milkyway-subtle"
	},
	"milkyway-bright": {
		color: "hsl(233,100%,92%)",
		preset: "milkyway-bright"
	},
	"milkyway-colored": {
		color: "black",
		preset: "milkyway-colored"
	}
};
var Ne = /* @__PURE__ */ ((r) => (r.POSITIVE_X = "pX", r.NEGATIVE_X = "nX", r.POSITIVE_Y = "pY", r.NEGATIVE_Y = "nY", r.POSITIVE_Z = "pZ", r.NEGATIVE_Z = "nZ", r))(Ne || {});
var tt = /* @__PURE__ */ new Map();
function qu(r) {
	const e = tt.get(r);
	e && (tt.delete(r), r.deleteTexture(e));
}
var Sa = /* @__PURE__ */ new Map();
var xa;
function Vu({ gl: r, faces: e, onReady: t, forceRefresh: n }) {
	if (tt.get(r) && !n && xa === JSON.stringify(e)) {
		t(tt.get(r), Sa.get(r));
		return;
	}
	xa = JSON.stringify(e);
	const a = tt.get(r) ?? r.createTexture();
	if (r.bindTexture(r.TEXTURE_CUBE_MAP, a), !e) {
		console.warn("[CubemapLayer][loadCubemapTexture]: Faces are null");
		return;
	}
	const o = Object.keys(e).length;
	if (o !== 6) {
		console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${o}`);
		return;
	}
	const i = Object.entries(e).map(([s, l]) => new Promise((u, c) => {
		const p = s;
		if (l === void 0) {
			c(/* @__PURE__ */ new Error(`[CubemapLayer][loadCubemapTexture]: Face ${s} is undefined`));
			return;
		}
		const d = new Image();
		d.crossOrigin = "anonymous";
		const f = () => {
			u({
				image: d,
				key: p
			});
		};
		d.src = l, d.complete && d.naturalWidth > 0 ? f() : d.onload = f, d.onerror = () => {
			c(/* @__PURE__ */ new Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${l}`));
		};
	}));
	Promise.all(i).then((s) => {
		for (let u = 0; u < s.length; u++) {
			const p = r.RGBA, d = r.RGBA, f = r.UNSIGNED_BYTE, { image: h, key: m } = s[u] ?? {};
			if (!h || !m) {
				console.warn("[CubemapLayer][loadCubemapTexture]: Image or key is null");
				continue;
			}
			const y = Gu(r, m);
			r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(y, 0, p, d, f, h);
		}
		r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.generateMipmap(r.TEXTURE_CUBE_MAP), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR);
		const l = s.map((u) => u.image);
		t(a, l), Sa.set(r, l), tt.set(r, a);
	}).catch((s) => {
		console.error("[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture", s);
	});
}
function Gu(r, e) {
	if (e === Ne.POSITIVE_X) return r.TEXTURE_CUBE_MAP_POSITIVE_X;
	if (e === Ne.NEGATIVE_X) return r.TEXTURE_CUBE_MAP_NEGATIVE_X;
	if (e === Ne.POSITIVE_Y) return r.TEXTURE_CUBE_MAP_POSITIVE_Y;
	if (e === Ne.NEGATIVE_Y) return r.TEXTURE_CUBE_MAP_NEGATIVE_Y;
	if (e === Ne.POSITIVE_Z) return r.TEXTURE_CUBE_MAP_POSITIVE_Z;
	if (e === Ne.NEGATIVE_Z) return r.TEXTURE_CUBE_MAP_NEGATIVE_Z;
	throw new Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${e}`);
}
function Hu(r, e, t) {
	return [
		ze(r[0], e[0], t),
		ze(r[1], e[1], t),
		ze(r[2], e[2], t),
		ze(r[3], e[3], t)
	];
}
function ze(r, e, t) {
	return r + (e - r) * t;
}
function Jt(r) {
	if (!r) return {};
	const e = Object.keys(r).sort().map((t) => [t, r[t]]);
	return Object.fromEntries(e);
}
var Je = "https://api.maptiler.com/resources/space", Zu = ["vertexPosition"], Ku = [
	"projectionMatrix",
	"modelViewMatrix",
	"cubeSampler",
	"bgColor",
	"fadeOpacity"
], ka = "%USE_TEXTURE_MACRO_MARKER%", Xu = "#define USE_TEXTURE", La = Ge.stars;
function Yu(r, e) {
	if (!Xr(r)) return { color: "transparent" };
	if (r === !0) return e;
	const t = { ...r };
	if (r.faces || r.path) return delete t.preset, t;
	const n = r.preset;
	if (!(n === void 0) && !(n in Ge)) throw new Error(`[CubemapLayer]: Invalid preset "${n}". Available presets: ${Object.keys(Ge).join(", ")}`);
	return {
		...t,
		color: t.color ?? Ge[n].color ?? "hsl(233,100%,92%)"
	};
}
var Or = class {
	/**
	* Creates a new instance of CubemapLayer
	*
	* @param {CubemapLayerConstructorOptions | true} cubemapConfig - Configuration options for the cubemap layer or `true` to use default options.
	* Can specify faces, preset, path, and color properties to configure the cubemap.
	*
	* @remarks You shouldn't have to use this class directly.
	* Instead, use the `Map.setHalo` method to create and add a halo layer to the map.
	* The constructor initializes the cubemap with the provided configuration.
	* It processes the faces definition, sets up background colors, and determines
	* whether to use a cubemap texture based on the provided options.
	*/
	constructor(e) {
		g(this, "id", "Cubemap Layer");
		g(this, "type", "custom");
		g(this, "renderingMode", "3d");
		/**
		* The map instance to which this layer is added.
		* @type {MapSDK}
		* @private
		*/
		g(this, "map");
		/**
		* The cubemap faces definition, which can be either a preset, path, or explicit face URLs.
		* @type {CubemapFaces | null}
		* @remarks
		* This property is set during the initialization of the layer and can be updated later.
		* If no faces are defined, it will be `null`.
		*/
		g(this, "faces");
		/**
		* Indicates whether to use a cubemap texture for rendering.
		* @type {boolean}
		* @private
		* @default true
		*/
		g(this, "useCubemapTexture", !0);
		/**
		* The current opacity of the fade effect applied to the cubemap image texture, used for fading in and out.
		* @type {number}
		* @private
		* @default 0.0
		*/
		g(this, "currentFadeOpacity", 0);
		/**
		* Indicates whether the cubemap needs to be updated, typically when the faces or texture changes.
		* @type {boolean}
		* @private
		* @default false
		*/
		g(this, "cubeMapNeedsUpdate", !1);
		/**
		* The background color of the cubemap layer, represented as a Vec4 (RGBA).
		* @type {Vec4}
		* @private
		*/
		g(this, "bgColor");
		/**
		* The previous background color used for transition animations.
		* @type {Vec4}
		* @private
		*/
		g(this, "previousBgColor", [
			0,
			0,
			0,
			0
		]);
		/**
		* The target background color to which the layer will transition.
		* @type {Vec4}
		* @private
		*/
		g(this, "targetBgColor", [
			0,
			0,
			0,
			0
		]);
		/**
		* The delta value used for transitioning the background color. 0 = start of transition, 1 = end of transition.
		* This value is incremented over time to create a smooth transition effect.
		* @type {number}
		* @private
		*/
		g(this, "transitionDelta", 0);
		/**
		* The WebGL context used for rendering the cubemap layer.
		* @type {WebGLContext}
		* @private
		*/
		g(this, "gl");
		/**
		* The cubemap object that contains the shader program, buffers and uniform locations for rendering.
		* @type {Object3D}
		* @private
		*/
		g(this, "cubemap");
		/**
		* The WebGL texture used for the cubemap, which is created from the defined faces.
		* This texture is used to render the cubemap in the scene.
		* @type {WebGLTexture | undefined}
		* @private
		*/
		g(this, "texture");
		/**
		* The key representing the current faces definition, used to diff / track changes in the cubemap faces.
		* @type {string}
		*/
		g(this, "currentFacesDefinitionKey", "");
		/**
		* The configuration options for the cubemap layer.
		* @type {CubemapLayerConstructorOptions}
		* @private
		*/
		g(this, "options");
		g(this, "animationActive", !0);
		/**
		* Animates the cubemap image fading in.
		* This method gradually increases the opacity of the cubemap image to create a fade-in effect.
		*
		* @private
		*/
		g(this, "imageIsAnimating", !1);
		/**
		* The delta value used for the image fade-in animation.
		* This value is incremented over time to create a smooth fade-in effect.
		* @type {number}
		* @private
		*/
		g(this, "imageFadeInDelta", 0);
		const t = Yu(e, La);
		this.options = t, this.currentFacesDefinitionKey = JSON.stringify(t.faces ?? t.preset ?? t.path), this.bgColor = [
			0,
			0,
			0,
			0
		], this.targetBgColor = Ut(t.color), this.faces = Ca(t), this.useCubemapTexture = this.faces !== null;
	}
	/**
	* Updates the cubemap object with the current faces and shader configuration.
	* This method is called when the cubemap faces change or when the layer is initialized.
	* @returns {void}
	* @remarks
	* It creates a new Object3D instance with the specified vertex and fragment shaders,
	* attributes, and uniforms. The cubemap will be rendered using this configuration.
	*/
	updateCubemap({ facesNeedUpdate: e } = { facesNeedUpdate: !0 }) {
		this.useCubemapTexture = this.faces !== null;
		const t = Ku.filter((n) => n === "cubeSampler" || n === "fadeOpacity" ? this.useCubemapTexture : !0);
		this.cubemap = Mo({
			gl: this.gl,
			vertexShaderSource: Uu,
			fragmentShaderSource: this.useCubemapTexture ? wa.replace(ka, Xu) : wa.replace(ka, ""),
			attributesKeys: Zu,
			uniformsKeys: t,
			vertices: ju,
			indices: Du
		}), this.cubeMapNeedsUpdate = e, this.useCubemapTexture && this.updateTexture(this.gl, this.faces), this.animateColorChange();
	}
	/**
	* Called when the layer is added to the map.
	* Initializes the cubemap and sets up the WebGL context.
	*
	* @param {MapSDK} map - The map instance to which this layer is added.
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
	*/
	onAdd(e, t) {
		this.map = e, this.gl = t, this.updateCubemap();
	}
	/**
	* Called when the layer is removed from the map.
	* Cleans up the cubemap resources and WebGL buffers.
	*
	* @param {MapSDK} _map - The map instance from which this layer is removed.
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
	*/
	onRemove(e, t) {
		this.cubemap && (this.texture && (qu(t), this.texture = void 0), t.deleteProgram(this.cubemap.shaderProgram), t.deleteBuffer(this.cubemap.positionBuffer));
	}
	/**
	* Updates the cubemap texture with the provided faces.
	* This method is called when the cubemap faces change or when the layer is initialized.
	*
	* @param {WebGLContext} gl - The WebGL context used for rendering.
	* @param {CubemapFaces} faces - The cubemap faces to be loaded into the texture.
	*/
	updateTexture(e, t) {
		if (this.cubeMapNeedsUpdate === !0 && !this.imageIsAnimating) {
			if (this.cubeMapNeedsUpdate = !1, !this.useCubemapTexture) return;
			Vu({
				gl: e,
				faces: t,
				onReady: (n) => {
					this.texture = n, this.animateIn();
				}
			});
		}
	}
	/**
	* Called before the layer is rendered.
	* Updates the cubemap texture with the current faces.
	*
	* @param {WebGLContext} gl - The WebGL context used for rendering.
	* @param {CustomRenderMethodInput} _options - Additional options for the render method.
	*/
	prerender(e, t) {
		this.faces && this.updateTexture(this.gl, this.faces);
	}
	/**
	* Lerps the background color transition of the cubemap layer.
	* This method smoothly transitions the background color from the previous color to the target color.
	*
	* @private
	*/
	animateColorChange() {
		const e = () => {
			this.transitionDelta < 1 && (requestAnimationFrame(e), this.bgColor = Hu(this.previousBgColor, this.targetBgColor, this.transitionDelta), this.transitionDelta += .075, this.map.triggerRepaint());
		};
		requestAnimationFrame(e);
	}
	/**
	* Animates the cubemap image fading in.
	* This method gradually increases the opacity of the cubemap image to create a fade-in effect.
	* @private
	*/
	async animateIn() {
		if (!this.imageIsAnimating) {
			if (!this.animationActive) {
				this.currentFadeOpacity = 1, this.imageFadeInDelta = 1, this.map.triggerRepaint();
				return;
			}
			return new Promise((e) => {
				this.imageIsAnimating = !0;
				const t = () => {
					if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + .05, 1), this.currentFadeOpacity = ze(0, 1, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta < 1) {
						requestAnimationFrame(t);
						return;
					}
					this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();
				};
				requestAnimationFrame(t);
			});
		}
	}
	/**
	* Animates the cubemap image fading out.
	* This method gradually decreases the opacity of the cubemap image to create a fade-out effect.
	* @returns {Promise<void>} A promise that resolves when the animation is complete.
	* @private
	*/
	async animateOut() {
		if (!(this.imageIsAnimating || !this.animationActive)) return new Promise((e) => {
			const t = () => {
				if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + .05, 1), this.currentFadeOpacity = ze(1, 0, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta >= 1) {
					this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();
					return;
				}
				requestAnimationFrame(t);
			};
			requestAnimationFrame(t);
		});
	}
	setAnimationActive(e) {
		this.animationActive = e;
	}
	/**
	* Renders the cubemap layer to the WebGL context.
	* This method is called internally during the rendering phase of the map.
	*
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
	* @param {CustomRenderMethodInput} _options - Additional options for the render method.
	* @throws Error if the map, cubemap, or texture is undefined.
	*/
	render(e, t) {
		if (!this.map.isGlobeProjection()) return;
		if (this.map === void 0) throw new Error("[CubemapLayer]: Map is undefined");
		if (this.cubemap === void 0) throw new Error("[CubemapLayer]: Cubemap is undefined");
		this.texture, e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA), e.useProgram(this.cubemap.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.cubemap.positionBuffer), e.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);
		const n = .1, a = 1e4, o = e.canvas, i = o.clientWidth / o.clientHeight, s = this.map.transform, l = s.fov * (Math.PI / 180), u = mt();
		xu(u, l, i, n, a), da(u, u, s.rollInRadians), fa(u, u, -s.pitchInRadians), da(u, u, s.bearingInRadians);
		const c = s.center.lat * Math.PI / 180, p = s.center.lng * Math.PI / 180;
		fa(u, u, c), wu(u, u, -p), e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, !1, u);
		const d = mt();
		if (e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, !1, d), e.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)), e.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity), this.useCubemapTexture && this.texture && (e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_CUBE_MAP, this.texture), e.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)), this.cubemap.indexBuffer === void 0) throw new Error("Index buffer is undefined");
		if (this.cubemap.indexBufferLength === void 0) throw new Error("Index buffer length is undefined");
		e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer), e.drawElements(e.TRIANGLES, this.cubemap.indexBufferLength, e.UNSIGNED_SHORT, 0);
	}
	setBgColor(e) {
		this.targetBgColor = e, this.previousBgColor = this.bgColor, this.transitionDelta = 0;
	}
	/**
	* Returns the current configuration options for the cubemap layer.
	* @returns {CubemapLayerConstructorOptions} The current configuration options.
	*/
	getConfig() {
		return this.options;
	}
	/**
	* Checks if the cubemap needs to be updated based on the provided specification.
	*
	* @param {CubemapDefinition} spec - The cubemap specification to compare with the current cubemap.
	* @returns {boolean} True if the cubemap needs to be updated, false otherwise.
	*/
	shouldUpdate(e) {
		const t = this.getConfig();
		if (e === void 0 && t) return !0;
		const n = typeof e == "boolean" ? e : Jt(e), a = Jt(t);
		return JSON.stringify(n) !== JSON.stringify(a);
	}
	async setCubemapFaces(e) {
		if (await this.animateOut(), !e.faces && !e.preset && !e.path) {
			this.faces = null, this.useCubemapTexture = !1, this.currentFacesDefinitionKey = "empty", await this.animateIn();
			return;
		}
		this.faces = Ca(e), this.currentFacesDefinitionKey = JSON.stringify(e.faces ?? e.preset ?? e.path);
	}
	/**
	* Sets the cubemap for the layer based on the provided definition.
	* This method updates the cubemap faces, background color, and triggers a repaint of the map.
	*
	* @param {CubemapDefinition} cubemap - The cubemap definition containing faces, preset, path, or color.
	* @returns {Promise<void>} A promise that resolves when the cubemap is set and the map is updated.
	* @remarks
	* This method checks if the provided cubemap definition has a color, and if so, it updates the background color.
	* It also checks if the faces definition has changed compared to the current one,
	* and if so, it updates the cubemap faces.
	* Finally, it calls `updateCubemap` to apply the changes and trigger a repaint of the map.
	*/
	async setCubemap(e) {
		const t = typeof e == "boolean" ? La : e;
		this.options = t;
		const n = JSON.stringify(t.faces ?? t.preset ?? t.path), a = this.currentFacesDefinitionKey !== n;
		a && (await this.setCubemapFaces(t), this.cubeMapNeedsUpdate = !0);
		const o = Ut(t.color);
		if (t.color && this.targetBgColor.toString() !== o.toString()) this.setBgColor(o);
		else if (!t.color && t.preset && t.preset in Ge) {
			const i = Ge[t.preset];
			this.setBgColor(Ut(i.color));
		}
		this.updateCubemap({ facesNeedUpdate: a });
	}
	/**
	* Shows the cubemap layer by setting its visibility to "visible".
	* This method is used to make the cubemap layer visible on the map.
	*/
	show() {
		this.map.setLayoutProperty(this.id, "visibility", "visible");
	}
	/**
	* Hides the cubemap layer by setting its visibility to "none".
	* This method is used to remove the cubemap layer from the map without deleting it.
	*/
	hide() {
		this.map.setLayoutProperty(this.id, "visibility", "none");
	}
};
function Xr(r) {
	return r ? typeof r == "boolean" ? !0 : !(!r.path && !r.preset && !r.faces && !r.color || r.preset && !(r.preset in Ge) || r.faces && (!r.faces.pX || !r.faces.nX || !r.faces.pY || !r.faces.nY || !r.faces.pZ || !r.faces.nZ)) : !1;
}
function Ca(r) {
	if (r.faces) return r.faces;
	if (r.preset) return {
		pX: `${Je}/${r.preset}/px.webp`,
		nX: `${Je}/${r.preset}/nx.webp`,
		pY: `${Je}/${r.preset}/py.webp`,
		nY: `${Je}/${r.preset}/ny.webp`,
		pZ: `${Je}/${r.preset}/pz.webp`,
		nZ: `${Je}/${r.preset}/nz.webp`
	};
	if (r.path) {
		const e = r.path.baseUrl, t = r.path.format ?? "png";
		return {
			pX: `${e}/px.${t}`,
			nX: `${e}/nx.${t}`,
			pY: `${e}/py.${t}`,
			nY: `${e}/ny.${t}`,
			pZ: `${e}/pz.${t}`,
			nZ: `${e}/nz.${t}`
		};
	}
	return null;
}
var Wu = `attribute vec3 a_position;

uniform mat4 u_matrix;
uniform mat4 u_rotationMatrix;

uniform float u_scale;

varying vec2 v_pos;
varying float v_scale;

void main() {
  v_scale = u_scale;
  v_pos = a_position.xy * u_scale;
  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);
}
`, Ju = `precision mediump float;
varying vec2 v_pos;
      
uniform int u_stopsNumber;
uniform float u_stops[100];
uniform vec4 u_colors[100];
uniform float u_maxDistance;

varying float v_scale;

const float EPSILON = 0.000001;

vec2 center = vec2(0.0, 0.0);
void main() {
  float rawDistance = distance(center, v_pos);
  float distanceFromGlobeEdge = rawDistance - 1.0;

    vec4 color = u_colors[0];

  // if we're further than the max distance, we should not render anything.
  // This is to always render a circle, otherwise we end up rendering
  // to the corners of the plane.
  if (distance(center, v_pos) > u_maxDistance * v_scale) {
    discard;
  }

  for (int i = 1; i < 100; i++) {
    // if we're past the last stop
    // we should fill to the end with the last stop color
    if (i >= u_stopsNumber) {
      color = u_colors[i - 1];
      break;
    }

    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);
    float lastStopValue = u_stops[i - 1];
    float thisStopValue = u_stops[i];

    // this is to avoid blending errors when the stops are the same
    // eg when you would want a sharp edge between two stops.
    // \`numbersAreEqual\` will be 1.0 if the numbers are equal, 0.0 if they are not.
    // We then subtract EPSILON from the last stop making the stop value _almost_ equal
    // to the next stop but not enough to cause blending issues.
    // It's more efficient to do this than an if / else statement.
    float numbersAreEqual = 1.0 - step(EPSILON, abs(lastStopValue - thisStopValue));
    lastStopValue = lastStopValue - numbersAreEqual * EPSILON;

    float lastScaledStopPosition = lastStopValue * pow(v_scale, 1.6);

    if (distanceFromGlobeEdge <= scaledStopPosition) {
      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);
      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);
      break;
    }
  }
  
  // gl_FragColor = color;
  gl_FragColor = vec4(color.rgb * color.a, color.a);
}
`, ke = 2, Qu = ["position"], ec = [
	"matrix",
	"rotationMatrix",
	"stopsNumber",
	"stops",
	"colors",
	"maxDistance",
	"scale"
], tc = [
	-ke,
	-ke,
	0,
	ke,
	-ke,
	0,
	-ke,
	ke,
	0,
	ke,
	ke,
	0
], Ft = [
	[0, "rgba(176, 208, 240, 1)"],
	[.1, "rgba(98, 168, 229, 0.3)"],
	[.2, "rgba(98, 168, 229, 0.0)"]
], $t = .9, Ea = .06;
var Fr = class {
	/**
	* Creates a new RadialGradientLayer instance.
	*
	* @param {RadialGradientLayerConstructorOptions | boolean} gradient - Configuration options for the radial gradient or a boolean value.
	* If a boolean is provided, default configuration options will be used.
	* If an `RadialGradientLayerConstructorOptions` is provided, it will be merged with default options.
	*/
	constructor(e) {
		g(this, "id", "Halo Layer");
		g(this, "type", "custom");
		g(this, "renderingMode", "3d");
		/**
		* The gradient definition used by this layer.
		* It contains the stops and scale for the radial gradient.
		* @private
		* @type {GradientDefinition}
		*/
		g(this, "gradient");
		/**
		* The scale of the radial gradient, which determines its size.
		* This value is animated from 0 to the target scale during the layer's appearance.
		* @private
		* @type {number}
		*/
		g(this, "scale", 0);
		/**
		* The animation delta value used to control the progress of the gradient's appearance animation.
		* It is incremented during each frame of the animation until it reaches 1.
		* @private
		* @type {number}
		*/
		g(this, "animationDelta", 0);
		/**
		* The MapSDK instance to which this layer is added.
		* This is set when the layer is added to the map.
		* @private
		* @type {MapSDK}
		*/
		g(this, "map");
		/**
		* The 3D object representing the radial gradient plane.
		* This object is created when the layer is added to the map and contains the shader program and buffers.
		* It is used for rendering the radial gradient effect.
		* @private
		* @type {Object3D<(typeof ATTRIBUTES_KEYS)[number], (typeof UNIFORMS_KEYS)[number]>}
		*/
		g(this, "plane");
		/**
		* Whether the halo should be animated in and out.
		* @private
		* @type {boolean}
		*/
		g(this, "animationActive", !0);
		if (typeof e == "boolean") {
			this.gradient = {
				scale: $t,
				stops: Ft
			};
			return;
		}
		const t = Aa(e);
		if (t.length > 0) throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
		this.gradient = {
			scale: e.scale ?? $t,
			stops: e.stops ?? Ft
		};
	}
	/**
	* Adds the radial gradient layer to the specified map.
	* This method is called by the map when the layer is added to it.
	*
	* @param {MapSDK} map - The MapSDK instance to which this layer is being added
	* @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL rendering context used for rendering the layer
	* @returns void
	*/
	onAdd(e, t) {
		this.map = e, this.plane = Mo({
			gl: t,
			vertexShaderSource: Wu,
			fragmentShaderSource: Ju,
			attributesKeys: Qu,
			uniformsKeys: ec,
			vertices: tc
		}), this.animateIn();
	}
	/**
	* Returns the current gradient configuration of the radial gradient layer.
	*
	* @returns {GradientDefinition} The current gradient configuration.
	*/
	getConfig() {
		return this.gradient;
	}
	/**
	* Checks if the gradient needs to be updated based on the provided specification.
	*
	* @param {GradientDefinition} spec - The gradient specification to compare with the current gradient.
	* @returns {boolean} True if the gradient needs to be updated, false otherwise.
	*/
	shouldUpdate(e) {
		const t = this.getConfig();
		if (e === void 0 && t) return !0;
		const n = typeof e == "boolean" ? e : Jt(e), a = Jt(t);
		return JSON.stringify(n) !== JSON.stringify(a);
	}
	/**
	* Animates the radial gradient into view by gradually scaling from 0 to the target scale.
	*
	* This method uses requestAnimationFrame to create a smooth scaling animation effect.
	* During each frame, it:
	*   1. Interpolates the scale value between 0 and the target scale
	*   2. Increments the animation progress (animationDelta)
	*   3. Triggers a map repaint
	*
	* @private
	* @returns {Promise<void>} A promise that resolves when the animation completes
	*/
	async animateIn() {
		if (!this.animationActive) {
			this.scale = this.gradient.scale, this.animationDelta = 1, this.map.triggerRepaint();
			return;
		}
		return new Promise((e) => {
			this.animationDelta = 0;
			const t = () => {
				if (this.animationDelta <= 1) {
					this.scale = ze(0, this.gradient.scale, this.animationDelta), this.animationDelta += Ea, this.map.triggerRepaint(), requestAnimationFrame(t);
					return;
				}
				e();
			};
			requestAnimationFrame(t);
		});
	}
	/**
	* Animates the radial gradient layer out by gradually reducing its scale to zero.
	*
	* This method creates a smooth transition effect by linearly interpolating the scale
	* from its current value to zero over multiple animation frames. During each frame,
	* the animation progresses by incrementing the internal animation delta value.
	*
	* The map is repainted after each animation step to reflect the updated scale.
	*
	* @private
	* @returns A Promise that resolves when the animation is complete.
	*/
	async animateOut() {
		if (this.animationActive) return this.animationDelta = 0, new Promise((e) => {
			const t = () => {
				if (this.animationDelta < 1) {
					this.scale = ze(this.gradient.scale, 0, this.animationDelta), this.animationDelta += Ea, this.map.triggerRepaint(), requestAnimationFrame(t);
					return;
				}
				e();
			};
			t();
		});
	}
	onRemove(e, t) {
		this.plane !== void 0 && (t.deleteProgram(this.plane.shaderProgram), t.deleteBuffer(this.plane.positionBuffer));
	}
	prerender(e, t) {}
	render(e, t) {
		if (this.map === void 0) throw new Error("[RadialGradientLayer]: Map is undefined");
		if (!this.map.isGlobeProjection()) return;
		if (this.plane === void 0) throw new Error("[RadialGradientLayer]: Plane is undefined");
		e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.useProgram(this.plane.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.plane.positionBuffer);
		const n = this.plane.programInfo.attributesLocations.position;
		e.enableVertexAttribArray(n), e.vertexAttribPointer(n, 3, e.FLOAT, !1, 0, 0);
		const a = mt(), o = this.scale;
		bu(a, a, [
			o,
			o,
			o
		]);
		const i = mt();
		vu(i, t.defaultProjectionData.mainMatrix, a);
		const s = this.plane.programInfo.uniformsLocations.matrix;
		e.uniformMatrix4fv(s, !1, i);
		const l = mt(), u = this.map.transform.cameraPosition, c = Ir(Dt(), u), p = ku(0, 1, 0), d = Dt();
		ha(d, p, c), Ir(d, d);
		const f = Dt();
		ha(f, c, d), Ir(f, f), gu(l, d[0], d[1], d[2], 0, f[0], f[1], f[2], 0, c[0], c[1], c[2], 0, 0, 0, 0, 1);
		const h = this.plane.programInfo.uniformsLocations.rotationMatrix;
		e.uniformMatrix4fv(h, !1, l);
		const m = this.gradient.stops.length, y = [], b = [];
		for (let v = 0; v <= m; v++) if (v < m) {
			y[v] = this.gradient.stops[v][0];
			const x = Ut(this.gradient.stops[v][1]);
			b.push(...x);
		}
		e.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, m), e.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(y)), e.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(b)), e.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, ke), e.uniform1f(this.plane.programInfo.uniformsLocations.scale, o), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
	}
	/**
	* Sets a new gradient for the radial gradient layer and animates the transition.
	*
	* This method first animates the current gradient out, then updates the gradient
	* property with the new gradient definition, and finally animates the new gradient in.
	*
	* @param {GradientDefinition} gradient - The new gradient definition to set for this layer.
	* @returns {Promise<void>} A promise that resolves when the new gradient is set and animated in.
	*/
	async setGradient(e) {
		if (e === !1) {
			await this.animateOut();
			return;
		}
		await this.animateOut();
		const t = Aa(e);
		if (t.length > 0) throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
		e === !0 ? (this.gradient.scale = $t, this.gradient.stops = Ft) : (this.gradient.scale = e.scale ?? $t, this.gradient.stops = e.stops ?? Ft), await this.animateIn();
	}
	setAnimationActive(e) {
		this.animationActive = e;
	}
	show() {
		this.map.setLayoutProperty(this.id, "visibility", "visible");
	}
	hide() {
		this.map.setLayoutProperty(this.id, "visibility", "none");
	}
};
var rc = ["scale", "stops"];
function Aa(r) {
	var t;
	const e = [];
	if (typeof r == "boolean") return [];
	try {
		const n = Object.keys(r).filter((a) => !rc.includes(a));
		n.length > 0 && e.push(`Properties ${n.map((a) => `\`${a}\``).join(", ")} are not supported.`);
	} catch {
		e.push("Halo specification is not an object.");
	}
	return typeof r.scale != "number" && e.push("Halo `scale` property is not a number."), (!r.stops || r.stops.length === 0) && e.push("Halo `stops` property is not an array."), (t = r.stops) != null && t.some((n) => typeof n[0] != "number" || typeof n[1] != "string") && e.push("Halo `stops` property is not an array of [number, string]"), e;
}
function nc() {
	const r = "color: #3A1888; background: white; padding: 5px 0; font-weight: bold;", e = "color: #FBC935; background: white; padding: 5px; font-weight: bold;", t = "color: #F1175D; background: white; padding: 5px 0; font-weight: bold;";
	console.info(`%c%c%c %cMapTiler SDK JS v${oi()} %c%c%c`, e + "padding-right: 0;", r, t, "color: #333; background: white; padding: 5px 0; font-weight: bold;", t, r, e + "padding-left: 0;");
}
var ac = {
	POINT: "POINT",
	COUNTRY: "COUNTRY"
};
var Po = class Ro extends import_maplibre_gl.default.Map {
	constructor(t) {
		t.logSDKVersion !== !1 && nc(), Ui(t.container), t.apiKey && (j.apiKey = t.apiKey);
		const { style: n, requiresUrlMonitoring: a, isFallback: o } = ua(t.style);
		o && console.warn("Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."), j.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
		const i = location.hash;
		let s = { compact: !1 };
		t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == "object" && (s = {
			...s,
			...t.attributionControl
		});
		const l = {
			...t,
			style: n,
			maplibreLogo: !1,
			transformRequest: Un(t.transformRequest),
			attributionControl: t.forceNoAttributionControl === !0 ? !1 : s
		};
		delete l.style;
		super(l);
		g(this, "telemetry");
		g(this, "space");
		g(this, "halo");
		g(this, "options");
		g(this, "isTerrainEnabled", !1);
		g(this, "terrainExaggeration", 1);
		g(this, "primaryLanguage");
		g(this, "terrainGrowing", !1);
		g(this, "terrainFlattening", !1);
		g(this, "minimap");
		g(this, "forceLanguageUpdate");
		g(this, "languageAlwaysBeenStyle");
		g(this, "isReady", !1);
		g(this, "terrainAnimationDuration", 1e3);
		g(this, "monitoredStyleUrls");
		g(this, "styleInProcess", !1);
		g(this, "curentProjection");
		g(this, "originalLabelStyle", new window.Map());
		g(this, "isStyleLocalized", !1);
		g(this, "languageIsUpdated", !1);
		g(this, "spaceboxLoadingState", {
			styleLoadCallbackSet: !1,
			styleLoadedCallbackFired: !1
		});
		this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);
		const u = () => {
			let h = "The distant style could not be loaded.";
			this.getStyle() ? h += " Leaving the style as is." : (this.setStyle(MapStyle.STREETS), h += `Loading default MapTiler Cloud style "${MapStyle.STREETS.getDefaultVariant().getId()}" as a fallback.`), console.warn(h);
		};
		if (this.on("style.load", () => {
			this.styleInProcess = !1, (typeof t.rtlTextPlugin == "string" || typeof t.rtlTextPlugin > "u") && $i(t.rtlTextPlugin);
		}), this.on("error", (h) => {
			if (h.error instanceof import_maplibre_gl.default.AJAXError) {
				const y = h.error.url, b = new URL(y);
				b.search = "";
				const v = b.href;
				this.monitoredStyleUrls && this.monitoredStyleUrls.has(v) && (this.monitoredStyleUrls.delete(v), u());
				return;
			}
			if (this.styleInProcess) {
				u();
				return;
			}
		}), j.caching && !jr && console.warn("The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"), j.caching && jr && Fi(), typeof t.language > "u") this.primaryLanguage = j.primaryLanguage;
		else this.primaryLanguage = toLanguageInfo(t.language, z) ?? j.primaryLanguage;
		this.forceLanguageUpdate = !(this.primaryLanguage === z.STYLE || this.primaryLanguage === z.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === z.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on("style.load", (h) => {
			this.curentProjection === "mercator" ? this.setProjection({ type: "mercator" }) : this.curentProjection === "globe" && this.setProjection({ type: "globe" });
		}), this.once("styledata", async () => {
			if (!t.geolocate || t.center || t.hash && i) return;
			try {
				if (t.geolocate === ac.COUNTRY) {
					await this.fitToIpBounds();
					return;
				}
			} catch (y) {
				console.warn(y.message);
			}
			let h;
			try {
				await this.centerOnIpPoint(t.zoom), h = this.getCameraHash();
			} catch (y) {
				console.warn(y.message);
			}
			(await navigator.permissions.query({ name: "geolocation" })).state === "granted" && navigator.geolocation.getCurrentPosition((y) => {
				h === this.getCameraHash() && (this.terrain ? this.easeTo({
					center: [y.coords.longitude, y.coords.latitude],
					zoom: t.zoom || 12,
					duration: 2e3
				}) : this.once("terrain", () => {
					this.easeTo({
						center: [y.coords.longitude, y.coords.latitude],
						zoom: t.zoom || 12,
						duration: 2e3
					});
				}));
			}, null, {
				maximumAge: 24 * 3600 * 1e3,
				timeout: 5e3,
				enableHighAccuracy: !1
			});
		}), this.on("styledata", () => {
			this.setPrimaryLanguage(this.primaryLanguage);
		}), this.on("styledata", () => {
			this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);
		}), this.once("load", async () => {
			let h = { logo: null };
			try {
				const m = Object.keys(this.style.tileManagers).map((v) => this.getSource(v)).filter((v) => v && "url" in v && typeof v.url == "string" && v.url.includes("tiles.json")), y = new URL(m[0].url);
				y.searchParams.has("key") || y.searchParams.append("key", j.apiKey), h = await (await fetch(y.href)).json();
			} catch {}
			if (t.customControls) {
				const m = "[data-maptiler-control-group]", y = "[data-maptiler-control]", b = (T) => {
					let N = T.dataset.maptilerControl;
					return (N === "true" || N === "") && (N = void 0), N;
				}, v = (T) => T.dataset.maptilerPosition;
				let x = [...this._container.ownerDocument.querySelectorAll(m)], E = [...this._container.ownerDocument.querySelectorAll(y)].filter((T) => T.closest(m) === null);
				if (typeof t.customControls == "string") {
					const T = t.customControls;
					x = x.filter((N) => N.matches(T) || N.closest(T) !== null), E = E.filter((N) => N.matches(T) || N.closest(T) !== null);
				}
				for (const T of x) {
					const N = new Kr(T);
					this.addControl(N, v(T));
					for (const ge of T.querySelectorAll(y)) N.configureGroupItem(ge, b(ge));
				}
				for (const T of E) this.addControl(new Kr(T, b(T)), v(T));
				const C = () => {
					const { lng: T, lat: N } = this.getCenter();
					this._container.style.setProperty("--maptiler-center-lng", String(T)), this._container.style.setProperty("--maptiler-center-lat", String(N)), this._container.style.setProperty("--maptiler-zoom", String(this.getZoom())), this._container.style.setProperty("--maptiler-bearing", String(this.getBearing())), this._container.style.setProperty("--maptiler-pitch", String(this.getPitch())), this._container.style.setProperty("--maptiler-roll", String(this.getRoll())), this._container.style.setProperty("--maptiler-is-globe-projection", String(this.isGlobeProjection())), this._container.style.setProperty("--maptiler-has-terrain", String(this.hasTerrain()));
				};
				C(), this.on("render", C);
			}
			if (t.forceNoAttributionControl !== !0) if ("logo" in h && h.logo) {
				const m = h.logo;
				this.addControl(new $n({ logoURL: m }), t.logoPosition);
			} else t.maptilerLogo && this.addControl(new $n(), t.logoPosition);
			if (t.scaleControl) {
				const m = t.scaleControl === !0 || t.scaleControl === void 0 ? "bottom-right" : t.scaleControl, y = new Ti({ unit: j.unit });
				this.addControl(y, m), j.on("unit", (b) => {
					y.setUnit(b);
				});
			}
			if (t.navigationControl !== !1) {
				const m = t.navigationControl === !0 || t.navigationControl === void 0 ? "top-right" : t.navigationControl;
				this.addControl(new pu(), m);
			}
			if (t.geolocateControl !== !1) {
				const m = t.geolocateControl === !0 || t.geolocateControl === void 0 ? "top-right" : t.geolocateControl;
				this.addControl(new du({
					positionOptions: {
						enableHighAccuracy: !0,
						maximumAge: 0,
						timeout: 6e3
					},
					fitBoundsOptions: { maxZoom: 15 },
					trackUserLocation: !0,
					showAccuracyCircle: !0,
					showUserLocation: !0
				}), m);
			}
			if (t.terrainControl) {
				const m = t.terrainControl === !0 || t.terrainControl === void 0 ? "top-right" : t.terrainControl;
				this.addControl(new cu(), m);
			}
			if (t.projectionControl) {
				const m = t.projectionControl === !0 || t.projectionControl === void 0 ? "top-right" : t.projectionControl;
				this.addControl(new mu(), m);
			}
			if (t.fullscreenControl) {
				const m = t.fullscreenControl === !0 || t.fullscreenControl === void 0 ? "top-right" : t.fullscreenControl;
				this.addControl(new _i({}), m);
			}
			this.isReady = !0, this.fire("ready", { target: this });
		});
		let c = !1, p = !1, d;
		this.once("ready", () => {
			c = !0, p && this.fire("loadWithTerrain", d);
		}), this.once("style.load", () => {
			const { minimap: h } = t;
			if (typeof h == "object") {
				const { zoom: m, center: y, style: b, language: v, apiKey: x, maptilerLogo: E, canvasContextAttributes: C, refreshExpiredTiles: T, maxBounds: N, scrollZoom: ge, minZoom: Xe, maxZoom: Ye, boxZoom: X, locale: We, fadeDuration: li, crossSourceCollisions: ui, clickTolerance: ci, bounds: pi, fitBoundsOptions: fi, pixelRatio: di, validateStyle: hi } = t;
				this.minimap = new _r(h, {
					zoom: m,
					center: y,
					style: b,
					language: v,
					apiKey: x,
					container: "null",
					maptilerLogo: E,
					canvasContextAttributes: C,
					refreshExpiredTiles: T,
					maxBounds: N,
					scrollZoom: ge,
					minZoom: Xe,
					maxZoom: Ye,
					boxZoom: X,
					locale: We,
					fadeDuration: li,
					crossSourceCollisions: ui,
					clickTolerance: ci,
					bounds: pi,
					fitBoundsOptions: fi,
					pixelRatio: di,
					validateStyle: hi
				}), this.addControl(this.minimap, h.position ?? "bottom-left");
			} else h === !0 ? (this.minimap = new _r({}, t), this.addControl(this.minimap, "bottom-left")) : h !== void 0 && h !== !1 && (this.minimap = new _r({}, t), this.addControl(this.minimap, h));
		});
		const f = (h) => {
			h.terrain && (p = !0, d = {
				type: "loadWithTerrain",
				target: this,
				terrain: h.terrain
			}, this.off("terrain", f), c && this.fire("loadWithTerrain", d));
		};
		this.on("terrain", f), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once("load", () => {
			this.getCanvas().addEventListener("webglcontextlost", (m) => {
				if (this._removed === !0) {
					console.warn("[webglcontextlost]", "WebGL context lost after map removal. This is harmless.");
					return;
				}
				console.warn("[webglcontextlost]", "Unexpected loss of WebGL context!"), this.fire("webglContextLost", m);
			});
			const h = this.getLayersOrder()[0];
			t.space && this.initSpace({
				options: t,
				before: h
			}), t.halo && this.initHalo({
				options: t,
				before: h
			});
		}), this.telemetry = new yu(this);
	}
	getSpace() {
		return this.space;
	}
	/**
	* Sets the space for the map.
	* @param {CubemapDefinition} space the `CubemapDefinition` options to set.
	* @remarks This method, at present, ** overwrites ** the current config.
	* If an option is not set it will internally revert to the default option
	* unless explicitly set when calling.
	*/
	setSpace(t, n = !0) {
		if (n && (this.options.space = t), t === !1) {
			this.space = void 0;
			return;
		}
		if (this.space) {
			this.space.setCubemap(t), this.getLayer(this.space.id) || this.addLayer(this.space, this.getLayersOrder()[0]);
			return;
		}
		this.space = new Or(t), this.once("load", () => {
			const a = this.getLayersOrder()[0];
			this.space && this.addLayer(this.space, a);
		});
	}
	/**
	* Enables the animations for the space layer.
	*/
	enableSpaceAnimations() {
		this.setSpaceAnimationActive(!0);
	}
	/**
	* Disables the animations for the space layer.
	*/
	disableSpaceAnimations() {
		this.setSpaceAnimationActive(!1);
	}
	/**
	* Enables the animations for the halo layer.
	*/
	enableHaloAnimations() {
		this.setHaloAnimationActive(!0);
	}
	/**
	* Disables the animations for the halo layer.
	*/
	disableHaloAnimations() {
		this.setHaloAnimationActive(!1);
	}
	/**
	* Sets whether the halo layer should be animated in and out.
	* @param active - Whether the animation should be active.
	*/
	setHaloAnimationActive(t) {
		this.halo ? this.halo.setAnimationActive(t) : this.once("load", () => {
			var n;
			(n = this.halo) == null || n.setAnimationActive(t);
		});
	}
	/**
	* Sets whether the space layer should be animated in and out.
	* @param active - Whether the animation should be active.
	*/
	setSpaceAnimationActive(t) {
		this.space ? this.space.setAnimationActive(t) : this.once("load", () => {
			var n;
			(n = this.space) == null || n.setAnimationActive(t);
		});
	}
	setSpaceFromStyle({ style: t }) {
		var i, s, l, u, c;
		if (this.options.space === !1) return;
		if (this.options.space !== !0 && Xr(this.options.space)) {
			this.setSpace(this.options.space);
			return;
		}
		const n = (s = (i = t.metadata) == null ? void 0 : i.maptiler) == null ? void 0 : s.space, a = Xr(n);
		if (JSON.stringify((l = this.space) == null ? void 0 : l.getConfig()) === JSON.stringify(n)) {
			if (this.space && !this.getLayer(this.space.id)) {
				const p = this.getLayersOrder()[0];
				this.addLayer(this.space, p);
			}
			return;
		}
		if (a) {
			this.setSpace(n, !1);
			return;
		}
		if (this.options.space === !0) {
			this.setSpace(!0);
			return;
		}
		if (((u = this.space) == null ? void 0 : u.getConfig()) && n === void 0) {
			this.setSpace({ color: "transparent" }, !1), this.removeLayer(((c = this.space) == null ? void 0 : c.id) ?? "");
			return;
		}
		if (this.space && this.isGlobeProjection()) {
			if (!this.getLayer(this.space.id)) {
				const p = this.getLayersOrder()[0];
				this.addLayer(this.space, p);
			}
			this.space.setCubemap(n);
		}
	}
	setHaloFromStyle({ style: t }) {
		var o, i, s;
		if (this.options.halo === !1) return;
		const n = (o = t.metadata) == null ? void 0 : o.maptiler;
		if (JSON.stringify((i = this.halo) == null ? void 0 : i.getConfig()) === JSON.stringify(n == null ? void 0 : n.halo)) {
			if (this.halo && !this.getLayer(this.halo.id)) {
				const l = this.getLayersOrder().indexOf(((s = this.space) == null ? void 0 : s.id) ?? "") + 1, u = this.getLayersOrder()[l];
				this.addLayer(this.halo, u);
			}
			return;
		}
		if (!(n != null && n.halo) && !this.options.halo) {
			this.setHalo({
				stops: [[0, "transparent"], [.01, "transparent"]],
				scale: 1
			});
			return;
		}
		(() => {
			var l;
			if (this.halo) {
				if (!this.getLayer(this.halo.id)) {
					const c = this.getLayersOrder().indexOf(((l = this.space) == null ? void 0 : l.id) ?? "") + 1, p = this.getLayersOrder()[c];
					this.addLayer(this.halo, p);
				}
				const u = (n == null ? void 0 : n.halo) ?? this.options.halo;
				u && this.halo.setGradient(u);
			}
		})();
	}
	initSpace({ options: t = this.options, before: n, spec: a }) {
		if (this.space) {
			this.getLayer(this.space.id) || this.addLayer(this.space, n);
			return;
		}
		if (t.space === !1) return;
		if (t.space) {
			this.space = new Or(t.space), this.addLayer(this.space, n);
			return;
		}
		const o = a;
		o && (this.space = new Or(o), this.addLayer(this.space, n));
	}
	initHalo({ options: t = this.options, before: n, spec: a }) {
		if (this.halo && this.getLayer(this.halo.id) || t.halo === !1) return;
		const o = a;
		if (t.halo) {
			this.halo = new Fr(t.halo), this.addLayer(this.halo, n);
			return;
		}
		o && (this.halo = new Fr(o), this.addLayer(this.halo, n));
	}
	getHalo() {
		return this.halo;
	}
	setHalo(t) {
		if (this.options.halo = t, !!this.isGlobeProjection()) {
			if (this.halo) {
				this.halo.setGradient(t);
				return;
			}
			this.halo = new Fr(t), this.once("load", () => {
				var s;
				const n = this.getLayersOrder(), a = n[0], i = n[n.indexOf(((s = this.space) == null ? void 0 : s.id) ?? "") + 2];
				this.halo && this.addLayer(this.halo, this.space ? i : a);
			});
		}
	}
	/**
	* Recreates the map instance with the same options.
	* Useful for WebGL context loss.
	*/
	recreate() {
		const t = {
			center: this.getCenter(),
			zoom: this.getZoom(),
			bearing: this.getBearing(),
			pitch: this.getPitch()
		};
		this.remove(), Object.assign(this, new Ro({ ...this.options })), this.once("load", () => {
			this.jumpTo(t);
		});
	}
	/**
	* Set the duration (millisec) of the terrain animation for growing or flattening.
	* Must be positive. (Built-in default: `1000` milliseconds)
	*/
	setTerrainAnimationDuration(t) {
		this.terrainAnimationDuration = Math.max(t, 0);
	}
	/**
	* Awaits for _this_ Map instance to be "loaded" and returns a Promise to the Map.
	* If _this_ Map instance is already loaded, the Promise is resolved directly,
	* otherwise, it is resolved as a result of the "load" event.
	* @returns
	*/
	async onLoadAsync() {
		return new Promise((t) => {
			if (this.loaded()) {
				t(this);
				return;
			}
			this.once("load", () => {
				t(this);
			});
		});
	}
	/**
	* Awaits for _this_ Map instance to be "ready" and returns a Promise to the Map.
	* If _this_ Map instance is already ready, the Promise is resolved directly,
	* otherwise, it is resolved as a result of the "ready" event.
	* A map instance is "ready" when all the controls that can be managed by the contructor are
	* dealt with. This happens after the "load" event, due to the asynchronous nature
	* of some built-in controls.
	*/
	async onReadyAsync() {
		return new Promise((t) => {
			if (this.isReady) {
				t(this);
				return;
			}
			this.once("ready", () => {
				t(this);
			});
		});
	}
	/**
	* Awaits for _this_ Map instance to be "loaded" as well as with terrain being non-null for the first time
	* and returns a Promise to the Map.
	* If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,
	* otherwise, it is resolved as a result of the "loadWithTerrain" event.
	* @returns
	*/
	async onLoadWithTerrainAsync() {
		return new Promise((t) => {
			if (this.isReady && this.terrain) {
				t(this);
				return;
			}
			this.once("loadWithTerrain", () => {
				t(this);
			});
		});
	}
	monitorStyleUrl(t) {
		typeof this.monitoredStyleUrls > "u" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());
		const n = new URL(t);
		n.search = "", this.monitoredStyleUrls.add(n.href);
	}
	/**
	* Update the style of the map.
	* Can be:
	* - a full style URL (possibly with API key)
	* - a shorthand with only the MapTIler style name (eg. `"streets-v2"`)
	* - a longer form with the prefix `"maptiler://"` (eg. `"maptiler://streets-v2"`)
	*/
	setStyle(t, n) {
		var c, p, d, f, h;
		this.originalLabelStyle.clear(), (c = this.minimap) == null || c.setStyle(t), this.forceLanguageUpdate = !0, this.once("idle", () => {
			this.forceLanguageUpdate = !1;
		});
		const a = ua(t);
		if (a.requiresUrlMonitoring && this.monitorStyleUrl(a.style), a.isFallback) {
			if (this.getStyle()) return console.warn("[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead."), this;
			console.warn("[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.");
		}
		this.spaceboxLoadingState.styleLoadedCallbackFired = !1, this.spaceboxLoadingState.styleLoadCallbackSet = !1;
		const o = this.getStyle(), i = a.style;
		try {
			super.setStyle(a.style, {
				...n,
				diff: typeof a.style != "string"
			}), this.styleInProcess = !0;
		} catch (m) {
			this.styleInProcess = !1, console.error("[Map.setStyle]: Error while setting style:", m);
		}
		const s = () => {
			const m = a.style;
			if (!m.projection || m.projection.type === "mercator") {
				console.warn("[Map.setStyle]: Neither space nor halo is supported for mercator projection. Ignoring...");
				return;
			}
			this.setSpaceFromStyle({ style: a.style }), this.setHaloFromStyle({ style: a.style });
		}, l = (m) => {
			var b, v, x, E;
			const y = (m == null ? void 0 : m.target.getStyle()) ?? a.style;
			if (!this.spaceboxLoadingState.styleLoadedCallbackFired && (this.spaceboxLoadingState.styleLoadedCallbackFired = !0, this.spaceboxLoadingState.styleLoadCallbackSet = !1, typeof y != "string")) try {
				const C = this.getLayersOrder()[0];
				this.space ? this.setSpaceFromStyle({ style: y }) : this.initSpace({
					before: C,
					spec: (v = (b = y.metadata) == null ? void 0 : b.maptiler) == null ? void 0 : v.space
				}), this.halo ? this.setHaloFromStyle({ style: y }) : this.initHalo({
					before: C,
					spec: (E = (x = y.metadata) == null ? void 0 : x.maptiler) == null ? void 0 : E.halo
				});
			} catch (C) {
				console.error(C);
			}
		};
		return typeof a.style == "string" || a.requiresUrlMonitoring ? (this.once("style.load", l), this) : (requestIdleCallback(() => {
			try {
				l();
			} catch (m) {
				console.error(m);
			}
		}), this.spaceboxLoadingState.styleLoadCallbackSet ? ((p = o == null ? void 0 : o.terrain) == null ? void 0 : p.source) !== ((d = i == null ? void 0 : i.terrain) == null ? void 0 : d.source) || ((f = o == null ? void 0 : o.terrain) == null ? void 0 : f.exaggeration) !== ((h = i == null ? void 0 : i.terrain) == null ? void 0 : h.exaggeration) ? (this.once("terrain", s), this) : this : (this.once("style.load", l), this.once("projection.change", l), this.spaceboxLoadingState.styleLoadCallbackSet = !0, this));
	}
	/**
	* Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
	* to the map's style.
	*
	* A layer defines how data from a specified source will be styled. Read more about layer types
	* and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
	*
	* @param layer - The layer to add,
	* conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
	* less commonly, the {@link CustomLayerInterface} specification.
	* The MapLibre Style Specification's layer definition is appropriate for most layers.
	*
	* @param beforeId - The ID of an existing layer to insert the new layer before,
	* resulting in the new layer appearing visually beneath the existing layer.
	* If this argument is not specified, the layer will be appended to the end of the layers array
	* and appear visually above all other layers.
	*
	* @returns `this`
	*/
	addLayer(t, n) {
		var a;
		return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);
	}
	/**
	* Moves a layer to a different z-position.
	*
	* @param id - The ID of the layer to move.
	* @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
	* @returns `this`
	*
	* @example
	* Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
	* ```ts
	* map.moveLayer('polygon', 'country-label');
	* ```
	*/
	moveLayer(t, n) {
		var a;
		return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);
	}
	/**
	* Removes the layer with the given ID from the map's style.
	*
	* An {@link ErrorEvent} will be fired if the image parameter is invald.
	*
	* @param id - The ID of the layer to remove
	* @returns `this`
	*
	* @example
	* If a layer with ID 'state-data' exists, remove it.
	* ```ts
	* if (map.getLayer('state-data')) map.removeLayer('state-data');
	* ```
	*/
	removeLayer(t) {
		var n;
		return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);
	}
	/**
	* Sets the zoom extent for the specified style layer. The zoom extent includes the
	* [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
	* and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
	* at which the layer will be rendered.
	*
	* Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
	* minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
	* zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
	* layer will not be rendered at all zoom levels in the zoom range.
	*/
	setLayerZoomRange(t, n, a) {
		var o;
		return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);
	}
	/**
	* Sets the filter for the specified style layer.
	*
	* Filters control which features a style layer renders from its source.
	* Any feature for which the filter expression evaluates to `true` will be
	* rendered on the map. Those that are false will be hidden.
	*
	* Use `setFilter` to show a subset of your source data.
	*
	* To clear the filter, pass `null` or `undefined` as the second parameter.
	*/
	setFilter(t, n, a) {
		var o;
		return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);
	}
	/**
	* Sets the value of a paint property in the specified style layer.
	*
	* @param layerId - The ID of the layer to set the paint property in.
	* @param name - The name of the paint property to set.
	* @param value - The value of the paint property to set.
	* Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
	* @param options - Options object.
	* @returns `this`
	* @example
	* ```ts
	* map.setPaintProperty('my-layer', 'fill-color', '#faafee');
	* ```
	*/
	setPaintProperty(t, n, a, o) {
		var i;
		return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);
	}
	/**
	* Sets the value of a layout property in the specified style layer.
	* Layout properties define how the layer is styled.
	* Layout properties for layers of the same type are documented together.
	* Layers of different types have different layout properties.
	* See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.
	* @param layerId - The ID of the layer to set the layout property in.
	* @param name - The name of the layout property to set.
	* @param value - The value of the layout property to set.
	* Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
	* @param options - Options object.
	* @returns `this`
	*/
	setLayoutProperty(t, n, a, o) {
		var i;
		return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);
	}
	/**
	* Sets the value of the style's glyphs property.
	*
	* @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
	* @param options - Options object.
	* @returns `this`
	* @example
	* ```ts
	* map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
	* ```
	*/
	setGlyphs(t, n) {
		var a;
		return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);
	}
	getStyleLanguage() {
		return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != "object" ? null : "maptiler:language" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata["maptiler:language"] == "string" ? getLanguageInfoFromFlag(this.style.stylesheet.metadata["maptiler:language"]) : null;
	}
	/**
	* Define the primary language of the map. Note that not all the languages shorthands provided are available.
	*/
	setLanguage(t) {
		var n;
		(n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {
			this.setPrimaryLanguage(t);
		});
	}
	/**
	* Define the primary language of the map. Note that not all the languages shorthands provided are available.
	*/
	setPrimaryLanguage(t) {
		const n = this.getStyleLanguage(), a = toLanguageInfo(t, z);
		if (!a) {
			console.warn(`The language "${a}" is not supported.`);
			return;
		}
		if (!(a.flag === z.STYLE.flag && n && (n.flag === z.AUTO.flag || n.flag === z.VISITOR.flag)) && (a.flag !== z.STYLE.flag && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate)) return;
		if (this.primaryLanguage.flag === z.STYLE_LOCK.flag) {
			console.warn("The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.");
			return;
		}
		this.primaryLanguage = a;
		let o = a;
		if (a.flag === z.STYLE.flag) {
			if (!n) {
				console.warn("The style has no default languages or has an invalid one.");
				return;
			}
			o = n;
		}
		let i = z.LOCAL.flag, s = ["get", i];
		o.flag === z.VISITOR.flag ? (i = Fn().flag, s = [
			"case",
			[
				"all",
				["has", i],
				["has", z.LOCAL.flag]
			],
			[
				"case",
				[
					"==",
					["get", i],
					["get", z.LOCAL.flag]
				],
				["get", z.LOCAL.flag],
				[
					"format",
					["get", i],
					{ "font-scale": .8 },
					`
`,
					["get", z.LOCAL.flag],
					{ "font-scale": 1.1 }
				]
			],
			["get", z.LOCAL.flag]
		]) : o.flag === z.VISITOR_ENGLISH.flag ? (i = z.ENGLISH.flag, s = [
			"case",
			[
				"all",
				["has", i],
				["has", z.LOCAL.flag]
			],
			[
				"case",
				[
					"==",
					["get", i],
					["get", z.LOCAL.flag]
				],
				["get", z.LOCAL.flag],
				[
					"format",
					["get", i],
					{ "font-scale": .8 },
					`
`,
					["get", z.LOCAL.flag],
					{ "font-scale": 1.1 }
				]
			],
			["get", z.LOCAL.flag]
		]) : o.flag === z.AUTO.flag ? (i = Fn().flag, s = [
			"coalesce",
			["get", i],
			["get", z.LOCAL.flag]
		]) : o === z.LOCAL ? (i = z.LOCAL.flag, s = ["get", i]) : (i = o.flag, s = [
			"coalesce",
			["get", i],
			["get", z.LOCAL.flag]
		]);
		const { layers: l } = this.getStyle(), u = this.originalLabelStyle.size === 0;
		if (u) {
			const c = Ki(l, this);
			this.isStyleLocalized = Object.keys(c.localized).length > 0;
		}
		for (const c of l) {
			if (c.type !== "symbol") continue;
			const p = c, d = this.getSource(p.source);
			if (!d || !("url" in d && typeof d.url == "string") || new URL(d.url).host !== W.maptilerApiHost) continue;
			const { id: h, layout: m } = p;
			if (!m || !("text-field" in m)) continue;
			let y;
			if (u ? (y = this.getLayoutProperty(h, "text-field"), this.originalLabelStyle.set(h, y)) : y = this.originalLabelStyle.get(h), typeof y == "string") {
				const { contains: b, exactMatch: v } = qi(y, this.isStyleLocalized);
				if (!b) continue;
				if (v) this.setLayoutProperty(h, "text-field", s);
				else {
					const x = Vi(y, s, this.isStyleLocalized);
					this.setLayoutProperty(h, "text-field", x);
				}
			} else {
				const b = Bi(y, s, this.isStyleLocalized);
				this.setLayoutProperty(h, "text-field", b);
			}
		}
		this.languageIsUpdated = !0;
	}
	/**
	* Get the primary language
	* @returns
	*/
	getPrimaryLanguage() {
		return this.primaryLanguage;
	}
	/**
	* Get the exaggeration factor applied to the terrain
	* @returns
	*/
	getTerrainExaggeration() {
		return this.terrainExaggeration;
	}
	/**
	* Know if terrian is enabled or not
	* @returns
	*/
	hasTerrain() {
		return this.isTerrainEnabled;
	}
	growTerrain(t) {
		if (!this.terrain) return;
		const n = performance.now(), a = this.terrain.exaggeration, o = t - a, i = () => {
			if (!this.terrain || this.terrainFlattening) return;
			const s = (performance.now() - n) / this.terrainAnimationDuration;
			if (s < .99) {
				const u = a + (1 - (1 - s) ** 4) * o;
				this.terrain.exaggeration = u, requestAnimationFrame(i);
			} else this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = t, this.fire("terrainAnimationStop", { terrain: this.terrain });
			this._elevationFreeze = !1, this.triggerRepaint();
		};
		!this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(i);
	}
	/**
	* Enables the 3D terrain visualization
	*/
	enableTerrain(t = this.terrainExaggeration) {
		if (t < 0) {
			console.warn("Terrain exaggeration cannot be negative.");
			return;
		}
		const n = (o) => {
			!this.terrain || o.type !== "data" || o.dataType !== "source" || !("source" in o) || o.sourceId !== "maptiler-terrain" || o.source.type !== "raster-dem" || o.isSourceLoaded && (this.off("data", n), this.growTerrain(t));
		}, a = () => {
			this.isTerrainEnabled = !0, this.terrainExaggeration = t, this.on("data", n), this.addSource(W.terrainSourceId, {
				type: "raster-dem",
				url: W.terrainSourceURL
			}), this.setTerrain({
				source: W.terrainSourceId,
				exaggeration: 0
			});
		};
		if (this.getTerrain()) {
			this.isTerrainEnabled = !0, this.growTerrain(t);
			return;
		}
		if (this.loaded() || this.isTerrainEnabled) a();
		else {
			const o = () => {
				this.getTerrain() && this.getSource(W.terrainSourceId) || a();
			};
			this.once("load", () => {
				o();
			}), this.once("moveend", () => {
				o();
			});
		}
	}
	/**
	* Disable the 3D terrain visualization
	*/
	disableTerrain() {
		if (!this.terrain) return;
		this.isTerrainEnabled = !1;
		const t = performance.now(), n = this.terrain.exaggeration, a = () => {
			if (!this.terrain || this.terrainGrowing) return;
			const o = (performance.now() - t) / this.terrainAnimationDuration;
			if (this._elevationFreeze = !1, o < .99) {
				const s = n * (1 - o) ** 4;
				this.terrain.exaggeration = s, requestAnimationFrame(a);
			} else this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(W.terrainSourceId) && this.removeSource(W.terrainSourceId), this.fire("terrainAnimationStop", { terrain: null });
			this.triggerRepaint();
		};
		!this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(a);
	}
	/**
	* Sets the 3D terrain exageration factor.
	* If the terrain was not enabled prior to the call of this method,
	* the method `.enableTerrain()` will be called.
	* If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.
	* If `animate` is `false`, no animated transition to the newly defined exaggeration.
	*/
	setTerrainExaggeration(t, n = !0) {
		!n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);
	}
	/**
	* Perform an action when the style is ready. It could be at the moment of calling this method
	* or later.
	*/
	onStyleReady(t) {
		this.isStyleLoaded() ? t() : this.once("styledata", () => {
			t();
		});
	}
	async fitToIpBounds() {
		const t = await geolocation.info();
		this.fitBounds(t.country_bounds, {
			duration: 0,
			padding: 100
		});
	}
	async centerOnIpPoint(t) {
		const n = await geolocation.info();
		this.jumpTo({
			center: [n.longitude ?? 0, n.latitude ?? 0],
			zoom: t || 11
		});
	}
	getCameraHash() {
		const t = new Float32Array(5), n = this.getCenter();
		return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), gBase64.fromUint8Array(new Uint8Array(t.buffer));
	}
	/**
	* Get the SDK config object.
	* This is convenient to dispatch the SDK configuration to externally built layers
	* that do not directly have access to the SDK configuration but do have access to a Map instance.
	*/
	getSdkConfig() {
		return j;
	}
	/**
	* Get the MapTiler session ID. Convenient to dispatch to externaly built component
	* that do not directly have access to the SDK configuration but do have access to a Map instance.
	* @returns
	*/
	getMaptilerSessionId() {
		return on;
	}
	/**
	*  Updates the requestManager's transform request with a new function.
	*
	* @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
	*    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
	*
	* @returns {Map} `this`
	*
	*  @example
	*  map.setTransformRequest((url: string, resourceType: string) => {});
	*/
	setTransformRequest(t) {
		return super.setTransformRequest(Un(t)), this;
	}
	/**
	* Gets the {@link ProjectionSpecification}.
	* @returns the projection specification.
	* @example
	* ```ts
	* let projection = map.getProjection();
	* ```
	*/
	getProjection() {
		return this.style.getProjection();
	}
	/**
	* Returns whether a globe projection is currently being used
	*/
	isGlobeProjection() {
		const t = this.getProjection();
		return t ? t.type === "globe" : !1;
	}
	/**
	* Activate the globe projection.
	*/
	enableGlobeProjection() {
		this.isGlobeProjection() !== !0 && (this.setProjection({ type: "globe" }), this.curentProjection = "globe");
	}
	/**
	* Activate the mercator projection.
	*/
	enableMercatorProjection() {
		this.isGlobeProjection() !== !1 && (this.setProjection({ type: "mercator" }), this.curentProjection = "mercator");
	}
	setProjection(t) {
		return this.fire("projection.change", {
			target: this,
			projection: t
		}), super.setProjection(t);
	}
	/**
	* Returns `true` is the language was ever updated, meaning changed
	* from what is delivered in the style.
	* Returns `false` if language in use is the language from the style
	* and has never been changed.
	*/
	isLanguageUpdated() {
		return this.languageIsUpdated;
	}
};
var ne = class {
	constructor(e, t, n, a = {}) {
		g(this, "type");
		g(this, "target");
		g(this, "originalEvent");
		g(this, "imageX");
		g(this, "imageY");
		g(this, "isOutOfBounds");
		this.type = e, this.target = t, this.originalEvent = n ?? null, Object.assign(this, a);
	}
};
var zo = [
	"idle",
	"render",
	"load",
	"remove",
	"idle"
], Oo = ["error"], Fo = ["resize"], $o = ["webglcontextlost", "webglcontextrestored"], No = [
	"moveend",
	"movestart",
	"move",
	"zoomend",
	"zoomstart",
	"zoom",
	"rotatestart",
	"rotateend",
	"rotate",
	"dragstart",
	"dragend",
	"drag",
	"boxzoomcancel",
	"boxzoomend",
	"boxzoomstart"
], jo = [
	"click",
	"dblclick",
	"mousedown",
	"mouseup",
	"mousemove",
	"mouseout",
	"mouseover",
	"contextmenu",
	"touchstart",
	"touchend",
	"touchmove",
	"touchcancel"
], Do = ["cooperativegestureprevented"], Uo = [
	"data",
	"dataloading",
	"sourcedata",
	"sourcedataloading",
	"dataabort",
	"sourcedataabort"
], oc = [
	...zo,
	...Oo,
	...Fo,
	...$o,
	...No,
	...jo,
	...Uo,
	...Do
], ic = ["lngLat", "_defaultPrevented"];
function sc({ map: r, viewer: e, lngLatToPx: t }) {
	oc.forEach((n) => {
		try {
			r.on(n, (a) => {
				const o = n;
				if (jo.includes(o)) {
					const f = a, h = f.lngLat && t(f.lngLat), m = e.getImageMetadata(), b = {
						isOutOfBounds: m ? h[0] < 0 || h[0] > m.width || h[1] < 0 || h[1] > m.height : !0,
						imageX: h[0],
						imageY: h[1],
						...Object.fromEntries(Object.entries(a).filter(([v]) => !ic.includes(v)))
					};
					e.fire(new ne(n, e, f.originalEvent, b));
					return;
				}
				const i = n;
				if (No.includes(i)) {
					const f = a;
					e.fire(new ne(n, e, f.originalEvent, f));
					return;
				}
				const s = n;
				if (Oo.includes(s)) {
					const f = a;
					e.fire(new ne(n, e, null, f));
					return;
				}
				const l = n;
				if (Fo.includes(l)) {
					const f = a;
					e.fire(new ne(n, e, null, f));
					return;
				}
				const u = n;
				if ($o.includes(u)) {
					const f = a;
					e.fire(new ne(n, e, f.originalEvent, f));
					return;
				}
				const c = n;
				if (Uo.includes(c)) {
					const f = a;
					e.fire(new ne(n, e, null, f));
					return;
				}
				const p = n;
				if (Do.includes(p)) {
					const f = a;
					e.fire(new ne(n, e, null, f));
					return;
				}
				const d = n;
				if (zo.includes(d)) {
					e.fire(new ne(n, e));
					return;
				}
			});
		} catch (a) {
			console.error(`Error forwarding event to ImageViewer, event of type "${n}" is not supported`, a);
		}
	});
}
var lc = class extends Error {
	constructor(t, n, a) {
		const o = `[${a}]: Failed to fetch ${n} at ${t.url}: ${t.status.toString()}: ${t.statusText}`;
		super(o);
		g(this, "status");
		g(this, "statusText");
		this.name = "FetchError", this.message = o, this.status = t.status, this.statusText = t.statusText;
	}
};
var Ta = 85.051129;
function uc(r, e) {
	return new an(e.x / r, e.y / r).toLngLat();
}
function cc(r) {
	return Math.pow(2, r);
}
function pc(r) {
	return Math.log(r) / Math.LN2;
}
function Bo(r, e, t) {
	return Math.min(t, Math.max(e, r));
}
function Yr(r) {
	return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function Wr(r) {
	return (180 + r) / 360;
}
function _a(r, e, t) {
	const n = t - e, a = ((r - e) % n + n) % n + e;
	return a === e ? t : a;
}
function fc(r, e) {
	const t = Bo(e.lat, -Ta, Ta);
	return new si(Wr(e.lng) * r, Yr(t) * r);
}
var dc = function(r, e) {
	e = Bo(e, this.minZoom, this.maxZoom);
	const t = {
		center: new ii(r.lng, r.lat),
		zoom: e
	};
	let n = this.lngRange;
	const a = this.latRange;
	if (n === null) {
		const X = 179.9999999999;
		n = [-X, X];
	}
	const o = this.tileSize * cc(t.zoom);
	let i = 0, s = o, l = 0, u = o, c = 0, p = 0;
	const { x: d, y: f } = this.size, h = .5;
	a && (i = Yr(a[1]) * o, s = Yr(a[0]) * o, s - i < h * f && (c = h * f / (s - i))), n && (l = _a(Wr(n[0]) * o, 0, o), u = _a(Wr(n[1]) * o, 0, o), u < l && (u += o), u - l < h * d && (p = h * d / (u - l)));
	const { x: m, y } = fc(o, r);
	let b, v;
	const x = Math.min(p || 0, c || 0);
	if (x) return t.zoom += pc(x), t;
	let E = 0, C = 0;
	const T = 1, N = 1 - (s - i) / f, ge = 1 - (u - l) / d;
	E = Math.max(ge, T), C = Math.max(N, T);
	const Xe = 1 - E, Ye = 1 - C;
	if (a) {
		const X = Ye * f / 2;
		y - X < i && (v = i + X), y + X > s && (v = s - X);
	}
	if (n) {
		const X = m, We = Xe * d / 2;
		X - We < l && (b = l + We), X + We > u && (b = u - We);
	}
	if (b !== void 0 || v !== void 0) t.center = uc(o, new si(b ?? m, v ?? y)).wrap();
	return t;
}, hc = {
	center: "translate(-50%,-50%)",
	top: "translate(-50%,0)",
	"top-left": "translate(0,0)",
	"top-right": "translate(-100%,0)",
	bottom: "translate(-50%,-100%)",
	"bottom-left": "translate(0,-100%)",
	"bottom-right": "translate(-100%,-100%)",
	left: "translate(0,-50%)",
	right: "translate(-100%,-50%)"
};
function mc(r) {
	function e(t) {
		if (!this._map) return;
		const n = this._map.loaded() && !this._map.isMoving();
		((t == null ? void 0 : t.type) === "terrain" || (t == null ? void 0 : t.type) === "render" && !n) && this._map.once("render", this._update), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
		let a = "";
		this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? a = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (a = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
		let o = "";
		this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? o = "rotateX(0deg)" : this._pitchAlignment === "map" && (o = `rotateX(${this._map.getPitch()}deg)`), !this._subpixelPositioning && (!t || t.type === "moveend") && (this._pos = this._pos.round());
		const i = `${hc[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o} ${a}`;
		this._element.style.transform = i;
	}
	r._update = e.bind(r);
}
var yc = class {
	constructor({ imageViewer: e }) {
		g(this, "viewer");
		g(this, "container");
		g(this, "handleClick", () => {
			this.viewer.fitImageToViewport({ ease: !0 });
		});
		if (!e) throw new Error("ImageViewerFitImageToBoundsControl: an instance of 'ImageViewer' is required");
		this.viewer = e;
	}
	onAdd(e) {
		const t = document.createElement("button");
		this.container = document.createElement("div"), this.container.classList.add("maplibregl-ctrl", "maplibregl-ctrl-group"), t.classList.add("maplibregl-ctrl-fit-image-to-bounds");
		const n = document.createElement("span");
		return n.classList.add("maplibregl-ctrl-icon"), t.title = "Zoom image to viewport bounds", t.appendChild(n), t.addEventListener("click", this.handleClick), this.container.appendChild(t), this.container;
	}
	onRemove() {
		this.container.remove();
	}
};
var qo = Symbol("MapTiler:ImageViewer:Internal:lngLatToPxInternal"), Vo = Symbol("MapTiler:ImageViewer:Internal:pxToLngLatInternal"), { Evented: gc } = import_maplibre_gl.default, vc = {
	style: {
		version: 8,
		sources: {},
		layers: []
	},
	minPitch: 0,
	maxPitch: 0,
	pitch: 0,
	bearing: 0,
	projection: "mercator",
	geolocateControl: !1,
	navigationControl: !1,
	projectionControl: !1,
	hash: !1,
	renderWorldCopies: !1,
	terrain: !1,
	space: !1,
	halo: !1,
	transformConstrain: dc
}, bc = {
	debug: !1,
	fitToBoundsControl: !0,
	navigationControl: !0
};
var Oa, Fa, $a;
var wc = class extends ($a = gc, Fa = qo, Oa = Vo, $a) {
	/**
	* The constructor for the ImageViewer.
	*
	* @param {Partial<ImageViewerConstructorOptions>} imageViewerConstructorOptions - The options for the ImageViewer.
	* @example
	* ```ts
	* import "@maptiler/sdk/dist/maptiler-sdk.css"; // import css
	* import { ImageViewer } from "@maptiler/sdk"; // import the sdk
	*
	* const imageViewer = new ImageViewer({
	*   container: document.getElementById("map"),
	*   imageUUID: "01986025-ceb9-7487-9ea6-7a8637dcc1a1",
	*   debug: true, // show tile boundaries, padding, collision boxes etc
	*   fitToBoundsControl: true, // show a control to fit the image to the viewport
	*   navigationControl: true, // show a navigation control
	*   center: [0, 0], // center in pixels
	*   zoom: 1, // zoom level
	*   bearing: 0, // bearing
	* });
	* ```
	*/
	constructor(t) {
		super();
		/**
		* The UUID of the image.
		*
		* @internal
		*/
		g(this, "imageUUID");
		/**
		* Whether to enable debug mode.
		*
		* @internal
		*/
		g(this, "debug");
		/**
		* The metadata of the image.
		*
		*/
		g(this, "imageMetadata");
		/**
		* Why not extend the Map class?
		* Because ImageViewer technically operates in screen space and not in map space.
		* We wrap map and perform calculations in screen space.
		* We do not want to have to extend the Map class and give access to
		* methods and properties that operate in LngLat space.   *
		*/
		g(this, "sdk");
		/**
		* The options for the ImageViewer.
		*
		* @internal
		*/
		g(this, "options");
		/**
		* The size of the image.
		*
		* @internal
		*/
		g(this, "imageSize");
		/**
		* The padded size max.
		*
		* @internal
		*/
		g(this, "paddedSizeMax");
		/**
		* The control to fit the image to the viewport.
		*/
		g(this, "fitToBoundsControlInstance");
		g(this, "shouldFitImageToViewport", !0);
		g(this, Fa, this.lngLatToPx.bind(this));
		g(this, Oa, this.pxToLngLat.bind(this));
		if (!t.imageUUID) throw new Error("[ImageViewer]: `imageUUID` is required");
		if (typeof t.container != "string" && !(t.container instanceof HTMLElement)) throw new Error("[ImageViewer]: `container` is required and must be a string or HTMLElement");
		this.options = {
			...bc,
			...t
		};
		const n = {
			...this.options,
			...vc
		};
		delete n.center, this.sdk = new Po(n), this.sdk.telemetry.registerViewerType("ImageViewer");
		const { imageUUID: a, debug: o } = t;
		this.imageUUID = a, this.debug = o ?? !1, this.debug && (this.sdk.showTileBoundaries = this.debug, this.sdk.showPadding = this.debug, this.sdk.showCollisionBoxes = this.debug, this.sdk.repaint = this.debug), this.init();
	}
	/**
	* The version of the ImageViewer / SDK.
	*/
	get version() {
		return this.sdk.version;
	}
	/**
	* Waits for the ImageViewer to be ready.
	*
	* @returns {Promise<void>}
	*/
	async onReadyAsync() {
		try {
			await this.sdk.onReadyAsync(), await Promise.race([new Promise((t, n) => {
				this.once("imageviewerready", (a) => {
					t(a);
				}), this.once("imagevieweriniterror", (a) => {
					n(a.error);
				});
			}), new Promise((t, n) => {
				setTimeout(() => {
					n(/* @__PURE__ */ new Error("Timeout waiting for image viewer to be ready"));
				}, 5e3);
			})]);
		} catch (t) {
			throw t;
		}
	}
	/**
	* Initializes the ImageViewer
	*  - fetches the image metadata
	*  - adds the image source to the sdk instance
	*  - sets the center to the middle of the image (if center is not provided)
	*  - monkeypatches the maplibre-gl sdk transform method to allow for overpanning and underzooming.
	*  - sets up global event forwarding / intercepting from the map instance
	*  - sets the center to the middle of the image (if center is not provided)
	*
	* @internal
	* @returns {Promise<void>}
	*/
	async init() {
		var t, n, a;
		try {
			await this.fetchImageMetadata(), this.addImageSource(), this.options.navigationControl && this.sdk.addControl(new Na({
				visualizePitch: !1,
				visualizeRoll: !1
			})), this.fitToBoundsControlInstance = new yc({ imageViewer: this }), this.options.fitToBoundsControl && this.sdk.addControl(this.fitToBoundsControlInstance), sc({
				map: this.sdk,
				viewer: this,
				lngLatToPx: (u) => this.lngLatToPx(u)
			});
			const { center: o, zoom: i, bearing: s } = this.options, l = o ?? [(((t = this.imageMetadata) == null ? void 0 : t.width) ?? 0) / 2, (((n = this.imageMetadata) == null ? void 0 : n.height) ?? 0) / 2];
			this.setCenter(l), this.setBearing(s ?? 0), this.options.zoom ? this.setZoom(i ?? ((a = this.imageMetadata) == null ? void 0 : a.maxzoom) ?? 5) : this.fitImageToViewport(), this.sdk.on("wheel", () => {
				this.shouldFitImageToViewport = !1;
			}), this.sdk.on("touchstart", () => {
				this.shouldFitImageToViewport = !1;
			}), this.sdk.on("drag", () => {
				this.shouldFitImageToViewport = !1;
			}), this.sdk.on("resize", () => {
				var d, f;
				const u = this.getCenter(), c = ((d = this.imageMetadata) == null ? void 0 : d.width) ?? 0, p = ((f = this.imageMetadata) == null ? void 0 : f.height) ?? 0;
				this.shouldFitImageToViewport && this.fitImageToViewport(), (u[0] !== c / 2 || u[1] !== p / 2) && this.setCenter(u);
			}), this.fire("imageviewerready", new ne("imageviewerready", this));
		} catch (o) {
			this.fire("imagevieweriniterror", { error: o });
		}
	}
	/**
	* Fits the image to the viewport.
	*
	* @param {Object} options - The options for the fit image to viewport.
	* @param {boolean} options.ease - Whether to ease to the viewport bounds.
	*/
	fitImageToViewport({ ease: t = !1 } = {}) {
		if (!this.imageMetadata) throw new Error("[ImageViewer]: Image metadata not found");
		const n = this.pxToLngLat([0, 0]), a = this.pxToLngLat([this.imageMetadata.width ?? 0, this.imageMetadata.height ?? 0]), o = this.sdk.cameraForBounds([n, a], { padding: 50 });
		o && (t ? this.sdk.easeTo({
			...o,
			pitch: 0
		}, null) : this.sdk.jumpTo({
			...o,
			pitch: 0
		}, null)), this.shouldFitImageToViewport = !0;
	}
	/**
	* Fetches the image metadata from the API.
	*
	* @internal
	* @returns {Promise<void>}
	*/
	async fetchImageMetadata() {
		const t = Sc(this.imageUUID), n = await fetch(t);
		if (!n.ok) throw new lc(n, "image metadata", "ImageViewer");
		this.imageMetadata = await n.json(), Object.freeze(this.imageMetadata);
	}
	/**
	* Adds the image source to the sdk instance.
	*
	* @internal
	* @returns {void}
	*/
	addImageSource() {
		if (!this.imageMetadata) throw this.fire("error", new ne("error", this, null, { error: /* @__PURE__ */ new Error("[ImageViewer]: Image metadata not found") })), /* @__PURE__ */ new Error("[ImageViewer]: Image metadata not found");
		const t = xc(this.imageUUID), n = (s) => Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
		this.imageSize = [this.imageMetadata.width, this.imageMetadata.height], this.paddedSizeMax = Math.max(n(this.imageSize[0]), n(this.imageSize[1]));
		const a = this.pxToLngLat([0, 0]), o = this.pxToLngLat(this.imageSize), i = [
			a.lng,
			o.lat,
			o.lng,
			a.lat
		];
		this.sdk.addSource("image", {
			...this.imageMetadata,
			type: "raster",
			bounds: i,
			tiles: [t]
		}), this.sdk.addLayer({
			id: "image",
			type: "raster",
			source: "image"
		});
	}
	/**
	* Triggers a repaint of the ImageViewer. Same as map.triggerRepaint().
	*
	* @internal
	* @returns {void}
	*/
	triggerRepaint() {
		this.sdk.triggerRepaint();
	}
	/**
	* The scroll zoom handler.
	*
	* @internal
	* @returns {ScrollZoomHandler}
	*/
	get scrollZoom() {
		return this.sdk.scrollZoom;
	}
	/**
	* The scroll zoom handler.
	*
	* @internal
	* @param {ScrollZoomHandler} value - The scroll zoom handler.
	*/
	set scrollZoom(t) {
		this.sdk.scrollZoom = t;
	}
	/**
	* The box zoom handler.
	*
	* @internal
	* @returns {BoxZoomHandler}
	*/
	get boxZoom() {
		return this.sdk.boxZoom;
	}
	/**
	* The box zoom handler.
	*
	* @internal
	* @param {BoxZoomHandler} value - The box zoom handler.
	*/
	set boxZoom(t) {
		this.sdk.boxZoom = t;
	}
	/**
	* The drag pan handler.
	*
	* @internal
	* @returns {DragPanHandler}
	*/
	get dragPan() {
		return this.sdk.dragPan;
	}
	/**
	* The drag pan handler.
	*
	* @internal
	* @param {DragPanHandler} value - The drag pan handler.
	*/
	set dragPan(t) {
		this.sdk.dragPan = t;
	}
	/**
	* The keyboard handler.
	*
	* @internal
	* @returns {KeyboardHandler}
	*/
	get keyboard() {
		return this.sdk.keyboard;
	}
	/**
	* The keyboard handler.
	*
	* @internal
	* @param {KeyboardHandler} value - The keyboard handler.
	*/
	set keyboard(t) {
		this.sdk.keyboard = t;
	}
	/**
	* The double click zoom handler.
	*
	* @internal
	* @returns {DoubleClickZoomHandler}
	*/
	get doubleClickZoom() {
		return this.sdk.doubleClickZoom;
	}
	/**
	* The double click zoom handler.
	*
	* @internal
	* @param {DoubleClickZoomHandler} value - The double click zoom handler.
	*/
	set doubleClickZoom(t) {
		this.sdk.doubleClickZoom = t;
	}
	/**
	* The touch zoom rotate handler.
	*
	* @internal
	* @returns {TwoFingersTouchZoomRotateHandler}
	*/
	get touchZoomRotate() {
		return this.sdk.touchZoomRotate;
	}
	/**
	* The touch zoom rotate handler.
	*
	* @internal
	* @param {TwoFingersTouchZoomRotateHandler} value - The touch zoom rotate handler.
	*/
	set touchZoomRotate(t) {
		this.sdk.touchZoomRotate = t;
	}
	/**
	* The cooperative gestures handler.
	*
	* @internal
	* @returns {CooperativeGesturesHandler}
	*/
	get cooperativeGestures() {
		return this.sdk.cooperativeGestures;
	}
	/**
	* The cooperative gestures handler.
	*
	* @internal
	* @param {CooperativeGesturesHandler} value - The cooperative gestures handler.
	*/
	set cooperativeGestures(t) {
		this.sdk.cooperativeGestures = t;
	}
	/**
	* Converts a LngLat to a px coordinate, based on the image metadata.
	*
	* @internal
	* @param {LngLat} lngLat - The LngLat to convert.
	* @returns {[number, number]} The px coordinate.
	*/
	lngLatToPx(t) {
		if (!this.paddedSizeMax) {
			const a = "[ImageViewer]: Unable to convert LngLat to px, padded size max not set";
			throw this.fire("error", new ne("error", this, null, { error: new Error(a) })), new Error(a);
		}
		const n = an.fromLngLat(t);
		return [n.x * this.paddedSizeMax, n.y * this.paddedSizeMax];
	}
	/**
	* Converts a px coordinate to a LngLat, based on the image metadata.
	*
	* @internal
	* @param {LngLat} lngLat - The LngLat to convert.
	* @returns {[number, number]} The px coordinate.
	*/
	pxToLngLat(t) {
		if (!this.paddedSizeMax) {
			const a = "[ImageViewer]: Unable to convert px to LngLat, padded size max not set";
			throw this.fire("error", new ne("error", this, null, { error: new Error(a) })), new Error(a);
		}
		return new an(t[0] / this.paddedSizeMax, t[1] / this.paddedSizeMax).toLngLat();
	}
	/**
	* Get the internal SDK instance.
	*
	* @returns {Map} The internal SDK instance.
	* @internal
	*/
	getSDKInternal() {
		return this.sdk;
	}
	/**
	* Get the canvas of the internal SDK instance.
	*
	* @returns {HTMLCanvasElement} The canvas of the internal SDK instance.
	*/
	getCanvas() {
		return this.sdk.getCanvas();
	}
	/**
	* Fly to a given center.
	*
	* @param {ImageViewerFlyToOptions} options - The options for the fly to.
	* @param {MapDataEvent} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	flyTo(t, n) {
		const a = this.pxToLngLat(t.center);
		return this.sdk.flyTo({
			...t,
			pitch: 0,
			center: a
		}, n), this;
	}
	/**
	* Jump to a given center.
	*
	* @param {ImageViewerJumpToOptions} options - The options for the jump to.
	* @param {MapDataEvent} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	jumpTo(t, n) {
		const a = this.pxToLngLat(t.center);
		return this.sdk.jumpTo({
			...t,
			pitch: 0,
			center: a
		}, n), this;
	}
	/**
	* Set the zoom level.
	*
	* @param {number} zoom - The zoom level.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	setZoom(t) {
		return this.sdk.setZoom(t), this;
	}
	/**
	* Get the zoom level.
	*
	* @returns {number} The zoom level.
	*/
	getZoom() {
		return this.sdk.getZoom();
	}
	/**
	* Get the center of the ImageViewer in pixels.
	*
	* @internal
	* @returns {[number, number]} The center of the ImageViewer.
	*/
	getCenter() {
		const t = this.sdk.getCenter();
		return this.lngLatToPx(t);
	}
	/**
	* Set the center of the ImageViewer in pixels.
	*
	* @param {number} center - The center of the ImageViewer.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	setCenter(t) {
		return this.sdk.setCenter(this.pxToLngLat(t)), this;
	}
	/**
	* Set the bearing of the ImageViewer in degrees.
	*
	* @param {number} bearing - The bearing of the ImageViewer.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	setBearing(t) {
		return this.sdk.setBearing(t), this;
	}
	/**
	* Get the bearing of the ImageViewer in degrees.
	*
	* @returns {number} The bearing of the ImageViewer.
	*/
	getBearing() {
		return this.sdk.getBearing();
	}
	/**
	* Pan by a given delta in pixels.
	*
	* @param {PointLike} delta - The delta to pan by.
	* @param {ImageViewerEaseToOptions} options - The options for the pan.
	* @param {any} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	panBy(t, n, a) {
		return this.sdk.panBy(t, {
			...n,
			pitch: 0
		}, a), this;
	}
	/**
	* Pan to a given center in pixels.
	*
	* @param {number} center - The center to pan to.
	* @param {ImageViewerEaseToOptions} options - The options for the pan.
	* @param {any} eventData - The event data.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	panTo(t, n, a) {
		return this.sdk.panTo(this.pxToLngLat(t), {
			...n,
			pitch: 0
		}, a), this;
	}
	/**
	* Get the image metadata.
	*
	* @returns {ImageMetadata} The image metadata.
	*/
	getImageMetadata() {
		return this.imageMetadata;
	}
	/**
	* Get the visible bounds of the image in the viewport in imagePixels.
	* [topLeft, bottomRight]
	*
	* @returns {[[number, number], [number, number]]} The visible bounds of the image.
	*/
	getImageBounds() {
		const n = this.sdk.getBounds().toArray().map((i) => this.lngLatToPx(ii.convert(i)));
		return [[n[0][0], n[1][1]], [n[1][0], n[0][1]]];
	}
	/**
	* Set the bounds of the image.
	*
	* @param {[[number, number], [number, number]]} bounds - The bounds of the image.
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	fitImageBounds([t, n]) {
		const a = this.pxToLngLat(t), o = this.pxToLngLat(n), i = Vc.convert([a, o]);
		return this.sdk.fitBounds(i), this;
	}
	/**
	* Destroys the ImageViewer, removes the map instance and all event listeners. Useful for cleanup.
	*
	* @returns {ImageViewer} The ImageViewer instance.
	*/
	remove() {
		this.fire("beforeremove", new ne("beforeremove", this)), this.sdk.remove(), this._listeners && Object.entries(this._listeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		}), this._oneTimeListeners && Object.entries(this._oneTimeListeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		});
	}
	pointIsWithinImageBounds(t) {
		const n = this.getImageMetadata();
		if (!n) return !1;
		const a = [[0, 0], [n.width, n.height]];
		return t[0] >= a[0][0] && t[0] <= a[1][0] && t[1] >= a[0][1] && t[1] <= a[1][1];
	}
};
function Sc(r) {
	return `${Go()}/${r}/image.json?key=${j.apiKey}`;
}
function xc(r) {
	return `${Go()}/${r}/{z}/{x}/{y}?key=${j.apiKey}`;
}
function Go() {
	return "https://api.maptiler.com/images";
}
var { Evented: kc } = import_maplibre_gl.default;
var vp = class extends kc {
	constructor({ ...t }) {
		super();
		g(this, "viewer");
		g(this, "marker");
		g(this, "position", [0, 0]);
		this.marker = new Ci(t);
	}
	/**
	* Adds the ImageViewerMarker to an instance of ImageViewer.
	*
	* @param {ImageViewer} viewer - The instance of ImageViewer to add the ImageViewerMarker to.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	addTo(t) {
		if (!(t instanceof wc)) throw new Error("[ImageViewerMarker]: an ImageViewerMarker must be added to an instance of ImageViewer");
		this.viewer = t, Ac(this.marker, this, this.viewer[qo]);
		const n = this.viewer.getSDKInternal();
		return this.setPosition(this.position), mc(this.marker), this.marker.addTo(n), this;
	}
	/**
	* Adds a class name to the ImageViewerMarker.
	*
	* @param {string} className - The class name to add to the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	addClassName(t) {
		return this.marker.addClassName(t), this;
	}
	/**
	* Gets the element of the ImageViewerMarker.
	*
	* @returns {HTMLElement} The element of the ImageViewerMarker.
	*/
	getElement() {
		return this.marker.getElement();
	}
	/**
	* Gets the position of the ImageViewerMarker.
	*
	* @returns {PointLike} The position of the ImageViewerMarker.
	* @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
	*
	*/
	getPosition() {
		return this.position;
	}
	/**
	* Gets the offset of the ImageViewerMarker.
	*
	* @returns {PointLike} The offset of the ImageViewerMarker.
	* @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
	*/
	getOffset() {
		return this.marker.getOffset();
	}
	/**
	* Gets the pitch alignment of the ImageViewerMarker.
	*
	* @returns {Alignment} The pitch alignment of the ImageViewerMarker.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	getPitchAlignment() {
		return this.marker.getPitchAlignment();
	}
	/**
	* Gets the popup of the ImageViewerMarker.
	*
	* @returns {Popup} The popup of the ImageViewerMarker.
	* @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
	*/
	getPopup() {
		return this.marker.getPopup();
	}
	/**
	* Gets the rotation of the ImageViewerMarker.
	*
	* @returns {number} The rotation of the ImageViewerMarker.
	*/
	getRotation() {
		return this.marker.getRotation();
	}
	/**
	* Gets the rotation alignment of the ImageViewerMarker.
	*
	* @returns {Alignment} The rotation alignment of the ImageViewerMarker.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	getRotationAlignment() {
		return this.marker.getRotationAlignment();
	}
	/**
	* Checks if the ImageViewerMarker is draggable.
	*
	* @returns {boolean} True if the ImageViewerMarker is draggable, false otherwise.
	*/
	isDraggable() {
		return this.marker.isDraggable();
	}
	/**
	* Fires an event on the ImageViewerMarker.
	*
	* @param {MarkerEventTypes | Event} event - The event to fire.
	* @param {Record<string, any>} data - The data to fire the event with.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	fire(t, n) {
		return super.fire(t, n), this;
	}
	/**
	* Removes an event listener from the ImageViewerMarker.
	*
	* @param {MarkerEventTypes} event - The event to remove the listener from.
	* @param {ImageViewerMarkerEvent} listener - The listener to remove.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	off(t, n) {
		return super.off(t, n), this;
	}
	/**
	* Adds an event listener to the ImageViewerMarker.
	*
	* @param {MarkerEventTypes} event - The event to add the listener to.
	* @param {ImageViewerMarkerEvent} listener - The listener to add.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	on(t, n) {
		return super.on(t, n);
	}
	/**
	* Checks if the ImageViewerMarker is within the image bounds.
	*
	* @returns {boolean} True if the ImageViewerMarker is within the image bounds, false otherwise.
	*/
	isWithinImageBounds() {
		return this.viewer.pointIsWithinImageBounds(this.position);
	}
	/**
	* Removes the ImageViewerMarker from the ImageViewer and cleans up the event listeners.
	*
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	remove() {
		return this.marker.remove(), this.marker._listeners && Object.entries(this.marker._listeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		}), this.marker._oneTimeListeners && Object.entries(this.marker._oneTimeListeners).forEach(([t, n]) => {
			n.forEach((a) => {
				this.off(t, a);
			});
		}), this;
	}
	/**
	* Removes a class name from the ImageViewerMarker dom element.
	*
	* @param {string} className - The class name to remove from the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	removeClassName(t) {
		return this.marker.removeClassName(t), this;
	}
	/**
	* Sets the draggable state of the ImageViewerMarker.
	*
	* @param {boolean} draggable - The draggable state of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setDraggable(t) {
		return this.marker.setDraggable(t), this;
	}
	/**
	* Sets the position of the ImageViewerMarker.
	*
	* @param {[number, number]} px - The position of the ImageViewerMarker in image pixels.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setPosition(t) {
		if (this.position[0] = t[0], this.position[1] = t[1], !this.viewer) return this;
		const n = this.viewer[Vo](t);
		return this.marker.setLngLat(n), this;
	}
	/**
	* Sets the offset of the ImageViewerMarker.
	*
	* @param {PointLike} offset - The offset of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setOffset(t) {
		return this.marker.setOffset(t), this;
	}
	/**
	* Sets the opacity of the ImageViewerMarker.
	*
	* @param {string} opacity - The opacity of the ImageViewerMarker.
	* @param {string} opacityWhenCovered - The opacity of the ImageViewerMarker when covered.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setOpacity(t, n) {
		return this.marker.setOpacity(t, n), this;
	}
	/**
	* Sets the pitch alignment of the ImageViewerMarker.
	*
	* @param {Alignment} pitchAlignment - The pitch alignment of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	setPitchAlignment(t) {
		return this.marker.setPitchAlignment(t), this;
	}
	/**
	* Sets the popup of the ImageViewerMarker.
	*
	* @param {Popup} popup - The popup of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	* @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
	*/
	setPopup(t) {
		return this.marker.setPopup(t), this;
	}
	/**
	* Sets the rotation of the ImageViewerMarker.
	*
	* @param {number} rotation - The rotation of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setRotation(t) {
		return this.marker.setRotation(t), this;
	}
	/**
	* Sets the rotation alignment of the ImageViewerMarker.
	*
	* @param {Alignment} rotationAlignment - The rotation alignment of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	* @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
	*/
	setRotationAlignment(t) {
		return this.marker.setRotationAlignment(t), this;
	}
	/**
	* Sets if subpixel positioning is enabled for the ImageViewerMarker.
	*
	* @param {boolean} subpixelPositioning - The subpixel positioning of the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	setSubpixelPositioning(t) {
		return this.marker.setSubpixelPositioning(t), this;
	}
	/**
	* Toggles a class name on the ImageViewerMarker dom element.
	*
	* @param {string} className - The class name to toggle on the ImageViewerMarker.
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	toggleClassName(t) {
		return this.marker.toggleClassName(t), this;
	}
	/**
	* Toggles the popup of the ImageViewerMarker.
	*
	* @returns {ImageViewerMarker} The ImageViewerMarker instance.
	*/
	togglePopup() {
		return this.marker.togglePopup(), this;
	}
};
var Lc = [
	"dragstart",
	"drag",
	"dragend"
], Cc = [
	"lngLat",
	"_defaultPrevented",
	"target"
];
var Ec = class {
	constructor(e, t, n) {
		g(this, "type");
		g(this, "target");
		this.type = e, this.target = t, Object.assign(this, n);
	}
};
function Ac(r, e, t) {
	Lc.forEach((n) => {
		r.on(n, (a) => {
			var i, s;
			if ((i = a.target) == null ? void 0 : i.getLngLat()) {
				const l = t((s = a.target) == null ? void 0 : s.getLngLat());
				e.setPosition(l);
			}
			e.fire(n, new Ec(n, e, { ...Object.fromEntries(Object.entries(a).filter(([l]) => !Cc.includes(l))) }));
		});
	});
}
function _n(r) {
	if (typeof DOMParser < "u") {
		const e = new DOMParser().parseFromString(r, "application/xml");
		if (e.querySelector("parsererror")) throw new Error("The provided string is not valid XML");
		return e;
	}
	throw new Error("No XML parser found");
}
function Ho(r, e) {
	if (!r.hasChildNodes()) return !1;
	for (const t of Array.from(r.childNodes)) {
		const n = t.nodeName;
		if (typeof n == "string" && n.trim().toLowerCase() === e.toLowerCase()) return !0;
	}
	return !1;
}
function Ia(r) {
	if (typeof XMLSerializer < "u") return new XMLSerializer().serializeToString(r);
	throw new Error("No XML serializer found");
}
function Zo(r) {
	const e = typeof r == "string" ? _n(r) : r;
	if (!Ho(e, "gpx")) throw new Error("The XML document is not valid GPX");
	const t = K(e, "trk"), n = K(e, "rte"), a = K(e, "wpt"), o = {
		type: "FeatureCollection",
		features: []
	};
	for (const i of Array.from(t)) {
		const s = Mc(i);
		s && o.features.push(s);
	}
	for (const i of Array.from(n)) {
		const s = Pc(i);
		s && o.features.push(s);
	}
	for (const i of Array.from(a)) o.features.push(Rc(i));
	return o;
}
function Ko(r, e) {
	let t = r;
	if (typeof t == "string" && (t = _n(t)), !Ho(t, "kml")) throw new Error("The XML document is not valid KML");
	const n = {
		type: "FeatureCollection",
		features: []
	}, a = {}, o = {}, i = {}, s = K(t, "Placemark"), l = K(t, "Style"), u = K(t, "StyleMap");
	for (const c of Array.from(l)) {
		const p = Pa(e !== void 0 ? e(c) : Ia(c)).toString(16);
		a[`#${He(c, "id")}`] = p, o[p] = c;
	}
	for (const c of Array.from(u)) {
		a[`#${He(c, "id")}`] = Pa(e !== void 0 ? e(c) : Ia(c)).toString(16);
		const p = K(c, "Pair"), d = {};
		for (const f of Array.from(p)) d[F(_(f, "key")) ?? ""] = F(_(f, "styleUrl"));
		i[`#${He(c, "id")}`] = d;
	}
	for (const c of Array.from(s)) n.features = n.features.concat(Ic(c, a, o, i));
	return n;
}
function Ma(r) {
	if (r === null) return ["#000000", 1];
	let e = "", t = 1, n = r;
	return n.startsWith("#") && (n = n.substring(1)), (n.length === 6 || n.length === 3) && (e = n), n.length === 8 && (t = Number.parseInt(n.substring(0, 2), 16) / 255, e = `#${n.substring(6, 8)}${n.substring(4, 6)}${n.substring(2, 4)}`), [e ?? "#000000", t ?? 1];
}
function Tc(r) {
	return Wo(r.split(" "));
}
function _c(r) {
	let e = K(r, "coord");
	const t = [], n = [];
	e.length === 0 && (e = K(r, "gx:coord"));
	for (const o of Array.from(e)) t.push(Tc(F(o) ?? ""));
	const a = K(r, "when");
	for (const o of Array.from(a)) n.push(F(o));
	return {
		coords: t,
		times: n
	};
}
function Bt(r) {
	const e = [
		"Polygon",
		"LineString",
		"Point",
		"Track",
		"gx:Track"
	];
	let t, n, a, o, i;
	const s = [], l = [];
	if (_(r, "MultiGeometry") !== null) return Bt(_(r, "MultiGeometry"));
	if (_(r, "MultiTrack") !== null) return Bt(_(r, "MultiTrack"));
	if (_(r, "gx:MultiTrack") !== null) return Bt(_(r, "gx:MultiTrack"));
	for (a = 0; a < e.length; a++) if (n = K(r, e[a]), n) {
		for (o = 0; o < n.length; o++) if (t = n[o], e[a] === "Point") s.push({
			type: "Point",
			coordinates: Jo(F(_(t, "coordinates")) ?? "")
		});
		else if (e[a] === "LineString") s.push({
			type: "LineString",
			coordinates: za(F(_(t, "coordinates")) ?? "")
		});
		else if (e[a] === "Polygon") {
			const u = K(t, "LinearRing"), c = [];
			for (i = 0; i < u.length; i++) c.push(za(F(_(u[i], "coordinates")) ?? ""));
			s.push({
				type: "Polygon",
				coordinates: c
			});
		} else if (e[a] === "Track" || e[a] === "gx:Track") {
			const u = _c(t);
			s.push({
				type: "LineString",
				coordinates: u.coords
			}), u.times.length && l.push(u.times);
		}
	}
	return {
		geoms: s,
		coordTimes: l
	};
}
function Ic(r, e, t, n) {
	const a = Bt(r), o = {}, i = F(_(r, "name")), s = F(_(r, "address")), l = F(_(r, "description")), u = _(r, "TimeSpan"), c = _(r, "TimeStamp"), p = _(r, "ExtendedData"), d = _(r, "visibility");
	let f, h = F(_(r, "styleUrl")), m = _(r, "LineStyle"), y = _(r, "PolyStyle");
	if (!a.geoms.length) return [];
	if (i && (o.name = i), s && (o.address = s), h) {
		h.startsWith("#") || (h = `#${h}`), o.styleUrl = h, e[h] && (o.styleHash = e[h]), n[h] && (o.styleMapHash = n[h], o.styleHash = e[n[h].normal ?? ""]);
		const v = t[o.styleHash ?? ""];
		if (v) {
			m || (m = _(v, "LineStyle")), y || (y = _(v, "PolyStyle"));
			const x = _(v, "IconStyle");
			if (x) {
				const E = _(x, "Icon");
				if (E) {
					const C = F(_(E, "href"));
					C && (o.icon = C);
				}
			}
		}
	}
	if (l && (o.description = l), u) {
		const v = F(_(u, "begin")), x = F(_(u, "end"));
		v && x && (o.timespan = {
			begin: v,
			end: x
		});
	}
	if (c !== null && (o.timestamp = F(_(c, "when")) ?? (/* @__PURE__ */ new Date()).toISOString()), m !== null) {
		const v = Ma(F(_(m, "color"))), x = v[0], E = v[1], C = Number.parseFloat(F(_(m, "width")) ?? "");
		x && (o.stroke = x), Number.isNaN(E) || (o["stroke-opacity"] = E), Number.isNaN(C) || (o["stroke-width"] = C);
	}
	if (y) {
		const v = Ma(F(_(y, "color"))), x = v[0], E = v[1], C = F(_(y, "fill")), T = F(_(y, "outline"));
		x && (o.fill = x), Number.isNaN(E) || (o["fill-opacity"] = E), C && (o["fill-opacity"] = C === "1" ? o["fill-opacity"] || 1 : 0), T && (o["stroke-opacity"] = T === "1" ? o["stroke-opacity"] || 1 : 0);
	}
	if (p) {
		const v = K(p, "Data"), x = K(p, "SimpleData");
		for (f = 0; f < v.length; f++) o[v[f].getAttribute("name") ?? ""] = F(_(v[f], "value")) ?? "";
		for (f = 0; f < x.length; f++) o[x[f].getAttribute("name") ?? ""] = F(x[f]) ?? "";
	}
	d !== null && (o.visibility = F(d) ?? ""), a.coordTimes.length !== 0 && (o.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);
	const b = {
		type: "Feature",
		geometry: a.geoms.length === 1 ? a.geoms[0] : {
			type: "GeometryCollection",
			geometries: a.geoms
		},
		properties: o
	};
	return He(r, "id") && (b.id = He(r, "id") ?? void 0), [b];
}
function Xo(r, e) {
	const t = K(r, e), n = [], a = [];
	let o = [];
	const i = t.length;
	if (!(i < 2)) {
		for (let s = 0; s < i; s++) {
			const l = Qo(t[s]);
			n.push(l.coordinates), l.time && a.push(l.time), (l.heartRate || o.length) && (o.length === 0 && (o = new Array(s).fill(null)), o.push(l.heartRate));
		}
		return {
			line: n,
			times: a,
			heartRates: o
		};
	}
}
function Mc(r) {
	const e = K(r, "trkseg"), t = [], n = [], a = [];
	let o;
	for (let s = 0; s < e.length; s++) if (o = Xo(e[s], "trkpt"), o !== void 0 && (o.line && t.push(o.line), o.times && o.times.length && n.push(o.times), a.length || o.heartRates && o.heartRates.length)) {
		if (!a.length) for (let l = 0; l < s; l++) a.push(new Array(t[l].length).fill(null));
		o.heartRates && o.heartRates.length ? a.push(o.heartRates) : a.push(new Array(o.line.length).fill(null));
	}
	if (t.length === 0) return;
	const i = {
		...In(r),
		...Yo(_(r, "extensions"))
	};
	return n.length !== 0 && (i.coordTimes = t.length === 1 ? n[0] : n), a.length !== 0 && (i.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {
		type: "Feature",
		properties: i,
		geometry: {
			type: "LineString",
			coordinates: t[0]
		}
	} : {
		type: "Feature",
		properties: i,
		geometry: {
			type: "MultiLineString",
			coordinates: t
		}
	};
}
function Pc(r) {
	const e = Xo(r, "rtept");
	return e === void 0 ? void 0 : {
		type: "Feature",
		properties: {
			...In(r),
			...Yo(_(r, "extensions"))
		},
		geometry: {
			type: "LineString",
			coordinates: e.line
		}
	};
}
function Rc(r) {
	return {
		type: "Feature",
		properties: {
			...In(r),
			...Jr(r, ["sym"])
		},
		geometry: {
			type: "Point",
			coordinates: Qo(r).coordinates
		}
	};
}
function Yo(r) {
	const e = {};
	if (r) {
		const t = _(r, "line");
		if (t) {
			const n = F(_(t, "color")), a = Number.parseFloat(F(_(t, "opacity")) ?? "0"), o = Number.parseFloat(F(_(t, "width")) ?? "0");
			n && (e.stroke = n), Number.isNaN(a) || (e["stroke-opacity"] = a), Number.isNaN(o) || (e["stroke-width"] = o * 96 / 25.4);
		}
	}
	return e;
}
function In(r) {
	const e = Jr(r, [
		"name",
		"cmt",
		"desc",
		"type",
		"time",
		"keywords"
	]), t = K(r, "link");
	if (t.length !== 0) {
		e.links = [];
		for (const n of Array.from(t)) {
			const a = {
				href: He(n, "href"),
				...Jr(n, ["text", "type"])
			};
			e.links.push(a);
		}
	}
	return e;
}
function Pa(r) {
	let e = 0;
	if (!r || !r.length) return e;
	for (let t = 0; t < r.length; t++) e = (e << 5) - e + r.charCodeAt(t) | 0;
	return e;
}
function K(r, e) {
	return r.getElementsByTagName(e);
}
function He(r, e) {
	return r.getAttribute(e);
}
function Ra(r, e) {
	return Number.parseFloat(He(r, e) ?? "0");
}
function _(r, e) {
	const t = K(r, e);
	return t.length ? t[0] : null;
}
function zc(r) {
	return r.normalize && r.normalize(), r;
}
function Wo(r) {
	return r.map(Number.parseFloat).map((e) => Number.isNaN(e) ? null : e);
}
function F(r) {
	return r && zc(r), r && r.textContent;
}
function Jr(r, e) {
	const t = {};
	let n, a;
	for (a = 0; a < e.length; a++) n = _(r, e[a]), n && (t[e[a]] = F(n) ?? "");
	return t;
}
function Jo(r) {
	return Wo(r.replace(/\s*/g, "").split(","));
}
function za(r) {
	const e = r.replace(/^\s*|\s*$/g, "").split(/\s+/), t = [];
	for (const n of e) t.push(Jo(n));
	return t;
}
function Qo(r) {
	const e = [Ra(r, "lon"), Ra(r, "lat")], t = _(r, "ele"), n = _(r, "gpxtpx:hr") || _(r, "hr"), a = _(r, "time");
	let o;
	return t && (o = Number.parseFloat(F(t) ?? "0"), Number.isNaN(o) || e.push(o)), {
		coordinates: e,
		time: a ? F(a) : null,
		heartRate: n !== null ? Number.parseFloat(F(n) ?? "0") : null
	};
}
function Oc(r) {
	let e = r;
	try {
		typeof e == "string" && (e = _n(e));
	} catch {
		return null;
	}
	try {
		return Zo(e);
	} catch {}
	try {
		return Ko(e);
	} catch {}
	return null;
}
async function Fc(r, e = {}) {
	const t = e.download ?? !1, n = await $c(r);
	if (t) {
		const a = e.filename ?? "maptiler_screenshot.png", o = document.createElement("a");
		o.style.display = "none", document.body.appendChild(o), o.href = URL.createObjectURL(n), o.download = a, o.click(), setTimeout(() => {
			document.body.removeChild(o), URL.revokeObjectURL(o.href);
		}, 0);
	}
	return n;
}
function $c(r) {
	return new Promise((e, t) => {
		r.redraw(), r.once("idle", () => {
			r.getCanvas().toBlob((n) => {
				if (!n) {
					t(Error("Screenshot could not be created."));
					return;
				}
				e(n);
			}, "image/png");
		});
	});
}
var Qr = [
	[
		"#1D5B79",
		"#468B97",
		"#EF6262",
		"#F3AA60"
	],
	[
		"#614BC3",
		"#33BBC5",
		"#85E6C5",
		"#C8FFE0"
	],
	[
		"#461959",
		"#7A316F",
		"#CD6688",
		"#AED8CC"
	],
	[
		"#0079FF",
		"#00DFA2",
		"#F6FA70",
		"#FF0060"
	],
	[
		"#39B5E0",
		"#A31ACB",
		"#FF78F0",
		"#F5EA5A"
	],
	[
		"#37E2D5",
		"#590696",
		"#C70A80",
		"#FBCB0A"
	],
	[
		"#FFD36E",
		"#FFF56D",
		"#99FFCD",
		"#9FB4FF"
	],
	[
		"#00EAD3",
		"#FFF5B7",
		"#FF449F",
		"#005F99"
	],
	[
		"#10A19D",
		"#540375",
		"#FF7000",
		"#FFBF00"
	]
];
function yr() {
	return Qr[~~(Math.random() * Qr.length)][~~(Math.random() * 4)];
}
function Mt() {
	return `maptiler_source_${Da()}`;
}
function Pt() {
	return `maptiler_layer_${Da()}`;
}
function en(r, e) {
	if (e <= r[0].zoom) return r[0].value;
	if (e >= r[r.length - 1].zoom) return r[r.length - 1].value;
	for (let t = 0; t < r.length - 1; t += 1) if (e >= r[t].zoom && e < r[t + 1].zoom) {
		const n = r[t + 1].zoom - r[t].zoom, a = (e - r[t].zoom) / n;
		return a * r[t + 1].value + (1 - a) * r[t].value;
	}
	return 0;
}
function Oe(r) {
	return [
		"interpolate",
		["linear"],
		["zoom"],
		...r.flatMap((e) => [e.zoom, e.value])
	];
}
function O(r) {
	return [
		"interpolate",
		["linear"],
		["zoom"],
		...r.flatMap((e) => [e.zoom, e.value])
	];
}
function ei(r, e) {
	if (typeof e == "number" && typeof r == "number") return 2 * e + r;
	if (typeof e == "number" && Array.isArray(r)) return [
		"interpolate",
		["linear"],
		["zoom"],
		...r.flatMap((t) => [t.zoom, 2 * e + t.value])
	];
	if (typeof r == "number" && Array.isArray(e)) return [
		"interpolate",
		["linear"],
		["zoom"],
		...e.flatMap((t) => [t.zoom, 2 * t.value + r])
	];
	if (Array.isArray(r) && Array.isArray(e)) return [
		"interpolate",
		["linear"],
		["zoom"],
		...Array.from(/* @__PURE__ */ new Set([...r.map((n) => n.zoom), ...e.map((n) => n.zoom)])).sort((n, a) => n < a ? -1 : 1).flatMap((n) => [n, 2 * en(e, n) + en(r, n)])
	];
	return 0;
}
function ti(r, e) {
	return [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((t) => [t.propertyValue, t.value])
	];
}
function Mn(r) {
	const e = r.trimStart(), t = `${e}${" ".repeat(r.length - e.length)}`, n = Array.from(t);
	if (!n.every((s) => s === " " || s === "_")) throw new Error("A dash pattern must be composed only of whitespace and underscore characters.");
	if (!(n.some((s) => s === "_") && n.some((s) => s === " "))) throw new Error("A dash pattern must contain at least one underscore and one whitespace character");
	const i = [1];
	for (let s = 1; s < n.length; s += 1) n[s - 1] === n[s] ? i[i.length - 1] += 1 : i.push(1);
	return i;
}
function tn(r, e) {
	return [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((t) => [t.value, t.color])
	];
}
function rn(r, e, t = !0) {
	return t ? [
		"interpolate",
		["linear"],
		["zoom"],
		0,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .025])
		],
		2,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .05])
		],
		4,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .1])
		],
		8,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius * .25])
		],
		16,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.value, n.pointRadius])
		]
	] : [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((n) => [n.value, n.pointRadius])
	];
}
function ri(r, e, t = !0) {
	return t ? [
		"interpolate",
		["linear"],
		["zoom"],
		0,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .025])
		],
		2,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .05])
		],
		4,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .1])
		],
		8,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value * .25])
		],
		16,
		[
			"interpolate",
			["linear"],
			["get", e],
			...r.flatMap((n) => [n.propertyValue, n.value])
		]
	] : [
		"interpolate",
		["linear"],
		["get", e],
		...r.flatMap((n) => [n.propertyValue, n.value])
	];
}
function nn(r, e) {
	return r.every((t) => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [
		"interpolate",
		["linear"],
		["get", e],
		...r.getRawColorStops().flatMap((t) => {
			const n = t.value, a = t.color;
			return [n, a.length === 4 ? a[3] / 255 : 1];
		})
	];
}
function ni(r, e = 10) {
	return [
		"interpolate",
		["linear"],
		["heatmap-density"],
		...Array.from({ length: e + 1 }, (t, n) => {
			const a = n / e;
			return [a, r.getColorHex(a)];
		}).flat()
	];
}
function Nt(r) {
	const e = r.toString(16);
	return e.length === 1 ? `0${e}` : e;
}
function Nc(r) {
	return `#${Nt(r[0])}${Nt(r[1])}${Nt(r[2])}${r.length === 4 ? Nt(r[3]) : ""}`;
}
var A = class A extends Array {
	constructor(t = {}) {
		super();
		g(this, "min", 0);
		g(this, "max", 1);
		"min" in t && (this.min = t.min), "max" in t && (this.max = t.max), "stops" in t && this.setStops(t.stops, { clone: !1 });
	}
	/**
	* Converts a array-definition color ramp definition into a usable ColorRamp instance.
	* Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
	* @param cr
	* @returns
	*/
	static fromArrayDefinition(t) {
		return new A({ stops: t.map((n) => ({
			value: n[0],
			color: n[1]
		})) });
	}
	setStops(t, n = { clone: !0 }) {
		const a = n.clone ? this.clone() : this;
		a.length = 0;
		let o = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
		for (let s = 0; s < t.length; s += 1) o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({
			value: t[s].value,
			color: t[s].color.slice()
		});
		return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;
	}
	scale(t, n, a = { clone: !0 }) {
		const o = a.clone, i = this[0].value, l = this.at(-1).value - i, u = n - t, c = [];
		for (let p = 0; p < this.length; p += 1) {
			const h = (this[p].value - i) / l * u + t;
			o ? c.push({
				value: h,
				color: this[p].color.slice()
			}) : this[p].value = h;
		}
		return o ? new A({ stops: c }) : this;
	}
	at(t) {
		return t < 0 ? this[this.length + t] : this[t];
	}
	clone() {
		return new A({ stops: this.getRawColorStops() });
	}
	getRawColorStops() {
		const t = [];
		for (let n = 0; n < this.length; n += 1) t.push({
			value: this[n].value,
			color: this[n].color
		});
		return t;
	}
	reverse(t = { clone: !0 }) {
		const n = t.clone ? this.clone() : this;
		for (let a = 0; a < ~~(n.length / 2); a += 1) {
			const o = n[a].color;
			n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;
		}
		return n;
	}
	getBounds() {
		return {
			min: this.min,
			max: this.max
		};
	}
	getColor(t, n = { smooth: !0 }) {
		if (t <= this[0].value) return this[0].color;
		if (t >= this.at(-1).value) return this.at(-1).color;
		for (let a = 0; a < this.length - 1; a += 1) {
			if (t > this[a + 1].value) continue;
			const o = this[a].color;
			if (!n.smooth) return o.slice();
			const i = this[a].value, s = this[a + 1].value, l = this[a + 1].color, u = (s - t) / (s - i);
			return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));
		}
		return [
			0,
			0,
			0
		];
	}
	/**
	* Get the color as an hexadecimal string
	*/
	getColorHex(t, n = {
		smooth: !0,
		withAlpha: !1
	}) {
		return Nc(this.getColor(t, n));
	}
	/**
	* Get the color of the color ramp at a relative position in [0, 1]
	*/
	getColorRelative(t, n = { smooth: !0 }) {
		const a = this.getBounds();
		return this.getColor(a.min + t * (a.max - a.min), n);
	}
	getCanvasStrip(t = {
		horizontal: !0,
		size: 512,
		smooth: !0
	}) {
		const n = document.createElement("canvas");
		n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;
		const a = n.getContext("2d");
		if (!a) throw new Error("Canvs context is missing");
		const o = a.getImageData(0, 0, n.width, n.height), i = o.data, s = t.size, l = this[0].value, p = (this.at(-1).value - l) / s;
		for (let d = 0; d < s; d += 1) {
			const f = this.getColor(l + d * p, { smooth: t.smooth });
			i[d * 4] = f[0], i[d * 4 + 1] = f[1], i[d * 4 + 2] = f[2], i[d * 4 + 3] = f.length > 3 ? f[3] : 255;
		}
		return a.putImageData(o, 0, 0), n;
	}
	/**
	* Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.
	*/
	resample(t, n = 15) {
		const a = this.getBounds(), o = this.scale(0, 1), i = 1 / (n - 1);
		let s;
		if (t === "ease-in-square") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = d ** 2;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-out-square") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 1 - (1 - d) ** 2;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-out-sqrt") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = d ** .5;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-in-sqrt") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 1 - (1 - d) ** .5;
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-out-exp") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 1 - 2 ** (-10 * d);
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else if (t === "ease-in-exp") s = Array.from({ length: n }, (c, p) => {
			const d = p * i, f = 2 ** (10 * d - 10);
			return {
				value: d,
				color: o.getColor(f)
			};
		});
		else throw new Error("Invalid ressampling method.");
		return new A({ stops: s }).scale(a.min, a.max);
	}
	/**
	* Makes a clone of this color ramp that is fully transparant at the begining of their range
	*/
	transparentStart() {
		const t = this.getRawColorStops();
		t.unshift({
			value: t[0].value,
			color: t[0].color.slice()
		}), t[1].value += .001;
		for (const n of t) n.color.length === 3 && n.color.push(255);
		return t[0].color[3] = 0, new A({ stops: t });
	}
	/**
	* Check if this color ramp has a transparent start
	*/
	hasTransparentStart() {
		return this[0].color.length === 4 && this[0].color[3] === 0;
	}
};
var ai = {
	NULL: new A({ stops: [{
		value: 0,
		color: [
			0,
			0,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			0,
			0,
			0,
			0
		]
	}] }),
	GRAY: new A({ stops: [{
		value: 0,
		color: [
			0,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			255
		]
	}] }),
	JET: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				131
			]
		},
		{
			value: .125,
			color: [
				0,
				60,
				170
			]
		},
		{
			value: .375,
			color: [
				5,
				255,
				255
			]
		},
		{
			value: .625,
			color: [
				255,
				255,
				0
			]
		},
		{
			value: .875,
			color: [
				250,
				0,
				0
			]
		},
		{
			value: 1,
			color: [
				128,
				0,
				0
			]
		}
	] }),
	HSV: new A({ stops: [
		{
			value: 0,
			color: [
				255,
				0,
				0
			]
		},
		{
			value: .169,
			color: [
				253,
				255,
				2
			]
		},
		{
			value: .173,
			color: [
				247,
				255,
				2
			]
		},
		{
			value: .337,
			color: [
				0,
				252,
				4
			]
		},
		{
			value: .341,
			color: [
				0,
				252,
				10
			]
		},
		{
			value: .506,
			color: [
				1,
				249,
				255
			]
		},
		{
			value: .671,
			color: [
				2,
				0,
				253
			]
		},
		{
			value: .675,
			color: [
				8,
				0,
				253
			]
		},
		{
			value: .839,
			color: [
				255,
				0,
				251
			]
		},
		{
			value: .843,
			color: [
				255,
				0,
				245
			]
		},
		{
			value: 1,
			color: [
				255,
				0,
				6
			]
		}
	] }),
	HOT: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .3,
			color: [
				230,
				0,
				0
			]
		},
		{
			value: .6,
			color: [
				255,
				210,
				0
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				255
			]
		}
	] }),
	SPRING: new A({ stops: [{
		value: 0,
		color: [
			255,
			0,
			255
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			0
		]
	}] }),
	SUMMER: new A({ stops: [{
		value: 0,
		color: [
			0,
			128,
			102
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			102
		]
	}] }),
	AUTOMN: new A({ stops: [{
		value: 0,
		color: [
			255,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			0
		]
	}] }),
	WINTER: new A({ stops: [{
		value: 0,
		color: [
			0,
			0,
			255
		]
	}, {
		value: 1,
		color: [
			0,
			255,
			128
		]
	}] }),
	BONE: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .376,
			color: [
				84,
				84,
				116
			]
		},
		{
			value: .753,
			color: [
				169,
				200,
				200
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				255
			]
		}
	] }),
	COPPER: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .804,
			color: [
				255,
				160,
				102
			]
		},
		{
			value: 1,
			color: [
				255,
				199,
				127
			]
		}
	] }),
	GREYS: new A({ stops: [{
		value: 0,
		color: [
			0,
			0,
			0
		]
	}, {
		value: 1,
		color: [
			255,
			255,
			255
		]
	}] }),
	YIGNBU: new A({ stops: [
		{
			value: 0,
			color: [
				8,
				29,
				88
			]
		},
		{
			value: .125,
			color: [
				37,
				52,
				148
			]
		},
		{
			value: .25,
			color: [
				34,
				94,
				168
			]
		},
		{
			value: .375,
			color: [
				29,
				145,
				192
			]
		},
		{
			value: .5,
			color: [
				65,
				182,
				196
			]
		},
		{
			value: .625,
			color: [
				127,
				205,
				187
			]
		},
		{
			value: .75,
			color: [
				199,
				233,
				180
			]
		},
		{
			value: .875,
			color: [
				237,
				248,
				217
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				217
			]
		}
	] }),
	GREENS: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				68,
				27
			]
		},
		{
			value: .125,
			color: [
				0,
				109,
				44
			]
		},
		{
			value: .25,
			color: [
				35,
				139,
				69
			]
		},
		{
			value: .375,
			color: [
				65,
				171,
				93
			]
		},
		{
			value: .5,
			color: [
				116,
				196,
				118
			]
		},
		{
			value: .625,
			color: [
				161,
				217,
				155
			]
		},
		{
			value: .75,
			color: [
				199,
				233,
				192
			]
		},
		{
			value: .875,
			color: [
				229,
				245,
				224
			]
		},
		{
			value: 1,
			color: [
				247,
				252,
				245
			]
		}
	] }),
	YIORRD: new A({ stops: [
		{
			value: 0,
			color: [
				128,
				0,
				38
			]
		},
		{
			value: .125,
			color: [
				189,
				0,
				38
			]
		},
		{
			value: .25,
			color: [
				227,
				26,
				28
			]
		},
		{
			value: .375,
			color: [
				252,
				78,
				42
			]
		},
		{
			value: .5,
			color: [
				253,
				141,
				60
			]
		},
		{
			value: .625,
			color: [
				254,
				178,
				76
			]
		},
		{
			value: .75,
			color: [
				254,
				217,
				118
			]
		},
		{
			value: .875,
			color: [
				255,
				237,
				160
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				204
			]
		}
	] }),
	BLUERED: new A({ stops: [{
		value: 0,
		color: [
			0,
			0,
			255
		]
	}, {
		value: 1,
		color: [
			255,
			0,
			0
		]
	}] }),
	RDBU: new A({ stops: [
		{
			value: 0,
			color: [
				5,
				10,
				172
			]
		},
		{
			value: .35,
			color: [
				106,
				137,
				247
			]
		},
		{
			value: .5,
			color: [
				190,
				190,
				190
			]
		},
		{
			value: .6,
			color: [
				220,
				170,
				132
			]
		},
		{
			value: .7,
			color: [
				230,
				145,
				90
			]
		},
		{
			value: 1,
			color: [
				178,
				10,
				28
			]
		}
	] }),
	PICNIC: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				255
			]
		},
		{
			value: .1,
			color: [
				51,
				153,
				255
			]
		},
		{
			value: .2,
			color: [
				102,
				204,
				255
			]
		},
		{
			value: .3,
			color: [
				153,
				204,
				255
			]
		},
		{
			value: .4,
			color: [
				204,
				204,
				255
			]
		},
		{
			value: .5,
			color: [
				255,
				255,
				255
			]
		},
		{
			value: .6,
			color: [
				255,
				204,
				255
			]
		},
		{
			value: .7,
			color: [
				255,
				153,
				255
			]
		},
		{
			value: .8,
			color: [
				255,
				102,
				204
			]
		},
		{
			value: .9,
			color: [
				255,
				102,
				102
			]
		},
		{
			value: 1,
			color: [
				255,
				0,
				0
			]
		}
	] }),
	RAINBOW: new A({ stops: [
		{
			value: 0,
			color: [
				150,
				0,
				90
			]
		},
		{
			value: .125,
			color: [
				0,
				0,
				200
			]
		},
		{
			value: .25,
			color: [
				0,
				25,
				255
			]
		},
		{
			value: .375,
			color: [
				0,
				152,
				255
			]
		},
		{
			value: .5,
			color: [
				44,
				255,
				150
			]
		},
		{
			value: .625,
			color: [
				151,
				255,
				0
			]
		},
		{
			value: .75,
			color: [
				255,
				234,
				0
			]
		},
		{
			value: .875,
			color: [
				255,
				111,
				0
			]
		},
		{
			value: 1,
			color: [
				255,
				0,
				0
			]
		}
	] }),
	PORTLAND: new A({ stops: [
		{
			value: 0,
			color: [
				12,
				51,
				131
			]
		},
		{
			value: .25,
			color: [
				10,
				136,
				186
			]
		},
		{
			value: .5,
			color: [
				242,
				211,
				56
			]
		},
		{
			value: .75,
			color: [
				242,
				143,
				56
			]
		},
		{
			value: 1,
			color: [
				217,
				30,
				30
			]
		}
	] }),
	BLACKBODY: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .2,
			color: [
				230,
				0,
				0
			]
		},
		{
			value: .4,
			color: [
				230,
				210,
				0
			]
		},
		{
			value: .7,
			color: [
				255,
				255,
				255
			]
		},
		{
			value: 1,
			color: [
				160,
				200,
				255
			]
		}
	] }),
	EARTH: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				130
			]
		},
		{
			value: .1,
			color: [
				0,
				180,
				180
			]
		},
		{
			value: .2,
			color: [
				40,
				210,
				40
			]
		},
		{
			value: .4,
			color: [
				230,
				230,
				50
			]
		},
		{
			value: .6,
			color: [
				120,
				70,
				20
			]
		},
		{
			value: 1,
			color: [
				255,
				255,
				255
			]
		}
	] }),
	ELECTRIC: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .15,
			color: [
				30,
				0,
				100
			]
		},
		{
			value: .4,
			color: [
				120,
				0,
				100
			]
		},
		{
			value: .6,
			color: [
				160,
				90,
				0
			]
		},
		{
			value: .8,
			color: [
				230,
				200,
				0
			]
		},
		{
			value: 1,
			color: [
				255,
				250,
				220
			]
		}
	] }),
	VIRIDIS: new A({ stops: [
		{
			value: 0,
			color: [
				68,
				1,
				84
			]
		},
		{
			value: .13,
			color: [
				71,
				44,
				122
			]
		},
		{
			value: .25,
			color: [
				59,
				81,
				139
			]
		},
		{
			value: .38,
			color: [
				44,
				113,
				142
			]
		},
		{
			value: .5,
			color: [
				33,
				144,
				141
			]
		},
		{
			value: .63,
			color: [
				39,
				173,
				129
			]
		},
		{
			value: .75,
			color: [
				92,
				200,
				99
			]
		},
		{
			value: .88,
			color: [
				170,
				220,
				50
			]
		},
		{
			value: 1,
			color: [
				253,
				231,
				37
			]
		}
	] }),
	INFERNO: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				4
			]
		},
		{
			value: .13,
			color: [
				31,
				12,
				72
			]
		},
		{
			value: .25,
			color: [
				85,
				15,
				109
			]
		},
		{
			value: .38,
			color: [
				136,
				34,
				106
			]
		},
		{
			value: .5,
			color: [
				186,
				54,
				85
			]
		},
		{
			value: .63,
			color: [
				227,
				89,
				51
			]
		},
		{
			value: .75,
			color: [
				249,
				140,
				10
			]
		},
		{
			value: .88,
			color: [
				249,
				201,
				50
			]
		},
		{
			value: 1,
			color: [
				252,
				255,
				164
			]
		}
	] }),
	MAGMA: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				4
			]
		},
		{
			value: .13,
			color: [
				28,
				16,
				68
			]
		},
		{
			value: .25,
			color: [
				79,
				18,
				123
			]
		},
		{
			value: .38,
			color: [
				129,
				37,
				129
			]
		},
		{
			value: .5,
			color: [
				181,
				54,
				122
			]
		},
		{
			value: .63,
			color: [
				229,
				80,
				100
			]
		},
		{
			value: .75,
			color: [
				251,
				135,
				97
			]
		},
		{
			value: .88,
			color: [
				254,
				194,
				135
			]
		},
		{
			value: 1,
			color: [
				252,
				253,
				191
			]
		}
	] }),
	PLASMA: new A({ stops: [
		{
			value: 0,
			color: [
				13,
				8,
				135
			]
		},
		{
			value: .13,
			color: [
				75,
				3,
				161
			]
		},
		{
			value: .25,
			color: [
				125,
				3,
				168
			]
		},
		{
			value: .38,
			color: [
				168,
				34,
				150
			]
		},
		{
			value: .5,
			color: [
				203,
				70,
				121
			]
		},
		{
			value: .63,
			color: [
				229,
				107,
				93
			]
		},
		{
			value: .75,
			color: [
				248,
				148,
				65
			]
		},
		{
			value: .88,
			color: [
				253,
				195,
				40
			]
		},
		{
			value: 1,
			color: [
				240,
				249,
				33
			]
		}
	] }),
	WARM: new A({ stops: [
		{
			value: 0,
			color: [
				125,
				0,
				179
			]
		},
		{
			value: .13,
			color: [
				172,
				0,
				187
			]
		},
		{
			value: .25,
			color: [
				219,
				0,
				170
			]
		},
		{
			value: .38,
			color: [
				255,
				0,
				130
			]
		},
		{
			value: .5,
			color: [
				255,
				63,
				74
			]
		},
		{
			value: .63,
			color: [
				255,
				123,
				0
			]
		},
		{
			value: .75,
			color: [
				234,
				176,
				0
			]
		},
		{
			value: .88,
			color: [
				190,
				228,
				0
			]
		},
		{
			value: 1,
			color: [
				147,
				255,
				0
			]
		}
	] }),
	COOL: new A({ stops: [
		{
			value: 0,
			color: [
				125,
				0,
				179
			]
		},
		{
			value: .13,
			color: [
				116,
				0,
				218
			]
		},
		{
			value: .25,
			color: [
				98,
				74,
				237
			]
		},
		{
			value: .38,
			color: [
				68,
				146,
				231
			]
		},
		{
			value: .5,
			color: [
				0,
				204,
				197
			]
		},
		{
			value: .63,
			color: [
				0,
				247,
				146
			]
		},
		{
			value: .75,
			color: [
				0,
				255,
				88
			]
		},
		{
			value: .88,
			color: [
				40,
				255,
				8
			]
		},
		{
			value: 1,
			color: [
				147,
				255,
				0
			]
		}
	] }),
	RAINBOW_SOFT: new A({ stops: [
		{
			value: 0,
			color: [
				125,
				0,
				179
			]
		},
		{
			value: .1,
			color: [
				199,
				0,
				180
			]
		},
		{
			value: .2,
			color: [
				255,
				0,
				121
			]
		},
		{
			value: .3,
			color: [
				255,
				108,
				0
			]
		},
		{
			value: .4,
			color: [
				222,
				194,
				0
			]
		},
		{
			value: .5,
			color: [
				150,
				255,
				0
			]
		},
		{
			value: .6,
			color: [
				0,
				255,
				55
			]
		},
		{
			value: .7,
			color: [
				0,
				246,
				150
			]
		},
		{
			value: .8,
			color: [
				50,
				167,
				222
			]
		},
		{
			value: .9,
			color: [
				103,
				51,
				235
			]
		},
		{
			value: 1,
			color: [
				124,
				0,
				186
			]
		}
	] }),
	BATHYMETRY: new A({ stops: [
		{
			value: 0,
			color: [
				40,
				26,
				44
			]
		},
		{
			value: .13,
			color: [
				59,
				49,
				90
			]
		},
		{
			value: .25,
			color: [
				64,
				76,
				139
			]
		},
		{
			value: .38,
			color: [
				63,
				110,
				151
			]
		},
		{
			value: .5,
			color: [
				72,
				142,
				158
			]
		},
		{
			value: .63,
			color: [
				85,
				174,
				163
			]
		},
		{
			value: .75,
			color: [
				120,
				206,
				163
			]
		},
		{
			value: .88,
			color: [
				187,
				230,
				172
			]
		},
		{
			value: 1,
			color: [
				253,
				254,
				204
			]
		}
	] }),
	CDOM: new A({ stops: [
		{
			value: 0,
			color: [
				47,
				15,
				62
			]
		},
		{
			value: .13,
			color: [
				87,
				23,
				86
			]
		},
		{
			value: .25,
			color: [
				130,
				28,
				99
			]
		},
		{
			value: .38,
			color: [
				171,
				41,
				96
			]
		},
		{
			value: .5,
			color: [
				206,
				67,
				86
			]
		},
		{
			value: .63,
			color: [
				230,
				106,
				84
			]
		},
		{
			value: .75,
			color: [
				242,
				149,
				103
			]
		},
		{
			value: .88,
			color: [
				249,
				193,
				135
			]
		},
		{
			value: 1,
			color: [
				254,
				237,
				176
			]
		}
	] }),
	CHLOROPHYLL: new A({ stops: [
		{
			value: 0,
			color: [
				18,
				36,
				20
			]
		},
		{
			value: .13,
			color: [
				25,
				63,
				41
			]
		},
		{
			value: .25,
			color: [
				24,
				91,
				59
			]
		},
		{
			value: .38,
			color: [
				13,
				119,
				72
			]
		},
		{
			value: .5,
			color: [
				18,
				148,
				80
			]
		},
		{
			value: .63,
			color: [
				80,
				173,
				89
			]
		},
		{
			value: .75,
			color: [
				132,
				196,
				122
			]
		},
		{
			value: .88,
			color: [
				175,
				221,
				162
			]
		},
		{
			value: 1,
			color: [
				215,
				249,
				208
			]
		}
	] }),
	DENSITY: new A({ stops: [
		{
			value: 0,
			color: [
				54,
				14,
				36
			]
		},
		{
			value: .13,
			color: [
				89,
				23,
				80
			]
		},
		{
			value: .25,
			color: [
				110,
				45,
				132
			]
		},
		{
			value: .38,
			color: [
				120,
				77,
				178
			]
		},
		{
			value: .5,
			color: [
				120,
				113,
				213
			]
		},
		{
			value: .63,
			color: [
				115,
				151,
				228
			]
		},
		{
			value: .75,
			color: [
				134,
				185,
				227
			]
		},
		{
			value: .88,
			color: [
				177,
				214,
				227
			]
		},
		{
			value: 1,
			color: [
				230,
				241,
				241
			]
		}
	] }),
	FREESURFACE_BLUE: new A({ stops: [
		{
			value: 0,
			color: [
				30,
				4,
				110
			]
		},
		{
			value: .13,
			color: [
				47,
				14,
				176
			]
		},
		{
			value: .25,
			color: [
				41,
				45,
				236
			]
		},
		{
			value: .38,
			color: [
				25,
				99,
				212
			]
		},
		{
			value: .5,
			color: [
				68,
				131,
				200
			]
		},
		{
			value: .63,
			color: [
				114,
				156,
				197
			]
		},
		{
			value: .75,
			color: [
				157,
				181,
				203
			]
		},
		{
			value: .88,
			color: [
				200,
				208,
				216
			]
		},
		{
			value: 1,
			color: [
				241,
				237,
				236
			]
		}
	] }),
	FREESURFACE_RED: new A({ stops: [
		{
			value: 0,
			color: [
				60,
				9,
				18
			]
		},
		{
			value: .13,
			color: [
				100,
				17,
				27
			]
		},
		{
			value: .25,
			color: [
				142,
				20,
				29
			]
		},
		{
			value: .38,
			color: [
				177,
				43,
				27
			]
		},
		{
			value: .5,
			color: [
				192,
				87,
				63
			]
		},
		{
			value: .63,
			color: [
				205,
				125,
				105
			]
		},
		{
			value: .75,
			color: [
				216,
				162,
				148
			]
		},
		{
			value: .88,
			color: [
				227,
				199,
				193
			]
		},
		{
			value: 1,
			color: [
				241,
				237,
				236
			]
		}
	] }),
	OXYGEN: new A({ stops: [
		{
			value: 0,
			color: [
				64,
				5,
				5
			]
		},
		{
			value: .13,
			color: [
				106,
				6,
				15
			]
		},
		{
			value: .25,
			color: [
				144,
				26,
				7
			]
		},
		{
			value: .38,
			color: [
				168,
				64,
				3
			]
		},
		{
			value: .5,
			color: [
				188,
				100,
				4
			]
		},
		{
			value: .63,
			color: [
				206,
				136,
				11
			]
		},
		{
			value: .75,
			color: [
				220,
				174,
				25
			]
		},
		{
			value: .88,
			color: [
				231,
				215,
				44
			]
		},
		{
			value: 1,
			color: [
				248,
				254,
				105
			]
		}
	] }),
	PAR: new A({ stops: [
		{
			value: 0,
			color: [
				51,
				20,
				24
			]
		},
		{
			value: .13,
			color: [
				90,
				32,
				35
			]
		},
		{
			value: .25,
			color: [
				129,
				44,
				34
			]
		},
		{
			value: .38,
			color: [
				159,
				68,
				25
			]
		},
		{
			value: .5,
			color: [
				182,
				99,
				19
			]
		},
		{
			value: .63,
			color: [
				199,
				134,
				22
			]
		},
		{
			value: .75,
			color: [
				212,
				171,
				35
			]
		},
		{
			value: .88,
			color: [
				221,
				210,
				54
			]
		},
		{
			value: 1,
			color: [
				225,
				253,
				75
			]
		}
	] }),
	PHASE: new A({ stops: [
		{
			value: 0,
			color: [
				145,
				105,
				18
			]
		},
		{
			value: .13,
			color: [
				184,
				71,
				38
			]
		},
		{
			value: .25,
			color: [
				186,
				58,
				115
			]
		},
		{
			value: .38,
			color: [
				160,
				71,
				185
			]
		},
		{
			value: .5,
			color: [
				110,
				97,
				218
			]
		},
		{
			value: .63,
			color: [
				50,
				123,
				164
			]
		},
		{
			value: .75,
			color: [
				31,
				131,
				110
			]
		},
		{
			value: .88,
			color: [
				77,
				129,
				34
			]
		},
		{
			value: 1,
			color: [
				145,
				105,
				18
			]
		}
	] }),
	SALINITY: new A({ stops: [
		{
			value: 0,
			color: [
				42,
				24,
				108
			]
		},
		{
			value: .13,
			color: [
				33,
				50,
				162
			]
		},
		{
			value: .25,
			color: [
				15,
				90,
				145
			]
		},
		{
			value: .38,
			color: [
				40,
				118,
				137
			]
		},
		{
			value: .5,
			color: [
				59,
				146,
				135
			]
		},
		{
			value: .63,
			color: [
				79,
				175,
				126
			]
		},
		{
			value: .75,
			color: [
				120,
				203,
				104
			]
		},
		{
			value: .88,
			color: [
				193,
				221,
				100
			]
		},
		{
			value: 1,
			color: [
				253,
				239,
				154
			]
		}
	] }),
	TEMPERATURE: new A({ stops: [
		{
			value: 0,
			color: [
				4,
				35,
				51
			]
		},
		{
			value: .13,
			color: [
				23,
				51,
				122
			]
		},
		{
			value: .25,
			color: [
				85,
				59,
				157
			]
		},
		{
			value: .38,
			color: [
				129,
				79,
				143
			]
		},
		{
			value: .5,
			color: [
				175,
				95,
				130
			]
		},
		{
			value: .63,
			color: [
				222,
				112,
				101
			]
		},
		{
			value: .75,
			color: [
				249,
				146,
				66
			]
		},
		{
			value: .88,
			color: [
				249,
				196,
				65
			]
		},
		{
			value: 1,
			color: [
				232,
				250,
				91
			]
		}
	] }),
	TURBIDITY: new A({ stops: [
		{
			value: 0,
			color: [
				34,
				31,
				27
			]
		},
		{
			value: .13,
			color: [
				65,
				50,
				41
			]
		},
		{
			value: .25,
			color: [
				98,
				69,
				52
			]
		},
		{
			value: .38,
			color: [
				131,
				89,
				57
			]
		},
		{
			value: .5,
			color: [
				161,
				112,
				59
			]
		},
		{
			value: .63,
			color: [
				185,
				140,
				66
			]
		},
		{
			value: .75,
			color: [
				202,
				174,
				88
			]
		},
		{
			value: .88,
			color: [
				216,
				209,
				126
			]
		},
		{
			value: 1,
			color: [
				233,
				246,
				171
			]
		}
	] }),
	VELOCITY_BLUE: new A({ stops: [
		{
			value: 0,
			color: [
				17,
				32,
				64
			]
		},
		{
			value: .13,
			color: [
				35,
				52,
				116
			]
		},
		{
			value: .25,
			color: [
				29,
				81,
				156
			]
		},
		{
			value: .38,
			color: [
				31,
				113,
				162
			]
		},
		{
			value: .5,
			color: [
				50,
				144,
				169
			]
		},
		{
			value: .63,
			color: [
				87,
				173,
				176
			]
		},
		{
			value: .75,
			color: [
				149,
				196,
				189
			]
		},
		{
			value: .88,
			color: [
				203,
				221,
				211
			]
		},
		{
			value: 1,
			color: [
				254,
				251,
				230
			]
		}
	] }),
	VELOCITY_GREEN: new A({ stops: [
		{
			value: 0,
			color: [
				23,
				35,
				19
			]
		},
		{
			value: .13,
			color: [
				24,
				64,
				38
			]
		},
		{
			value: .25,
			color: [
				11,
				95,
				45
			]
		},
		{
			value: .38,
			color: [
				39,
				123,
				35
			]
		},
		{
			value: .5,
			color: [
				95,
				146,
				12
			]
		},
		{
			value: .63,
			color: [
				152,
				165,
				18
			]
		},
		{
			value: .75,
			color: [
				201,
				186,
				69
			]
		},
		{
			value: .88,
			color: [
				233,
				216,
				137
			]
		},
		{
			value: 1,
			color: [
				255,
				253,
				205
			]
		}
	] }),
	CUBEHELIX: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				0,
				0
			]
		},
		{
			value: .07,
			color: [
				22,
				5,
				59
			]
		},
		{
			value: .13,
			color: [
				60,
				4,
				105
			]
		},
		{
			value: .2,
			color: [
				109,
				1,
				135
			]
		},
		{
			value: .27,
			color: [
				161,
				0,
				147
			]
		},
		{
			value: .33,
			color: [
				210,
				2,
				142
			]
		},
		{
			value: .4,
			color: [
				251,
				11,
				123
			]
		},
		{
			value: .47,
			color: [
				255,
				29,
				97
			]
		},
		{
			value: .53,
			color: [
				255,
				54,
				69
			]
		},
		{
			value: .6,
			color: [
				255,
				85,
				46
			]
		},
		{
			value: .67,
			color: [
				255,
				120,
				34
			]
		},
		{
			value: .73,
			color: [
				255,
				157,
				37
			]
		},
		{
			value: .8,
			color: [
				241,
				191,
				57
			]
		},
		{
			value: .87,
			color: [
				224,
				220,
				93
			]
		},
		{
			value: .93,
			color: [
				218,
				241,
				142
			]
		},
		{
			value: 1,
			color: [
				227,
				253,
				198
			]
		}
	] }),
	CIVIDIS: new A({ stops: [
		{
			value: 0,
			color: [
				0,
				32,
				77,
				255
			]
		},
		{
			value: .125,
			color: [
				5,
				54,
				110,
				255
			]
		},
		{
			value: .25,
			color: [
				65,
				77,
				108,
				255
			]
		},
		{
			value: .375,
			color: [
				97,
				100,
				111,
				255
			]
		},
		{
			value: .5,
			color: [
				125,
				124,
				121,
				255
			]
		},
		{
			value: .625,
			color: [
				156,
				149,
				120,
				255
			]
		},
		{
			value: .75,
			color: [
				190,
				175,
				111,
				255
			]
		},
		{
			value: .875,
			color: [
				225,
				204,
				94,
				255
			]
		},
		{
			value: 1,
			color: [
				255,
				235,
				70,
				255
			]
		}
	] }),
	TURBO: new A({ stops: [
		{
			value: 0,
			color: [
				48,
				18,
				59,
				255
			]
		},
		{
			value: .125,
			color: [
				70,
				107,
				227,
				255
			]
		},
		{
			value: .25,
			color: [
				40,
				187,
				236,
				255
			]
		},
		{
			value: .375,
			color: [
				49,
				242,
				153,
				255
			]
		},
		{
			value: .5,
			color: [
				162,
				252,
				60,
				255
			]
		},
		{
			value: .625,
			color: [
				237,
				208,
				58,
				255
			]
		},
		{
			value: .75,
			color: [
				251,
				128,
				34,
				255
			]
		},
		{
			value: .875,
			color: [
				210,
				49,
				5,
				255
			]
		},
		{
			value: 1,
			color: [
				122,
				4,
				3,
				255
			]
		}
	] }),
	ROCKET: new A({ stops: [
		{
			value: 0,
			color: [
				250,
				235,
				221,
				0
			]
		},
		{
			value: .133,
			color: [
				250,
				235,
				221,
				255
			]
		},
		{
			value: .266,
			color: [
				246,
				170,
				130,
				255
			]
		},
		{
			value: .4,
			color: [
				240,
				96,
				67,
				255
			]
		},
		{
			value: .533,
			color: [
				203,
				27,
				79,
				255
			]
		},
		{
			value: .666,
			color: [
				132,
				30,
				90,
				255
			]
		},
		{
			value: .8,
			color: [
				63,
				27,
				68,
				255
			]
		},
		{
			value: 1,
			color: [
				3,
				5,
				26,
				255
			]
		}
	] }),
	MAKO: new A({ stops: [
		{
			value: 0,
			color: [
				11,
				4,
				5,
				255
			]
		},
		{
			value: .125,
			color: [
				43,
				28,
				53,
				255
			]
		},
		{
			value: .25,
			color: [
				62,
				53,
				107,
				255
			]
		},
		{
			value: .375,
			color: [
				59,
				86,
				152,
				255
			]
		},
		{
			value: .5,
			color: [
				53,
				123,
				162,
				255
			]
		},
		{
			value: .625,
			color: [
				53,
				158,
				170,
				255
			]
		},
		{
			value: .75,
			color: [
				73,
				193,
				173,
				255
			]
		},
		{
			value: .875,
			color: [
				150,
				221,
				181,
				255
			]
		},
		{
			value: 1,
			color: [
				222,
				245,
				229,
				255
			]
		}
	] })
};
async function jc(r, e, t = {}) {
	var a, o;
	if (!e.sourceId && !e.data) throw new Error("Creating a polyline layer requires an existing .sourceId or a valid .data property");
	let n = e.data;
	if (typeof n == "string") {
		if (Qt(n)) n = `https://api.maptiler.com/data/${e.data}/features.json?key=${j.apiKey}`;
		else if (((a = n.split(".").pop()) == null ? void 0 : a.toLowerCase().trim()) === "gpx") n = Zo(await (await fetch(n, t)).text());
		else if (((o = n.split(".").pop()) == null ? void 0 : o.toLowerCase().trim()) === "kml") n = Ko(await (await fetch(n, t)).text());
		else {
			const i = ji(n) ?? Oc(n);
			i && (n = i);
		}
		if (!n) throw new Error("Polyline data was provided as string but is incompatible with valid formats.");
	}
	return Dc(r, {
		...e,
		data: n
	});
}
function Dc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.sourceId ?? Mt(), n = e.layerId ?? Pt(), a = {
		polylineLayerId: n,
		polylineOutlineLayerId: "",
		polylineSourceId: t
	};
	e.data && !r.getSource(t) && r.addSource(t, {
		type: "geojson",
		data: e.data
	});
	const o = e.lineWidth ?? 3, i = e.lineColor ?? yr(), s = e.lineOpacity ?? 1, l = e.lineBlur ?? 0, u = e.lineGapWidth ?? 0;
	let c = e.lineDashArray ?? null;
	const p = e.outlineWidth ?? 1, d = e.outlineColor ?? "#FFFFFF", f = e.outlineOpacity ?? 1, h = e.outlineBlur ?? 0;
	if (typeof c == "string" && (c = Mn(c)), e.outline === !0) {
		const m = `${n}_outline`;
		a.polylineOutlineLayerId = m, r.addLayer({
			id: m,
			type: "line",
			source: t,
			layout: {
				"line-join": e.lineJoin ?? "round",
				"line-cap": e.lineCap ?? "round"
			},
			minzoom: e.minzoom ?? 0,
			maxzoom: e.maxzoom ?? 23,
			paint: {
				"line-opacity": typeof f == "number" ? f : O(f),
				"line-color": typeof d == "string" ? d : Oe(d),
				"line-width": ei(o, p),
				"line-blur": typeof h == "number" ? h : O(h)
			}
		}, e.beforeId);
	}
	return r.addLayer({
		id: n,
		type: "line",
		source: t,
		layout: {
			"line-join": e.lineJoin ?? "round",
			"line-cap": e.lineCap ?? "round"
		},
		minzoom: e.minzoom ?? 0,
		maxzoom: e.maxzoom ?? 23,
		paint: {
			"line-opacity": typeof s == "number" ? s : O(s),
			"line-color": typeof i == "string" ? i : Oe(i),
			"line-width": typeof o == "number" ? o : O(o),
			"line-blur": typeof l == "number" ? l : O(l),
			"line-gap-width": typeof u == "number" ? u : O(u),
			...c && { "line-dasharray": c }
		}
	}, e.beforeId), a;
}
function Uc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.sourceId ?? Mt(), n = e.layerId ?? Pt(), a = {
		polygonLayerId: n,
		polygonOutlineLayerId: e.outline ? `${n}_outline` : "",
		polygonSourceId: t
	};
	if (e.data && !r.getSource(t)) {
		let m = e.data;
		typeof m == "string" && Qt(m) && (m = `https://api.maptiler.com/data/${m}/features.json?key=${j.apiKey}`), r.addSource(t, {
			type: "geojson",
			data: m
		});
	}
	let o = e.outlineDashArray ?? null;
	const i = e.outlineWidth ?? 1, s = e.outlineColor ?? "#FFFFFF", l = e.outlineOpacity ?? 1, u = e.outlineBlur ?? 0, c = e.fillColor ?? yr(), p = e.fillOpacity ?? 1, d = e.outlinePosition ?? "center", f = e.pattern ?? null;
	typeof o == "string" && (o = Mn(o));
	const h = (m = null) => {
		if (r.addLayer({
			id: n,
			type: "fill",
			source: t,
			minzoom: e.minzoom ?? 0,
			maxzoom: e.maxzoom ?? 23,
			paint: {
				"fill-color": typeof c == "string" ? c : Oe(c),
				"fill-opacity": typeof p == "number" ? p : O(p),
				...m && { "fill-pattern": m }
			}
		}, e.beforeId), e.outline === !0) {
			let y;
			d === "inside" ? typeof i == "number" ? y = .5 * i : y = O(i.map(({ zoom: b, value: v }) => ({
				zoom: b,
				value: .5 * v
			}))) : d === "outside" ? typeof i == "number" ? y = -.5 * i : y = O(i.map((b) => ({
				zoom: b.zoom,
				value: -.5 * b.value
			}))) : y = 0, r.addLayer({
				id: a.polygonOutlineLayerId,
				type: "line",
				source: t,
				layout: {
					"line-join": e.outlineJoin ?? "round",
					"line-cap": e.outlineCap ?? "butt"
				},
				minzoom: e.minzoom ?? 0,
				maxzoom: e.maxzoom ?? 23,
				paint: {
					"line-opacity": typeof l == "number" ? l : O(l),
					"line-color": typeof s == "string" ? s : Oe(s),
					"line-width": typeof i == "number" ? i : O(i),
					"line-blur": typeof u == "number" ? u : O(u),
					"line-offset": y,
					...o && { "line-dasharray": o }
				}
			}, e.beforeId);
		}
	};
	return f ? r.hasImage(f) ? h(f) : r.loadImage(f).then((m) => {
		r.addImage(f, m.data), h(f);
	}).catch((m) => {
		console.error("Could not load the pattern image.", m.message), h();
	}) : h(), a;
}
function Bc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.minPointRadius ?? 10, n = e.maxPointRadius ?? 50, a = e.cluster ?? !1, o = 20, i = Array.isArray(e.pointColor) ? e.pointColor : ai.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample("ease-out-square"), s = i.getBounds(), l = e.sourceId ?? Mt(), u = e.layerId ?? Pt(), c = e.showLabel ?? a, p = e.alignOnViewport ?? !0, d = e.outline ?? !1, f = e.outlineOpacity ?? 1, h = e.outlineWidth ?? 1, m = e.outlineColor ?? "#FFFFFF";
	let y;
	const b = e.zoomCompensation ?? !0, v = e.minzoom ?? 0, x = e.maxzoom ?? 23;
	typeof e.pointOpacity == "number" ? y = e.pointOpacity : Array.isArray(e.pointOpacity) ? y = O(e.pointOpacity) : e.cluster ? y = nn(i, "point_count") : e.property ? y = nn(i, e.property) : y = O([
		{
			zoom: v,
			value: 0
		},
		{
			zoom: v + .25,
			value: 1
		},
		{
			zoom: x - .25,
			value: 1
		},
		{
			zoom: x,
			value: 0
		}
	]);
	const E = {
		pointLayerId: u,
		clusterLayerId: "",
		labelLayerId: "",
		pointSourceId: l
	};
	if (e.data && !r.getSource(l)) {
		let C = e.data;
		typeof C == "string" && Qt(C) && (C = `https://api.maptiler.com/data/${C}/features.json?key=${j.apiKey}`), r.addSource(l, {
			type: "geojson",
			data: C,
			cluster: a
		});
	}
	if (a) {
		E.clusterLayerId = `${u}_cluster`;
		const C = Array.from({ length: o }, (T, N) => {
			const ge = s.min + N * (s.max - s.min) / (o - 1);
			return {
				value: ge,
				pointRadius: t + (n - t) * (N / (o - 1)) ** .5,
				color: i.getColorHex(ge)
			};
		});
		r.addLayer({
			id: E.clusterLayerId,
			type: "circle",
			source: l,
			filter: ["has", "point_count"],
			paint: {
				"circle-color": typeof e.pointColor == "string" ? e.pointColor : tn(C, "point_count"),
				"circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : rn(C, "point_count", !1),
				"circle-pitch-alignment": p ? "viewport" : "map",
				"circle-pitch-scale": "map",
				"circle-opacity": y,
				...d && {
					"circle-stroke-opacity": typeof f == "number" ? f : O(f),
					"circle-stroke-width": typeof h == "number" ? h : O(h),
					"circle-stroke-color": typeof m == "string" ? m : Oe(m)
				}
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId), r.addLayer({
			id: E.pointLayerId,
			type: "circle",
			source: l,
			filter: ["!", ["has", "point_count"]],
			paint: {
				"circle-pitch-alignment": p ? "viewport" : "map",
				"circle-pitch-scale": "map",
				"circle-color": typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(i.getBounds().min),
				"circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : C[0].pointRadius * .75,
				"circle-opacity": y,
				...d && {
					"circle-stroke-opacity": typeof f == "number" ? f : O(f),
					"circle-stroke-width": typeof h == "number" ? h : O(h),
					"circle-stroke-color": typeof m == "string" ? m : Oe(m)
				}
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId);
	} else {
		let C = typeof e.pointColor == "string" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : yr(), T = typeof e.pointRadius == "number" ? b ? O([
			{
				zoom: 0,
				value: e.pointRadius * .025
			},
			{
				zoom: 2,
				value: e.pointRadius * .05
			},
			{
				zoom: 4,
				value: e.pointRadius * .1
			},
			{
				zoom: 8,
				value: e.pointRadius * .25
			},
			{
				zoom: 16,
				value: e.pointRadius * 1
			}
		]) : e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : b ? O([
			{
				zoom: 0,
				value: t * .05
			},
			{
				zoom: 2,
				value: t * .1
			},
			{
				zoom: 4,
				value: t * .2
			},
			{
				zoom: 8,
				value: t * .5
			},
			{
				zoom: 16,
				value: t * 1
			}
		]) : t;
		if (e.property && Array.isArray(e.pointColor)) {
			const N = Array.from({ length: o }, (ge, Xe) => {
				const Ye = s.min + Xe * (s.max - s.min) / (o - 1);
				return {
					value: Ye,
					pointRadius: typeof e.pointRadius == "number" ? e.pointRadius : t + (n - t) * (Xe / (o - 1)) ** .5,
					color: typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(Ye)
				};
			});
			C = tn(N, e.property), T = rn(N, e.property, b);
		}
		r.addLayer({
			id: E.pointLayerId,
			type: "circle",
			source: l,
			layout: { "circle-sort-key": e.property ? [
				"/",
				1,
				["get", e.property]
			] : 0 },
			paint: {
				"circle-pitch-alignment": p ? "viewport" : "map",
				"circle-pitch-scale": "map",
				"circle-color": C,
				"circle-opacity": y,
				"circle-radius": T,
				...d && {
					"circle-stroke-opacity": typeof f == "number" ? f : O(f),
					"circle-stroke-width": typeof h == "number" ? h : O(h),
					"circle-stroke-color": typeof m == "string" ? m : Oe(m)
				}
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId);
	}
	if (c !== !1 && (e.cluster || e.property)) {
		E.labelLayerId = `${u}_label`;
		const C = e.labelColor ?? "#fff", T = e.labelSize ?? 12;
		r.addLayer({
			id: E.labelLayerId,
			type: "symbol",
			source: l,
			filter: ["has", e.cluster ? "point_count" : e.property],
			layout: {
				"text-field": e.cluster ? "{point_count_abbreviated}" : `{${e.property}}`,
				"text-font": ["Noto Sans Regular"],
				"text-size": T,
				"text-pitch-alignment": p ? "viewport" : "map",
				"symbol-sort-key": [
					"/",
					1,
					["get", e.cluster ? "point_count" : e.property]
				]
			},
			paint: {
				"text-color": C,
				"text-opacity": y
			},
			minzoom: v,
			maxzoom: x
		}, e.beforeId);
	}
	return E;
}
function qc(r, e) {
	if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
	const t = e.sourceId ?? Mt(), n = e.layerId ?? Pt(), a = e.minzoom ?? 0, o = e.maxzoom ?? 23, i = e.zoomCompensation ?? !0, s = e.opacity ?? [
		{
			zoom: a,
			value: 0
		},
		{
			zoom: a + .25,
			value: 1
		},
		{
			zoom: o - .25,
			value: 1
		},
		{
			zoom: o,
			value: 0
		}
	];
	let l = Array.isArray(e.colorRamp) ? e.colorRamp : ai.TURBO.transparentStart();
	const u = l.getBounds();
	(u.min !== 0 || u.max !== 1) && (l = l.scale(0, 1)), l.hasTransparentStart() || (l = l.transparentStart());
	const c = e.intensity ?? [
		{
			zoom: 0,
			value: .01
		},
		{
			zoom: 4,
			value: .2
		},
		{
			zoom: 16,
			value: 1
		}
	], p = e.property ?? null, d = e.weight ?? 1;
	let f = 1;
	p ? typeof d == "number" ? (f = d, typeof e.weight == "number" && console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`")) : Array.isArray(d) ? f = ti(d, p) : console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`") : typeof d == "number" ? f = d : Array.isArray(d) && console.warn("The options `.propertyValueWeights` can only be used when `.property` is provided.");
	const h = [
		{
			zoom: 0,
			value: 50 * .025
		},
		{
			zoom: 2,
			value: 50 * .05
		},
		{
			zoom: 4,
			value: 50 * .1
		},
		{
			zoom: 8,
			value: 50 * .25
		},
		{
			zoom: 16,
			value: 50
		}
	], m = e.radius ?? (i ? h : 10);
	let y = 1;
	typeof m == "number" ? y = m : Array.isArray(m) && "zoom" in m[0] ? y = O(m) : p && Array.isArray(m) && "propertyValue" in m[0] ? y = ri(m, p, i) : !p && Array.isArray(m) && "propertyValue" in m[0] ? (y = O(h), console.warn("The option `.radius` can only be property-driven if the option `.property` is provided.")) : y = O(h);
	const b = {
		heatmapLayerId: n,
		heatmapSourceId: t
	};
	if (e.data && !r.getSource(t)) {
		let v = e.data;
		typeof v == "string" && Qt(v) && (v = `https://api.maptiler.com/data/${v}/features.json?key=${j.apiKey}`), r.addSource(t, {
			type: "geojson",
			data: v
		});
	}
	return r.addLayer({
		id: n,
		type: "heatmap",
		source: t,
		minzoom: a,
		maxzoom: o,
		paint: {
			"heatmap-weight": f,
			"heatmap-intensity": typeof c == "number" ? c : O(c),
			"heatmap-color": ni(l),
			"heatmap-radius": y,
			"heatmap-opacity": typeof s == "number" ? s : O(s)
		}
	}, e.beforeId), b;
}
var bp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	addHeatmap: qc,
	addPoint: Bc,
	addPolygon: Uc,
	addPolyline: jc,
	colorDrivenByProperty: tn,
	colorPalettes: Qr,
	computeRampedOutlineWidth: ei,
	dashArrayMaker: Mn,
	generateRandomLayerName: Pt,
	generateRandomSourceName: Mt,
	getRandomColor: yr,
	heatmapIntensityFromColorRamp: ni,
	lerpZoomNumberValues: en,
	opacityDrivenByProperty: nn,
	paintColorOptionsToPaintSpec: Oe,
	radiusDrivenByProperty: rn,
	radiusDrivenByPropertyHeatmap: ri,
	rampedOptionsToLayerPaintSpec: O,
	rampedPropertyValueWeight: ti,
	takeScreenshot: Fc
}, Symbol.toStringTag, { value: "Module" }));
function oi() {
	return "3.10.2";
}
var wp = import_maplibre_gl.default.Map, Sp = import_maplibre_gl.default.Marker, xp = import_maplibre_gl.default.Popup, kp = import_maplibre_gl.default.Style, Lp = import_maplibre_gl.default.CanvasSource, Cp = import_maplibre_gl.default.GeoJSONSource, Ep = import_maplibre_gl.default.ImageSource, Ap = import_maplibre_gl.default.RasterTileSource, Tp = import_maplibre_gl.default.RasterDEMTileSource, _p = import_maplibre_gl.default.VectorTileSource, Ip = import_maplibre_gl.default.VideoSource, Mp = import_maplibre_gl.default.NavigationControl, Pp = import_maplibre_gl.default.GeolocateControl, Rp = import_maplibre_gl.default.AttributionControl, zp = import_maplibre_gl.default.LogoControl, Op = import_maplibre_gl.default.ScaleControl, Fp = import_maplibre_gl.default.FullscreenControl, $p = import_maplibre_gl.default.TerrainControl, Np = import_maplibre_gl.default.BoxZoomHandler, jp = import_maplibre_gl.default.ScrollZoomHandler, Dp = import_maplibre_gl.default.CooperativeGesturesHandler, Up = import_maplibre_gl.default.KeyboardHandler, Bp = import_maplibre_gl.default.TwoFingersTouchPitchHandler, qp = import_maplibre_gl.default.MapWheelEvent, Vp = import_maplibre_gl.default.MapTouchEvent, Gp = import_maplibre_gl.default.MapMouseEvent, Hp = import_maplibre_gl.default.config, Zp = import_maplibre_gl.default.getVersion, { setRTLTextPlugin: Kp, getRTLTextPluginStatus: Xp, LngLat: ii, LngLatBounds: Vc, MercatorCoordinate: an, Evented: Yp, AJAXError: Wp, prewarm: Jp, clearPrewarmedResources: Qp, Hash: ef, Point: si, EdgeInsets: tf, DragRotateHandler: rf, DragPanHandler: nf, TwoFingersTouchZoomRotateHandler: af, DoubleClickZoomHandler: of, TwoFingersTouchZoomHandler: sf, TwoFingersTouchRotateHandler: lf, getWorkerCount: uf, setWorkerCount: cf, getMaxParallelImageRequests: pf, setMaxParallelImageRequests: ff, getWorkerUrl: df, setWorkerUrl: hf, addSourceType: mf, importScriptInWorkers: yf, addProtocol: gf, removeProtocol: vf } = import_maplibre_gl.default;

//#endregion
export { Wp as AJAXError, sp as AttributionControl, Rp as AttributionControlMLGL, up as BoxZoomHandler, Np as BoxZoomHandlerMLGL, ep as CanvasSource, Lp as CanvasSourceMLGL, A as ColorRamp, ai as ColorRampCollection, pp as CooperativeGesturesHandler, Dp as CooperativeGesturesHandlerMLGL, Ne as CubemapFaceNames, Bu as CubemapImagesPresets, Or as CubemapLayer, Ce as DOMcreate, Lt as DOMremove, of as DoubleClickZoomHandler, nf as DragPanHandler, rf as DragRotateHandler, tf as EdgeInsets, Yp as Evented, _i as FullscreenControl, Fp as FullscreenControlMLGL, tp as GeoJSONSource, Cp as GeoJSONSourceMLGL, Ei as GeolocateControl, Pp as GeolocateControlMLGL, ac as GeolocationType, ef as Hash, rp as ImageSource, Ep as ImageSourceMLGL, wc as ImageViewer, ne as ImageViewerEvent, vp as ImageViewerMarker, Ec as ImageViewerMarkerEvent, fp as KeyboardHandler, Up as KeyboardHandlerMLGL, z as Language, ii as LngLat, Vc as LngLatBounds, Ai as LogoControl, zp as LogoControlMLGL, Po as Map, wp as MapMLGL, yp as MapMouseEvent, Gp as MapMouseEventMLGL, MapStyle, MapStyleVariant, mp as MapTouchEvent, Vp as MapTouchEventMLGL, hp as MapWheelEvent, qp as MapWheelEventMLGL, hu as MaptilerCustomControl, Kr as MaptilerExternalControl, du as MaptilerGeolocateControl, $n as MaptilerLogoControl, pu as MaptilerNavigationControl, mu as MaptilerProjectionControl, cu as MaptilerTerrainControl, Ci as Marker, Sp as MarkerMLGL, an as MercatorCoordinate, Mp as NavigationControMLGL, Na as NavigationControl, si as Point, Jc as Popup, xp as PopupMLGL, Fr as RadialGradientLayer, ap as RasterDEMTileSource, Tp as RasterDEMTileSourceMLGL, np as RasterTileSource, Ap as RasterTileSourceMLGL, ReferenceMapStyle, Ti as ScaleControl, Op as ScaleControlMLGL, cp as ScrollZoomHandler, jp as ScrollZoomHandlerMLGL, Ii as SdkConfig, ServiceError, Qc as Style, kp as StyleMLGL, $p as TerrainControMLGL, lp as TerrainControl, dp as TwoFingersTouchPitchHandler, Bp as TwoFingersTouchPitchHandlerMLGL, lf as TwoFingersTouchRotateHandler, sf as TwoFingersTouchZoomHandler, af as TwoFingersTouchZoomRotateHandler, op as VectorTileSource, _p as VectorTileSourceMLGL, ip as VideoSource, Ip as VideoSourceMLGL, gf as addProtocol, mf as addSourceType, areSameLanguages, bufferToPixelDataBrowser, canParsePixelData, circumferenceAtLatitude, Qp as clearPrewarmedResources, j as config, Hp as configMLGL, coordinates, Ge as cubemapPresets, data, gp as displayWebGLContextLostWarning, elevation, expandMapStyle, geocoding, geolocation, getAutoLanguage, Fn as getBrowserLanguage, getBufferToPixelDataParser, getLanguageInfoFromCode, getLanguageInfoFromFlag, getLanguageInfoFromKey, Zp as getMapLibreVersion, pf as getMaxParallelImageRequests, Xp as getRTLTextPluginStatus, getTileCache, oi as getVersion, Di as getWebGLSupportError, uf as getWorkerCount, df as getWorkerUrl, Zo as gpx, Oc as gpxOrKml, Ho as hasChildNodeWithName, bp as helpers, yf as importScriptInWorkers, isLanguageInfo, Ko as kml, mapStylePresetList, math, misc, Jp as prewarm, vf as removeProtocol, ff as setMaxParallelImageRequests, Kp as setRTLTextPlugin, cf as setWorkerCount, hf as setWorkerUrl, staticMaps, _n as str2xml, styleToStyle, toLanguageInfo, Ao as toggleProjection, Eo as toggleTerrain, Ia as xml2str };
//# sourceMappingURL=@maptiler_sdk.js.map